/**
 * Enhanced OAuth2 Auto-Refresh Tests
 * Tests the production-ready OAuth2 implementation with Secret Manager integration
 */

import { describe, test, expect, beforeEach, afterEach, jest } from '@jest/globals';
import fs from 'fs';
import path from 'path';

// Mock dependencies
jest.mock('@google-cloud/secret-manager');
jest.mock('googleapis');

describe('Enhanced OAuth2 Client', () => {
  const mockTokensPath = './test-oauth2-tokens.json';
  const validTokens = {
    access_token: 'test_access_token',
    refresh_token: 'test_refresh_token',
    scope: 'https://www.googleapis.com/auth/calendar',
    token_type: 'Bearer',
    expiry_date: Date.now() + 3600000 // 1 hour from now
  };

  const expiredTokens = {
    ...validTokens,
    expiry_date: Date.now() - 1000 // 1 second ago
  };

  beforeEach(() => {
    // Clean up any existing OAuth2 state
    jest.resetModules();

    // Set up environment variables
    process.env.USE_OAUTH2 = 'true';
    process.env.GOOGLE_OAUTH_CLIENT_ID = 'test_client_id';
    process.env.GOOGLE_OAUTH_CLIENT_SECRET = 'test_client_secret';
    process.env.OAUTH2_TOKENS_FILE = mockTokensPath;
    process.env.FIREBASE_PROJECT_ID = 'test-project';

    // Clean up test files
    if (fs.existsSync(mockTokensPath)) {
      fs.unlinkSync(mockTokensPath);
    }
  });

  afterEach(() => {
    // Clean up test files
    if (fs.existsSync(mockTokensPath)) {
      fs.unlinkSync(mockTokensPath);
    }

    // Clean up environment
    delete process.env.USE_OAUTH2;
    delete process.env.OAUTH2_TOKENS_FILE;
  });

  test('should initialize with valid tokens', async () => {
    // Create valid tokens file
    fs.writeFileSync(mockTokensPath, JSON.stringify(validTokens, null, 2));

    // Mock Google Auth client
    const mockClient = {
      setCredentials: jest.fn(),
      on: jest.fn(),
      refreshAccessToken: jest.fn()
    } as any;

    const mockGoogle = {
      auth: {
        OAuth2: jest.fn(() => mockClient)
      }
    };

    jest.doMock('googleapis', () => ({ google: mockGoogle }));

    const { getOAuth2Client, isOAuth2Available } = await import('../services/oauth2-client.js');

    const available = await isOAuth2Available();
    expect(available).toBe(true);

    const client = await getOAuth2Client();
    expect(client).toBe(mockClient);
    expect(mockClient.setCredentials).toHaveBeenCalledWith(validTokens);
  });

  test('should handle expired tokens and refresh automatically', async () => {
    // Create expired tokens file
    fs.writeFileSync(mockTokensPath, JSON.stringify(expiredTokens, null, 2));

    const newTokens = {
      access_token: 'new_access_token',
      expiry_date: Date.now() + 3600000
    };

    const mockClient = {
      setCredentials: jest.fn(),
      on: jest.fn(),
      refreshAccessToken: jest.fn().mockResolvedValue({ credentials: newTokens }) as any
    } as any;

    const mockGoogle = {
      auth: {
        OAuth2: jest.fn(() => mockClient)
      }
    };

    jest.doMock('googleapis', () => ({ google: mockGoogle }));

    const { getOAuth2Client } = await import('../services/oauth2-client.js');

    const client = await getOAuth2Client();
    expect(client).toBe(mockClient);
    expect(mockClient.refreshAccessToken).toHaveBeenCalled();
  });

  test('should provide token status information', async () => {
    // Create valid tokens file
    fs.writeFileSync(mockTokensPath, JSON.stringify(validTokens, null, 2));

    const mockClient = {
      setCredentials: jest.fn(),
      on: jest.fn(),
      refreshAccessToken: jest.fn()
    } as any;

    const mockGoogle = {
      auth: {
        OAuth2: jest.fn(() => mockClient)
      }
    };

    jest.doMock('googleapis', () => ({ google: mockGoogle }));

    const { getTokenStatus, getOAuth2Client } = await import('../services/oauth2-client.js');

    // Initialize the client first
    await getOAuth2Client();

    const status = getTokenStatus();
    expect(status.available).toBe(true);
    expect(status.expiresAt).toBeDefined();
    expect(status.timeUntilExpiryMs).toBeGreaterThan(0);
    expect(status.needsRefresh).toBe(false);
  });

  test('should handle force token refresh', async () => {
    // Create valid tokens file
    fs.writeFileSync(mockTokensPath, JSON.stringify(validTokens, null, 2));

    const newTokens = {
      access_token: 'force_refreshed_token',
      expiry_date: Date.now() + 3600000
    };

    const mockClient = {
      setCredentials: jest.fn(),
      on: jest.fn(),
      refreshAccessToken: jest.fn().mockResolvedValue({ credentials: newTokens }) as any
    } as any;

    const mockGoogle = {
      auth: {
        OAuth2: jest.fn(() => mockClient)
      }
    };

    jest.doMock('googleapis', () => ({ google: mockGoogle }));

    const { forceTokenRefresh, getOAuth2Client } = await import('../services/oauth2-client.js');

    // Initialize the client first
    await getOAuth2Client();

    const result = await forceTokenRefresh();
    expect(result).toBe(true);
    expect(mockClient.refreshAccessToken).toHaveBeenCalled();
  });

  test('should return null when OAuth2 is disabled', async () => {
    delete process.env.USE_OAUTH2;

    const { isOAuth2Available } = await import('../services/oauth2-client.js');

    const available = await isOAuth2Available();
    expect(available).toBe(false);
  });

  test('should handle missing tokens file gracefully', async () => {
    // Don't create tokens file

    const { isOAuth2Available } = await import('../services/oauth2-client.js');

    const available = await isOAuth2Available();
    expect(available).toBe(false);
  });

  test('should handle corrupted tokens file gracefully', async () => {
    // Create corrupted tokens file
    fs.writeFileSync(mockTokensPath, 'invalid json content');

    const { isOAuth2Available } = await import('../services/oauth2-client.js');

    const available = await isOAuth2Available();
    expect(available).toBe(false);
  });

  test('should integrate with Google Auth Service fallback', async () => {
    // Don't create tokens file (OAuth2 unavailable)
    delete process.env.USE_OAUTH2;

    // Mock Service Account auth
    const mockServiceClient = {
      getAccessToken: jest.fn().mockResolvedValue({ token: 'service_account_token' }) as any
    } as any;

    const mockGoogleAuth = {
      getClient: jest.fn().mockResolvedValue(mockServiceClient)
    } as any;

    const mockGoogle = {
      calendar: jest.fn().mockReturnValue({ events: { list: jest.fn() } })
    };

    jest.doMock('google-auth-library', () => ({
      GoogleAuth: jest.fn(() => mockGoogleAuth)
    }));

    jest.doMock('googleapis', () => ({ google: mockGoogle }));

    const { getCalendar } = await import('../services/google-auth-service.js');

    const calendar = await getCalendar();
    expect(calendar).toBeDefined();
    expect(mockGoogleAuth.getClient).toHaveBeenCalled();
  });

  test('should handle Secret Manager integration', async () => {
    // Create valid tokens file
    fs.writeFileSync(mockTokensPath, JSON.stringify(validTokens, null, 2));

    const mockSecretClient = {
      addSecretVersion: jest.fn().mockResolvedValue([{ name: 'test' }]) as any
    } as any;

    const mockSecretManager = {
      SecretManagerServiceClient: jest.fn(() => mockSecretClient)
    };

    jest.doMock('@google-cloud/secret-manager', () => mockSecretManager);

    const mockClient = {
      setCredentials: jest.fn(),
      on: jest.fn((event: string, callback: Function) => {
        if (event === 'tokens') {
          // Simulate token refresh event
          setTimeout(() => {
            callback({
              access_token: 'new_token',
              expiry_date: Date.now() + 3600000
            });
          }, 10);
        }
      }),
      refreshAccessToken: jest.fn()
    };

    const mockGoogle = {
      auth: {
        OAuth2: jest.fn(() => mockClient)
      }
    };

    jest.doMock('googleapis', () => ({ google: mockGoogle }));

    const { getOAuth2Client } = await import('../services/oauth2-client.js');

    const client = await getOAuth2Client();
    expect(client).toBe(mockClient);

    // Wait for token event to be processed
    await new Promise(resolve => setTimeout(resolve, 50));

    // Secret Manager should have been called to save tokens
    expect(mockSecretClient.addSecretVersion).toHaveBeenCalled();
  });

  test('should clean up on shutdown', async () => {
    // Create valid tokens file
    fs.writeFileSync(mockTokensPath, JSON.stringify(validTokens, null, 2));

    const mockClient = {
      setCredentials: jest.fn(),
      on: jest.fn(),
      refreshAccessToken: jest.fn()
    } as any;

    const mockGoogle = {
      auth: {
        OAuth2: jest.fn(() => mockClient)
      }
    };

    jest.doMock('googleapis', () => ({ google: mockGoogle }));

    const { getOAuth2Client, cleanupOAuth2Client } = await import('../services/oauth2-client.js');

    // Initialize the client
    await getOAuth2Client();

    // Test cleanup
    expect(() => cleanupOAuth2Client()).not.toThrow();
  });
});

describe('OAuth2 Router Endpoints', () => {
  test('should provide OAuth2 status endpoint', async () => {
    const { ok } = await import('../utils/response.js');

    // Mock handlers
    const handlers = {
      'oauth2.status': async () => {
        return ok({
          available: true,
          expiresAt: new Date().toISOString(),
          timeUntilExpiryMs: 3600000,
          needsRefresh: false,
          refreshInProgress: false,
          lastRefresh: null
        });
      }
    };

    const result = await handlers['oauth2.status']();
    expect(result.ok).toBe(true);
    expect(result.data.available).toBe(true);
  });

  test('should provide OAuth2 refresh endpoint', async () => {
    const { ok } = await import('../utils/response.js');

    const handlers = {
      'oauth2.refresh': async () => {
        return ok({ success: true, message: 'Token refreshed successfully' });
      }
    };

    const result = await handlers['oauth2.refresh']();
    expect(result.ok).toBe(true);
    expect(result.data.success).toBe(true);
  });
});