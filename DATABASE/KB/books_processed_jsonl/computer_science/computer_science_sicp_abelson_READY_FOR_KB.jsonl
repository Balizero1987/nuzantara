{"id": "computer_science_sicp_abelson_chunk_0000_3c191b54", "text": "Structure and\nInterpretation\nof Computer \nPrograms\nHarold Abelson and\nGerald Jay Sussman\nwith Julie Sussman \nforeword by Alan J. PerlisUnofﬁcial Texinfo Format 2.andresraba5.6second edition\n\n©1996 by e Massachuses Institute of Technology\nStructure and Interpretation of Computer Programs,\nsecond edition\nHarold Abelson and Gerald Jay Sussman\nwith Julie Sussman, foreword by Alan J. Perlis\nis work is licensed under a Creative Commons\nAribution-ShareAlike 4.0 International License\n(  . ). Based on a work at mitpress.mit.edu . e  Press\nCambridge, Massachuses\nLondon, England\nMcGraw-Hill Book Company\nNew York, St. Louis, San Francisco,\nMontreal, Toronto\nUnoﬃcial Texinfo Format 2.andresraba5.6 (February 2, 2016),\nbased on 2.neilvandyke4 (January 10, 2007). Contents\nUnoﬃcial Texinfo Format ix\nDedication xii\nForeword xiii\nPreface to the Second Edition xix\nPreface to the First Edition xxi\nAnowledgments xxv\n1 Building Abstractions with Procedures 1\n1.1 e Elements of Programming . . . . . .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 0, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1011}}
{"id": "computer_science_sicp_abelson_chunk_0001_4071092c", "text": ". . . . . . . . . . . . . 6\n1.1.1 Expressions . . . . . . . . . . . . . . . . . . . . 7\n1.1.2 Naming and the Environment . . . . . . . . . . 10\n1.1.3 Evaluating Combinations . . . . . . . . . . . . 12\n1.1.4 Compound Procedures . . . . . . . . . . . . . . 15\n1.1.5 e Substitution Model for Procedure Application 18\n1.1.6 Conditional Expressions and Predicates . . . . 22\n1.1.7 Example: Square Roots by Newton’s Method . .28\niii\n1.1.8 Procedures as Black-Box Abstractions . . . . . 33\n1.2 Procedures and the Processes ey Generate . . . . . . 40\n1.2.1 Linear Recursion and Iteration . . . . . . . . . 41\n1.2.2 Tree Recursion . . . . . . . . . . . . . . . . . . 47\n1.2.3 Orders of Growth . . . . . . . . . . . . . . . . . 54\n1.2.4 Exponentiation . . . . . . . . . . . . . . . . . . 57\n1.2.5 Greatest Common Divisors . . . . . . . . . . . 62\n1.2.6 Example: Testing for Primality . . . . . . . . . 65\n1.3 Formulating Abstractions\nwith Higher-Order Procedures . . . . . . . . . . . . . . 74\n1.3.1 Procedures as Arguments . . . . . . . . . . . . 76\n1.3.2 Constructing Procedures Using lambda . . . . . 83\n1.3.3 Procedures as General Methods . . . . . . . . . 89\n1.3.4 Procedures as Returned Values . . . . . . . . .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 1, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1209}}
{"id": "computer_science_sicp_abelson_chunk_0002_fed6b178", "text": ". . . . . . . . 74\n1.3.1 Procedures as Arguments . . . . . . . . . . . . 76\n1.3.2 Constructing Procedures Using lambda . . . . . 83\n1.3.3 Procedures as General Methods . . . . . . . . . 89\n1.3.4 Procedures as Returned Values . . . . . . . . . 97\n2 Building Abstractions with Data 107\n2.1 Introduction to Data Abstraction . . . . . . . . . . . . . 112\n2.1.1 Example: Arithmetic Operations\nfor Rational Numbers . . . . . . . . . . . . . . . 113\n2.1.2 Abstraction Barriers . . . . . . . . . . . . . . . 118\n2.1.3 What Is Meant by Data? . . . . . . . . . . . . . 122\n2.1.4 Extended Exercise: Interval Arithmetic . . . . . 126\n2.2 Hierarchical Data and the Closure Property . . . . . . . 132\n2.2.1 Representing Sequences . . . . . . . . . . . . . 134\n2.2.2 Hierarchical Structures . . . . . . . . . . . . . . 147\n2.2.3 Sequences as Conventional Interfaces . . . . . 154\n2.2.4 Example: A Picture Language . . . . . . . . . . 172\n2.3 Symbolic Data . . . . . . . . . . . . . . . . . . . . . . . 192\n2.3.1 otation . . . . . . . . . . . . . . . . . . . . . 192\niv\n2.3.2 Example: Symbolic Diﬀerentiation . . . . . . . 197\n2.3.3 Example: Representing Sets . . . . . . . . . . . 205\n2.3.4 Example: Huﬀman Encoding Trees . . . . . . .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 2, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1221}}
{"id": "computer_science_sicp_abelson_chunk_0003_c63ccfaa", "text": ". . . . . . . . . . . 192\n2.3.1 otation . . . . . . . . . . . . . . . . . . . . . 192\niv\n2.3.2 Example: Symbolic Diﬀerentiation . . . . . . . 197\n2.3.3 Example: Representing Sets . . . . . . . . . . . 205\n2.3.4 Example: Huﬀman Encoding Trees . . . . . . . 218\n2.4 Multiple Representations for Abstract Data . . . . . . . 229\n2.4.1 Representations for Complex Numbers . . . . . 232\n2.4.2 Tagged data . . . . . . . . . . . . . . . . . . . . 237\n2.4.3 Data-Directed Programming and Additivity . .242\n2.5 Systems with Generic Operations . . . . . . . . . . . . 254\n2.5.1 Generic Arithmetic Operations . . . . . . . . . 255\n2.5.2 Combining Data of Diﬀerent Types . . . . . . . 262\n2.5.3 Example: Symbolic Algebra . . . . . . . . . . . 274\n3 Modularity, Objects, and State 294\n3.1 Assignment and Local State . . . . . . . . . . . . . . . 296\n3.1.1 Local State Variables . . . . . . . . . . . . . . . 297\n3.1.2 e Beneﬁts of Introducing Assignment . . . . 305\n3.1.3 e Costs of Introducing Assignment . . . . . . 311\n3.2 e Environment Model of Evaluation . . . . . . . . . . 320\n3.2.1 e Rules for Evaluation . . . . . . . . . . . . . 322\n3.2.2 Applying Simple Procedures . . . . . . . . . . .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 3, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1188}}
{"id": "computer_science_sicp_abelson_chunk_0004_c78d0fbc", "text": ". 305\n3.1.3 e Costs of Introducing Assignment . . . . . . 311\n3.2 e Environment Model of Evaluation . . . . . . . . . . 320\n3.2.1 e Rules for Evaluation . . . . . . . . . . . . . 322\n3.2.2 Applying Simple Procedures . . . . . . . . . . . 327\n3.2.3 Frames as the Repository of Local State . . . . 330\n3.2.4 Internal Deﬁnitions . . . . . . . . . . . . . . . . 337\n3.3 Modeling with Mutable Data . . . . . . . . . . . . . . . 341\n3.3.1 Mutable List Structure . . . . . . . . . . . . . . 342\n3.3.2 Representing eues . . . . . . . . . . . . . . . 353\n3.3.3 Representing Tables . . . . . . . . . . . . . . . 360\n3.3.4 A Simulator for Digital Circuits . . . . . . . . . 369\n3.3.5 Propagation of Constraints . . . . . . . . . . . 386\n3.4 Concurrency: Time Is of the Essence . . . . . . . . . . . 401\nv\n3.4.1 e Nature of Time in Concurrent Systems . .403\n3.4.2 Mechanisms for Controlling Concurrency . . .410\n3.5 Streams . . . . . . . . . . . . . . . . . . . . . . . . . . . 428\n3.5.1 Streams Are Delayed Lists . . . . . . . . . . . . 430\n3.5.2 Inﬁnite Streams . . . . . . . . . . . . . . . . . . 441\n3.5.3 Exploiting the Stream Paradigm . . . . . . . . . 453\n3.5.4 Streams and Delayed Evaluation . . . . . . . .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 4, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1208}}
{"id": "computer_science_sicp_abelson_chunk_0005_bc008594", "text": ". . . . . . . . . 428\n3.5.1 Streams Are Delayed Lists . . . . . . . . . . . . 430\n3.5.2 Inﬁnite Streams . . . . . . . . . . . . . . . . . . 441\n3.5.3 Exploiting the Stream Paradigm . . . . . . . . . 453\n3.5.4 Streams and Delayed Evaluation . . . . . . . . 470\n3.5.5 Modularity of Functional Programs\nand Modularity of Objects . . . . . . . . . . . . 479\n4 Metalinguistic Abstraction 487\n4.1 e Metacircular Evaluator . . . . . . . . . . . . . . . . 492\n4.1.1 e Core of the Evaluator . . . . . . . . . . . . 495\n4.1.2 Representing Expressions . . . . . . . . . . . . 501\n4.1.3 Evaluator Data Structures . . . . . . . . . . . . 512\n4.1.4 Running the Evaluator as a Program . . . . . . 518\n4.1.5 Data as Programs . . . . . . . . . . . . . . . . . 522\n4.1.6 Internal Deﬁnitions . . . . . . . . . . . . . . . . 526\n4.1.7 Separating Syntactic Analysis from Execution .534\n4.2 Variations on a Scheme — Lazy Evaluation . . . . . . . 541\n4.2.1 Normal Order and Applicative Order . . . . . . 542\n4.2.2 An Interpreter with Lazy Evaluation . . . . . . 544\n4.2.3 Streams as Lazy Lists . . . . . . . . . . . . . . . 555\n4.3 Variations on a Scheme — Nondeterministic Computing 559\n4.3.1 Amb and Search . . . . .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 5, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1197}}
{"id": "computer_science_sicp_abelson_chunk_0006_f3603377", "text": ". . . . . 542\n4.2.2 An Interpreter with Lazy Evaluation . . . . . . 544\n4.2.3 Streams as Lazy Lists . . . . . . . . . . . . . . . 555\n4.3 Variations on a Scheme — Nondeterministic Computing 559\n4.3.1 Amb and Search . . . . . . . . . . . . . . . . . 561\n4.3.2 Examples of Nondeterministic Programs . . . . 567\n4.3.3 Implementing the ambEvaluator . . . . . . . . 578\n4.4 Logic Programming . . . . . . . . . . . . . . . . . . . . 594\n4.4.1 Deductive Information Retrieval . . . . . . . . 599\nvi\n4.4.2 How the ery System Works . . . . . . . . . 615\n4.4.3 Is Logic Programming Mathematical Logic? . .627\n4.4.4 Implementing the ery System . . . . . . . . 635\n4.4.4.1 e Driver Loop and Instantiation . .636\n4.4.4.2 e Evaluator . . . . . . . . . . . . . 638\n4.4.4.3 Finding Assertions\nby Paern Matching . . . . . . . . . 642\n4.4.4.4 Rules and Uniﬁcation . . . . . . . . . 645\n4.4.4.5 Maintaining the Data Base . . . . . . 651\n4.4.4.6 Stream Operations . . . . . . . . . . 654\n4.4.4.7 ery Syntax Procedures . . . . . . . 656\n4.4.4.8 Frames and Bindings . . . . . . . . . 659\n5 Computing with Register Maines 666\n5.1 Designing Register Machines . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 6, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1171}}
{"id": "computer_science_sicp_abelson_chunk_0007_b8042333", "text": ". . . . . . . . . 654\n4.4.4.7 ery Syntax Procedures . . . . . . . 656\n4.4.4.8 Frames and Bindings . . . . . . . . . 659\n5 Computing with Register Maines 666\n5.1 Designing Register Machines . . . . . . . . . . . . . . . 668\n5.1.1 A Language for Describing Register Machines .672\n5.1.2 Abstraction in Machine Design . . . . . . . . . 678\n5.1.3 Subroutines . . . . . . . . . . . . . . . . . . . . 681\n5.1.4 Using a Stack to Implement Recursion . . . . . 686\n5.1.5 Instruction Summary . . . . . . . . . . . . . . . 695\n5.2 A Register-Machine Simulator . . . . . . . . . . . . . . 696\n5.2.1 e Machine Model . . . . . . . . . . . . . . . . 698\n5.2.2 e Assembler . . . . . . . . . . . . . . . . . . 704\n5.2.3 Generating Execution Procedures\nfor Instructions . . . . . . . . . . . . . . . . . . 708\n5.2.4 Monitoring Machine Performance . . . . . . . 718\n5.3 Storage Allocation and Garbage Collection . . . . . . . 723\n5.3.1 Memory as Vectors . . . . . . . . . . . . . . . . 724\n5.3.2 Maintaining the Illusion of Inﬁnite Memory . .731\nvii\n5.4 e Explicit-Control Evaluator . . . . . . . . . . . . . . 741\n5.4.1 e Core of the Explicit-Control Evaluator . .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 7, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1151}}
{"id": "computer_science_sicp_abelson_chunk_0008_25b8f326", "text": ". . . . . . . . . . . . . . . 724\n5.3.2 Maintaining the Illusion of Inﬁnite Memory . .731\nvii\n5.4 e Explicit-Control Evaluator . . . . . . . . . . . . . . 741\n5.4.1 e Core of the Explicit-Control Evaluator . . .743\n5.4.2 Sequence Evaluation and Tail Recursion . . . . 751\n5.4.3 Conditionals, Assignments, and Deﬁnitions . .756\n5.4.4 Running the Evaluator . . . . . . . . . . . . . . 759\n5.5 Compilation . . . . . . . . . . . . . . . . . . . . . . . . 767\n5.5.1 Structure of the Compiler . . . . . . . . . . . . 772\n5.5.2 Compiling Expressions . . . . . . . . . . . . . . 779\n5.5.3 Compiling Combinations . . . . . . . . . . . . 788\n5.5.4 Combining Instruction Sequences . . . . . . . . 797\n5.5.5 An Example of Compiled Code . . . . . . . . . 802\n5.5.6 Lexical Addressing . . . . . . . . . . . . . . . . 817\n5.5.7 Interfacing Compiled Code to the Evaluator . .823\nReferences 834\nList of Exercises 844\nList of Figures 846\nIndex 848\nColophon 855\nviii\nUnoﬀicial Texinfo Format\nis is the second edition book, from Unoﬃcial Texinfo Format.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 8, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1040}}
{"id": "computer_science_sicp_abelson_chunk_0009_731f02b0", "text": ".823\nReferences 834\nList of Exercises 844\nList of Figures 846\nIndex 848\nColophon 855\nviii\nUnoﬀicial Texinfo Format\nis is the second edition book, from Unoﬃcial Texinfo Format. YouareprobablyreadingitinanInfohypertextbrowser,suchasthe\nInfomodeofEmacs.YoumightalternativelybereadingitT EX-formaed\non your screen or printer, though that would be silly. And, if printed,\nexpensive. e freely-distributed oﬃcial -and-format was ﬁrst con-\nvertedpersonallytoUnoﬃcialTexinfoFormat( )version1byLytha\nAyth during a long Emacs lovefest weekend in April, 2001. eis easier to search than the format. It is also much\nmore accessible to people running on modest computers, such as do-\nnated ’386-based PCs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 9, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 715}}
{"id": "computer_science_sicp_abelson_chunk_0010_885f0b99", "text": "eis easier to search than the format. It is also much\nmore accessible to people running on modest computers, such as do-\nnated ’386-based PCs. A 386 can, in theory, run Linux, Emacs, and a\nScheme interpreter simultaneously, but most 386s probably can’t also\nrunbothNetscapeandthenecessaryXWindowSystemwithoutprema-\nturely introducing budding young underfunded hackers to the concept\nofthrashing .canalsoﬁtuncompressedona1.44 ﬂoppydiskee,\nwhich may come in handy for installing on PCs that do not have\nInternet or access. e Texinfo conversion has been a straight transliteration, to the\nextent possible. Like the T EX-to-conversion, this was not without\nsomeintroductionofbreakage.InthecaseofUnoﬃcialTexinfoFormat,\nix\nﬁgureshavesuﬀeredanamateurishresurrectionofthelostartof . Also, it’s quite possible that some errors of ambiguity were introduced\nduring the conversion of some of the copious superscripts (‘ˆ’) and sub-\nscripts (‘_’).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 10, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_sicp_abelson_chunk_0011_b941fd9c", "text": "Also, it’s quite possible that some errors of ambiguity were introduced\nduring the conversion of some of the copious superscripts (‘ˆ’) and sub-\nscripts (‘_’). Divining whichhas been le as an exercise to the reader. But at least we don’t put our brave astronauts at risk by encoding the\ngreater-than-or-equal symbol as <u>&gt;</u> . If you modify sicp.texi to correct errors or improve the art,\nthenupdatethe @set utfversion 2.andresraba5.6 linetoreﬂectyour\ndelta.Forexample,ifyoustartedwithLytha’sversion 1,andyourname\nis Bob, then you could name your successive versions 1.bob1,1.bob2,\n: : :1.bob n.Alsoupdate utfversiondate .Ifyouwanttodistributeyour\nversion on the Web, then embedding the string “sicp.texi” somewhere\nin the ﬁle or Web page will make it easier for people to ﬁnd with Web\nsearch engines. It is believed that the Unoﬃcial Texinfo Format is in keeping with\nthe spirit of the graciously freely-distributed version.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 11, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 941}}
{"id": "computer_science_sicp_abelson_chunk_0012_e4021fac", "text": "It is believed that the Unoﬃcial Texinfo Format is in keeping with\nthe spirit of the graciously freely-distributed version. But you\nnever know when someone’s armada of lawyers might need something\nto do, and get their shorts all in a knot over some benign lile thing,\nso think twice before you use your full name or distribute Info, ,\nPostScript, or formats that might embed your account or machine\nname. Peath, Lytha Ayth\nAddendum: See also the video lectures by Abelson and Sussman:\nat  or  . Second Addendum: Above is the original introduction to the from\n2001. Ten years later, has been transformed: mathematical symbols\nand formulas are properly typeset, and ﬁgures drawn in vector graph-\nics. e original text formulas and art ﬁgures are still there in\nx\nthe Texinfo source, but will display only when compiled to Info output. At the dawn of e-book readers and tablets, reading a on screen is\noﬃcially not silly anymore. Enjoy!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 12, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_sicp_abelson_chunk_0013_47721177", "text": "At the dawn of e-book readers and tablets, reading a on screen is\noﬃcially not silly anymore. Enjoy! A.R, May, 2011\nxi\nDedication\nT    ,inrespectandadmiration,tothespiritthat\nlives in the computer. “I think that it’s extraordinarily important that we in com-\nputer science keep fun in computing. When it started out,\nit was an awful lot of fun. Of course, the paying customers\ngotshaedeverynowandthen,andaerawhilewebegan\ntotaketheircomplaintsseriously.Webegantofeelasifwe\nreallywereresponsibleforthesuccessful,error-freeperfect\nuse of these machines. I don’t think we are. I think we’re\nresponsible for stretching them, seing them oﬀ in new di-\nrections, and keeping fun in the house. I hope the ﬁeld of\ncomputer science never loses its sense of fun. Above all, I\nhope we don’t become missionaries. Don’t feel as if you’re\nBible salesmen. e world has too many of those already. What you know about computing other people will learn.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 13, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 957}}
{"id": "computer_science_sicp_abelson_chunk_0014_7f7645a0", "text": "Above all, I\nhope we don’t become missionaries. Don’t feel as if you’re\nBible salesmen. e world has too many of those already. What you know about computing other people will learn. Don’t feel as if the key to successful computing is only in\nyour hands. What’s in your hands, I think and hope, is in-\ntelligence:theabilitytoseethemachineasmorethanwhen\nyou were ﬁrst led up to it, that you can make it more.”\n—Alan J. Perlis (April 1, 1922 – February 7, 1990)\nxii\nForeword\nE, ,  , psychologists, and parents pro-\ngram. Armies, students, and some societies are programmed. An\nassault on large problems employs a succession of programs, most of\nwhich spring into existence en route. ese programs are rife with is-\nsues that appear to be particular to the problem at hand. To appreciate\nprogrammingasanintellectualactivityinitsownrightyoumustturnto\ncomputerprogramming;youmustreadandwritecomputerprograms—\nmany of them.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 14, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 943}}
{"id": "computer_science_sicp_abelson_chunk_0015_59d8b92f", "text": "To appreciate\nprogrammingasanintellectualactivityinitsownrightyoumustturnto\ncomputerprogramming;youmustreadandwritecomputerprograms—\nmany of them. It doesn’t maer much what the programs are about or\nwhat applications they serve. What does maer is how well they per-\nform and how smoothly they ﬁt with other programs in the creation\nof still greater programs. e programmer must seek both perfection\nof part and adequacy of collection. In this book the use of “program” is\nfocused on the creation, execution, and study of programs wrien in a\ndialect of Lisp for execution on a digital computer. Using Lisp we re-\nstrict or limit not what we may program, but only the notation for our\nprogram descriptions. Our traﬃc with the subject maer of this book involves us with\nthreefociofphenomena:thehumanmind,collectionsofcomputerpro-\ngrams, and the computer. Every computer program is a model, hatched\nin the mind, of a real or mental process.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 15, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_sicp_abelson_chunk_0016_d67529d3", "text": "Every computer program is a model, hatched\nin the mind, of a real or mental process. ese processes, arising from\nxiii\nhuman experience and thought, are huge in number, intricate in de-\ntail,and atanytime onlypartially understood.eyaremodeled toour\npermanent satisfaction rarely by our computer programs. us even\nthough our programs are carefully handcraed discrete collections of\nsymbols,mosaicsofinterlockingfunctions,theycontinuallyevolve:we\nchange them as our perception of the model deepens, enlarges, gen-\neralizes until the model ultimately aains a metastable place within\nstill another model with which we struggle. e source of the exhilara-\ntion associated with computer programming is the continual unfolding\nwithin the mind and on the computer of mechanisms expressed as pro-\ngrams and the explosion of perception they generate. If art interprets\nour dreams, the computer executes them in the guise of programs! For all its power, the computer is a harsh taskmaster.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 16, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_sicp_abelson_chunk_0017_176d427b", "text": "If art interprets\nour dreams, the computer executes them in the guise of programs! For all its power, the computer is a harsh taskmaster. Its programs\nmustbecorrect,andwhatwewishtosaymustbesaidaccuratelyinev-\nery detail. As in every other symbolic activity, we become convinced of\nprogram truth through argument. Lisp itself can be assigned a seman-\ntics (another model, by the way), and if a program’s function can be\nspeciﬁed, say, in the predicate calculus, the proof methods of logic can\nbe used to make an acceptable correctness argument. Unfortunately, as\nprograms get large and complicated, as they almost always do, the ade-\nquacy,consistency,andcorrectnessofthespeciﬁcationsthemselvesbe-\ncome open to doubt, so that complete formal arguments of correctness\nseldom accompany large programs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 17, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 798}}
{"id": "computer_science_sicp_abelson_chunk_0018_90803eef", "text": "Since large programs grow from\nsmall ones, it is crucial that we develop an arsenal of standard program\nstructures of whose correctness we have become sure—we call them\nidioms—and learn to combine them into larger structures using orga-\nnizational techniques of proven value. ese techniques are treated at\nlengthinthisbook,andunderstandingthemisessentialtoparticipation\nin the Promethean enterprise called programming. More than anything\nxiv\nelse,theuncoveringandmasteryofpowerfulorganizationaltechniques\nacceleratesourabilitytocreatelarge,signiﬁcantprograms.Conversely,\nsincewritinglargeprogramsisverytaxing,wearestimulatedtoinvent\nnew methods of reducing the mass of function and detail to be ﬁed\ninto large programs. Unlike programs, computers must obey the laws of physics. If they\nwish to perform rapidly—a few nanoseconds per state change—they\nmust transmit electrons only small distances (at most 11\n2feet).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 18, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_sicp_abelson_chunk_0019_08af5350", "text": "Unlike programs, computers must obey the laws of physics. If they\nwish to perform rapidly—a few nanoseconds per state change—they\nmust transmit electrons only small distances (at most 11\n2feet). e heat\ngeneratedbythehugenumberofdevicessoconcentratedinspacehasto\nberemoved.Anexquisiteengineeringarthasbeendevelopedbalancing\nbetween multiplicity of function and density of devices. In any event,\nhardware always operates at a level more primitive than that at which\nwe care to program. e processes that transform our Lisp programs\nto “machine” programs are themselves abstract models which we pro-\ngram. eir study and creation give a great deal of insight into the or-\nganizational programs associated with programming arbitrary models. Of course the computer itself can be so modeled.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 19, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 786}}
{"id": "computer_science_sicp_abelson_chunk_0020_6534ad04", "text": "eir study and creation give a great deal of insight into the or-\nganizational programs associated with programming arbitrary models. Of course the computer itself can be so modeled. ink of it: the behav-\nior of the smallest physical switching element is modeled by quantum\nmechanics described by diﬀerential equations whose detailed behavior\nis captured by numerical approximations represented in computer pro-\ngrams executing on computers composed of : : :! It is not merely a maer of tactical convenience to separately iden-\ntify the three foci. Even though, as they say, it’s all in the head, this\nlogical separation induces an acceleration of symbolic traﬃc between\nthese foci whose richness, vitality, and potential is exceeded in human\nexperience only by the evolution of life itself. At best, relationships be-\ntweenthefociaremetastable.ecomputersareneverlargeenoughor\nfast enough.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 20, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_sicp_abelson_chunk_0021_995a13c8", "text": "At best, relationships be-\ntweenthefociaremetastable.ecomputersareneverlargeenoughor\nfast enough. Each breakthrough in hardware technology leads to more\nmassive programming enterprises, new organizational principles, and\nxv\nan enrichment of abstract models. Every reader should ask himself pe-\nriodically “Toward what end, toward what end?”—but do not ask it too\noen lest you pass up the fun of programming for the constipation of\nbiersweet philosophy. Among the programs we write, some (but never enough) perform a\nprecise mathematical function such as sorting or ﬁnding the maximum\nof a sequence of numbers, determining primality, or ﬁnding the square\nroot. We call such programs algorithms, and a great deal is known of\ntheir optimal behavior, particularly with respect to the two important\nparameters of execution time and data storage requirements.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 21, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 856}}
{"id": "computer_science_sicp_abelson_chunk_0022_c4b833b1", "text": "We call such programs algorithms, and a great deal is known of\ntheir optimal behavior, particularly with respect to the two important\nparameters of execution time and data storage requirements. A pro-\ngrammershouldacquiregoodalgorithmsandidioms.Eventhoughsome\nprogramsresist precise speciﬁcations, it is the responsibility of the pro-\ngrammer to estimate, and always to aempt to improve, their perfor-\nmance. Lisp is a survivor, having been in use for about a quarter of a cen-\ntury. Among the active programming languages only Fortran has had\na longer life. Both languages have supported the programming needs\nofimportant areas of application, Fortran forscientiﬁc and engineering\ncomputation and Lisp for artiﬁcial intelligence. ese two areas con-\ntinue to be important, and their programmers are so devoted to these\ntwolanguagesthatLispandFortranmaywellcontinueinactiveusefor\nat least another quarter-century. Lisp changes.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 22, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_sicp_abelson_chunk_0023_14add80d", "text": "ese two areas con-\ntinue to be important, and their programmers are so devoted to these\ntwolanguagesthatLispandFortranmaywellcontinueinactiveusefor\nat least another quarter-century. Lisp changes. e Scheme dialect used in this text has evolved from\nthe original Lisp and diﬀers from the laer in several important ways,\nincludingstaticscopingforvariablebindingandpermiingfunctionsto\nyield functions as values. In its semantic structure Scheme is as closely\nakintoAlgol60astoearlyLisps.Algol60,nevertobeanactivelanguage\nagain, lives on in the genes of Scheme and Pascal. It would be diﬃcult\ntoﬁndtwolanguagesthatarethecommunicatingcoinoftwomoredif-\nxvi\nferent cultures than those gathered around these two languages. Pas-\ncal is for building pyramids—imposing, breathtaking, static structures\nbuilt by armies pushing heavy blocks into place.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 23, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 842}}
{"id": "computer_science_sicp_abelson_chunk_0024_02b08dfd", "text": "Pas-\ncal is for building pyramids—imposing, breathtaking, static structures\nbuilt by armies pushing heavy blocks into place. Lisp is for building\norganisms—imposing,breathtaking,dynamicstructuresbuiltbysquads\nﬁingﬂuctuatingmyriadsofsimplerorganismsintoplace.eorganiz-\ningprinciplesusedarethesameinbothcases,exceptforoneextraordi-\nnarily important diﬀerence: e discretionary exportable functionality\nentrusted to the individual Lisp programmer is more than an order of\nmagnitude greater than that to be found within Pascal enterprises. Lisp\nprograms inﬂate libraries with functions whose utility transcends the\napplication that produced them. e list, Lisp’s native data structure, is\nlargely responsible for such growth of utility. e simple structure and\nnaturalapplicabilityoflistsarereﬂectedinfunctionsthatareamazingly\nnonidiosyncratic.InPascaltheplethoraofdeclarabledatastructuresin-\nduces a specialization within functions that inhibits and penalizes ca-\nsual cooperation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 24, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_sicp_abelson_chunk_0025_5ab33073", "text": "It is beer to have 100 functions operate on one data\nstructure than to have 10 functions operate on 10 data structures. As a\nresult the pyramid must stand unchanged for a millennium; the organ-\nism must evolve or perish. To illustrate this diﬀerence, compare the treatment of material and\nexerciseswithinthisbookwiththatinanyﬁrst-coursetextusingPascal. Do not labor under the illusion that this is a text digestible at only,\npeculiar to the breed found there. It is precisely what a serious book on\nprogramming Lisp must be, no maer who the student is or where it is\nused. Note that this is a text about programming, unlike most Lisp books,\nwhich are used as a preparation for work in artiﬁcial intelligence. Aer\nall, the critical programming concerns of soware engineering and ar-\ntiﬁcial intelligence tend to coalesce as the systems under investigation\nxvii\nbecome larger. is explains why there is such growing interest in Lisp\noutside of artiﬁcial intelligence.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 25, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_sicp_abelson_chunk_0026_ef64ad08", "text": "is explains why there is such growing interest in Lisp\noutside of artiﬁcial intelligence. As one would expect from its goals, artiﬁcial intelligence research\ngenerates many signiﬁcant programming problems. In other program-\nming cultures this spate of problems spawns new languages. Indeed, in\nanyverylargeprogrammingtaskausefulorganizingprincipleistocon-\ntrol and isolate traﬃc within the task modules via the invention of lan-\nguage.eselanguagestendtobecomelessprimitiveasoneapproaches\nthe boundaries of the system where we humans interact most oen. As\na result, such systems contain complex language-processing functions\nreplicatedmanytimes.Lisphassuchasimplesyntaxandsemanticsthat\nparsing can be treated as an elementary task. us parsing technology\nplaysalmostnoroleinLispprograms,andtheconstructionoflanguage\nprocessors is rarely an impediment to the rate of growth and change of\nlarge Lisp systems.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 26, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 908}}
{"id": "computer_science_sicp_abelson_chunk_0027_6a659b80", "text": "us parsing technology\nplaysalmostnoroleinLispprograms,andtheconstructionoflanguage\nprocessors is rarely an impediment to the rate of growth and change of\nlarge Lisp systems. Finally, it is this very simplicity of syntax and se-\nmantics that is responsible for the burden and freedom borne by all\nLisp programmers. No Lisp program of any size beyond a few lines can\nbewrienwithoutbeingsaturatedwithdiscretionaryfunctions.Invent\nand ﬁt; have ﬁts and reinvent! We toast the Lisp programmer who pens\nhis thoughts within nests of parentheses. Alan J. Perlis\nNew Haven, Connecticut\nxviii\nPreface to the Second Edition\nIs it possible that soware is not like anything else, that it\nis meant to be discarded: that the whole point is to always\nsee it as a soap bubble? —Alan J.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 27, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 770}}
{"id": "computer_science_sicp_abelson_chunk_0028_ffeb6890", "text": "—Alan J. Perlis\nT     has been the basis of ’s entry-level\ncomputersciencesubjectsince1980.Wehadbeenteachingthisma-\nterial for four years when the ﬁrst edition was published, and twelve\nmore years have elapsed until the appearance of this second edition. We are pleased that our work has been widely adopted and incorpo-\nrated into other texts. We have seen our students take the ideas and\nprograms in this book and build them in as the core of new computer\nsystemsandlanguages.InliteralrealizationofanancientTalmudicpun,\nour students have become our builders. We are lucky to have such ca-\npable students and such accomplished builders. In preparing this edition, we have incorporated hundreds of clariﬁ-\ncationssuggestedbyourownteachingexperienceandthecommentsof\ncolleagues at and elsewhere.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 28, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 819}}
{"id": "computer_science_sicp_abelson_chunk_0029_390d7c46", "text": "In preparing this edition, we have incorporated hundreds of clariﬁ-\ncationssuggestedbyourownteachingexperienceandthecommentsof\ncolleagues at and elsewhere. We have redesigned most of the ma-\njor programming systems in the book, including the generic-arithmetic\nsystem, the interpreters, the register-machine simulator, and the com-\npiler; and we have rewrien all the program examples to ensure that\nxix\nany Scheme implementation conforming to the Scheme standard\n(IEEE 1990 ) will be able to run the code. iseditionemphasizesseveralnewthemes.emostimportantof\nthese is the central role played by diﬀerent approaches to dealing with\ntime in computational models: objects with state, concurrent program-\nming, functional programming, lazy evaluation, and nondeterministic\nprogramming.Wehaveincludednewsectionsonconcurrencyandnon-\ndeterminism, and we have tried to integrate this theme throughout the\nbook. e ﬁrst edition of the book closely followed the syllabus of our\none-semester subject.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 29, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_sicp_abelson_chunk_0030_1cbd2a41", "text": "e ﬁrst edition of the book closely followed the syllabus of our\none-semester subject. With all the new material in the second edi-\ntion, it will not be possible to cover everything in a single semester,\nso the instructor will have to pick and choose. In our own teaching, we\nsometimesskipthesectiononlogicprogramming( Section4.4 ),wehave\nstudents use the register-machine simulator but we do not cover its im-\nplementation ( Section 5.2 ), and we give only a cursory overview of the\ncompiler ( Section 5.5 ). Even so, this is still an intense course. Some in-\nstructorsmaywishtocoveronlytheﬁrstthreeorfourchapters,leaving\nthe other material for subsequent courses. eWorld-Wide-Website hp://mitpress.mit.edu/sicp providessup-\nport for users of this book. is includes programs from the book, sam-\npleprogrammingassignments,supplementarymaterials,anddownload-\nable implementations of the Scheme dialect of Lisp. xx\nPreface to the First Edition\nA computer is like a violin.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 30, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_sicp_abelson_chunk_0031_458215f7", "text": "xx\nPreface to the First Edition\nA computer is like a violin. You can imagine a novice try-\ningﬁrstaphonographandthenaviolin.elaer,hesays,\nsounds terrible. at is the argument we have heard from\nour humanists and most of our computer scientists. Com-\nputer programs are good, they say, for particular purposes,\nbut they aren’t ﬂexible. Neither is a violin, or a typewriter,\nuntil you learn how to use it. —Marvin Minsky, “Why Programming Is a Good Medium\nforExpressingPoorly-UnderstoodandSloppily-Formulated\nIdeas”\n“T S  I  C P”\nistheentry-levelsubjectincomputerscienceattheMassachuses\nInstitute of Technology. It is required of all students at who major\nin electrical engineering or in computer science, as one-fourth of the\n“commoncorecurriculum,”whichalsoincludestwosubjectsoncircuits\nand linear systems and a subject on the design of digital systems.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 31, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_sicp_abelson_chunk_0032_6f17ca5b", "text": "We\nhave been involved in the development of this subject since 1978, and\nwe have taught this material in its present form since the fall of 1980 to\nbetween 600 and 700 students each year. Most of these students have\nxxi\nhad lile or no prior formal training in computation, although many\nhave played with computers a bit and a few have had extensive pro-\ngramming or hardware-design experience. Our design of this introductory computer-science subject reﬂects\ntwo major concerns. First, we want to establish the idea that a com-\nputer language is not just a way of geing a computer to perform oper-\nations but rather that it is a novel formal medium for expressing ideas\nabout methodology. us, programs must be wrien for people to read,\nand only incidentally for machines to execute.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 32, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 786}}
{"id": "computer_science_sicp_abelson_chunk_0033_4c703e14", "text": "us, programs must be wrien for people to read,\nand only incidentally for machines to execute. Second, we believe that\nthe essential material to be addressed by a subject at this level is not\nthe syntax of particular programming-language constructs, nor clever\nalgorithms for computing particular functions eﬃciently, nor even the\nmathematicalanalysisofalgorithmsandthefoundationsofcomputing,\nbut rather the techniques used to control the intellectual complexity of\nlarge soware systems. Our goal is that students who complete this subject should have a\ngood feel for the elements of style and the aesthetics of programming. ey should have command of the major techniques for controlling\ncomplexity in a large system. ey should be capable of reading a 50-\npage-long program, if it is wrien in an exemplary style. ey should\nknow what not to read, and what they need not understand at any mo-\nment.eyshouldfeelsecureaboutmodifyingaprogram,retainingthe\nspirit and style of the original author.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 33, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 997}}
{"id": "computer_science_sicp_abelson_chunk_0034_53419d82", "text": "ey should\nknow what not to read, and what they need not understand at any mo-\nment.eyshouldfeelsecureaboutmodifyingaprogram,retainingthe\nspirit and style of the original author. eseskillsarebynomeansuniquetocomputerprogramming.e\ntechniques we teach and draw upon are common to all of engineering\ndesign.Wecontrolcomplexitybybuildingabstractionsthathidedetails\nwhen appropriate. We control complexity by establishing conventional\ninterfaces that enable us to construct systems by combining standard,\nwell-understoodpiecesina“mixandmatch”way.Wecontrolcomplex-\nxxii\nitybyestablishingnewlanguagesfordescribingadesign,eachofwhich\nemphasizes particular aspects of the design and deemphasizes others. Underlyingourapproachtothissubjectisourconvictionthat“com-\nputer science” is not a science and that its signiﬁcance has lile to do\nwith computers. e computer revolution is a revolution in the way we\nthink and in the way we express what we think.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 34, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_sicp_abelson_chunk_0035_ead24fbf", "text": "e computer revolution is a revolution in the way we\nthink and in the way we express what we think. e essence of this\nchange is the emergence of what might best be called procedural epis-\ntemology —the study of the structure of knowledge from an imperative\npoint of view, as opposed to the more declarative point of view taken\nby classical mathematical subjects. Mathematics provides a framework\nfor dealing precisely with notions of “what is.” Computation provides a\nframework for dealing precisely with notions of “how to.”\nIn teaching our material we use a dialect of the programming lan-\nguage Lisp. We never formally teach the language, because we don’t\nhave to. We just use it, and students pick it up in a few days. is is\none great advantage of Lisp-like languages: ey have very few ways\nof forming compound expressions, and almost no syntactic structure. All of the formal properties can be covered in an hour, like the rules\nof chess.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 35, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_sicp_abelson_chunk_0036_44e220de", "text": "All of the formal properties can be covered in an hour, like the rules\nof chess. Aer a short time we forget about syntactic details of the lan-\nguage(becausetherearenone)andgetonwiththerealissues—ﬁguring\nout what we want to compute, how we will decompose problems into\nmanageable parts, and how we will work on the parts. Another advan-\ntage of Lisp is that it supports (but does not enforce) more of the large-\nscale strategies for modular decomposition of programs than any other\nlanguage we know. We can make procedural and data abstractions, we\ncan use higher-order functions to capture common paerns of usage,\nwe can model local state using assignment and data mutation, we can\nlinkpartsofaprogramwithstreamsanddelayedevaluation,andwecan\neasilyimplementembeddedlanguages.Allofthisisembeddedinanin-\nxxiii\nteractive environment with excellent support for incremental program\ndesign, construction, testing, and debugging.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 36, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 925}}
{"id": "computer_science_sicp_abelson_chunk_0037_27dd75fd", "text": "We thank all the genera-\ntionsofLispwizards,startingwithJohnMcCarthy,whohavefashioned\na ﬁne tool of unprecedented power and elegance. Scheme, the dialect of Lisp that we use, is an aempt to bring to-\ngetherthepowerandeleganceofLispandAlgol.FromLispwetakethe\nmetalinguistic power that derives from the simple syntax, the uniform\nrepresentation of programs as data objects, and the garbage-collected\nheap-allocateddata.FromAlgolwetakelexicalscopingandblockstruc-\nture, which are gis from the pioneers of programming-language de-\nsign who were on the Algol commiee. We wish to cite John Reynolds\nand Peter Landin for their insights into the relationship of Church’s λ-\ncalculus to the structure of programming languages. We also recognize\nour debt to the mathematicians who scouted out this territory decades\nbeforecomputersappearedonthescene.esepioneersincludeAlonzo\nChurch, Barkley Rosser, Stephen Kleene, and Haskell Curry.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 37, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_sicp_abelson_chunk_0038_55c1a7f3", "text": "xxiv\nAcknowledgments\nW     the many people who have helped us\ndevelop this book and this curriculum. Oursubjectisaclearintellectualdescendantof“6.231,”awonderful\nsubject on programming linguistics and the λ-calculus taught at in\nthe late 1960s by Jack Wozencra and Arthur Evans, Jr. We owe a great debt to Robert Fano, who reorganized ’s intro-\nductory curriculum in electrical engineering and computer science to\nemphasize the principles of engineering design. He led us in starting\noutonthisenterpriseandwrotetheﬁrstsetofsubjectnotesfromwhich\nthis book evolved. Much of the style and aesthetics of programming that we try to\nteach were developed in conjunction with Guy Lewis Steele Jr., who\ncollaborated with Gerald Jay Sussman in the initial development of the\nSchemelanguage.Inaddition,DavidTurner,PeterHenderson,DanFried-\nman, David Wise, and Will Clinger have taught us many of the tech-\nniques of the functional programming community that appear in this\nbook.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 38, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_sicp_abelson_chunk_0039_de4101e4", "text": "Joel Moses taught us about structuring large systems. His experi-\nence with the Macsyma system for symbolic computation provided the\ninsight that one should avoid complexities of control and concentrate\nxxv\non organizing the data to reﬂect the real structure of the world being\nmodeled. Marvin Minsky and Seymour Papert formed many of our aitudes\nabout programming and its place in our intellectual lives. To them we\nowe the understanding that computation provides a means of expres-\nsion for exploring ideas that would otherwise be too complex to deal\nwith precisely. ey emphasize that a student’s ability to write and\nmodify programs provides a powerful medium in which exploring be-\ncomes a natural activity. We also strongly agree with Alan Perlis that programming is lots of\nfunandwehadbeerbecarefultosupportthejoyofprogramming.Part\nof this joy derives from observing great masters at work. We are fortu-\nnatetohavebeenapprenticeprogrammersatthefeetofBillGosperand\nRichard Greenbla.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 39, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_sicp_abelson_chunk_0040_5fc91c6e", "text": "We are fortu-\nnatetohavebeenapprenticeprogrammersatthefeetofBillGosperand\nRichard Greenbla. It is diﬃcult to identify all the people who have contributed to the\ndevelopment of our curriculum. We thank all the lecturers, recitation\ninstructors, and tutors who have worked with us over the past ﬁeen\nyearsandputinmanyextrahoursonoursubject,especiallyBillSiebert,\nAlbert Meyer, Joe Stoy, Randy Davis, Louis Braida, Eric Grimson, Rod\nBrooks, Lynn Stein and Peter Szolovits. We would like to specially ac-\nknowledge the outstanding teaching contributions of Franklyn Turbak,\nnow at Wellesley; his work in undergraduate instruction set a standard\nthat we can all aspire to. We are grateful to Jerry Saltzer and Jim Miller\nfor helping us grapple with the mysteries of concurrency, and to Peter\nSzolovitsandDavidMcAllesterfortheircontributionstotheexposition\nof nondeterministic evaluation in Chapter 4 . Many people have put in signiﬁcant eﬀort presenting this material\nat other universities.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 40, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_sicp_abelson_chunk_0041_35ae257c", "text": "Many people have put in signiﬁcant eﬀort presenting this material\nat other universities. Some of the people we have worked closely with\nare Jacob Katzenelson at the Technion, Hardy Mayer at the University\nxxvi\nof California at Irvine, Joe Stoy at Oxford, Elisha Sacks at Purdue, and\nJan Komorowski at the Norwegian University of Science and Technol-\nogy. We are exceptionally proud of our colleagues who have received\nmajorteachingawardsfortheiradaptationsofthissubjectatotheruni-\nversities, including Kenneth Yip at Yale, Brian Harvey at the University\nof California at Berkeley, and Dan Huenlocher at Cornell. AlMoyéarrangedforustoteachthismaterialtoengineersatHewle-\nPackard, and for the production of videotapes of these lectures. We\nwould like to thank the talented instructors—in particular Jim Miller,\nBill Siebert, and Mike Eisenberg—who have designed continuing edu-\ncationcoursesincorporatingthesetapesandtaughtthematuniversities\nand industry all over the world.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 41, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_sicp_abelson_chunk_0042_7e2a0c82", "text": "Many educators in other countries have put in signiﬁcant work\ntranslating the ﬁrst edition. Michel Briand, Pierre Chamard, and An-\ndré Pic produced a French edition; Susanne Daniels-Herold produced\na German edition; and Fumio Motoyoshi produced a Japanese edition. We do not know who produced the Chinese edition, but we consider\nit an honor to have been selected as the subject of an “unauthorized”\ntranslation. Itishardtoenumerateallthepeoplewhohavemadetechnicalcon-\ntributions to the development of the Scheme systems we use for in-\nstructional purposes. In addition to Guy Steele, principal wizards have\nincluded Chris Hanson, Joe Bowbeer, Jim Miller, Guillermo Rozas, and\nStephen Adams.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 42, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 691}}
{"id": "computer_science_sicp_abelson_chunk_0043_d1502a1b", "text": "In addition to Guy Steele, principal wizards have\nincluded Chris Hanson, Joe Bowbeer, Jim Miller, Guillermo Rozas, and\nStephen Adams. Others who have put in signiﬁcant time are Richard\nStallman, Alan Bawden, Kent Pitman, Jon Ta, Neil Mayle, John Lamp-\ning, Gwyn Osnos, Tracy Larrabee, George Carree, Soma Chaudhuri,\nBill Chiarchiaro, Steven Kirsch, Leigh Klotz, Wayne Noss, Todd Cass,\nPatrickO’Donnell,Kevineobald,DanielWeise,KennethSinclair,An-\nthony Courtemanche, Henry M. Wu, Andrew Berlin, and Ruth Shyu. xxvii\nBeyond the implementation, we would like to thank the many\npeople who worked on the Scheme standard, including William\nClinger and Jonathan Rees, who edited the R4RS, and Chris Haynes,\nDavid Bartley, Chris Hanson, and Jim Miller, who prepared the \nstandard. Dan Friedman has been a long-time leader of the Scheme commu-\nnity.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 43, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 854}}
{"id": "computer_science_sicp_abelson_chunk_0044_155467ec", "text": "Dan Friedman has been a long-time leader of the Scheme commu-\nnity. e community’s broader work goes beyond issues of language\ndesign to encompass signiﬁcant educational innovations, such as the\nhigh-school curriculum based on EdScheme by Schemer’s Inc., and the\nwonderful books by Mike Eisenberg and by Brian Harvey and Mahew\nWright. We appreciate the work of those who contributed to making this a\nreal book, especially Terry Ehling, Larry Cohen, and Paul Bethge at the\nPress. Ella Mazel found the wonderful cover image. For the second\nedition we are particularly grateful to Bernard and Ella Mazel for help\nwith the book design, and to David Jones, T EX wizard extraordinaire. Wealsoareindebtedtothosereaderswhomadepenetratingcomments\non the new dra: Jacob Katzenelson, Hardy Mayer, Jim Miller, and es-\npeciallyBrianHarvey,whodiduntothisbookasJuliediduntohisbook\nSimply Scheme .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 44, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_sicp_abelson_chunk_0045_cb76d16f", "text": "Finally, we would like to acknowledge the support of the organiza-\ntions that have encouraged this work over the years, including support\nfrom Hewle-Packard, made possible by Ira Goldstein and Joel Birn-\nbaum, and support from , made possible by Bob Kahn. xxviii\n\nBuilding Abstractions with Procedures\neactsofthemind,whereinitexertsitspoweroversimple\nideas, are chieﬂy these three: 1. Combining several simple\nideas into one compound one, and thus all complex ideas\naremade.2.esecondisbringingtwoideas,whethersim-\nple or complex, together, and seing them by one another\nso as to take a view of them at once, without uniting them\ninto one, by which it gets all its ideas of relations. 3. e\nthird is separating them from all other ideas that accom-\npany them in their real existence: this is called abstraction,\nand thus all its general ideas are made. —John Locke, An Essay Concerning Human Understanding\n(1690)\nW     the idea of a computational process .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 45, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_sicp_abelson_chunk_0046_e33bc4c5", "text": "—John Locke, An Essay Concerning Human Understanding\n(1690)\nW     the idea of a computational process . Com-\nputational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called data. 1\ne evolution of a process is directed by a paern of rules called a pro-\ngram. People create programs to direct processes. In eﬀect, we conjure\nthe spirits of the computer with our spells. A computational process is indeed much like a sorcerer’s idea of a\nspirit. It cannot be seen or touched. It is not composed of maer at all. However, it is very real. It can perform intellectual work. It can answer\nquestions. It can aﬀect the world by disbursing money at a bank or by\ncontrolling a robot arm in a factory. e programs we use to conjure\nprocesses are like a sorcerer’s spells. ey are carefully composed from\nsymbolicexpressionsinarcaneandesoteric programming languages that\nprescribe the tasks we want our processes to perform.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 46, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 997}}
{"id": "computer_science_sicp_abelson_chunk_0047_f3543acc", "text": "ey are carefully composed from\nsymbolicexpressionsinarcaneandesoteric programming languages that\nprescribe the tasks we want our processes to perform. Acomputationalprocess,inacorrectlyworkingcomputer,executes\nprograms precisely and accurately. us, like the sorcerer’s appren-\ntice, novice programmers must learn to understand and to anticipate\nthe consequences of their conjuring. Even small errors (usually called\nbugsorglitches) in programs can have complex and unanticipated con-\nsequences. Fortunately,learningtoprogramisconsiderablylessdangerousthan\nlearningsorcery,becausethespiritswedealwithareconvenientlycon-\ntained in a secure way. Real-world programming, however, requires\ncare, expertise, and wisdom. A small bug in a computer-aided design\nprogram, for example, can lead to the catastrophic collapse of an air-\nplane or a dam or the self-destruction of an industrial robot.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 47, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_sicp_abelson_chunk_0048_4a900fa7", "text": "A small bug in a computer-aided design\nprogram, for example, can lead to the catastrophic collapse of an air-\nplane or a dam or the self-destruction of an industrial robot. Master soware engineers have the ability to organize programs so\nthat they can be reasonably sure that the resulting processes will per-\nform the tasks intended. ey can visualize the behavior of their sys-\ntems in advance. ey know how to structure programs so that unan-\nticipated problems do not lead to catastrophic consequences, and when\nproblems do arise, they can debugtheir programs. Well-designed com-\n2\nputational systems, like well-designed automobiles or nuclear reactors,\nare designed in a modular manner, so that the parts can be constructed,\nreplaced, and debugged separately. Programming in Lisp\nWe need an appropriate language for describing processes, and we will\nuse for this purpose the programming language Lisp.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 48, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_sicp_abelson_chunk_0049_564a9842", "text": "Programming in Lisp\nWe need an appropriate language for describing processes, and we will\nuse for this purpose the programming language Lisp. Just as our every-\ndaythoughtsareusuallyexpressedinournaturallanguage(suchasEn-\nglish,French,orJapanese),anddescriptionsofquantitativephenomena\nare expressed with mathematical notations, our procedural thoughts\nwill be expressed in Lisp. Lisp was invented in the late 1950s as a for-\nmalism for reasoning about the use of certain kinds of logical expres-\nsions, called recursion equations , as a model for computation. e lan-\nguage was conceived by John McCarthy and is based on his paper “Re-\ncursive Functions of Symbolic Expressions and eir Computation by\nMachine” ( McCarthy 1960 ). Despite its inception as a mathematical formalism, Lisp is a practi-\ncal programming language. A Lisp interpreter is a machine that carries\nout processes described in the Lisp language.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 49, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_sicp_abelson_chunk_0050_bf3bbd01", "text": "Despite its inception as a mathematical formalism, Lisp is a practi-\ncal programming language. A Lisp interpreter is a machine that carries\nout processes described in the Lisp language. e ﬁrst Lisp interpreter\nwas implemented by McCarthy with the help of colleagues and stu-\ndentsintheArtiﬁcialIntelligenceGroupofthe ResearchLaboratory\nof Electronics and in the Computation Center.1Lisp, whose name\nis an acronym for LISt Processing, was designed to provide symbol-\nmanipulating capabilities for aacking programming problems such as\nthe symbolic diﬀerentiation and integration of algebraic expressions. It included for this purpose new data objects known as atoms and lists,\n1eLisp 1 Programmer’s Manual appeared in 1960, and the Lisp 1.5 Programmer’s\nManual (McCarthy et al. 1965 ) was published in 1962. e early history of Lisp is de-\nscribed in McCarthy 1978 . 3\nwhichmoststrikinglysetitapartfromallotherlanguagesoftheperiod. Lisp was not the product of a concerted design eﬀort.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 50, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_sicp_abelson_chunk_0051_3672638a", "text": "e early history of Lisp is de-\nscribed in McCarthy 1978 . 3\nwhichmoststrikinglysetitapartfromallotherlanguagesoftheperiod. Lisp was not the product of a concerted design eﬀort. Instead, it\nevolved informally in an experimental manner in response to users’\nneeds and to pragmatic implementation considerations. Lisp’s informal\nevolution has continued through the years, and the community of Lisp\nusers has traditionally resisted aempts to promulgate any “oﬃcial”\ndeﬁnition of the language. is evolution, together with the ﬂexibility\nandeleganceoftheinitialconception,hasenabledLisp,whichisthesec-\nond oldest language in widespread use today (only Fortran is older), to\ncontinually adapt to encompass the most modern ideas about program\ndesign. us, Lisp is by now a family of dialects, which, while sharing\nmostof theoriginal features,may diﬀerfromoneanother insigniﬁcant\nways.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 51, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 879}}
{"id": "computer_science_sicp_abelson_chunk_0052_09989251", "text": "us, Lisp is by now a family of dialects, which, while sharing\nmostof theoriginal features,may diﬀerfromoneanother insigniﬁcant\nways. e dialect of Lisp used in this book is called Scheme.2\nBecause of its experimental character and its emphasis on symbol\nmanipulation, Lisp was at ﬁrst very ineﬃcient for numerical compu-\ntations, at least in comparison with Fortran. Over the years, however,\n2e two dialects in which most major Lisp programs of the 1970s were wrien are\nMacLisp ( Moon 1978 ;Pitman 1983 ), developed at the Project, and Interlisp\n(Teitelman 1974 ), developed at Bolt Beranek and Newman Inc. and the Xerox Palo Alto\nResearch Center.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 52, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 656}}
{"id": "computer_science_sicp_abelson_chunk_0053_85c09a0d", "text": "and the Xerox Palo Alto\nResearch Center. Portable Standard Lisp ( Hearn 1969 ;Griss 1981 ) was a Lisp dialect\ndesignedtobeeasilyportablebetweendiﬀerentmachines.MacLispspawnedanumber\nof subdialects, such as Franz Lisp, which was developed at the University of California\nat Berkeley, and Zetalisp ( Moon and Weinreb 1981 ), which was based on a special-\npurpose processor designed at the Artiﬁcial Intelligence Laboratory to run Lisp\nvery eﬃciently. e Lisp dialect used in this book, called Scheme ( Steele and Sussman\n1975), was invented in 1975 by Guy Lewis Steele Jr. and Gerald Jay Sussman of the \nArtiﬁcial Intelligence Laboratory and later reimplemented for instructional use at . Scheme became an standard in 1990 ( IEEE 1990 ). e Common Lisp dialect ( Steele\n1982,Steele 1990 ) was developed by the Lisp community to combine features from the\nearlier Lisp dialects to make an industrial standard for Lisp. Common Lisp became an\nstandard in 1994 ( ANSI 1994 ).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 53, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_sicp_abelson_chunk_0054_eaaacdf8", "text": "Common Lisp became an\nstandard in 1994 ( ANSI 1994 ). 4\nLisp compilers have been developed that translate programs into ma-\nchine code that can perform numerical computations reasonably eﬃ-\nciently. And for special applications, Lisp has been used with great ef-\nfectiveness.3Although Lisp has not yet overcome its old reputation as\nhopelessly ineﬃcient, Lisp is now used in many applications where ef-\nﬁciency is not the central concern. For example, Lisp has become a lan-\nguage of choice for operating-system shell languages and for extension\nlanguages for editors and computer-aided design systems. If Lisp is not a mainstream language, why are we using it as the\nframework for our discussion of programming?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 54, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 716}}
{"id": "computer_science_sicp_abelson_chunk_0055_c1cd51a5", "text": "If Lisp is not a mainstream language, why are we using it as the\nframework for our discussion of programming? Because the language\npossessesuniquefeaturesthatmakeitanexcellentmediumforstudying\nimportantprogrammingconstructsand datastructuresand forrelating\nthemtothelinguisticfeaturesthatsupportthem.emostsigniﬁcantof\nthesefeaturesisthefactthatLispdescriptionsofprocesses,called proce-\ndures, can themselves be represented and manipulated as Lisp data. e\nimportanceofthisisthattherearepowerfulprogram-designtechniques\nthat rely on the ability to blur the traditional distinction between “pas-\nsive” data and “active” processes. As we shall discover, Lisp’s ﬂexibility\nin handling procedures as data makes it one of the most convenient\nlanguages in existence for exploring these techniques.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 55, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 791}}
{"id": "computer_science_sicp_abelson_chunk_0056_34406584", "text": "As we shall discover, Lisp’s ﬂexibility\nin handling procedures as data makes it one of the most convenient\nlanguages in existence for exploring these techniques. e ability to\nrepresent procedures as data also makes Lisp an excellent language for\nwritingprogramsthatmustmanipulateotherprogramsasdata,suchas\ntheinterpretersandcompilersthatsupportcomputerlanguages.Above\nand beyond these considerations, programming in Lisp is great fun. 3One such special application was a breakthrough computation of scientiﬁc\nimportance—an integration of the motion of the Solar System that extended previous\nresults by nearly two orders of magnitude, and demonstrated that the dynamics of the\nSolar System is chaotic. is computation was made possible by new integration al-\ngorithms,aspecial-purpose compiler,and aspecial-purpose computerallimplemented\nwiththeaidofsowaretoolswrieninLisp( Abelsonetal.1992 ;SussmanandWisdom\n1992).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 56, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_sicp_abelson_chunk_0057_8cb6e836", "text": "5\n1.1The Elements of Programming\nA powerful programming language is more than just a means for in-\nstructing a computer to perform tasks. e language also serves as a\nframework within which we organize our ideas about processes. us,\nwhen we describe a language, we should pay particular aention to the\nmeans that the language provides for combining simple ideas to form\nmore complex ideas. Every powerful language has three mechanisms\nfor accomplishing this:\n•primitive expressions , which represent the simplest entities the\nlanguage is concerned with,\n•means of combination , by which compound elements are built\nfrom simpler ones, and\n•means of abstraction ,bywhichcompoundelementscanbenamed\nand manipulated as units. In programming, we deal with two kinds of elements: procedures and\ndata. (Later we will discover that they are really not so distinct.) Infor-\nmally, data is “stuﬀ” that we want to manipulate, and procedures are\ndescriptions of the rules for manipulating the data.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 57, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_sicp_abelson_chunk_0058_451c9353", "text": "(Later we will discover that they are really not so distinct.) Infor-\nmally, data is “stuﬀ” that we want to manipulate, and procedures are\ndescriptions of the rules for manipulating the data. us, any powerful\nprogramming language should be able to describe primitive data and\nprimitive procedures and should have methods for combining and ab-\nstracting procedures and data. In this chapter we will deal only with simple numerical data so that\nwe can focus on the rules for building procedures.4In later chapters we\n4e characterization of numbers as “simple data” is a barefaced bluﬀ. In fact, the\ntreatment of numbers is one of the trickiest and most confusing aspects of any pro-\n6\nwillseethatthesesamerulesallowustobuildprocedurestomanipulate\ncompound data as well. 1.1.1Expressions\nOneeasywaytogetstartedatprogrammingistoexaminesometypical\ninteractions with an interpreter for the Scheme dialect of Lisp. Imagine\nthat you are siing at a computer terminal.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 58, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_sicp_abelson_chunk_0059_90f37a30", "text": "1.1.1Expressions\nOneeasywaytogetstartedatprogrammingistoexaminesometypical\ninteractions with an interpreter for the Scheme dialect of Lisp. Imagine\nthat you are siing at a computer terminal. You type an expression , and\nthe interpreter responds by displaying the result of its evaluating that\nexpression. Onekindofprimitiveexpressionyoumighttypeisanumber.(More\nprecisely, the expression that you type consists of the numerals that\nrepresent the number in base 10.) If you present Lisp with a number\n486\nthe interpreter will respond by printing5\n486\ngramming language. Some typical issues involved are these: Some computer systems\ndistinguish integers, such as 2, from real numbers , such as 2.71. Is the real number 2.00\ndiﬀerent from the integer 2? Are the arithmetic operations used for integers the same\nas the operations used for real numbers? Does 6 divided by 2 produce 3, or 3.0? How\nlarge a number can we represent?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 59, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_sicp_abelson_chunk_0060_29b135f6", "text": "Are the arithmetic operations used for integers the same\nas the operations used for real numbers? Does 6 divided by 2 produce 3, or 3.0? How\nlarge a number can we represent? How many decimal places of accuracy can we repre-\nsent?Istherangeofintegersthesameastherangeofrealnumbers?Aboveandbeyond\nthese questions, of course, lies a collection of issues concerning roundoﬀ and trunca-\ntion errors—the entire science of numerical analysis. Since our focus in this book is on\nlarge-scaleprogramdesignratherthanonnumericaltechniques,wearegoingtoignore\nthese problems. e numerical examples in this chapter will exhibit the usual roundoﬀ\nbehavior that one observes when using arithmetic operations that preserve a limited\nnumber of decimal places of accuracy in noninteger operations. 5roughout this book, when we wish to emphasize the distinction between the\ninput typed by the user and the response printed by the interpreter, we will show the\nlaer in slanted characters.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 60, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_sicp_abelson_chunk_0061_b0cf52b3", "text": "5roughout this book, when we wish to emphasize the distinction between the\ninput typed by the user and the response printed by the interpreter, we will show the\nlaer in slanted characters. 7\nExpressions representing numbers may be combined with an expres-\nsion representing a primitive procedure (such as +or*) to form a com-\npound expression that represents the application of the procedure to\nthose numbers. For example:\n(+ 137 349)\n486\n(- 1000 334)\n666\n(* 5 99)\n495\n(/ 10 5)\n2\n(+ 2.7 10)\n12.7\nExpressions such as these, formed by delimiting a list of expressions\nwithin parentheses in order to denote procedure application, are called\ncombinations . e lemost element in the list is called the operator, and\nthe other elements are called operands . e value of a combination is\nobtained by applying the procedure speciﬁed by the operator to the ar-\nguments that are the values of the operands.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 61, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_sicp_abelson_chunk_0062_19f6ba87", "text": "e value of a combination is\nobtained by applying the procedure speciﬁed by the operator to the ar-\nguments that are the values of the operands. e convention of placing the operator to the le of the operands\nis known as preﬁx notation , and it may be somewhat confusing at ﬁrst\nbecause it departs signiﬁcantly from the customary mathematical con-\nvention. Preﬁx notation has several advantages, however. One of them\nis that it can accommodate procedures that may take an arbitrary num-\nber of arguments, as in the following examples:\n8\n(+ 21 35 12 7)\n75\n(* 25 4 12)\n1200\nNo ambiguity can arise, because the operator is always the lemost el-\nement and the entire combination is delimited by the parentheses.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 62, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 709}}
{"id": "computer_science_sicp_abelson_chunk_0063_99428088", "text": "Asecondadvantageofpreﬁxnotationisthatitextendsinastraight-\nforward way to allow combinations to be nested, that is, to have combi-\nnations whose elements are themselves combinations:\n(+ (* 3 5) (- 10 6))\n19\nere is no limit (in principle) to the depth of such nesting and to the\noverallcomplexityof the expressionsthat the Lisp interpretercan eval-\nuate.Itiswehumanswhogetconfusedbystillrelativelysimpleexpres-\nsions such as\n(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))\nwhich theinterpreterwouldreadily evaluateto be 57. Wecan help our-\nselves by writing such an expression in the form\n(+ (* 3\n(+ (* 2 4)\n(+ 3 5)))\n(+ (- 10 7)\n6))\nfollowing a formaing convention known as prey-printing , in which\neach long combination is wrien so that the operands are aligned ver-\ntically.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 63, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 777}}
{"id": "computer_science_sicp_abelson_chunk_0064_cd5e795b", "text": "e resulting indentations display clearly the structure of the\n9\nexpression.6\nEven with complex expressions, the interpreter always operates in\nthesamebasiccycle:Itreadsanexpressionfromtheterminal,evaluates\nthe expression, and prints the result. is mode of operation is oen\nexpressed by saying that the interpreter runs in a read-eval-print loop . Observe in particular that it is not necessary to explicitly instruct the\ninterpreter to print the value of the expression.7\n1.1.2Naming and the Environment\nA critical aspect of a programming language is the means it provides\nforusingnamestorefertocomputationalobjects.Wesaythatthename\nidentiﬁes a variable whose valueis the object. In the Scheme dialect of Lisp, we name things with define.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 64, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 741}}
{"id": "computer_science_sicp_abelson_chunk_0065_d4d260c5", "text": "In the Scheme dialect of Lisp, we name things with define. Typing\n(define size 2)\ncauses the interpreter to associate the value 2 with the name size.8\nOnce the name sizehas been associated with the number 2, we can\nrefer to the value 2 by name:\nsize\n2\n6Lisp systems typically provide features to aid the user in formaing expressions. Two especially useful features are one that automatically indents to the proper prey-\nprint position whenever a new line is started and one that highlights the matching le\nparenthesis whenever a right parenthesis is typed. 7Lisp obeys the convention that every expression has a value. is convention, to-\ngether with the old reputation of Lisp as an ineﬃcient language, is the source of the\nquipbyAlanPerlis(paraphrasingOscarWilde)that“Lispprogrammersknowthevalue\nof everything but the cost of nothing.”\n8In this book, we do not show the interpreter’s response to evaluating deﬁnitions,\nsince this is highly implementation-dependent.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 65, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_sicp_abelson_chunk_0066_0c837d59", "text": "10\n(* 5 size )\n10\nHere are further examples of the use of define:\n(define pi3.14159)\n(define radius 10)\n(*pi(*radius radius ))\n314.159\n(define circumference (* 2 piradius ))\ncircumference\n62.8318\ndefine is our language’s simplest means of abstraction, for it allows\nus to use simple names to refer to the results of compound operations,\nsuch as the circumference computed above. In general, computational\nobjects may have very complex structures, and it would be extremely\ninconvenienttohavetorememberandrepeattheirdetailseachtimewe\nwant to use them. Indeed, complex programs are constructed by build-\ning, step by step, computational objects of increasing complexity.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 66, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 668}}
{"id": "computer_science_sicp_abelson_chunk_0067_1b80a5bb", "text": "Indeed, complex programs are constructed by build-\ning, step by step, computational objects of increasing complexity. e\ninterpreter makes this step-by-step program construction particularly\nconvenient because name-object associations can be created incremen-\ntallyinsuccessiveinteractions.isfeatureencouragestheincremental\ndevelopment and testing of programs and is largely responsible for the\nfact that a Lisp program usually consists of a large number of relatively\nsimple procedures. Itshouldbeclearthatthepossibilityofassociatingvalueswithsym-\nbolsandlaterretrievingthemmeansthattheinterpretermustmaintain\nsome sort of memory that keeps track of the name-object pairs. is\nmemory is called the environment (more precisely the global environ-\nment, since we will see later that a computation may involve a number\n11\nof diﬀerent environments).9\n1.1.3Evaluating Combinations\nOne of our goals in this chapter is to isolate issues about thinking pro-\ncedurally.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 67, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_sicp_abelson_chunk_0068_da8eea71", "text": "As a case in point, let us consider that, in evaluating combi-\nnations, the interpreter is itself following a procedure. To evaluate a combination, do the following:\n1.Evaluate the subexpressions of the combination. 2.Apply the procedure that is the value of the lemost subexpres-\nsion (the operator) to the arguments that are the values of the\nother subexpressions (the operands). Even this simple rule illustrates some important points about processes\nin general. First, observe that the ﬁrst step dictates that in order to ac-\ncomplish the evaluation process for a combination we must ﬁrst per-\nform the evaluation process on each element of the combination. us,\nthe evaluation rule is recursive in nature; that is, it includes, as one of\nits steps, the need to invoke the rule itself.10\nNotice how succinctly the idea of recursion can be used to express\nwhat, in the case of a deeply nested combination, would otherwise be\nviewed as a rather complicated process.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 68, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_sicp_abelson_chunk_0069_fb27c26c", "text": "For example, evaluating\n9Chapter 3 will show that this notion of environment is crucial, both for under-\nstanding how the interpreter works and for implementing interpreters. 10It may seem strange that the evaluation rule says, as part of the ﬁrst step, that\nwe should evaluate the lemost element of a combination, since at this point that can\nonly be an operator such as +or*representing a built-in primitive procedure such as\naddition or multiplication. We will see later that it is useful to be able to work with\ncombinations whose operators are themselves compound expressions. 12\n15 26\n24 2390\n75 3\n6 4+\n**\n+Figure1.1: Tree representation, showing the value of each\nsubcombination.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 69, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 687}}
{"id": "computer_science_sicp_abelson_chunk_0070_d90df9a0", "text": "12\n15 26\n24 2390\n75 3\n6 4+\n**\n+Figure1.1: Tree representation, showing the value of each\nsubcombination. (* (+ 2 (* 4 6))\n(+ 3 5 7))\nrequires that the evaluation rule be applied to four diﬀerent combina-\ntions.Wecanobtainapictureofthisprocessbyrepresentingthecombi-\nnationintheformofatree,asshownin Figure1.1 .Eachcombinationis\nrepresentedbyanodewithbranchescorrespondingtotheoperatorand\nthe operands of the combination stemming from it. e terminal nodes\n(that is, nodes with no branches stemming from them) represent either\noperators or numbers. Viewing evaluation in terms of the tree, we can\nimaginethatthevaluesoftheoperandspercolateupward,startingfrom\nthe terminal nodes and then combining at higher and higher levels. In\ngeneral, we shall see that recursion is a very powerful technique for\ndealing with hierarchical, treelike objects. In fact, the “percolate values\nupward” form of the evaluation rule is an example of a general kind of\nprocess known as tree accumulation .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 70, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_sicp_abelson_chunk_0071_e913959c", "text": "In fact, the “percolate values\nupward” form of the evaluation rule is an example of a general kind of\nprocess known as tree accumulation . Next,observethattherepeatedapplicationoftheﬁrststepbringsus\ntothepointwhereweneedtoevaluate,notcombinations,butprimitive\nexpressions such as numerals, built-in operators, or other names. We\n13\ntake care of the primitive cases by stipulating that\n•the values of numerals are the numbers that they name,\n•the values of built-in operators are the machine instruction se-\nquences that carry out the corresponding operations, and\n•the values of other names are the objects associated with those\nnames in the environment. Wemayregardthesecondruleasaspecialcaseofthethirdonebystip-\nulatingthatsymbolssuchas +and*arealsoincludedintheglobalenvi-\nronment,andareassociatedwiththesequencesofmachineinstructions\nthataretheir“values.”ekeypointtonoticeistheroleoftheenviron-\nment in determining the meaning of the symbols in expressions.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 71, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_sicp_abelson_chunk_0072_a1bb98bd", "text": "In an\ninteractivelanguagesuchasLisp,itismeaninglesstospeakofthevalue\nof an expression such as (+ x 1) without specifying any information\nabout the environment that would provide a meaning for the symbol\nx(or even for the symbol +). As we shall see in Chapter 3 , the general\nnotion of the environment as providing a context in which evaluation\ntakesplacewillplayanimportantroleinourunderstandingofprogram\nexecution. Notice that the evaluation rule given above does not handle deﬁni-\ntions. For instance, evaluating (define x 3) does not apply defineto\ntwo arguments, one of which is the value of the symbol xand the other\nof which is 3, since the purpose of the defineis precisely to associate x\nwith a value. (at is, (define x 3) is not a combination.)\nSuchexceptionstothegeneralevaluationrulearecalled special forms . defineis the only example of a special form that we have seen so far,\nbut we will meet others shortly. Each special form has its own evalu-\nation rule.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 72, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_sicp_abelson_chunk_0073_e6f8537c", "text": "defineis the only example of a special form that we have seen so far,\nbut we will meet others shortly. Each special form has its own evalu-\nation rule. e various kinds of expressions (each with its associated\n14\nevaluation rule) constitute the syntax of the programming language. In\ncomparison with most other programming languages, Lisp has a very\nsimple syntax; that is, the evaluation rule for expressions can be de-\nscribed by a simple general rule together with specialized rules for a\nsmall number of special forms.11\n1.1.4Compound Procedures\nWehaveidentiﬁedinLispsomeoftheelementsthatmustappearinany\npowerful programming language:\n•Numbersandarithmeticoperationsareprimitivedataandproce-\ndures. •Nesting of combinations provides a means of combining opera-\ntions. •Deﬁnitions that associate names with values provide a limited\nmeans of abstraction.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 73, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 856}}
{"id": "computer_science_sicp_abelson_chunk_0074_b4816c84", "text": "•Nesting of combinations provides a means of combining opera-\ntions. •Deﬁnitions that associate names with values provide a limited\nmeans of abstraction. Now we will learn about procedure deﬁnitions , a much more powerful\nabstraction technique by which a compound operation can be given a\nname and then referred to as a unit. 11Special syntactic forms that are simply convenient alternative surface structures\nfor things that can be wrien in more uniform ways are sometimes called syntactic\nsugar, to use a phrase coined by Peter Landin. In comparison with users of other lan-\nguages, Lisp programmers, as a rule, are less concerned with maers of syntax.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 74, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 656}}
{"id": "computer_science_sicp_abelson_chunk_0075_9b6b8fc8", "text": "In comparison with users of other lan-\nguages, Lisp programmers, as a rule, are less concerned with maers of syntax. (By\ncontrast, examine any Pascal manual and notice how much of it is devoted to descrip-\ntions of syntax.) is disdain for syntax is due partly to the ﬂexibility of Lisp, which\nmakes it easy to change surface syntax, and partly to the observation that many “con-\nvenient” syntactic constructs, which make the language less uniform, end up causing\nmore trouble than they are worth when programs become large and complex. In the\nwords of Alan Perlis, “Syntactic sugar causes cancer of the semicolon.”\n15\nWe begin by examining how to express the idea of “squaring.” We\nmightsay,“Tosquaresomething,multiplyitbyitself.”isisexpressed\nin our language as\n(define (square x) (* xx))\nWe can understand this in the following way:\n(define (square x) (* x x))\n| | | | | |\nTo square something, multiply it by itself . We have here a compound procedure , which has been given the name\nsquare.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 75, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_sicp_abelson_chunk_0076_d38e4f92", "text": "We have here a compound procedure , which has been given the name\nsquare. e procedure represents the operation of multiplying some-\nthingbyitself.ethingtobemultipliedisgivenalocalname, x,which\nplaysthesamerolethatapronounplaysinnaturallanguage.Evaluating\nthe deﬁnition creates this compound procedure and associates it with\nthe name square.12\ne general form of a procedure deﬁnition is\n(define (⟨name⟩⟨formal parameters ⟩)\n⟨body⟩)\ne⟨name⟩isasymboltobeassociatedwiththeproceduredeﬁnitionin\nthe environment.13e⟨formal parameters ⟩are the names used within\nthe body of the procedure to refer to the corresponding arguments of\nthe procedure. e ⟨body⟩is an expression that will yield the value of\n12Observethattherearetwodiﬀerentoperationsbeingcombinedhere:wearecreat-\ningtheprocedure,andwearegivingitthename square.Itispossible,indeedimportant,\nto be able to separate these two notions—to create procedures without naming them,\nand to give names to procedures that have already been created.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 76, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_sicp_abelson_chunk_0077_eb20bee6", "text": "We will see how to do\nthis inSection 1.3.2 . 13roughout this book, we will describe the general syntax of expressions by using\nitalic symbols delimited by angle brackets—e.g., ⟨name⟩—to denote the “slots” in the\nexpression to be ﬁlled in when such an expression is actually used. 16\nthe procedure application when the formal parameters are replaced by\nthe actual arguments to which the procedure is applied.14e⟨name⟩\nandthe⟨formal parameters⟩aregroupedwithinparentheses,justasthey\nwould be in an actual call to the procedure being deﬁned. Having deﬁned square, we can now use it:\n(square 21)\n441\n(square (+ 2 5))\n49\n(square (square 3))\n81\nWecanalsouse squareasabuildingblockindeﬁningotherprocedures.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 77, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 701}}
{"id": "computer_science_sicp_abelson_chunk_0078_d0c671f7", "text": "Having deﬁned square, we can now use it:\n(square 21)\n441\n(square (+ 2 5))\n49\n(square (square 3))\n81\nWecanalsouse squareasabuildingblockindeﬁningotherprocedures. For example, x2+y2can be expressed as\n(+ ( square x) (square y))\nWe can easily deﬁne a procedure sum-of-squares that, given any two\nnumbers as arguments, produces the sum of their squares:\n(define (sum-of-squares xy)\n(+ ( square x) (square y)))\n(sum-of-squares 3 4)\n25\nNow we can use sum-of-squares as a building block in constructing\nfurther procedures:\n(define (fa)\n(sum-of-squares (+a1) (* a2)))\n(f5)\n136\n14Moregenerally,thebodyoftheprocedurecanbeasequenceofexpressions.Inthis\ncase, the interpreter evaluates each expression in the sequence in turn and returns the\nvalue of the ﬁnal expression as the value of the procedure application. 17\nCompound procedures are used in exactly the same way as primitive\nprocedures.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 78, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 881}}
{"id": "computer_science_sicp_abelson_chunk_0079_80e88787", "text": "17\nCompound procedures are used in exactly the same way as primitive\nprocedures. Indeed, one could not tell by looking at the deﬁnition of\nsum-of-squares given above whether squarewas built into the inter-\npreter, like +and*, or deﬁned as a compound procedure. 1.1.5The Substitution Model for Procedure Application\nTo evaluate a combination whose operator names a compound proce-\ndure, the interpreter follows much the same process as for combina-\ntions whose operators name primitive procedures, which we described\ninSection 1.1.3 . at is, the interpreter evaluates the elements of the\ncombination and applies the procedure (which is the value of the oper-\nator of the combination) to the arguments (which are the values of the\noperands of the combination). We can assume that the mechanism for applying primitive proce-\ndures to arguments is built into the interpreter.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 79, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 872}}
{"id": "computer_science_sicp_abelson_chunk_0080_c75b473e", "text": "We can assume that the mechanism for applying primitive proce-\ndures to arguments is built into the interpreter. For compound proce-\ndures, the application process is as follows:\nToapplyacompoundproceduretoarguments,evaluatethe\nbodyoftheprocedurewitheachformalparameterreplaced\nby the corresponding argument. To illustrate this process, let’s evaluate the combination\n(f5)\nwhere fistheproceduredeﬁnedin Section1.1.4 .Webeginbyretrieving\nthe body of f:\n(sum-of-squares (+a1) (* a2))\nen we replace the formal parameter aby the argument 5:\n(sum-of-squares (+ 5 1) (* 5 2))\n18\nus the problem reduces to the evaluation of a combination with two\noperands and an operator sum-of-squares . Evaluating this combina-\ntion involves three subproblems. We must evaluate the operator to get\nthe procedure to be applied, and we must evaluate the operands to get\nthe arguments.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 80, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 863}}
{"id": "computer_science_sicp_abelson_chunk_0081_e9a50f47", "text": "Evaluating this combina-\ntion involves three subproblems. We must evaluate the operator to get\nthe procedure to be applied, and we must evaluate the operands to get\nthe arguments. Now (+ 5 1) produces 6 and (* 5 2) produces 10, so\nwemustapplythe sum-of-squares procedureto6and10.esevalues\nare substituted for the formal parameters xandyin the body of sum-\nof-squares , reducing the expression to\n(+ ( square 6) ( square 10))\nIf we use the deﬁnition of square, this reduces to\n(+ (* 6 6) (* 10 10))\nwhich reduces by multiplication to\n(+ 36 100)\nand ﬁnally to\n136\ne process we have just described is called the substitution model for\nprocedure application. It can be taken as a model that determines the\n“meaning” of procedure application, insofar as the procedures in this\nchapter are concerned. However, there are two points that should be\nstressed:\n•e purpose of the substitution is to help us think about proce-\ndure application, not to provide a description of how the inter-\npreter really works.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 81, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_sicp_abelson_chunk_0082_80e55f9c", "text": "Typical interpreters do not evaluate proce-\ndure applications by manipulating the text of a procedure to sub-\nstitute values for the formal parameters. In practice, the “substi-\ntution” is accomplished by using a local environment for the for-\nmal parameters. We will discuss this more fully in Chapter 3 and\n19\nChapter4 whenweexaminetheimplementationofaninterpreter\nin detail. •Over the course of this book, we will present a sequence of in-\ncreasingly elaborate models of how interpreters work, culminat-\ning with a complete implementation of an interpreter and com-\npilerinChapter5 .esubstitutionmodelisonlytheﬁrstofthese\nmodels—a way to get started thinking formally about the evalu-\nation process. In general, when modeling phenomena in science\nand engineering, we begin with simpliﬁed, incomplete models. As we examine things in greater detail, these simple models be-\ncome inadequate and must be replaced by more reﬁned models. e substitution model is no exception.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 82, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_sicp_abelson_chunk_0083_5e0de005", "text": "As we examine things in greater detail, these simple models be-\ncome inadequate and must be replaced by more reﬁned models. e substitution model is no exception. In particular, when we\naddress in Chapter 3 the use of procedures with “mutable data,”\nwe will see that the substitution model breaks down and must be\nreplacedbyamorecomplicatedmodelofprocedureapplication.15\nApplicative order versus normal order\nAccording to the description of evaluation given in Section 1.1.3 , the\ninterpreter ﬁrst evaluates the operator and operands and then applies\nthe resulting procedure to the resulting arguments. is is not the only\nway to perform evaluation. An alternative evaluation model would not\nevaluate the operands until their values were needed. Instead it would\n15Despite the simplicity of the substitution idea, it turns out to be surprisingly com-\nplicated to give a rigorous mathematical deﬁnition of the substitution process.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 83, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_sicp_abelson_chunk_0084_5de8b8b6", "text": "Instead it would\n15Despite the simplicity of the substitution idea, it turns out to be surprisingly com-\nplicated to give a rigorous mathematical deﬁnition of the substitution process. e\nproblemarisesfromthepossibilityofconfusionbetweenthenamesusedfortheformal\nparametersofaprocedureandthe(possiblyidentical)namesusedintheexpressionsto\nwhich the procedure may be applied. Indeed, there is a long history of erroneous def-\ninitions of substitution in the literature of logic and programming semantics. See Stoy\n1977for a careful discussion of substitution. 20\nﬁrst substitute operand expressions for parameters until it obtained an\nexpressioninvolvingonlyprimitiveoperators,andwouldthenperform\nthe evaluation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 84, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 709}}
{"id": "computer_science_sicp_abelson_chunk_0085_764c9d69", "text": "20\nﬁrst substitute operand expressions for parameters until it obtained an\nexpressioninvolvingonlyprimitiveoperators,andwouldthenperform\nthe evaluation. If we used this method, the evaluation of (f 5)would\nproceed according to the sequence of expansions\n(sum-of-squares (+ 5 1) (* 5 2))\n(+ ( square (+ 5 1)) (square (* 5 2)) )\n(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))\nfollowed by the reductions\n(+ (* 6 6) (* 10 10))\n(+ 36 100)\n136\nis gives the same answer as our previous evaluation model, but the\nprocess is diﬀerent. In particular, the evaluations of (+ 5 1) and(* 5\n2)areeachperformedtwicehere,correspondingtothereductionofthe\nexpression (* x x) with xreplaced respectively by (+ 5 1) and(* 5\n2). is alternative “fully expand and then reduce” evaluation method\nis known as normal-order evaluation , in contrast to the “evaluate the\narguments and then apply” method that the interpreter actually uses,\nwhich is called applicative-order evaluation .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 85, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_sicp_abelson_chunk_0086_4cfa0e1b", "text": "It can be shown that, for\nprocedure applications that can be modeled using substitution (includ-\ning all the procedures in the ﬁrst two chapters of this book) and that\nyield legitimate values, normal-order and applicative-order evaluation\nproduce the same value. (See Exercise 1.5 for an instance of an “illegit-\nimate” value where normal-order and applicative-order evaluation do\nnot give the same result.)\nLisp uses applicative-order evaluation, partly because of the addi-\ntionaleﬃciencyobtainedfromavoidingmultipleevaluationsofexpres-\nsionssuchasthoseillustratedwith (+ 5 1) and(* 5 2) aboveand,more\n21\nsigniﬁcantly,becausenormal-orderevaluationbecomesmuchmorecom-\nplicatedtodealwithwhenweleavetherealmofproceduresthatcanbe\nmodeled by substitution.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 86, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 752}}
{"id": "computer_science_sicp_abelson_chunk_0087_f28f84df", "text": "On the other hand, normal-order evaluation\ncan be an extremely valuable tool, and we will investigate some of its\nimplications in Chapter 3 andChapter 4 .16\n1.1.6Conditional Expressions and Predicates\ne expressive power of the class of procedures that we can deﬁne at\nthis point is very limited, because we have no way to make tests and\nto perform diﬀerent operations depending on the result of a test.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 87, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 403}}
{"id": "computer_science_sicp_abelson_chunk_0088_687d5212", "text": "For\ninstance,wecannotdeﬁneaprocedurethatcomputestheabsolutevalue\nofanumberbytestingwhetherthenumberispositive,negative,orzero\nand taking diﬀerent actions in the diﬀerent cases according to the rule\njxj=8>>><>>>:xifx>0;\n0 if x=0;\n\u0000xifx<0:\nis construct is called a case analysis , and there is a special form in\nLispfornotatingsuchacaseanalysis.Itiscalled cond(whichstandsfor\n“conditional”), and it is used as follows:\n(define (abs x)\n(cond ((> x0)x)\n((= x0) 0)\n((< x0) (- x))))\ne general form of a conditional expression is\n16InChapter3 wewillintroduce stream processing ,whichisawayofhandlingappar-\nently “inﬁnite” data structures by incorporating a limited form of normal-order evalu-\nation. In Section 4.2 we will modify the Scheme interpreter to produce a normal-order\nvariant of Scheme. 22\n(cond (⟨p1⟩⟨e1⟩)\n(⟨p2⟩⟨e2⟩)\n: : :\n(⟨pn⟩⟨en⟩))\nconsisting of the symbol condfollowed by parenthesized pairs of ex-\npressions\n(⟨p⟩⟨e⟩)\ncalled clauses.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 88, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_sicp_abelson_chunk_0089_0e15a6cc", "text": "22\n(cond (⟨p1⟩⟨e1⟩)\n(⟨p2⟩⟨e2⟩)\n: : :\n(⟨pn⟩⟨en⟩))\nconsisting of the symbol condfollowed by parenthesized pairs of ex-\npressions\n(⟨p⟩⟨e⟩)\ncalled clauses. e ﬁrst expression in each pair is a predicate —that is, an\nexpression whose value is interpreted as either true or false.17\nConditionalexpressionsareevaluatedasfollows.epredicate ⟨p1⟩\nis evaluated ﬁrst. If its value is false, then ⟨p2⟩is evaluated. If⟨p2⟩’s\nvalue is also false, then ⟨p3⟩is evaluated. is process continues until\na predicate is found whose value is true, in which case the interpreter\nreturns the value of the corresponding consequent expression ⟨e⟩of the\nclause as the value of the conditional expression. If none of the ⟨p⟩’s is\nfound to be true, the value of the condis undeﬁned. e word predicate is used for procedures that return true or false,\nas well as for expressions that evaluate to true or false.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 89, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 880}}
{"id": "computer_science_sicp_abelson_chunk_0090_5e356dd2", "text": "e word predicate is used for procedures that return true or false,\nas well as for expressions that evaluate to true or false. e absolute-\nvalue procedure absmakes use of the primitive predicates >,<, and =.18\nesetaketwonumbersasargumentsandtestwhethertheﬁrstnumber\nis, respectively, greater than, less than, or equal to the second number,\nreturning true or false accordingly. Another way to write the absolute-value procedure is\n17“Interpreted as either true or false” means this: In Scheme, there are two distin-\nguishedvaluesthataredenotedbytheconstants #tand#f.Whentheinterpreterchecks\na predicate’s value, it interprets #fas false. Any other value is treated as true. (us,\nproviding #tis logically unnecessary, but it is convenient.) In this book we will use\nnames trueandfalse, which are associated with the values #tand#frespectively. 18absalso uses the “minus” operator -, which, when used with a single operand, as\nin(- x), indicates negation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 90, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 955}}
{"id": "computer_science_sicp_abelson_chunk_0091_ff46e11c", "text": "18absalso uses the “minus” operator -, which, when used with a single operand, as\nin(- x), indicates negation. 23\n(define (abs x)\n(cond ((< x0) (- x))\n(else x)))\nwhich could be expressed in English as “If xis less than zero return \u0000x;\notherwisereturn x.”elseisaspecialsymbolthatcanbeusedinplaceof\nthe⟨p⟩in the ﬁnal clause of a cond. is causes the condto return as its\nvalue the value of the corresponding ⟨e⟩whenever all previous clauses\nhave been bypassed. In fact, any expression that always evaluates to a\ntrue value could be used as the ⟨p⟩here. Here is yet another way to write the absolute-value procedure:\n(define (abs x)\n(if(<x0)\n(-x)\nx))\nis uses the special form if, a restricted type of conditional that can\nbe used when there are precisely two cases in the case analysis. e\ngeneral form of an ifexpression is\n(if⟨predicate⟩⟨consequent⟩⟨alternative⟩)\nTo evaluate an ifexpression, the interpreter starts by evaluating the\n⟨predicate⟩part of the expression.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 91, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_sicp_abelson_chunk_0092_2fd13b27", "text": "e\ngeneral form of an ifexpression is\n(if⟨predicate⟩⟨consequent⟩⟨alternative⟩)\nTo evaluate an ifexpression, the interpreter starts by evaluating the\n⟨predicate⟩part of the expression. If the ⟨predicate⟩evaluates to a true\nvalue, the interpreter then evaluates the ⟨consequent⟩and returns its\nvalue. Otherwise it evaluates the ⟨alternative⟩and returns its value.19\nIn addition to primitive predicates such as <,=, and >, there are log-\nical composition operations, which enable us to construct compound\n19Aminordiﬀerencebetween ifandcondisthatthe⟨e⟩partofeach condclausemay\nbe a sequence of expressions. If the corresponding ⟨p⟩is found to be true, the expres-\nsions⟨e⟩areevaluatedinsequenceandthevalueoftheﬁnalexpressioninthesequence\nis returned as the value of the cond. In an ifexpression, however, the ⟨consequent⟩and\n⟨alternative⟩must be single expressions. 24\npredicates.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 92, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 876}}
{"id": "computer_science_sicp_abelson_chunk_0093_e80c30a0", "text": "In an ifexpression, however, the ⟨consequent⟩and\n⟨alternative⟩must be single expressions. 24\npredicates. e three most frequently used are these:\n•(and⟨e1⟩: : :⟨en⟩)\neinterpreterevaluatestheexpressions ⟨e⟩oneatatime,inle-\nto-right order. If any ⟨e⟩evaluates to false, the value of the and\nexpression is false, and the rest of the ⟨e⟩’s are not evaluated. If\nall⟨e⟩’s evaluate to true values, the value of the andexpression is\nthe value of the last one. •(or⟨e1⟩: : :⟨en⟩)\neinterpreterevaluatestheexpressions ⟨e⟩oneatatime,inle-\nto-right order. If any ⟨e⟩evaluates to a true value, that value is\nreturned as the value of the orexpression, and the rest of the\n⟨e⟩’s are not evaluated. If all ⟨e⟩’s evaluate to false, the value of\ntheorexpression is false. •(not⟨e⟩)\ne value of a notexpression is true when the expression ⟨e⟩\nevaluates to false, and false otherwise. Notice that andandorare special forms, not procedures, because the\nsubexpressionsarenotnecessarilyallevaluated. notisanordinarypro-\ncedure.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 93, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1008}}
{"id": "computer_science_sicp_abelson_chunk_0094_ab05a951", "text": "Notice that andandorare special forms, not procedures, because the\nsubexpressionsarenotnecessarilyallevaluated. notisanordinarypro-\ncedure. As an example of how these are used, the condition that a number\nxbe in the range 5 <x<10 may be expressed as\n(and (>x5) (< x10))\nAsanotherexample,wecandeﬁneapredicatetotestwhetheronenum-\nber is greater than or equal to another as\n(define (>= xy) (or(>xy) (= xy)))\n25\nor alternatively as\n(define (>= xy) (not (<xy)))\nExercise 1.1: Below is a sequence of expressions. What is\ntheresultprintedbytheinterpreterinresponsetoeachex-\npression? Assume that the sequence is to be evaluated in\nthe order in which it is presented.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 94, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 659}}
{"id": "computer_science_sicp_abelson_chunk_0095_6648dc9b", "text": "What is\ntheresultprintedbytheinterpreterinresponsetoeachex-\npression? Assume that the sequence is to be evaluated in\nthe order in which it is presented. 10\n(+ 5 3 4)\n(- 9 1)\n(/ 6 2)\n(+ (* 2 4) (- 4 6))\n(define a3)\n(define b(+a1))\n(+ab(*ab))\n(=ab)\n(if(and (>ba) (< b(*ab)))\nb\na)\n(cond ((= a4) 6)\n((= b4) (+ 6 7 a))\n(else 25))\n(+ 2 ( if(>ba)ba))\n(* ( cond ((> ab)a)\n((< ab)b)\n(else -1))\n(+a1))\n26\nExercise1.2: Translatethefollowingexpressionintopreﬁx\nform:\n5 + 4 + (2\u0000(3\u0000(6 +4\n5)))\n3(6\u00002)(2\u00007):\nExercise 1.3: Deﬁne a procedure that takes three numbers\nasargumentsandreturnsthesumofthesquaresofthetwo\nlarger numbers. Exercise 1.4: Observe that our model of evaluation allows\nfor combinations whose operators are compound expres-\nsions.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 95, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 732}}
{"id": "computer_science_sicp_abelson_chunk_0096_9651b6bb", "text": "Exercise 1.4: Observe that our model of evaluation allows\nfor combinations whose operators are compound expres-\nsions. Use this observation to describe the behavior of the\nfollowing procedure:\n(define (a-plus-abs-b ab)\n((if(>b0) + -) ab))\nExercise1.5: BenBitdiddlehasinventedatesttodetermine\nwhethertheinterpreterheisfacedwithisusingapplicative-\norderevaluationornormal-orderevaluation.Hedeﬁnesthe\nfollowing two procedures:\n(define (p) (p))\n(define (test xy)\n(if(=x0) 0 y))\nen he evaluates the expression\n(test 0 (p))\nWhat behavior will Ben observe with an interpreter that\nuses applicative-order evaluation? What behavior will he\nobserve with an interpreter that uses normal-order evalu-\nation? Explain your answer.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 96, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 717}}
{"id": "computer_science_sicp_abelson_chunk_0097_f5c74ddc", "text": "What behavior will he\nobserve with an interpreter that uses normal-order evalu-\nation? Explain your answer. (Assume that the evaluation\n27\nrule for the special form ifis the same whether the in-\nterpreter is using normal or applicative order: e predi-\ncate expression is evaluated ﬁrst, and the resultdetermines\nwhether to evaluate the consequent or the alternative ex-\npression.)\n1.1.7Example: Square Roots by Newton’s Method\nProcedures, as introduced above, are much like ordinary mathematical\nfunctions. ey specify a value that is determined by one or more pa-\nrameters. But there is an important diﬀerence between mathematical\nfunctions and computer procedures. Procedures must be eﬀective. As a case in point, consider the problem of computing square roots. We can deﬁne the square-root function as\npx=theysuch that y\u00150 andy2=x:\nis describes a perfectly legitimate mathematical function.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 97, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_sicp_abelson_chunk_0098_2469f1ee", "text": "As a case in point, consider the problem of computing square roots. We can deﬁne the square-root function as\npx=theysuch that y\u00150 andy2=x:\nis describes a perfectly legitimate mathematical function. We could\nuse it to recognize whether one number is the square root of another,\nor to derive facts about square roots in general. On the other hand, the\ndeﬁnitiondoes not describea procedure.Indeed,ittells usalmostnoth-\ning about how to actually ﬁnd the square root of a given number. It will\nnot help maers to rephrase this deﬁnition in pseudo-Lisp:\n(define (sqrt x)\n(the y(and (>= y0)\n(= ( square y)x))))\nis only begs the question. e contrast between function and procedure is a reﬂection of the\ngeneraldistinctionbetweendescribingpropertiesofthingsanddescrib-\ning how to do things, or, as it is sometimes referred to, the distinction\n28\nbetween declarative knowledge and imperative knowledge.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 98, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 896}}
{"id": "computer_science_sicp_abelson_chunk_0099_f06b428b", "text": "In mathe-\nmaticsweareusuallyconcernedwithdeclarative(whatis)descriptions,\nwhereasincomputerscienceweareusuallyconcernedwithimperative\n(how to) descriptions.20\nHow does one compute square roots? e most common way is to\nuse Newton’s method of successive approximations, which says that\nwheneverwehaveaguess yforthevalueofthesquarerootofanumber\nx,wecanperformasimplemanipulationtogetabeerguess(onecloser\nto the actual square root) by averaging ywith x=y.21For example, we\ncan compute the square root of 2 as follows. Suppose our initial guess\nis 1:\nGuess Quotient Average\n1 (2/1) = 2 ((2 + 1)/2) = 1.5\n1.5 (2/1.5) = 1.3333 ((1.3333 + 1.5)/2) = 1.4167\n1.4167 (2/1.4167) = 1.4118 ((1.4167 + 1.4118)/2) = 1.4142\n1.4142 ... ... 20Declarativeandimperativedescriptionsareintimatelyrelated,asindeedaremath-\nematics and computer science. For instance, to say that the answer produced by a pro-\ngram is “correct” is to make a declarative statement about the program.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 99, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_sicp_abelson_chunk_0100_2bece66d", "text": "For instance, to say that the answer produced by a pro-\ngram is “correct” is to make a declarative statement about the program. ere is a large\namount of research aimed at establishing techniques for proving that programs are\ncorrect, and much of the technical diﬃculty of this subject has to do with negotiating\nthe transition between imperative statements (from which programs are constructed)\nand declarative statements (which can be used to deduce things). In a related vein, an\nimportantcurrentareainprogramming-languagedesignistheexplorationofso-called\nveryhigh-levellanguages,inwhichoneactuallyprogramsintermsofdeclarativestate-\nments. e idea is to make interpreters sophisticated enough so that, given “what is”\nknowledge speciﬁed by the programmer, they can generate “how to” knowledge auto-\nmatically.iscannotbedoneingeneral,butthereareimportantareaswhereprogress\nhas been made. We shall revisit this idea in Chapter 4 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 100, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 932}}
{"id": "computer_science_sicp_abelson_chunk_0101_25a9d4db", "text": "We shall revisit this idea in Chapter 4 . 21is square-root algorithm is actually a special case of Newton’s method, which is\nageneraltechniqueforﬁndingrootsofequations.esquare-rootalgorithmitselfwas\ndeveloped by Heron of Alexandria in the ﬁrst century ..We will see how to express\nthe general Newton’s method as a Lisp procedure in Section 1.3.4 . 29\nContinuing this process, we obtain beer and beer approximations to\nthe square root. Now let’s formalize the process in terms of procedures. We start\nwith a value for the radicand (the number whose square root we are\ntryingtocompute)andavaluefortheguess.Iftheguessisgoodenough\nfor our purposes, we are done; if not, we must repeat the process with\nan improved guess. We write this basic strategy as a procedure:\n(define (sqrt-iter guess x)\n(if(good-enough?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 101, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 812}}
{"id": "computer_science_sicp_abelson_chunk_0102_cd1be796", "text": "We write this basic strategy as a procedure:\n(define (sqrt-iter guess x)\n(if(good-enough? guess x)\nguess\n(sqrt-iter (improve guess x)x)))\nA guess is improved by averaging it with the quotient of the radicand\nand the old guess:\n(define (improve guess x)\n(average guess (/xguess )))\nwhere\n(define (average xy)\n(/ (+ xy) 2))\nWe also have to say what we mean by “good enough.” e following\nwill do for illustration, but it is not really a very good test. (See Exercise\n1.7.)eideaistoimprovetheansweruntilitiscloseenoughsothatits\nsquare diﬀers from the radicand by less than a predetermined tolerance\n(here 0.001):22\n(define (good-enough? guess x)\n(< ( abs (- ( square guess )x)) 0.001))\n22We will usually give predicates names ending with question marks, to help us re-\nmember that they are predicates. is is just a stylistic convention. As far as the inter-\npreter is concerned, the question mark is just an ordinary character.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 102, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_sicp_abelson_chunk_0103_13de937b", "text": "is is just a stylistic convention. As far as the inter-\npreter is concerned, the question mark is just an ordinary character. 30\nFinally,weneedawaytogetstarted.Forinstance,wecanalwaysguess\nthat the square root of any number is 1:23\n(define (sqrt x)\n(sqrt-iter 1.0 x))\nIf we type these deﬁnitions to the interpreter, we can use sqrtjust as\nwe can use any procedure:\n(sqrt 9)\n3.00009155413138\n(sqrt (+ 100 37))\n11.704699917758145\n(sqrt (+ ( sqrt 2) ( sqrt 3)))\n1.7739279023207892\n(square (sqrt 1000))\n1000.000369924366\nesqrtprogram also illustrates that the simple procedural language\nwe have introduced so far is suﬃcient for writing any purely numeri-\ncal program that one could write in, say, C or Pascal. is might seem\nsurprising, since we have not included in our language any iterative\n23Observethatweexpressourinitialguessas1.0ratherthan1.iswouldnotmake\nany diﬀerence in many Lisp implementations.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 103, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 906}}
{"id": "computer_science_sicp_abelson_chunk_0104_10933a4d", "text": "is might seem\nsurprising, since we have not included in our language any iterative\n23Observethatweexpressourinitialguessas1.0ratherthan1.iswouldnotmake\nany diﬀerence in many Lisp implementations. Scheme, however, distinguishes be-\ntween exact integers and decimal values, and dividing two integers produces a rational\nnumber rather than a decimal. For example, dividing 10 by 6 yields 5/3, while dividing\n10.0 by 6.0 yields 1.6666666666666667. (We will learn how to implement arithmetic on\nrationalnumbersin Section2.1.1 .)Ifwestartwithaninitialguessof1inoursquare-root\nprogram, and xis an exact integer, all subsequent values produced in the square-root\ncomputationwillberationalnumbersratherthandecimals.Mixedoperationsonratio-\nnalnumbersanddecimalsalwaysyielddecimals,sostartingwithaninitialguessof1.0\nforces all subsequent values to be decimals. 31\n(looping) constructs that direct the computer to do something over and\nover again.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 104, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_sicp_abelson_chunk_0105_d29ab994", "text": "31\n(looping) constructs that direct the computer to do something over and\nover again. sqrt-iter , on the other hand, demonstrates how iteration\ncanbeaccomplishedusingnospecialconstructotherthantheordinary\nability to call a procedure.24\nExercise1.6: AlyssaP.Hackerdoesn’tseewhy ifneedsto\nbe provided as a special form. “Why can’t I just deﬁne it as\nanordinaryprocedureintermsof cond?”sheasks.Alyssa’s\nfriend Eva Lu Ator claims this can indeed be done, and she\ndeﬁnes a new version of if:\n(define (new-if predicate then-clause else-clause )\n(cond (predicate then-clause )\n(else else-clause )))\nEva demonstrates the program for Alyssa:\n(new-if (= 2 3) 0 5)\n5\n(new-if (= 1 1) 0 5)\n0\nDelighted, Alyssa uses new-if to rewrite the square-root\nprogram:\n(define (sqrt-iter guess x)\n(new-if (good-enough? guess x)\nguess\n(sqrt-iter (improve guess x)x)))\nWhathappenswhenAlyssaaemptstousethistocompute\nsquare roots? Explain.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 105, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 912}}
{"id": "computer_science_sicp_abelson_chunk_0106_6694aa41", "text": "guess x)\nguess\n(sqrt-iter (improve guess x)x)))\nWhathappenswhenAlyssaaemptstousethistocompute\nsquare roots? Explain. 24Readers who are worried about the eﬃciency issues involved in using procedure\ncallstoimplementiterationshouldnotetheremarkson“tailrecursion”in Section1.2.1 . 32\nExercise 1.7: e good-enough? test used in computing\nsquarerootswillnotbeveryeﬀectiveforﬁndingthesquare\nrootsofverysmallnumbers.Also,inrealcomputers,arith-\nmetic operations are almost always performed with lim-\nitedprecision.ismakesourtestinadequateforverylarge\nnumbers.Explainthesestatements,withexamplesshowing\nhow the test fails for small and large numbers. An alterna-\ntive strategy for implementing good-enough? is to watch\nhow guesschanges from one iteration to the next and to\nstop when the change is a very small fraction of the guess. Design a square-root procedure that uses this kind of end\ntest. Does this work beer for small and large numbers?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 106, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_sicp_abelson_chunk_0107_4e77643c", "text": "Design a square-root procedure that uses this kind of end\ntest. Does this work beer for small and large numbers? Exercise 1.8: Newton’s method for cube roots is based on\nthe fact that if yis an approximation to the cube root of x,\nthen a beer approximation is given by the value\nx=y2+ 2y\n3:\nUse this formula to implement a cube-root procedure anal-\nogoustothesquare-rootprocedure.(In Section1.3.4 wewill\nsee how to implement Newton’s method in general as an\nabstractionofthesesquare-rootandcube-rootprocedures.)\n1.1.8Procedures as Black-Box Abstractions\nsqrtisourﬁrstexampleofaprocessdeﬁnedbyasetofmutuallydeﬁned\nprocedures. Notice that the deﬁnition of sqrt-iter isrecursive ; that is,\nthe procedure is deﬁned in terms of itself. e idea of being able to\ndeﬁne a procedure in terms of itself may be disturbing; it may seem\n33\n sqrt\n |\n sqrt-iter\n / \\\n good-enough improve\n / \\ \\\nsquare abs averageFigure1.2: Proceduraldecompositionofthe sqrtprogram.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 107, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_sicp_abelson_chunk_0108_36bbdc5d", "text": "unclear how such a “circular” deﬁnition could make sense at all, much\nless specify a well-deﬁned process to be carried out by a computer. is\nwill be addressed more carefully in Section 1.2 . But ﬁrst let’s consider\nsome other important points illustrated by the sqrtexample. Observe that the problem of computing square roots breaks up nat-\nurally into a number of subproblems: how to tell whether a guess is\ngood enough, how to improve a guess, and so on. Each of these tasks is\naccomplished by a separate procedure. e entire sqrtprogram can be\nviewed as a cluster of procedures (shown in Figure 1.2 ) that mirrors the\ndecomposition of the problem into subproblems.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 108, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 668}}
{"id": "computer_science_sicp_abelson_chunk_0109_abd1c2cc", "text": "e entire sqrtprogram can be\nviewed as a cluster of procedures (shown in Figure 1.2 ) that mirrors the\ndecomposition of the problem into subproblems. e importance of this decomposition strategy is not simply that\noneisdividingtheprogramintoparts.Aerall,wecouldtakeanylarge\nprogram and divide it into parts—the ﬁrst ten lines, the next ten lines,\nthenexttenlines,andsoon.Rather,itiscrucialthateachprocedureac-\ncomplishes an identiﬁable task that can be used as a module in deﬁning\nother procedures. For example, when we deﬁne the good-enough? pro-\ncedure in terms of square, we are able to regard the squareprocedure\nas a “black box.” We are not at that moment concerned with howthe\nprocedure computes its result, only with the fact that it computes the\nsquare. e details of how the square is computed can be suppressed,\nto be considered at a later time. Indeed, as far as the good-enough?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 109, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 891}}
{"id": "computer_science_sicp_abelson_chunk_0110_b1be2d83", "text": "e details of how the square is computed can be suppressed,\nto be considered at a later time. Indeed, as far as the good-enough? pro-\n34\ncedure is concerned, squareis not quite a procedure but rather an ab-\nstraction of a procedure, a so-called procedural abstraction . At this level\nof abstraction, any procedure that computes the square is equally good. us, considering only the values they return, the following two\nprocedures for squaring a number should be indistinguishable. Each\ntakes a numerical argument and produces the square of that number\nas the value.25\n(define (square x) (* xx))\n(define (square x) (exp (double (log x))))\n(define (double x) (+ xx))\nSo a procedure deﬁnition should be able to suppress detail. e users\nof the procedure may not have wrien the procedure themselves, but\nmay have obtained it from another programmer as a black box. A user\nshould not need to know how the procedure is implemented in order to\nuse it.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 110, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_sicp_abelson_chunk_0111_26f19293", "text": "A user\nshould not need to know how the procedure is implemented in order to\nuse it. Local names\nOne detail of a procedure’s implementation that should not maer to\nthe user of the procedure is the implementer’s choice of names for the\nprocedure’s formal parameters. us, the following procedures should\nnot be distinguishable:\n(define (square x) (* xx))\n(define (square y) (* yy))\n25It is not even clear which of these procedures is a more eﬃcient implementation. isdependsuponthehardwareavailable.erearemachinesforwhichthe“obvious”\nimplementation is the less eﬃcient one. Consider a machine that has extensive tables\nof logarithms and antilogarithms stored in a very eﬃcient manner. 35\nis principle—that the meaning of a procedure should be independent\nof the parameter names used by its author—seems on the surface to\nbe self-evident, but its consequences are profound. e simplest conse-\nquence is that the parameter names of a procedure must be local to the\nbody of the procedure.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 111, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_sicp_abelson_chunk_0112_c9b4d539", "text": "e simplest conse-\nquence is that the parameter names of a procedure must be local to the\nbody of the procedure. For example, we used squarein the deﬁnition\nofgood-enough? in our square-root procedure:\n(define (good-enough? guess x)\n(< ( abs (- ( square guess )x))\n0.001))\neintentionoftheauthorof good-enough? istodetermineifthesquare\noftheﬁrstargumentiswithinagiventoleranceofthesecondargument. Weseethattheauthorof good-enough? usedthename guesstoreferto\nthe ﬁrst argument and xto referto the second argument. e argument\nofsquareisguess. If the author of squareused x(as above) to refer to\nthat argument, we see that the xingood-enough? must be a diﬀerent x\nthan the one in square. Running the procedure squaremust not aﬀect\nthe value of xthat is used by good-enough? , because that value of x\nmay be needed by good-enough? aer squareis done computing.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 112, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 857}}
{"id": "computer_science_sicp_abelson_chunk_0113_fcffe7b1", "text": "Running the procedure squaremust not aﬀect\nthe value of xthat is used by good-enough? , because that value of x\nmay be needed by good-enough? aer squareis done computing. If the parameters were not local to the bodies of their respective\nprocedures, then the parameter xinsquarecould be confused with the\nparameter xingood-enough? ,andthebehaviorof good-enough? would\ndependuponwhichversionof squareweused.us, squarewouldnot\nbe the black box we desired. A formal parameter of a procedure has a very special role in the\nprocedure deﬁnition, in that it doesn’t maer what name the formal\nparameter has. Such a name is called a bound variable , and we say that\nthe procedure deﬁnition bindsits formal parameters. e meaning of\na procedure deﬁnition is unchanged if a bound variable is consistently\n36\nrenamed throughout the deﬁnition.26If a variable is not bound, we say\nthat it is free. e set of expressions for which a binding deﬁnes a name\nis called the scopeof that name.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 113, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_sicp_abelson_chunk_0114_abc8c9c1", "text": "e set of expressions for which a binding deﬁnes a name\nis called the scopeof that name. In a procedure deﬁnition, the bound\nvariables declared as the formal parameters of the procedure have the\nbody of the procedure as their scope. In the deﬁnition of good-enough? above, guessand xare bound\nvariables but <,-,abs, and square are free. e meaning of good-\nenough? should be independent of the names we choose for guessand\nxso long as they are distinct and diﬀerent from <,-,abs, and square. (If we renamed guesstoabswe would have introduced a bug by cap-\nturingthe variable abs. It would have changed from free to bound.) e\nmeaning of good-enough? is not independent of the names of its free\nvariables,however.Itsurelydependsuponthefact(externaltothisdef-\ninition)thatthesymbol absnamesaprocedureforcomputingtheabso-\nlutevalueofanumber. good-enough? willcomputeadiﬀerentfunction\nif we substitute cosforabsin its deﬁnition.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 114, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_sicp_abelson_chunk_0115_448cf044", "text": "good-enough? willcomputeadiﬀerentfunction\nif we substitute cosforabsin its deﬁnition. Internal definitions and block structure\nWe have one kind of name isolation available to us so far: e formal\nparameters of a procedure are local to the body of the procedure. e\nsquare-root program illustrates another way in which we would like\nto control the use of names. e existing program consists of separate\nprocedures:\n(define (sqrt x)\n(sqrt-iter 1.0 x))\n(define (sqrt-iter guess x)\n(if(good-enough? guess x)\n26e concept of consistent renaming is actually subtle and diﬃcult to deﬁne for-\nmally. Famous logicians have made embarrassing errors here. 37\nguess\n(sqrt-iter (improve guess x)x)))\n(define (good-enough? guess x)\n(< ( abs (- ( square guess )x)) 0.001))\n(define (improve guess x)\n(average guess (/xguess )))\neproblemwiththisprogramisthattheonlyprocedurethatisimpor-\ntant to users of sqrtissqrt. e other procedures ( sqrt-iter ,good-\nenough?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 115, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_sicp_abelson_chunk_0116_cfd881be", "text": "e other procedures ( sqrt-iter ,good-\nenough? ,and improve )onlyclueruptheirminds.eymaynotdeﬁne\nany other procedure called good-enough? as part of another program\nto work together with the square-root program, because sqrtneeds it. e problem is especially severe in the construction of large systems\nby many separate programmers. For example, in the construction of a\nlarge library of numerical procedures, many numerical functions are\ncomputed as successive approximations and thus might have proce-\ndures named good-enough? andimprove as auxiliary procedures. We\nwould like to localize the subprocedures, hiding them inside sqrtso\nthatsqrtcouldcoexistwithothersuccessiveapproximations,eachhav-\ning its own private good-enough? procedure. To make this possible, we\nallow a procedure to have internal deﬁnitions that are local to that pro-\ncedure. For example, in the square-root problem we can write\n(define (sqrt x)\n(define (good-enough?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 116, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 943}}
{"id": "computer_science_sicp_abelson_chunk_0117_edd505c6", "text": "To make this possible, we\nallow a procedure to have internal deﬁnitions that are local to that pro-\ncedure. For example, in the square-root problem we can write\n(define (sqrt x)\n(define (good-enough? guess x)\n(< ( abs (- ( square guess )x)) 0.001))\n(define (improve guess x) (average guess (/xguess )))\n(define (sqrt-iter guess x)\n(if(good-enough? guess x)\nguess\n(sqrt-iter (improve guess x)x)))\n(sqrt-iter 1.0 x))\n38\nSuch nesting of deﬁnitions, called block structure , is basically the right\nsolution to the simplest name-packaging problem. But there is a bet-\nter idea lurking here. In addition to internalizing the deﬁnitions of the\nauxiliaryprocedures,wecansimplifythem.Since xisboundinthedeﬁ-\nnitionof sqrt,theprocedures good-enough? ,improve ,and sqrt-iter ,\nwhich are deﬁned internally to sqrt, are in the scope of x. us, it is\nnot necessary to pass xexplicitly to each of these procedures. Instead,\nwe allow xto be a free variable in the internal deﬁnitions, as shown be-\nlow.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 117, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_sicp_abelson_chunk_0118_848345df", "text": "us, it is\nnot necessary to pass xexplicitly to each of these procedures. Instead,\nwe allow xto be a free variable in the internal deﬁnitions, as shown be-\nlow. en xgets its value from the argument with which the enclosing\nprocedure sqrtis called. is discipline is called lexical scoping .27\n(define (sqrt x)\n(define (good-enough? guess )\n(< ( abs (- ( square guess )x)) 0.001))\n(define (improve guess )\n(average guess (/xguess )))\n(define (sqrt-iter guess )\n(if(good-enough? guess )\nguess\n(sqrt-iter (improve guess ))))\n(sqrt-iter 1.0))\nWe will use block structure extensively to help us break up large pro-\ngramsintotractablepieces.28eideaofblockstructureoriginatedwith\nthe programming language Algol 60. It appears in most advanced pro-\ngramming languages and is an important tool for helping to organize\nthe construction of large programs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 118, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 846}}
{"id": "computer_science_sicp_abelson_chunk_0119_ae93d122", "text": "It appears in most advanced pro-\ngramming languages and is an important tool for helping to organize\nthe construction of large programs. 27Lexical scoping dictates that free variables in a procedure are taken to refer to\nbindings made by enclosing procedure deﬁnitions; that is, they are looked up in the\nenvironment in which the procedure was deﬁned. We will see how this works in detail\nin chapter 3 when we study environments and the detailed behavior of the interpreter. 28Embeddeddeﬁnitionsmustcomeﬁrstinaprocedurebody.emanagementisnot\nresponsible for the consequences of running programs that intertwine deﬁnition and\nuse. 39\n1.2ProceduresandtheProcessesTheyGenerate\nWe have now considered the elements of programming: We have used\nprimitive arithmetic operations, we have combined these operations,\nandwehaveabstractedthesecompositeoperationsbydeﬁningthemas\ncompound procedures.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 119, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_sicp_abelson_chunk_0120_3c4dc04e", "text": "But that is not enough to enable us to say that\nweknowhowtoprogram.Oursituationisanalogoustothatofsomeone\nwho has learned the rules for how the pieces move in chess but knows\nnothing of typical openings, tactics, or strategy. Like the novice chess\nplayer, we don’t yet know the common paerns of usage in the do-\nmain.Welacktheknowledgeofwhichmovesareworthmaking(which\nprocedures are worth deﬁning). We lack the experience to predict the\nconsequences of making a move (executing a procedure). e ability to visualize the consequences of the actions under con-\nsideration is crucial to becoming an expert programmer, just as it is in\nany synthetic, creative activity. In becoming an expert photographer,\nfor example, one must learn how to look at a scene and know how dark\neach region will appear on a print for each possible choice of exposure\nanddevelopmentconditions.Onlythencanonereasonbackward,plan-\nningframing,lighting,exposure,anddevelopmenttoobtainthedesired\neﬀects.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 120, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_sicp_abelson_chunk_0121_77ec7c0b", "text": "So it is with programming, where we are planning the course\nof action to be taken by a process and where we control the process by\nmeans of a program. To become experts, we must learn to visualize the\nprocessesgeneratedbyvarioustypesofprocedures.Onlyaerwehave\ndeveloped such a skill can we learn to reliably construct programs that\nexhibit the desired behavior. A procedure is a paern for the local evolution of a computational\nprocess.Itspeciﬁeshoweachstageoftheprocessisbuiltupontheprevi-\nousstage.Wewouldliketobeabletomakestatementsabouttheoverall,\n40\norglobal,behaviorofaprocesswhoselocalevolutionhasbeenspeciﬁed\nbyaprocedure.isisverydiﬃculttodoingeneral,butwecanatleast\ntry to describe some typical paerns of process evolution. In this section we will examine some common “shapes” for pro-\ncesses generated by simple procedures. We will also investigate the\nrates at which these processes consume the important computational\nresources of time and space.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 121, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_sicp_abelson_chunk_0122_0ab88441", "text": "We will also investigate the\nrates at which these processes consume the important computational\nresources of time and space. e procedures we will consider are very\nsimple. eir role is like that played by test paerns in photography: as\noversimpliﬁed prototypical paerns, rather than practical examples in\ntheir own right. 1.2.1Linear Recursion and Iteration\nWe begin by considering the factorial function, deﬁned by\nn!=n\u0001(n\u00001)\u0001(n\u00002)\u0001\u0001\u00013\u00012\u00011:\nere are many ways to compute factorials. One way is to make use\nof the observation that n! is equal to ntimes (n\u00001)! for any positive\ninteger n:\nn!=n\u0001[(n\u00001)\u0001(n\u00002)\u0001\u0001\u00013\u00012\u00011]=n\u0001(n\u00001)!:\nus, we can compute n! by computing (n\u00001)!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 122, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 670}}
{"id": "computer_science_sicp_abelson_chunk_0123_1dce04c9", "text": "One way is to make use\nof the observation that n! is equal to ntimes (n\u00001)! for any positive\ninteger n:\nn!=n\u0001[(n\u00001)\u0001(n\u00002)\u0001\u0001\u00013\u00012\u00011]=n\u0001(n\u00001)!:\nus, we can compute n! by computing (n\u00001)! and multiplying the\nresultby n.Ifweaddthestipulationthat1!isequalto1,thisobservation\ntranslates directly into a procedure:\n(define (factorial n)\n(if(=n1)\n1\n(*n(factorial (-n1)))))\n41\n(factorial 6)\n(* 6 (factorial 5))\n(* 6 (* 5 (factorial 4)))\n(* 6 (* 5 (* 4 (factorial 3))))\n(* 6 (* 5 (* 4 (* 3 (factorial 2)))))\n(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))\n(* 6 (* 5 (* 4 (* 3 (* 2 1)))))\n(* 6 (* 5 (* 4 (* 3 2))))\n(* 6 (* 5 (* 4 6)))\n(* 6 (* 5 24))\n(* 6 120)\n720 Figure 1.3: A linear recursive process for computing 6!. We can use the substitution model of Section 1.1.5 to watch this proce-\ndure in action computing 6!, as shown in Figure 1.3 . Now let’s take a diﬀerent perspective on computing factorials. We\ncould describe a rule for computing n!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 123, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_sicp_abelson_chunk_0124_7c669ffc", "text": "Now let’s take a diﬀerent perspective on computing factorials. We\ncould describe a rule for computing n! by specifying that we ﬁrst mul-\ntiply 1 by 2, then multiply the result by 3, then by 4, and so on until we\nreach n. More formally, we maintain a running product, together with\na counter that counts from 1 up to n. We can describe the computation\nbysayingthatthecounterandtheproductsimultaneouslychangefrom\none step to the next according to the rule\nproduct counter *product\ncounter counter + 1\nand stipulating that n! is the value of the product when the counter\nexceeds n. Once again, we can recast our description as a procedure for com-\nputing factorials:29\n29In a real program we would probably use the block structure introduced in the last\nsection to hide the deﬁnition of fact-iter :\n42\n(factorial 6)\n(fact-iter 1 1 6)\n(fact-iter 1 2 6)\n(fact-iter 2 3 6)\n(fact-iter 6 4 6)\n(fact-iter 24 5 6)\n(fact-iter 120 6 6)\n(fact-iter 720 7 6)\n720Figure 1.4: A linear iterative process for computing 6!.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 124, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_sicp_abelson_chunk_0125_512f8fd8", "text": "(define (factorial n)\n(fact-iter 1 1 n))\n(define (fact-iter product counter max-count )\n(if(>counter max-count )\nproduct\n(fact-iter (*counter product )\n(+counter 1)\nmax-count )))\nAs before, we can use the substitution model to visualize the process of\ncomputing 6!, as shown in Figure 1.4 . (define (factorial n)\n(define (iter product counter )\n(if(>counter n)\nproduct\n(iter (*counter product )\n(+counter 1))))\n(iter 1 1))\nWe avoided doing this here so as to minimize the number of things to think about at\nonce. 43\nCompare the two processes. From one point of view, they seem\nhardlydiﬀerentatall.Bothcomputethesamemathematicalfunctionon\nthesamedomain,andeachrequiresanumberofstepsproportionalto n\ntocompute n!.Indeed,bothprocessesevencarryoutthesamesequence\nof multiplications, obtaining the same sequence of partial products. On\ntheotherhand,whenweconsiderthe“shapes”ofthetwoprocesses,we\nﬁnd that they evolve quite diﬀerently.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 125, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_sicp_abelson_chunk_0126_89488264", "text": "On\ntheotherhand,whenweconsiderthe“shapes”ofthetwoprocesses,we\nﬁnd that they evolve quite diﬀerently. Considertheﬁrstprocess.esubstitutionmodelrevealsashapeof\nexpansionfollowedbycontraction,indicatedbythearrowin Figure1.3 . e expansion occurs as the process builds up a chain of deferred oper-\nations(in this case, a chain of multiplications). e contraction occurs\nas the operations are actually performed. is type of process, charac-\nterized by a chain of deferred operations, is called a recursive process . Carrying out this process requires that the interpreter keep track of the\noperationstobeperformedlateron.Inthecomputationof n!,thelength\nof the chain of deferred multiplications, and hence the amount of infor-\nmationneededtokeeptrackofit,growslinearlywith n(isproportional\nton), just like the number of steps. Such a process is called a linear re-\ncursive process . By contrast, the second process does not grow and shrink.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 126, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_sicp_abelson_chunk_0127_a99f044e", "text": "Such a process is called a linear re-\ncursive process . By contrast, the second process does not grow and shrink. At each\nstep, all we need to keep track of, for any n, are the current values of\nthevariables product ,counter ,and max-count .Wecallthisan iterative\nprocess. In general, an iterative process is one whose state can be sum-\nmarized by a ﬁxed number of state variables , together with a ﬁxed rule\nthat describes how the state variables should be updated as the process\nmoves from state to state and an (optional) end test that speciﬁes con-\nditions under which the process should terminate. In computing n!, the\nnumberofstepsrequiredgrowslinearlywith n.Suchaprocessiscalled\nalinear iterative process . 44\necontrastbetweenthetwoprocessescanbeseeninanotherway. In the iterative case, the program variables provide a complete descrip-\ntion of the state of the process at any point.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 127, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 891}}
{"id": "computer_science_sicp_abelson_chunk_0128_3d3e1503", "text": "44\necontrastbetweenthetwoprocessescanbeseeninanotherway. In the iterative case, the program variables provide a complete descrip-\ntion of the state of the process at any point. If we stopped the compu-\ntation between steps, all we would need to do to resume the computa-\ntion is to supply the interpreter with the values of the three program\nvariables. Not so with the recursive process. In this case there is some\nadditional “hidden” information, maintained by the interpreter and not\ncontainedintheprogramvariables,whichindicates“wheretheprocess\nis”innegotiatingthechainofdeferredoperations.elongerthechain,\nthe more information must be maintained.30\nIn contrasting iteration and recursion, we must be careful not to\nconfuse the notion of a recursive processwith the notion of a recursive\nprocedure . When we describe a procedure as recursive, we are referring\nto the syntactic fact that the procedure deﬁnition refers (either directly\nor indirectly) to the procedure itself.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 128, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_sicp_abelson_chunk_0129_69f65eb9", "text": "When we describe a procedure as recursive, we are referring\nto the syntactic fact that the procedure deﬁnition refers (either directly\nor indirectly) to the procedure itself. But when we describe a process\nas following a paern that is, say, linearly recursive, we are speaking\nabouthowtheprocessevolves,notaboutthesyntaxofhowaprocedure\niswrien.Itmayseemdisturbingthatwerefertoarecursiveprocedure\nsuchas fact-iter asgeneratinganiterativeprocess.However,thepro-\ncess really is iterative: Its state is captured completely by its three state\nvariables, and an interpreter need keep track of only three variables in\norder to execute the process.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 129, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 642}}
{"id": "computer_science_sicp_abelson_chunk_0130_af17d567", "text": "Onereasonthatthedistinctionbetweenprocessandproceduremay\nbe confusing is that most implementations of common languages (in-\ncludingAda,Pascal,andC)aredesignedinsuchawaythattheinterpre-\ntation of any recursive procedure consumes an amount of memory that\n30Whenwediscusstheimplementationofproceduresonregistermachinesin Chap-\nter 5, we will see that any iterative process can be realized “in hardware” as a machine\nthat has a ﬁxed set of registers and no auxiliary memory. In contrast, realizing a re-\ncursive process requires a machine that uses an auxiliary data structure known as a\nstack. 45\ngrows with the number of procedure calls, even when the process de-\nscribed is, in principle,iterative. As a consequence, these languagescan\ndescribe iterative processes only by resorting to special-purpose “loop-\ning constructs” such as do,repeat,until,for, and while. e imple-\nmentation of Scheme we shall consider in Chapter 5 does not share this\ndefect.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 130, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_sicp_abelson_chunk_0131_065d5c60", "text": "e imple-\nmentation of Scheme we shall consider in Chapter 5 does not share this\ndefect. It will execute an iterative process in constant space, even if the\niterative process is described by a recursive procedure. An implemen-\ntation with this property is called tail-recursive . With a tail-recursive\nimplementation, iteration can be expressed using the ordinary proce-\ndurecallmechanism,sothatspecialiterationconstructsareusefulonly\nas syntactic sugar.31\nExercise1.9: Eachofthefollowingtwoproceduresdeﬁnes\na method for adding two positive integers in terms of the\nprocedures inc, which increments its argument by 1, and\ndec, which decrements its argument by 1. (define (+ab)\n(if(=a0)b(inc (+ ( dec a)b))))\n(define (+ab)\n(if(=a0)b(+ ( dec a) (inc b))))\nUsing the substitution model, illustrate the process gener-\nated by each procedure in evaluating (+ 4 5) . Are these\nprocesses iterative or recursive? 31Tail recursion has long been known as a compiler optimization trick.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 131, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_sicp_abelson_chunk_0132_8bf5481c", "text": "Are these\nprocesses iterative or recursive? 31Tail recursion has long been known as a compiler optimization trick. A coherent\nsemanticbasisfortailrecursionwasprovidedbyCarl Hewi(1977) ,whoexplaineditin\nterms of the “message-passing” model of computation that we shall discuss in Chapter\n3.Inspiredbythis,GeraldJaySussmanandGuyLewisSteeleJr.(see SteeleandSussman\n1975) constructed a tail-recursive interpreter for Scheme. Steele later showed how tail\nrecursion is a consequence of the natural way to compile procedure calls ( Steele 1977 ). estandard for Scheme requires that Scheme implementations be tail-recursive. 46\nExercise 1.10: e following procedure computes a math-\nematical function called Ackermann’s function. (define (Axy)\n(cond ((= y0) 0)\n((= x0) (* 2 y))\n((= y1) 2)\n(else (A(-x1) ( Ax(-y1))))))\nWhat are the values of the following expressions?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 132, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 865}}
{"id": "computer_science_sicp_abelson_chunk_0133_6cfc2fbd", "text": "(define (Axy)\n(cond ((= y0) 0)\n((= x0) (* 2 y))\n((= y1) 2)\n(else (A(-x1) ( Ax(-y1))))))\nWhat are the values of the following expressions? (A1 10)\n(A2 4)\n(A3 3)\nConsider the following procedures, where Ais the proce-\ndure deﬁned above:\n(define (fn) (A0n))\n(define (gn) (A1n))\n(define (hn) (A2n))\n(define (kn) (* 5 nn))\nGiveconcisemathematicaldeﬁnitionsforthefunctionscom-\nputed by the procedures f,g, and hfor positive integer val-\nues of n. For example, (k n)computes 5 n2. 1.2.2Tree Recursion\nAnother common paern of computation is called tree recursion .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 133, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 557}}
{"id": "computer_science_sicp_abelson_chunk_0134_eb459a4e", "text": "For example, (k n)computes 5 n2. 1.2.2Tree Recursion\nAnother common paern of computation is called tree recursion . As an\nexample, consider computing the sequence of Fibonacci numbers, in\nwhich each number is the sum of the preceding two:\n0;1;1;2;3;5;8;13;21; : : : :\n47\nIn general, the Fibonacci numbers can be deﬁned by the rule\nFib (n)=8>>>>><>>>>>:0 ifn=0;\n1 ifn=1;\nFib (n\u00001)+ Fib (n\u00002)otherwise :\nWe can immediately translate this deﬁnition into a recursive procedure\nfor computing Fibonacci numbers:\n(define (fib n)\n(cond ((= n0) 0)\n((= n1) 1)\n(else (+ ( fib (-n1))\n(fib (-n2))))))\nConsiderthepaernofthiscomputation.Tocompute (fib 5) ,wecom-\npute (fib 4) and(fib 3) . To compute (fib 4) , we compute (fib 3)\nand(fib 2) . In general, the evolved process looks like a tree, as shown\ninFigure 1.5 . Notice that the branches split into two at each level (ex-\ncept at the boom); this reﬂects the fact that the fibprocedure calls\nitself twice each time it is invoked.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 134, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_sicp_abelson_chunk_0135_ffbe4b23", "text": "Notice that the branches split into two at each level (ex-\ncept at the boom); this reﬂects the fact that the fibprocedure calls\nitself twice each time it is invoked. is procedure is instructive as a prototypical tree recursion, but it\nisaterriblewaytocomputeFibonaccinumbersbecauseitdoessomuch\nredundantcomputation.Noticein Figure1.5 thattheentirecomputation\nof(fib 3) —almosthalfthework—isduplicated.Infact,itisnothardto\nshow that the number of times the procedure will compute (fib 1) or\n(fib 0) (the number of leaves in the above tree, in general) is precisely\nFib(n+1). To get an idea of how bad this is, one can show that the value\nofFib( n)growsexponentiallywith n.Moreprecisely(see Exercise1.13 ),\nFib(n) is the closest integer to ϕn=p\n5, where\nϕ=1 +p\n5\n2\u00191:6180\n48\n fib5\n fib4 fib3\n fib3 fib2 fib2 fib1\n 1\n fib2 fib1 fib1 fib0 fib1 fib0\n 1 1 0 1 0\nfib1 fib0\n1 0Figure 1.5: e tree-recursive process generated in com-\nputing (fib 5) .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 135, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 943}}
{"id": "computer_science_sicp_abelson_chunk_0136_66adc2f0", "text": "is the golden ratio , which satisﬁes the equation\nϕ2=ϕ+ 1:\nus, the process uses a number of steps that grows exponentially with\nthe input. On the other hand, the space required grows only linearly\nwith the input, because we need keep track only of which nodes are\nabove us in the tree at any point in the computation. In general, the\nnumber of steps required by a tree-recursive process will be propor-\ntional to the number of nodes in the tree, while the space required will\nbe proportional to the maximum depth of the tree. We can also formulate an iterative process for computing the Fi-\nbonaccinumbers.eideaistouseapairofintegers aandb,initialized\nto Fib(1) = 1 and Fib(0) = 0, and to repeatedly apply the simultaneous\n49\ntransformations\na a+b;\nb a:\nIt is not hard to show that, aer applying this transformation ntimes, a\nandbwill be equal, respectively, to Fib( n+ 1) and Fib( n).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 136, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_sicp_abelson_chunk_0137_1831855a", "text": "us, we can\ncompute Fibonacci numbers iteratively using the procedure\n(define (fib n)\n(fib-iter 1 0 n))\n(define (fib-iter abcount )\n(if(=count 0)\nb\n(fib-iter (+ab)a(-count 1))))\nissecondmethodforcomputingFib( n)isalineariteration.ediﬀer-\nence in number of steps required by the two methods—one linear in n,\none growing as fast as Fib( n) itself—is enormous, even for small inputs. One should not conclude from this that tree-recursive processes\nare useless. When we consider processes that operate on hierarchically\nstructured data rather than numbers, we will ﬁnd that tree recursion is\na natural and powerful tool.32But even in numerical operations, tree-\nrecursive processes can be useful in helping us to understand and de-\nsign programs. For instance, although the ﬁrst fibprocedure is much\nlesseﬃcientthanthesecondone,itismorestraightforward,beinglile\nmore than a translation into Lisp of the deﬁnition of the Fibonacci se-\nquence.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 137, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_sicp_abelson_chunk_0138_fd141d46", "text": "For instance, although the ﬁrst fibprocedure is much\nlesseﬃcientthanthesecondone,itismorestraightforward,beinglile\nmore than a translation into Lisp of the deﬁnition of the Fibonacci se-\nquence. To formulate the iterative algorithm required noticing that the\ncomputation could be recast as an iteration with three state variables. 32An example of this was hinted at in Section 1.1.3 . e interpreter itself evaluates\nexpressions using a tree-recursive process. 50\nExample: Counting change\nIt takes only a bit of cleverness to come up with the iterative Fibonacci\nalgorithm. In contrast, consider the following problem: How many dif-\nferent ways can we make change of $1.00, given half-dollars, quarters,\ndimes, nickels, and pennies? More generally, can we write a procedure\ntocomputethenumberofwaystochangeanygivenamountofmoney? is problem has a simple solution as a recursive procedure. Sup-\npose we think of the types of coins available as arranged in some order.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 138, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_sicp_abelson_chunk_0139_860afaca", "text": "is problem has a simple solution as a recursive procedure. Sup-\npose we think of the types of coins available as arranged in some order. en the following relation holds:\ne number of ways to change amount ausing nkinds of coins\nequals\n•the number of ways to change amount ausing all but the ﬁrst\nkind of coin, plus\n•the number of ways to change amount a\u0000dusing all nkinds of\ncoins, where dis the denomination of the ﬁrst kind of coin. To see why this is true, observe that the ways to make change can be\ndivided into two groups: those that do not use any of the ﬁrst kind of\ncoin, and those that do. erefore, the total number of ways to make\nchangeforsomeamountisequaltothenumberofwaystomakechange\nfor the amount without using any of the ﬁrst kind of coin, plus the\nnumber of ways to make change assuming that we do use the ﬁrst kind\nof coin. But the laer number is equal to the number of ways to make\nchange for the amount that remains aer using a coin of the ﬁrst kind.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 139, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_sicp_abelson_chunk_0140_e89e84cd", "text": "But the laer number is equal to the number of ways to make\nchange for the amount that remains aer using a coin of the ﬁrst kind. us, we can recursively reduce the problem of changing a given\namount to the problem of changing smaller amounts using fewer kinds\nof coins. Consider this reduction rule carefully, and convince yourself\n51\nthat we can use it to describe an algorithm if we specify the following\ndegenerate cases:33\n•Ifais exactly 0, we should count that as 1 way to make change. •Ifaislessthan0,weshouldcountthatas0waystomakechange. •Ifnis 0, we should count that as 0 ways to make change.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 140, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 603}}
{"id": "computer_science_sicp_abelson_chunk_0141_5fb7ca73", "text": "•Ifaislessthan0,weshouldcountthatas0waystomakechange. •Ifnis 0, we should count that as 0 ways to make change. We can easily translate this description into a recursive procedure:\n(define (count-change amount ) (ccamount 5))\n(define (ccamount kinds-of-coins )\n(cond ((= amount 0) 1)\n((or(<amount 0) (= kinds-of-coins 0)) 0)\n(else (+ ( ccamount\n(-kinds-of-coins 1))\n(cc(-amount\n(first-denomination\nkinds-of-coins ))\nkinds-of-coins )))))\n(define (first-denomination kinds-of-coins )\n(cond ((= kinds-of-coins 1) 1)\n((= kinds-of-coins 2) 5)\n((= kinds-of-coins 3) 10)\n((= kinds-of-coins 4) 25)\n((= kinds-of-coins 5) 50)))\n(e first-denomination proceduretakesasinputthenumberofkinds\nof coins available and returns the denomination of the ﬁrst kind.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 141, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 743}}
{"id": "computer_science_sicp_abelson_chunk_0142_4d088d57", "text": "Here\nwe are thinking of the coins as arranged in order from largest to small-\nest, but any order would do as well.) We can now answer our original\nquestion about changing a dollar:\n33For example, work through in detail how the reduction rule applies to the problem\nof making change for 10 cents using pennies and nickels. 52\n(count-change 100)\n292\ncount-change generatesatree-recursiveprocesswithredundanciessim-\nilartothoseinourﬁrstimplementationof fib.(Itwilltakequiteawhile\nfor that 292 to be computed.) On the other hand, it is not obvious how\nto design a beer algorithm for computing the result, and we leave this\nproblem as a challenge.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 142, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 643}}
{"id": "computer_science_sicp_abelson_chunk_0143_e26c411c", "text": "e observation that a tree-recursive process\nmay be highly ineﬃcient but oen easy to specify and understand has\nled people to propose that one could get the best of both worlds by\ndesigning a “smart compiler” that could transform tree-recursive pro-\ncedures into more eﬃcient procedures that compute the same result.34\nExercise 1.11: A function fis deﬁned by the rule that\nf(n)=8>><>>:nifn<3,\nf(n\u00001)+ 2f(n\u00002)+ 3f(n\u00003)ifn\u00153. Writeaprocedurethatcomputes fbymeansofarecursive\nprocess.Writeaprocedurethatcomputes fbymeansofan\niterative process. Exercise 1.12: e following paern of numbers is called\nPascal’s triangle . 34One approach to coping with redundant computations is to arrange maers so\nthat we automatically construct a table of values as they are computed. Each time we\nare asked to apply the procedure to some argument, we ﬁrst look to see if the value\nis already stored in the table, in which case we avoid performing the redundant com-\nputation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 143, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 958}}
{"id": "computer_science_sicp_abelson_chunk_0144_11b8abd1", "text": "Each time we\nare asked to apply the procedure to some argument, we ﬁrst look to see if the value\nis already stored in the table, in which case we avoid performing the redundant com-\nputation. is strategy, known as tabulation ormemoization , can be implemented in a\nstraightforward way. Tabulation can sometimes be used to transform processes that\nrequire an exponential number of steps (such as count-change ) into processes whose\nspace and time requirements grow linearly with the input. See Exercise 3.27 . 53\n1\n1 1\n1 2 1\n1 3 3 1\n1 4 6 4 1\n. . . e numbers at the edge of the triangle are all 1, and each\nnumber inside the triangle is the sum of the two numbers\nabove it.35Write a procedure that computes elements of\nPascal’s triangle by means of a recursive process. Exercise 1.13: Prove that Fib( n) is the closest integer to\nϕn=p\n5, whereϕ=(1 +p\n5)=2. Hint: Let ψ=(1\u0000p\n5)=2. Use induction and the deﬁnition of the Fibonacci numbers\n(seeSection 1.2.2 ) to prove that Fib (n)=(ϕn\u0000ψn)=p\n5.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 144, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_sicp_abelson_chunk_0145_1ec18353", "text": "Hint: Let ψ=(1\u0000p\n5)=2. Use induction and the deﬁnition of the Fibonacci numbers\n(seeSection 1.2.2 ) to prove that Fib (n)=(ϕn\u0000ψn)=p\n5. 1.2.3Orders of Growth\ne previous examples illustrate that processes can diﬀer considerably\nin the rates at which they consume computational resources. One con-\nvenient way to describe this diﬀerence is to use the notion of order of\ngrowthto obtain a gross measure of the resources required by a process\nas the inputs become larger. 35e elements of Pascal’s triangle are called the binomial coeﬃcients , because the\nnthrow consists of the coeﬃcients of the terms in the expansion of (x+y)n. is pat-\ntern for computing the coeﬃcients appeared in Blaise Pascal’s 1653 seminal work on\nprobability theory, Traité du triangle arithmétique .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 145, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 772}}
{"id": "computer_science_sicp_abelson_chunk_0146_3f640a82", "text": "is pat-\ntern for computing the coeﬃcients appeared in Blaise Pascal’s 1653 seminal work on\nprobability theory, Traité du triangle arithmétique . According to Knuth (1973) , the same\npaern appears in the Szu-yuen Yü-chien (“e Precious Mirror of the Four Elements”),\npublished by the Chinese mathematician Chu Shih-chieh in 1303, in the works of the\ntwelh-century Persian poet and mathematician Omar Khayyam, and in the works of\nthe twelh-century Hindu mathematician Bháscara Áchárya. 54\nLetnbe a parameter that measures the size of the problem, and let\nR(n)be the amount of resources the process requires for a problem of\nsizen. In our previous examples we took nto be the number for which\na given function is to be computed, but there are other possibilities. For\ninstance,ifourgoalistocomputeanapproximationtothesquarerootof\nanumber,wemighttake ntobethenumberofdigitsaccuracyrequired.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 146, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 890}}
{"id": "computer_science_sicp_abelson_chunk_0147_56788099", "text": "For\ninstance,ifourgoalistocomputeanapproximationtothesquarerootof\nanumber,wemighttake ntobethenumberofdigitsaccuracyrequired. For matrix multiplication we might take nto be the number of rows in\nthematrices.Ingeneralthereareanumberofpropertiesoftheproblem\nwith respect to which it will be desirable to analyze a given process. Similarly, R(n)might measure the number of internal storage registers\nused, the number of elementary machine operations performed, and so\non.Incomputersthatdoonlyaﬁxednumberofoperationsatatime,the\ntimerequiredwillbeproportionaltothenumberofelementarymachine\noperations performed.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 147, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 606}}
{"id": "computer_science_sicp_abelson_chunk_0148_c0a24538", "text": "Wesaythat R(n)hasorderofgrowth Θ(f(n)),wrien R(n)=Θ(f(n))\n(pronounced “theta of f(n)”), if there are positive constants k1andk2\nindependent of nsuch that k1f(n)\u0014R(n)\u0014k2f(n)for any suﬃciently\nlargevalueof n.(Inotherwords,forlarge n,thevalue R(n)issandwiched\nbetween k1f(n)andk2f(n).)\nFor instance, with the linear recursive process for computing facto-\nrial described in Section 1.2.1 the number of steps grows proportionally\nto the input n. us, the steps required for this process grows as Θ(n). We also saw that the space required grows as Θ(n). For the iterative\nfactorial, the number of steps is still Θ(n)but the space is Θ(1)—that\nis, constant.36e tree-recursive Fibonacci computation requires Θ(ϕn)\n36ese statements mask a great deal of oversimpliﬁcation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 148, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 765}}
{"id": "computer_science_sicp_abelson_chunk_0149_96d5bec5", "text": "For instance, if we count\nprocess steps as “machine operations” we are making the assumption that the number\nof machine operations needed to perform, say, a multiplication is independent of the\nsizeofthenumberstobemultiplied,whichisfalseifthenumbersaresuﬃcientlylarge. Similar remarks hold for the estimates of space. Like the design and description of a\nprocess, the analysis of a process can be carried out at various levels of abstraction. 55\nsteps and space Θ(n), whereϕis the golden ratio described in Section\n1.2.2. Orders of growth provide only a crude description of the behavior\nof a process.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 149, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 601}}
{"id": "computer_science_sicp_abelson_chunk_0150_1fd31b0d", "text": "55\nsteps and space Θ(n), whereϕis the golden ratio described in Section\n1.2.2. Orders of growth provide only a crude description of the behavior\nof a process. For example, a process requiring n2steps and a process\nrequiring 1000 n2steps and a process requiring 3 n2+ 10n+ 17 steps all\nhaveΘ(n2)orderofgrowth.Ontheotherhand,orderofgrowthprovides\nausefulindicationofhowwemayexpectthebehavioroftheprocessto\nchangeaswechangethesizeoftheproblem.Fora Θ(n)(linear)process,\ndoublingthesizewillroughlydoubletheamountofresourcesused.For\nanexponentialprocess,eachincrementinproblemsizewillmultiplythe\nresourceutilizationbya constant factor.In the remainderof Section 1.2\nwe will examine two algorithms whose order of growth is logarithmic,\nso that doubling the problem size increases the resource requirement\nby a constant amount. Exercise 1.14: Draw the tree illustrating the process gen-\nerated by the count-change procedure of Section 1.2.2 in\nmaking change for 11 cents.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 150, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_sicp_abelson_chunk_0151_8fffe16f", "text": "Exercise 1.14: Draw the tree illustrating the process gen-\nerated by the count-change procedure of Section 1.2.2 in\nmaking change for 11 cents. What are the orders of growth\nof the space and number of steps used by this process as\nthe amount to be changed increases? Exercise 1.15: e sine of an angle (speciﬁed in radians)\ncanbecomputedbymakinguseoftheapproximationsin x\u0019x\nifxis suﬃciently small, and the trigonometric identity\nsinx=3sinx\n3\u00004sin3x\n3\nto reduce the size of the argument of sin. (For purposes of\nthisexerciseanangleisconsidered“suﬃcientlysmall”ifits\nmagnitude is not greater than 0.1 radians.) ese ideas are\nincorporated in the following procedures:\n56\n(define (cube x) (* xxx))\n(define (px) (- (* 3 x) (* 4 ( cube x))))\n(define (sine angle )\n(if(not (> ( abs angle ) 0.1))\nangle\n(p(sine (/angle 3.0)))))\na.Howmanytimesistheprocedure pappliedwhen (sine\n12.15)is evaluated?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 151, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_sicp_abelson_chunk_0152_adee2775", "text": "b.What is the order of growth in space and number of\nsteps(asafunctionof a)usedbytheprocessgenerated\nby the sineprocedure when (sine a) is evaluated? 1.2.4Exponentiation\nConsider the problem of computing the exponential of a given number. We would like a procedure that takes as arguments a base band a posi-\ntive integer exponent nand computes bn. One way to do this is via the\nrecursive deﬁnition\nbn=b\u0001bn\u00001;\nb0=1;\nwhich translates readily into the procedure\n(define (expt bn)\n(if(=n0)\n1\n(*b(expt b(-n1)))))\nis is a linear recursive process, which requires Θ(n)steps and Θ(n)\nspace.Justaswithfactorial,wecanreadilyformulateanequivalentlin-\near iteration:\n57\n(define (expt bn)\n(expt-iter bn1))\n(define (expt-iter bcounter product )\n(if(=counter 0)\nproduct\n(expt-iter b\n(-counter 1)\n(*bproduct ))))\nis version requires Θ(n)steps and Θ(1)space. We can compute exponentials in fewer steps by using successive\nsquaring.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 152, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_sicp_abelson_chunk_0153_379460bf", "text": "We can compute exponentials in fewer steps by using successive\nsquaring. For instance, rather than computing b8as\nb\u0001(b\u0001(b\u0001(b\u0001(b\u0001(b\u0001(b\u0001b)))))) ;\nwe can compute it using three multiplications:\nb2=b\u0001b;\nb4=b2\u0001b2;\nb8=b4\u0001b4:\nis method works ﬁne for exponents that are powers of 2. We can\nalso take advantage of successive squaring in computing exponentials\nin general if we use the rule\nbn=(bn=2)2ifnis even ;\nbn=b\u0001bn\u00001ifnis odd :\nWe can express this method as a procedure:\n(define (fast-expt bn)\n(cond ((= n0) 1)\n((even? n) (square (fast-expt b(/n2))))\n(else (*b(fast-expt b(-n1))))))\n58\nwherethepredicatetotestwhetheranintegerisevenisdeﬁnedinterms\nof the primitive procedure remainder by\n(define (even? n)\n(= ( remainder n2) 0))\neprocessevolvedby fast-expt growslogarithmicallywith ninboth\nspace and number of steps.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 153, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 814}}
{"id": "computer_science_sicp_abelson_chunk_0154_3a829305", "text": "n)\n(= ( remainder n2) 0))\neprocessevolvedby fast-expt growslogarithmicallywith ninboth\nspace and number of steps. To see this, observe that computing b2nus-\ningfast-expt requires only one more multiplication than computing\nbn.esizeoftheexponentwecancomputethereforedoubles(approx-\nimately) with every new multiplication we are allowed. us, the num-\nber of multiplications required for an exponent of ngrows about as fast\nas the logarithm of nto the base 2. e process has Θ(logn)growth.37\ne diﬀerence between Θ(logn)growth and Θ(n)growth becomes\nstriking as nbecomes large.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 154, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 577}}
{"id": "computer_science_sicp_abelson_chunk_0155_67129f71", "text": "e process has Θ(logn)growth.37\ne diﬀerence between Θ(logn)growth and Θ(n)growth becomes\nstriking as nbecomes large. For example, fast-expt forn= 1000 re-\nquires only 14 multiplications.38It is also possible to use the idea of\nsuccessive squaring to devise an iterative algorithm that computes ex-\nponentials with a logarithmic number of steps (see Exercise 1.16 ), al-\nthough, as is oen the case with iterative algorithms, this is not wrien\ndown so straightforwardly as the recursive algorithm.39\nExercise 1.16: Design a procedure that evolves an itera-\ntive exponentiation process that uses successive squaring\n37More precisely, the number of multiplications required is equal to 1 less than the\nlog base 2 of nplus the number of ones in the binary representation of n. is total\nis always less than twice the log base 2 of n.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 155, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 831}}
{"id": "computer_science_sicp_abelson_chunk_0156_1f22a305", "text": "is total\nis always less than twice the log base 2 of n. e arbitrary constants k1andk2in the\ndeﬁnition of order notation imply that, for a logarithmic process, the base to which\nlogarithms are taken does not maer, so all such processes are described as Θ(logn). 38You may wonder why anyone would care about raising numbers to the 1000th\npower. See Section 1.2.6 . 39is iterative algorithm is ancient. It appears in the Chandah-sutra by Áchárya\nPingala, wrien before 200 ..SeeKnuth 1981 , section 4.6.3, for a full discussion and\nanalysis of this and other methods of exponentiation. 59\nandusesalogarithmicnumberofsteps,asdoes fast-expt . (Hint: Using the observation that (bn=2)2=(b2)n=2, keep,\nalong with the exponent nand the base b, an additional\nstatevariable a,anddeﬁnethestatetransformationinsuch\nawaythattheproduct abnisunchangedfromstatetostate. At the beginning of the process ais taken to be 1, and the\nanswer is given by the value of aat the end of the process.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 156, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_sicp_abelson_chunk_0157_56602685", "text": "At the beginning of the process ais taken to be 1, and the\nanswer is given by the value of aat the end of the process. In general, the technique of deﬁning an invariant quantity\nthat remains unchanged from state to state is a powerful\nway to think about the design of iterative algorithms.)\nExercise 1.17: e exponentiation algorithms in this sec-\ntion are based on performing exponentiation by means of\nrepeated multiplication. In a similar way, one can perform\ninteger multiplication by means of repeated addition. e\nfollowing multiplication procedure (in which it is assumed\nthat our language can only add, not multiply) is analogous\nto the exptprocedure:\n(define (*ab)\n(if(=b0)\n0\n(+a(*a(-b1)))))\nis algorithm takes a number of steps that is linear in b. Now suppose we include, together with addition, opera-\ntions double, which doubles an integer, and halve, which\ndivides an (even) integer by 2.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 157, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 903}}
{"id": "computer_science_sicp_abelson_chunk_0158_45b6dc5d", "text": "Now suppose we include, together with addition, opera-\ntions double, which doubles an integer, and halve, which\ndivides an (even) integer by 2. Using these, design a mul-\ntiplication procedure analogous to fast-expt that uses a\nlogarithmic number of steps. 60\nExercise 1.18: Using the results of Exercise 1.16 andExer-\ncise1.17 ,deviseaprocedurethatgeneratesaniterativepro-\ncess for multiplying two integers in terms of adding, dou-\nbling,andhalvingandusesalogarithmicnumberofsteps.40\nExercise 1.19: ere is a clever algorithm for computing\nthe Fibonacci numbers in a logarithmic number of steps. Recall the transformation of the state variables aandbin\nthefib-iter processof Section1.2.2 :a a+bandb a. Call this transformation T, and observe that applying T\noverandoveragain ntimes,startingwith1and0,produces\nthe pair Fib( n+1) and Fib( n).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 158, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 841}}
{"id": "computer_science_sicp_abelson_chunk_0159_30221ddd", "text": "Call this transformation T, and observe that applying T\noverandoveragain ntimes,startingwith1and0,produces\nthe pair Fib( n+1) and Fib( n). In other words, the Fibonacci\nnumbersareproducedbyapplying Tn,thenthpowerofthe\ntransformation T,startingwiththepair(1,0).Nowconsider\nTto be the special case of p=0 and q=1 in a family of\ntransformations Tpq, where Tpqtransforms the pair (a;b)\naccording to a bq+aq+apandb bp+aq. Show\nthat if we apply such a transformation Tpqtwice, the eﬀect\nis the same as using a single transformation Tp′q′of the\nsame form, and compute p′andq′in terms of pandq. is\ngives us an explicit way to square these transformations,\nand thus we can compute Tnusing successive squaring, as\nin the fast-expt procedure.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 159, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 732}}
{"id": "computer_science_sicp_abelson_chunk_0160_455a86e1", "text": "is\ngives us an explicit way to square these transformations,\nand thus we can compute Tnusing successive squaring, as\nin the fast-expt procedure. Put this all together to com-\nplete the following procedure, which runs in a logarithmic\nnumber of steps:41\n40is algorithm, which is sometimes known as the “Russian peasant method” of\nmultiplication,isancient.ExamplesofitsusearefoundintheRhindPapyrus,oneofthe\ntwo oldest mathematical documents in existence, wrien about 1700 ..(and copied\nfrom an even older document) by an Egyptian scribe named A’h-mose. 41is exercise was suggested to us by Joe Stoy, based on an example in Kaldewaij\n1990. 61\n(define (fib n)\n(fib-iter 1 0 0 1 n))\n(define (fib-iter abpqcount )\n(cond ((= count 0)b)\n((even?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 160, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 742}}
{"id": "computer_science_sicp_abelson_chunk_0161_214365c5", "text": "41is exercise was suggested to us by Joe Stoy, based on an example in Kaldewaij\n1990. 61\n(define (fib n)\n(fib-iter 1 0 0 1 n))\n(define (fib-iter abpqcount )\n(cond ((= count 0)b)\n((even? count )\n(fib-iter a\nb\n⟨??⟩; compute p′\n⟨??⟩; compute q′\n(/count 2)))\n(else (fib-iter (+ (* bq) (* aq) (* ap))\n(+ (* bp) (* aq))\np\nq\n(-count 1)))))\n1.2.5Greatest Common Divisors\ne greatest common divisor ( ) of two integers aandbis deﬁned to\nbe the largest integer that divides both aandbwith no remainder. For\nexample, the of 16 and 28 is 4. In Chapter 2 , when we investigate\nhow to implement rational-number arithmetic, we will need to be able\nto compute s in order to reduce rational numbers to lowest terms. (To reduce a rational number to lowest terms, we must divide both the\nnumerator and the denominator by their . For example, 16/28 re-\nduces to 4/7.) One way to ﬁnd the of two integers is to factor them\nand search for common factors, but there is a famous algorithm that is\nmuch more eﬃcient.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 161, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_sicp_abelson_chunk_0162_565d77ca", "text": "For example, 16/28 re-\nduces to 4/7.) One way to ﬁnd the of two integers is to factor them\nand search for common factors, but there is a famous algorithm that is\nmuch more eﬃcient. e idea of the algorithm is based on the observation that, if ris the\nremainder when ais divided by b, then the common divisors of aandb\nare precisely the same as the common divisors of bandr. us, we can\n62\nuse the equation\nGCD(a,b) = GCD(b,r)\nto successively reduce the problem of computing a to the problem\nof computing the of smaller and smaller pairs of integers. For ex-\nample,\nGCD(206,40) = GCD(40,6)\n= GCD(6,4)\n= GCD(4,2)\n= GCD(2,0)\n= 2\nreduces (, ) to(, ) , which is 2. It is possible to show that\nstarting with any two positive integers and performing repeated reduc-\ntionswillalwayseventuallyproduceapairwherethesecondnumberis\n0. en the is the other number in the pair.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 162, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 887}}
{"id": "computer_science_sicp_abelson_chunk_0163_86ff7843", "text": "en the is the other number in the pair. is method for com-\nputing the is known as Euclid’s Algorithm .42\nIt is easy to express Euclid’s Algorithm as a procedure:\n(define (gcd ab)\n(if(=b0)\na\n(gcd b(remainder ab))))\nisgeneratesaniterativeprocess,whosenumberofstepsgrowsasthe\nlogarithm of the numbers involved. 42Euclid’s Algorithm is so called because it appears in Euclid’s Elements (Book 7, ca. 300..). According to Knuth (1973) , it can be considered the oldest known nontrivial\nalgorithm.eancientEgyptianmethodofmultiplication( Exercise1.18 )issurelyolder,\nbut, as Knuth explains, Euclid’s algorithm is the oldest known to have been presented\nas a general algorithm, rather than as a set of illustrative examples.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 163, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 727}}
{"id": "computer_science_sicp_abelson_chunk_0164_179a0b25", "text": "63\ne fact that the number of steps required by Euclid’s Algorithm\nhas logarithmic growth bears an interesting relation to the Fibonacci\nnumbers:\nLamé’sTheorem: IfEuclid’sAlgorithmrequires kstepsto\ncompute the of some pair, then the smaller number in\nthe pair must be greater than or equal to the kthFibonacci\nnumber.43\nWecanusethistheoremtogetanorder-of-growthestimateforEuclid’s\nAlgorithm.Let nbethesmallerofthetwoinputstotheprocedure.Ifthe\nprocesstakes ksteps,thenwemusthave n\u0015Fib (k)\u0019ϕk=p\n5.erefore\nthenumberofsteps kgrowsasthelogarithm(tothebase ϕ)ofn.Hence,\nthe order of growth is Θ(logn). 43is theorem was proved in 1845 by Gabriel Lamé, a French mathematician and\nengineer known chieﬂy for his contributions to mathematical physics. To prove the\ntheorem, we consider pairs ( ak;bk), where ak\u0015bk, for which Euclid’s Algorithm\nterminatesin ksteps.eproofisbasedontheclaimthat,if (ak+1;bk+1)! (ak;bk)!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 164, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_sicp_abelson_chunk_0165_cbdd7bc2", "text": "To prove the\ntheorem, we consider pairs ( ak;bk), where ak\u0015bk, for which Euclid’s Algorithm\nterminatesin ksteps.eproofisbasedontheclaimthat,if (ak+1;bk+1)! (ak;bk)! (ak\u00001;bk\u00001)are three successive pairs in the reduction process, then we must have\nbk+1\u0015bk+bk\u00001. To verify the claim, consider that a reduction step is deﬁned by\napplying the transformation ak\u00001=bk;bk\u00001=remainder of akdivided by bk. e\nsecond equation means that ak=qbk+bk\u00001for some positive integer q. And since q\nmust be at least 1 we have ak=qbk+bk\u00001\u0015bk+bk\u00001. But in the previous reduction\nstepwehave bk+1=ak.erefore, bk+1=ak\u0015bk+bk\u00001.isveriﬁestheclaim.Now\nwe can prove the theorem by induction on k, the number of steps that the algorithm\nrequirestoterminate.eresultistrue for k=1,sincethismerelyrequiresthat bbeat\nleastaslargeasFib(1)=1.Now,assumethattheresultistrueforallintegerslessthanor\nequalto kandestablishtheresultfor k+1.Let (ak+1;bk+1)! (ak;bk)! (ak\u00001;bk\u00001)\nbe successive pairs in the reduction process.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 165, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_sicp_abelson_chunk_0166_46245590", "text": "(ak;bk)! (ak\u00001;bk\u00001)\nbe successive pairs in the reduction process. By our induction hypotheses, we have\nbk\u00001\u0015Fib (k\u00001)andbk\u0015Fib (k). us, applying the claim we just proved together\nwith the deﬁnition of the Fibonacci numbers gives bk+1\u0015bk+bk\u00001\u0015Fib (k)+Fib (k\u0000\n1)=Fib (k+ 1 ), which completes the proof of Lamé’s eorem. 64\nExercise 1.20: e process that a procedure generates is\nof course dependent on the rules used by the interpreter. As an example, consider the iterative gcdprocedure given\nabove. Suppose we were to interpret this procedure using\nnormal-orderevaluation,asdiscussedin Section1.1.5 .(e\nnormal-order-evaluationrulefor ifisdescribedin Exercise\n1.5.)Usingthesubstitutionmethod(fornormalorder),illus-\ntratetheprocessgeneratedinevaluating (gcd 206 40) and\nindicate the remainder operations that are actually per-\nformed.Howmany remainder operationsareactuallyper-\nformed in the normal-order evaluation of (gcd 206 40) ? In the applicative-order evaluation?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 166, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_sicp_abelson_chunk_0167_cfabb173", "text": "In the applicative-order evaluation? 1.2.6Example: Testing for Primality\nis section describes two methods for checking the primality of an in-\nteger n,onewithorderofgrowth Θ(pn),anda“probabilistic”algorithm\nwith order of growth Θ(logn). e exercises at the end of this section\nsuggest programming projects based on these algorithms. Searching for divisors\nSince ancient times, mathematicians have been fascinated by problems\nconcerningprimenumbers,andmanypeoplehaveworkedontheprob-\nlem of determining ways to test if numbers are prime. One way to test\nifanumberisprimeistoﬁndthenumber’sdivisors.efollowingpro-\ngramﬁndsthesmallestintegraldivisor(greaterthan1)ofagivennum-\nbern. It does this in a straightforward way, by testing nfor divisibility\nby successive integers starting with 2. (define (smallest-divisor n) (find-divisor n2))\n65\n(define (find-divisor ntest-divisor )\n(cond ((> ( square test-divisor )n)n)\n((divides?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 167, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_sicp_abelson_chunk_0168_b81971de", "text": "(define (smallest-divisor n) (find-divisor n2))\n65\n(define (find-divisor ntest-divisor )\n(cond ((> ( square test-divisor )n)n)\n((divides? test-divisor n)test-divisor )\n(else (find-divisor n(+test-divisor 1)))))\n(define (divides? ab) (= ( remainder ba) 0))\nWecantestwhetheranumberisprimeasfollows: nisprimeifandonly\nifnis its own smallest divisor. (define (prime? n)\n(=n(smallest-divisor n)))\neendtestfor find-divisor isbasedonthefactthatif nisnotprimeit\nmusthaveadivisorlessthanorequaltopn.44ismeansthatthealgo-\nrithmneedonlytestdivisorsbetween1andpn.Consequently,thenum-\nber of steps required to identify nas prime will have order of growth\nΘ(pn). The Fermat test\neΘ(logn)primality test is based on a result from number theory\nknown as Fermat’s Lile eorem.45\n44Ifdis a divisor of n, then so is n=d. But dandn=dcannot both be greater thanpn. 45PierredeFermat(1601-1665)isconsideredtobethefounderofmodernnumberthe-\nory.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 168, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_sicp_abelson_chunk_0169_e3ab9832", "text": "But dandn=dcannot both be greater thanpn. 45PierredeFermat(1601-1665)isconsideredtobethefounderofmodernnumberthe-\nory. He obtained many important number-theoretic results, but he usually announced\njust the results, without providing his proofs. Fermat’s Lile eorem was stated in a\nleer he wrote in 1640. e ﬁrst published proof was given by Euler in 1736 (and an\nearlier, identical proof was discovered in the unpublished manuscripts of Leibniz). e\nmost famous of Fermat’s results—known as Fermat’s Last eorem—was joed down\nin 1637 in his copy of the book Arithmetic (by the third-century Greek mathematician\nDiophantus)withtheremark“Ihavediscoveredatrulyremarkableproof,butthismar-\ngin is too small to contain it.” Finding a proof of Fermat’s Last eorem became one of\nthe most famous challenges in number theory. A complete solution was ﬁnally given\nin 1995 by Andrew Wiles of Princeton University.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 169, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 906}}
{"id": "computer_science_sicp_abelson_chunk_0170_69cb2d7c", "text": "A complete solution was ﬁnally given\nin 1995 by Andrew Wiles of Princeton University. 66\nFermat’s Lile Theorem: Ifnis a prime number and a\nis any positive integer less than n, then araised to the nth\npower is congruent to amodulo n. (Two numbers are said to be congruent modulo nif they both have the\nsame remainder when divided by n. e remainder of a number awhen\ndividedby nisalsoreferredtoasthe remainder of amodulo n,orsimply\nasamodulo n.)\nIfnis not prime, then, in general, most of the numbers a<nwill\nnot satisfy the above relation. is leads to the following algorithm for\ntesting primality: Given a number n, pick a random number a<nand\ncompute the remainder of anmodulo n. If the result is not equal to a,\nthen nis certainly not prime. If it is a, then chances are good that nis\nprime. Now pick another random number aand test it with the same\nmethod. If it also satisﬁes the equation, then we can be even more con-\nﬁdent that nis prime.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 170, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_sicp_abelson_chunk_0171_0397e86b", "text": "If it is a, then chances are good that nis\nprime. Now pick another random number aand test it with the same\nmethod. If it also satisﬁes the equation, then we can be even more con-\nﬁdent that nis prime. By trying more and more values of a, we can\nincrease our conﬁdence in the result. is algorithm is known as the\nFermat test. To implement the Fermat test, we need a procedure that computes\nthe exponential of a number modulo another number:\n(define (expmod base exp m)\n(cond ((= exp 0) 1)\n((even? exp)\n(remainder\n(square (expmod base (/exp 2)m))\nm))\n(else\n(remainder\n(*base (expmod base (-exp 1)m))\nm))))\n67\nis is very similar to the fast-expt procedure of Section 1.2.4 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 171, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 674}}
{"id": "computer_science_sicp_abelson_chunk_0172_6d25d687", "text": "exp)\n(remainder\n(square (expmod base (/exp 2)m))\nm))\n(else\n(remainder\n(*base (expmod base (-exp 1)m))\nm))))\n67\nis is very similar to the fast-expt procedure of Section 1.2.4 . It uses\nsuccessive squaring, so that the number of steps grows logarithmically\nwith the exponent.46\neFermattestisperformedbychoosingatrandomanumber abe-\ntween1and n\u00001inclusiveandcheckingwhethertheremaindermodulo\nnofthe nthpowerof aisequalto a.erandomnumber aischosenus-\ning the procedure random, which we assume is included as a primitive\nin Scheme. randomreturns a nonnegative integer less than its integer\ninput. Hence, to obtain a random number between 1 and n\u00001, we call\nrandomwith an input of n\u00001 and add 1 to the result:\n(define (fermat-test n)\n(define (try-it a)\n(= ( expmod ann)a))\n(try-it (+ 1 ( random (-n1)))))\nefollowingprocedurerunsthetestagivennumberoftimes,asspec-\niﬁedbyaparameter.Itsvalueistrueifthetestsucceedseverytime,and\nfalse otherwise. (define (fast-prime?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 172, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_sicp_abelson_chunk_0173_26189096", "text": "(define (fast-prime? ntimes )\n(cond ((= times 0)true )\n((fermat-test n) (fast-prime? n(-times 1)))\n(else false )))\n46e reduction steps in the cases where the exponent eis greater than 1 are based\non the fact that, for any integers x,y, and m, we can ﬁnd the remainder of xtimesy\nmodulo mby computing separately the remainders of xmodulo mandymodulo m,\nmultiplying these, and then taking the remainder of the result modulo m. For instance,\nin the case where eis even, we compute the remainder of be=2modulo m, square this,\nand take the remainder modulo m. is technique is useful because it means we can\nperform our computation without ever having to deal with numbers much larger than\nm. (Compare Exercise 1.25 .)\n68\nProbabilistic methods\ne Fermat test diﬀers in character from most familiar algorithms, in\nwhich one computes an answer that is guaranteed to be correct. Here,\nthe answer obtained is only probably correct.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 173, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_sicp_abelson_chunk_0174_bf9f36d2", "text": "Here,\nthe answer obtained is only probably correct. More precisely, if never\nfails the Fermat test, we can be certain that nis not prime. But the fact\nthatnpasses the test, while an extremely strong indication, is still not\na guarantee that nis prime. What we would like to say is that for any\nnumber n, if we perform the test enough times and ﬁnd that nalways\npasses the test, then the probability of error in our primality test can be\nmade as small as we like. Unfortunately,thisassertionisnotquitecorrect.eredoexistnum-\nbersthatfooltheFermattest:numbers nthatarenotprimeandyethave\nthe property that anis congruent to amodulo nfor all integers a<n. Such numbers are extremely rare, so the Fermat test is quite reliable in\npractice.47\nerearevariationsoftheFermattestthatcannotbefooled.Inthese\ntests, as with the Fermat method, one tests the primality of an integer n\nby choosing a random integer a<nand checking some condition that\ndepends upon nanda.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 174, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_sicp_abelson_chunk_0175_67a7adb0", "text": "(SeeExercise 1.28 for an example of such a test.)\nOn the other hand, in contrast to the Fermat test, one can prove that,\nfor any n, the condition does not hold for most of the integers a<n\nunless nis prime. us, if npasses the test for some random choice of\n47Numbers that fool the Fermat test are called Carmichael numbers , and lile is\nknown about them other than that they are extremely rare. ere are 255 Carmichael\nnumbers below 100,000,000. e smallest few are 561, 1105, 1729, 2465, 2821, and 6601. In testing primality of very large numbers chosen at random, the chance of stumbling\nuponavaluethatfoolstheFermattestislessthanthechancethatcosmicradiationwill\ncausethecomputertomakeanerrorincarryingouta“correct”algorithm.Considering\nan algorithm to be inadequate for the ﬁrst reason but not for the second illustrates the\ndiﬀerence between mathematics and engineering. 69\na, the chances are beer than even that nis prime.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 175, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_sicp_abelson_chunk_0176_5eafaed2", "text": "69\na, the chances are beer than even that nis prime. If npasses the test\nfor two random choices of a, the chances are beer than 3 out of 4 that\nnis prime. By running the test with more and more randomly chosen\nvalues of awe can make the probability of error as small as we like. e existence of tests for which one can prove that the chance of\nerrorbecomesarbitrarilysmallhassparkedinterestinalgorithmsofthis\ntype, which have come to be known as probabilistic algorithms . ere is\nagreatdealofresearchactivityinthisarea,andprobabilisticalgorithms\nhave been fruitfully applied to many ﬁelds.48\nExercise1.21: Usethe smallest-divisor proceduretoﬁnd\nthe smallest divisor of each of the following numbers: 199,\n1999, 19999.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 176, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 720}}
{"id": "computer_science_sicp_abelson_chunk_0177_3d099e66", "text": "Exercise 1.22: Most Lisp implementations include a prim-\nitive called runtime that returns an integer that speciﬁes\nthe amount of time the system has been running (mea-\nsured,forexample,inmicroseconds).efollowing timed-\nprime-test procedure,whencalledwithaninteger n,prints\nnandcheckstoseeif nisprime.If nisprime,theprocedure\nprints three asterisks followed by the amount of time used\nin performing the test. 48One of the most striking applications of probabilistic prime testing has been to the\nﬁeld of cryptography. Although it is now computationally infeasible to factor an arbi-\ntrary200-digitnumber,theprimalityofsuchanumbercanbecheckedinafewseconds\nwiththeFermattest.isfactformsthebasisofatechniqueforconstructing“unbreak-\nable codes” suggested by Rivest et al. (1977) . e resulting RSA algorithm has become\na widely used technique for enhancing the security of electronic communications.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 177, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 897}}
{"id": "computer_science_sicp_abelson_chunk_0178_96fc7ca5", "text": "(1977) . e resulting RSA algorithm has become\na widely used technique for enhancing the security of electronic communications. Be-\ncause of this and related developments, the study of prime numbers, once considered\nthe epitome of a topic in “pure” mathematics to be studied only for its own sake, now\nturns out to have important practical applications to cryptography, electronic funds\ntransfer, and information retrieval. 70\n(define (timed-prime-test n)\n(newline )\n(display n)\n(start-prime-test n(runtime )))\n(define (start-prime-test nstart-time )\n(if(prime? n)\n(report-prime (- ( runtime )start-time ))))\n(define (report-prime elapsed-time )\n(display \"*** \")\n(display elapsed-time ))\nUsingthisprocedure,writeaprocedure search-for-primes\nthat checks the primality of consecutive odd integers in a\nspeciﬁedrange.Useyourproceduretoﬁndthethreesmall-\nest primes larger than 1000; larger than 10,000; larger than\n100,000; larger than 1,000,000.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 178, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_sicp_abelson_chunk_0179_5aa58091", "text": "Note the time needed to test\neachprime.Sincethetestingalgorithmhasorderofgrowth\nofΘ(pn), you should expect that testing for primes around\n10,000 should take aboutp\n10 times as long as testing for\nprimes around 1000. Do your timing data bear this out? How well do the data for 100,000 and 1,000,000 support the\nΘ(pn)prediction?Isyourresultcompatiblewiththenotion\nthatprogramsonyourmachinerunintimeproportionalto\nthe number of steps required for the computation? Exercise1.23: esmallest-divisor procedureshownat\nthestartofthissectiondoeslotsofneedlesstesting:Aerit\ncheckstoseeifthenumberisdivisibleby2thereisnopoint\nin checking to see if it is divisible by any larger even num-\nbers. is suggests that the values used for test-divisor\nshould not be 2, 3, 4, 5, 6, : : :, but rather 2, 3, 5, 7, 9, : : :.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 179, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 803}}
{"id": "computer_science_sicp_abelson_chunk_0180_39039acc", "text": "is suggests that the values used for test-divisor\nshould not be 2, 3, 4, 5, 6, : : :, but rather 2, 3, 5, 7, 9, : : :. 71\nTo implement this change, deﬁne a procedure nextthat re-\nturns3ifitsinputisequalto2andotherwisereturnsitsin-\nputplus2.Modifythe smallest-divisor proceduretouse\n(next test-divisor) instead of (+ test-divisor 1) . With timed-prime-test incorporating this modiﬁed ver-\nsion of smallest-divisor , run the test for each of the 12\nprimesfoundin Exercise1.22 .Sincethismodiﬁcationhalves\nthe number of test steps, you should expect it to run about\ntwice as fast. Is this expectation conﬁrmed? If not, what is\nthe observed ratio of the speeds of the two algorithms, and\nhow do you explain the fact that it is diﬀerent from 2? Exercise1.24: Modifythe timed-prime-test procedureof\nExercise1.22 touse fast-prime? (theFermatmethod),and\ntest each of the 12 primes you found in that exercise.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 180, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 900}}
{"id": "computer_science_sicp_abelson_chunk_0181_79fada30", "text": "Exercise1.24: Modifythe timed-prime-test procedureof\nExercise1.22 touse fast-prime? (theFermatmethod),and\ntest each of the 12 primes you found in that exercise. Since\ntheFermattesthas Θ(logn)growth,howwouldyouexpect\nthe time to test primes near 1,000,000 to compare with the\ntime needed to test primes near 1000? Do your data bear\nthis out? Can you explain any discrepancy you ﬁnd? Exercise1.25: AlyssaP.Hackercomplainsthatwewentto\na lot of extra work in writing expmod. Aer all, she says,\nsince we already know how to compute exponentials, we\ncould have simply wrien\n(define (expmod base exp m)\n(remainder (fast-expt base exp)m))\nIs she correct? Would this procedure serve as well for our\nfast prime tester? Explain. 72\nExercise1.26: LouisReasonerishavinggreatdiﬃcultydo-\ningExercise 1.24 . His fast-prime? test seems to run more\nslowly than his prime?test. Louis calls his friend Eva Lu\nAtor over to help.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 181, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_sicp_abelson_chunk_0182_5f7dd7bd", "text": "Explain. 72\nExercise1.26: LouisReasonerishavinggreatdiﬃcultydo-\ningExercise 1.24 . His fast-prime? test seems to run more\nslowly than his prime?test. Louis calls his friend Eva Lu\nAtor over to help. When they examine Louis’s code, they\nﬁnd that he has rewrien the expmodprocedure to use an\nexplicit multiplication, rather than calling square:\n(define (expmod base exp m)\n(cond ((= exp 0) 1)\n((even? exp)\n(remainder (* ( expmod base (/exp 2)m)\n(expmod base (/exp 2)m))\nm))\n(else\n(remainder (*base\n(expmod base (-exp 1)m))\nm))))\n“I don’t see what diﬀerence that could make,” says Louis. “I do.” says Eva. “By writing the procedure like that, you\nhave transformed the Θ(logn)process into a Θ(n)process.”\nExplain. Exercise 1.27: Demonstrate that the Carmichael numbers\nlistedin Footnote1.47 reallydofooltheFermattest.atis,\nwrite a procedure that takes an integer nand tests whether\naniscongruentto amodulo nforevery a<n,andtryyour\nprocedure on the given Carmichael numbers.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 182, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_sicp_abelson_chunk_0183_b26e7fb2", "text": "Exercise 1.28: One variant of the Fermat test that cannot\nbe fooled is called the Miller-Rabin test (Miller 1976 ;Rabin\n1980). is starts from an alternate form of Fermat’s Lile\n73\neorem, which states that if nis a prime number and ais\nanypositiveintegerlessthan n,then araisedtothe( n\u00001)-st\npoweriscongruentto1modulo n.Totesttheprimalityofa\nnumber nby the Miller-Rabin test, we pick a random num-\nbera<nandraise atothe( n\u00001)-stpowermodulo nusing\ntheexpmodprocedure. However, whenever we perform the\nsquaringstepin expmod,wechecktoseeifwehavediscov-\nereda“nontrivialsquarerootof1modulo n,”thatis,anum-\nbernotequalto1or n\u00001whosesquareisequalto1modulo\nn.Itispossibletoprovethatifsuchanontrivialsquareroot\nof 1 exists, then nis not prime. It is also possible to prove\nthatif nisanoddnumberthatisnotprime,then,foratleast\nhalf the numbers a<n, computing an\u00001in this way will\nreveal a nontrivial square root of 1 modulo n.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 183, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_sicp_abelson_chunk_0184_3cccbebb", "text": "It is also possible to prove\nthatif nisanoddnumberthatisnotprime,then,foratleast\nhalf the numbers a<n, computing an\u00001in this way will\nreveal a nontrivial square root of 1 modulo n. (is is why\nthe Miller-Rabin test cannot be fooled.) Modify the expmod\nprocedure to signal if it discovers a nontrivial square root\nof 1, and use this to implement the Miller-Rabin test with\na procedure analogous to fermat-test . Check your pro-\ncedure by testing various known primes and non-primes. Hint:Oneconvenientwaytomake expmodsignalistohave\nit return 0. 1.3Formulating Abstractions\nwith Higher-Order Procedures\nWe have seen that procedures are, in eﬀect, abstractions that describe\ncompound operations on numbers independent of the particular num-\nbers. For example, when we\n74\n(define (cube x) (* xxx))\nwe are not talking about the cube of a particular number, but rather\nabout a method for obtaining the cube of any number.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 184, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 915}}
{"id": "computer_science_sicp_abelson_chunk_0185_c63c2242", "text": "For example, when we\n74\n(define (cube x) (* xxx))\nwe are not talking about the cube of a particular number, but rather\nabout a method for obtaining the cube of any number. Of course we\ncouldgetalongwithouteverdeﬁningthisprocedure,byalwayswriting\nexpressions such as\n(* 3 3 3)\n(*xxx)\n(*yyy)\nand never mentioning cubeexplicitly. is would place us at a serious\ndisadvantage,forcingustoworkalwaysattheleveloftheparticularop-\nerationsthathappentobeprimitivesinthelanguage(multiplication,in\nthiscase)ratherthanintermsofhigher-leveloperations.Ourprograms\nwouldbeabletocomputecubes,butourlanguagewouldlacktheability\nto express the concept of cubing. One of the things we should demand\nfrom a powerful programming language is the ability to build abstrac-\ntionsbyassigningnamestocommonpaernsandthentoworkinterms\nof the abstractions directly. Procedures provide this ability. is is why\nall but the most primitive programming languagesinclude mechanisms\nfor deﬁning procedures.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 185, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_sicp_abelson_chunk_0186_d3dc1892", "text": "Procedures provide this ability. is is why\nall but the most primitive programming languagesinclude mechanisms\nfor deﬁning procedures. Yet even in numerical processing we will be severely limited in our\nabilitytocreateabstractionsifwearerestrictedtoprocedureswhosepa-\nrameters must be numbers. Oen the same programming paern will\nbeusedwithanumberofdiﬀerentprocedures.Toexpresssuchpaerns\nas concepts, we will need to construct procedures that can accept pro-\ncedures as arguments or return procedures as values. Procedures that\nmanipulate procedures are called higher-order procedures . is section\nshows how higher-order procedures can serve as powerful abstraction\nmechanisms, vastly increasing the expressive power of our language. 75\n1.3.1Procedures as Arguments\nConsider the following three procedures.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 186, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 810}}
{"id": "computer_science_sicp_abelson_chunk_0187_4774c8eb", "text": "75\n1.3.1Procedures as Arguments\nConsider the following three procedures. e ﬁrst computes the sum of\nthe integers from athrough b:\n(define (sum-integers ab)\n(if(>ab)\n0\n(+a(sum-integers (+a1)b))))\ne second computes the sum of the cubes of the integers in the given\nrange:\n(define (sum-cubes ab)\n(if(>ab)\n0\n(+ ( cube a)\n(sum-cubes (+a1)b))))\ne third computes the sum of a sequence of terms in the series\n1\n1\u00013+1\n5\u00017+1\n9\u000111+: : : ;\nwhich converges to π=8 (very slowly):49\n(define (pi-sum ab)\n(if(>ab)\n0\n(+ (/ 1.0 (* a(+a2)))\n(pi-sum (+a4)b))))\n49is series, usually wrien in the equivalent formπ\n4=1\u00001\n3+1\n5\u00001\n7+: : :, is due\nto Leibniz. We’ll see how to use this as the basis for some fancy numerical tricks in\nSection 3.5.3 . 76\nese three procedures clearly share a common underlying paern. ey are for the most part identical, diﬀering only in the name of the\nprocedure, the function of aused to compute the term to be added, and\nthe function that provides the next value of a.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 187, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_sicp_abelson_chunk_0188_024222af", "text": "ey are for the most part identical, diﬀering only in the name of the\nprocedure, the function of aused to compute the term to be added, and\nthe function that provides the next value of a. We could generate each\nof the procedures by ﬁlling in slots in the same template:\n(define (⟨name⟩ab)\n(if(>ab)\n0\n(+ (⟨term⟩a)\n(⟨name⟩(⟨next⟩a)b))))\ne presence of such a common paern is strong evidence that there is\na useful abstraction waiting to be brought to the surface. Indeed, math-\nematicians long ago identiﬁed the abstraction of summation of a series\nand invented “sigma notation,” for example\nb∑\nn=af(n)=f(a)+\u0001\u0001\u0001+f(b);\nto express this concept. e power of sigma notation is that it allows\nmathematicianstodealwiththeconceptofsummationitselfratherthan\nonly with particular sums—for example, to formulate general results\naboutsumsthatareindependentoftheparticularseriesbeingsummed.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 188, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_sicp_abelson_chunk_0189_f083ca04", "text": "Similarly, as program designers, we would like our language to be\npowerful enough so that we can write a procedure that expresses the\nconcept of summation itself rather than only procedures that compute\nparticular sums. We can do so readily in our procedural language by\ntakingthecommontemplateshownaboveandtransformingthe“slots”\ninto formal parameters:\n(define (sum term anext b)\n(if(>ab)\n77\n0\n(+ ( term a)\n(sum term (next a)next b))))\nNotice that sumtakes as its arguments the lower and upper bounds a\nandbtogether with the procedures termandnext. We can use sumjust\nas we would any procedure.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 189, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 595}}
{"id": "computer_science_sicp_abelson_chunk_0190_36d2ad91", "text": "We can use sumjust\nas we would any procedure. For example, we can use it (along with a\nprocedure incthat increments its argument by 1) to deﬁne sum-cubes :\n(define (inc n) (+ n1))\n(define (sum-cubes ab)\n(sum cube ainc b))\nUsing this, we can compute the sum of the cubes of the integers from 1\nto 10:\n(sum-cubes 1 10)\n3025\nWiththeaidofanidentityproceduretocomputetheterm,wecandeﬁne\nsum-integers in terms of sum:\n(define (identity x)x)\n(define (sum-integers ab)\n(sum identity ainc b))\nen we can add up the integers from 1 to 10:\n(sum-integers 1 10)\n55\nWe can also deﬁne pi-sumin the same way:50\n50Noticethatwehaveusedblockstructure( Section1.1.8 )toembedthedeﬁnitionsof\npi-next andpi-term within pi-sum, since these procedures are unlikely to be useful\nfor any other purpose. We will see how to get rid of them altogether in Section 1.3.2 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 190, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 839}}
{"id": "computer_science_sicp_abelson_chunk_0191_2fba5211", "text": "We will see how to get rid of them altogether in Section 1.3.2 . 78\n(define (pi-sum ab)\n(define (pi-term x)\n(/ 1.0 (* x(+x2))))\n(define (pi-next x)\n(+x4))\n(sum pi-term api-next b))\nUsing these procedures, we can compute an approximation to π:\n(* 8 ( pi-sum 1 1000))\n3.139592655589783\nOnce we have sum, we can use it as a building block in formulating fur-\ntherconcepts.Forinstance,thedeﬁniteintegralofafunction fbetween\nthe limits aandbcan be approximated numerically using the formula\n∫b\naf=[\nf(\na+dx\n2)\n+f(\na+dx+dx\n2)\n+f(\na+ 2dx+dx\n2)\n+: : :]\ndx\nfor small values of dx. We can express this directly as a procedure:\n(define (integral fabdx)\n(define (add-dx x)\n(+xdx))\n(* ( sum f(+a(/dx2.0)) add-dx b)\ndx))\n(integral cube 0 1 0.01)\n.24998750000000042\n(integral cube 0 1 0.001)\n.249999875000001\n(e exact value of the integral of cubebetween 0 and 1 is 1/4.)\n79\nExercise 1.29: Simpson’s Rule is a more accurate method\nofnumericalintegrationthanthemethodillustratedabove.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 191, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_sicp_abelson_chunk_0192_2a0cf5aa", "text": "Using Simpson’s Rule, the integral of a function fbetween\naandbis approximated as\nh\n3(y0+ 4y1+ 2y2+ 4y3+ 2y4+\u0001\u0001\u0001+ 2yn\u00002+ 4yn\u00001+yn);\nwhere h=(b\u0000a)=n, for some even integer n, andyk=\nf(a+kh). (Increasing nincreases the accuracy of the ap-\nproximation.) Deﬁne a procedure that takes as arguments\nf,a,b, and nand returns the value of the integral, com-\nputed using Simpson’s Rule. Use your procedure to inte-\ngrate cubebetween 0 and 1 (with n=100 and n=1000),\nandcomparetheresultstothoseofthe integral procedure\nshown above. Exercise 1.30: esumprocedure above generates a linear\nrecursion. e procedure can be rewrien so that the sum\nis performed iteratively.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 192, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 657}}
{"id": "computer_science_sicp_abelson_chunk_0193_14f07996", "text": "Exercise 1.30: esumprocedure above generates a linear\nrecursion. e procedure can be rewrien so that the sum\nis performed iteratively. Show how to do this by ﬁlling in\nthe missing expressions in the following deﬁnition:\n(define (sum term anext b)\n(define (iter aresult )\n(if⟨??⟩\n⟨??⟩\n(iter⟨??⟩⟨??⟩)))\n(iter⟨??⟩⟨??⟩))\nExercise 1.31:\na.esumprocedure is only the simplest of a vast num-\nberofsimilarabstractionsthatcanbecapturedashigher-\n80\norderprocedures.51Writeananalogousprocedurecalled\nproduct that returns the product of the values of a\nfunctionatpointsoveragivenrange.Showhowtode-\nﬁnefactorial intermsof product .Alsouse product\nto compute approximations to πusing the formula52\nπ\n4=2\u00014\u00014\u00016\u00016\u00018\u0001\u0001\u0001\n3\u00013\u00015\u00015\u00017\u00017\u0001\u0001\u0001:\nb.If your product procedure generates a recursive pro-\ncess, write one that generates an iterative process. If\nit generates an iterative process, write one that gen-\nerates a recursive process.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 193, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_sicp_abelson_chunk_0194_9bc004f3", "text": "If\nit generates an iterative process, write one that gen-\nerates a recursive process. Exercise 1.32:\na.Show that sumand product (Exercise 1.31 ) are both\nspecialcasesofastillmoregeneralnotioncalled accumulate\nthat combines a collection of terms, using some gen-\neral accumulation function:\n(accumulate combiner null-value term anext b)\n51e intent of Exercise 1.31 through Exercise 1.33 is to demonstrate the expressive\npower that is aained by using an appropriate abstraction to consolidate many seem-\ningly disparate operations. However, though accumulation and ﬁltering are elegant\nideas, our hands are somewhat tied in using them at this point since we do not yet\nhave data structures to provide suitable means of combination for these abstractions. We will return to these ideas in Section 2.2.3 when we show how to use sequences as\ninterfaces for combining ﬁlters and accumulators to build even more powerful abstrac-\ntions.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 194, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 931}}
{"id": "computer_science_sicp_abelson_chunk_0195_02619ccc", "text": "We will return to these ideas in Section 2.2.3 when we show how to use sequences as\ninterfaces for combining ﬁlters and accumulators to build even more powerful abstrac-\ntions. We will see there how these methods really come into their own as a powerful\nand elegant approach to designing programs. 52is formula was discovered by the seventeenth-century English mathematician\nJohn Wallis. 81\naccumulate takes as arguments the same term and\nrangespeciﬁcationsas sumandproduct ,togetherwith\nacombiner procedure (of two arguments) that speci-\nﬁes how the current term is to be combined with the\naccumulationoftheprecedingtermsanda null-value\nthat speciﬁes what base value to use when the terms\nrun out. Write accumulate and show how sumand\nproduct canbothbedeﬁnedassimplecallsto accumulate . b.If your accumulate procedure generates a recursive\nprocess, write one that generates an iterative process. Ifitgeneratesaniterativeprocess,writeonethatgen-\nerates a recursive process.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 195, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_sicp_abelson_chunk_0196_20612a06", "text": "b.If your accumulate procedure generates a recursive\nprocess, write one that generates an iterative process. Ifitgeneratesaniterativeprocess,writeonethatgen-\nerates a recursive process. Exercise 1.33: You can obtain an even more general ver-\nsion of accumulate (Exercise 1.32 ) by introducing the no-\ntionofa ﬁlteronthetermstobecombined.atis,combine\nonly those terms derived from values in the range that sat-\nisfyaspeciﬁedcondition.eresulting filtered-accumulate\nabstraction takes the same arguments as accumulate, to-\ngether with an additional predicate of one argument that\nspeciﬁestheﬁlter.Write filtered-accumulate asaproce-\ndure. Show how to express the following using filtered-\naccumulate :\na.the sum of the squares of the prime numbers in the\ninterval atob(assumingthatyouhavea prime?pred-\nicate already wrien)\nb.theproductofallthepositiveintegerslessthan nthat\narerelativelyprimeto n(i.e.,allpositiveintegers i<n\nsuch that  (i;n)=1).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 196, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_sicp_abelson_chunk_0197_735ae882", "text": "82\n1.3.2Constructing Procedures Using lambda\nIn using sumas inSection 1.3.1 , it seems terribly awkward to have to\ndeﬁne trivial procedures such as pi-term andpi-next just so we can\nuse them as arguments to our higher-order procedure.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 197, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 234}}
{"id": "computer_science_sicp_abelson_chunk_0198_6c064a10", "text": "Rather than de-\nﬁnepi-next andpi-term , it would be more convenient to have a way\nto directly specify “the procedure that returns its input incremented by\n4” and “the procedure that returns the reciprocal of its input times its\ninput plus 2.” We can do this by introducing the special form lambda,\nwhichcreatesprocedures.Using lambdawecandescribewhatwewant\nas\n(lambda (x) (+ x4))\nand\n(lambda (x) (/ 1.0 (* x(+x2))))\nenour pi-sumprocedurecanbeexpressedwithoutdeﬁninganyaux-\niliary procedures as\n(define (pi-sum ab)\n(sum (lambda (x) (/ 1.0 (* x(+x2))))\na\n(lambda (x) (+ x4))\nb))\nAgainusing lambda,wecanwritethe integral procedurewithouthav-\ning to deﬁne the auxiliary procedure add-dx:\n(define (integral fabdx)\n(* ( sum f\n(+a(/dx2.0))\n(lambda (x) (+ xdx))\nb)\ndx))\n83\nIn general, lambda is used to create procedures in the same way as\ndefine, except that no name is speciﬁed for the procedure:\n(lambda (⟨formal-parameters ⟩)⟨body⟩)\ne resulting procedure is just as much a procedure as one that is cre-\nated using define.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 198, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1019}}
{"id": "computer_science_sicp_abelson_chunk_0199_63a6f2a5", "text": "e only diﬀerence is that it has not been associated\nwith any name in the environment. In fact,\n(define (plus4 x) (+ x4))\nis equivalent to\n(define plus4 (lambda (x) (+ x4)))\nWe can read a lambdaexpression as follows:\n(lambda (x) (+ x 4))\n| | | | |\nthe procedure ofanargument xthat adds xand 4\nLike any expression that has a procedure as its value, a lambdaexpres-\nsion can be used as the operator in a combination such as\n((lambda (xyz) (+ xy(square z)))\n1 2 3)\n12\nor, more generally, in any context where we would normally use a pro-\ncedure name.53\n53It would be clearer and less intimidating to people learning Lisp if a name more\nobviousthan lambda,suchas make-procedure ,wereused.Buttheconventionisﬁrmly\nentrenched. e notation is adopted from the λ-calculus, a mathematical formalism in-\ntroduced by the mathematical logician Alonzo Church (1941) . Church developed the\nλ-calculus to provide a rigorous foundation for studying the notions of function and\nfunction application.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 199, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_sicp_abelson_chunk_0200_adb5cea5", "text": "Church developed the\nλ-calculus to provide a rigorous foundation for studying the notions of function and\nfunction application. e λ-calculus has become a basic tool for mathematical investi-\ngations of the semantics of programming languages. 84\nUsing letto create local variables\nAnother use of lambdais in creating local variables. We oen need lo-\ncal variables in our procedures other than those that have been bound\nas formal parameters.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 200, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 442}}
{"id": "computer_science_sicp_abelson_chunk_0201_3b119d60", "text": "84\nUsing letto create local variables\nAnother use of lambdais in creating local variables. We oen need lo-\ncal variables in our procedures other than those that have been bound\nas formal parameters. For example, suppose we wish to compute the\nfunction\nf(x;y)=x(1 +xy)2+y(1\u0000y)+(1 +xy)(1\u0000y);\nwhich we could also express as\na=1 +xy;\nb=1\u0000y;\nf(x;y)=xa2+yb+ab:\nIn writing a procedure to compute f, we would like to include as local\nvariablesnotonly xandybutalsothenamesofintermediatequantities\nlikeaandb.Onewaytoaccomplishthisistouseanauxiliaryprocedure\nto bind the local variables:\n(define (fxy)\n(define (f-helper ab)\n(+ (* x(square a))\n(*yb)\n(*ab)))\n(f-helper (+ 1 (* xy))\n(- 1 y)))\nOf course, we could use a lambdaexpression to specify an anonymous\nprocedure for binding our local variables.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 201, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 789}}
{"id": "computer_science_sicp_abelson_chunk_0202_b4596fa2", "text": "e body of fthen becomes\na single call to that procedure:\n(define (fxy)\n((lambda (ab)\n85\n(+ (* x(square a))\n(*yb)\n(*ab)))\n(+ 1 (* xy))\n(- 1 y)))\nisconstructissousefulthatthereisaspecialformcalled lettomake\nits use more convenient. Using let, the fprocedure could be wrien as\n(define (fxy)\n(let ((a(+ 1 (* xy)))\n(b(- 1 y)))\n(+ (* x(square a))\n(*yb)\n(*ab))))\ne general form of a letexpression is\n(let ((⟨var 1⟩⟨exp1⟩)\n(⟨var 2⟩⟨exp2⟩)\n: : :\n(⟨var n⟩⟨expn⟩))\n⟨body⟩)\nwhich can be thought of as saying\nlet⟨var1⟩have the value ⟨exp1⟩and\n⟨var2⟩have the value ⟨exp2⟩and\n: : :\n⟨varn⟩have the value ⟨expn⟩\nin⟨body⟩\ne ﬁrst part of the letexpression is a list of name-expression pairs. When the letis evaluated, each name is associated with the value of\nthe corresponding expression. e body of the letis evaluated with\nthese names bound as local variables.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 202, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 849}}
{"id": "computer_science_sicp_abelson_chunk_0203_3ade6edf", "text": "When the letis evaluated, each name is associated with the value of\nthe corresponding expression. e body of the letis evaluated with\nthese names bound as local variables. e way this happens is that the\nletexpression is interpreted as an alternate syntax for\n86\n((lambda (⟨var1⟩: : :⟨varn⟩)\n⟨body⟩)\n⟨exp1⟩\n: : :\n⟨expn⟩)\nNo new mechanism is required in the interpreter in order to provide\nlocal variables. A letexpression is simply syntactic sugar for the un-\nderlying lambdaapplication. We can see from this equivalence that the scope of a variable spec-\niﬁed by a letexpression is the body of the let. is implies that:\n•letallows one to bind variables as locally as possible to where\nthey are to be used. For example, if the value of xis 5, the value\nof the expression\n(+ ( let ((x3))\n(+x(*x10)))\nx)\nis 38. Here, the xin the body of the letis 3, so the value of the\nletexpression is 33. On the other hand, the xthat is the second\nargument to the outermost +is still 5.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 203, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_sicp_abelson_chunk_0204_5ee9f66e", "text": "Here, the xin the body of the letis 3, so the value of the\nletexpression is 33. On the other hand, the xthat is the second\nargument to the outermost +is still 5. •e variables’ values are computed outside the let. is maers\nwhen the expressions that provide the values for the local vari-\nables depend upon variables having the same names as the local\nvariables themselves. For example, if the value of xis 2, the ex-\npression\n(let ((x3)\n(y(+x2)))\n(*xy))\n87\nwill have the value 12 because, inside the body of the let,xwill\nbe 3 and ywill be 4 (which is the outer xplus 2). Sometimeswecanuseinternaldeﬁnitionstogetthesameeﬀectaswith\nlet.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 204, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 637}}
{"id": "computer_science_sicp_abelson_chunk_0205_1ebc2241", "text": "Sometimeswecanuseinternaldeﬁnitionstogetthesameeﬀectaswith\nlet. For example, we could have deﬁned the procedure fabove as\n(define (fxy)\n(define a(+ 1 (* xy)))\n(define b(- 1 y))\n(+ (* x(square a))\n(*yb)\n(*ab)))\nWeprefer,however,to use letin situations likethis and to use internal\ndefineonly for internal procedures.54\nExercise 1.34: Suppose we deﬁne the procedure\n(define (fg) (g2))\nen we have\n(fsquare )\n4\n(f(lambda (z) (* z(+z1))))\n6\nWhathappensifwe(perversely)asktheinterpretertoeval-\nuate the combination (f f)? Explain. 54Understanding internal deﬁnitions well enough to be sure a program means what\nweintendittomeanrequiresamoreelaboratemodeloftheevaluationprocessthanwe\nhave presented in this chapter. e subtleties do not arise with internal deﬁnitions of\nprocedures, however. We will return to this issue in Section 4.1.6 , aer we learn more\nabout evaluation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 205, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 870}}
{"id": "computer_science_sicp_abelson_chunk_0206_f0d68dc6", "text": "e subtleties do not arise with internal deﬁnitions of\nprocedures, however. We will return to this issue in Section 4.1.6 , aer we learn more\nabout evaluation. 88\n1.3.3Procedures as General Methods\nWe introduced compound procedures in Section 1.1.4 as a mechanism\nfor abstracting paerns of numerical operations so as to make them in-\ndependent of the particular numbers involved. With higher-order pro-\ncedures, such as the integral procedure of Section 1.3.1 , we began to\nsee a more powerful kind of abstraction: procedures used to express\ngeneral methods of computation, independent of the particular func-\ntionsinvolved.Inthissectionwediscusstwomoreelaborateexamples—\ngeneral methods for ﬁnding zeros and ﬁxed points of functions—and\nshow how these methods can be expressed directly as procedures. Finding roots of equations by the half-interval method\nehalf-interval method is a simple but powerful technique for ﬁnding\nroots of an equation f(x)=0, where fis a continuous function.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 206, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_sicp_abelson_chunk_0207_ec67db02", "text": "Finding roots of equations by the half-interval method\nehalf-interval method is a simple but powerful technique for ﬁnding\nroots of an equation f(x)=0, where fis a continuous function. e\nidea is that, if we are given points aandbsuch that f(a)<0<f(b),\nthen fmust have at least one zero between aandb. To locate a zero,\nletxbe the average of aandb, and compute f(x). Iff(x)>0, then\nfmust have a zero between aandx. Iff(x)<0, then fmust have a\nzero between xandb. Continuing in this way, we can identify smaller\nand smaller intervals on which fmust have a zero. When we reach a\npoint where the interval is small enough, the process stops. Since the\nintervalofuncertaintyisreducedbyhalfateachstepoftheprocess,the\nnumber of steps required grows as Θ(log (L=T)), where Lis the length\nof the original interval and Tis the error tolerance (that is, the size of\nthe interval we will consider “small enough”).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 207, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_sicp_abelson_chunk_0208_7768d490", "text": "Here is a procedure that\nimplements this strategy:\n(define (search fneg-point pos-point )\n(let ((midpoint (average neg-point pos-point )))\n89\n(if(close-enough? neg-point pos-point )\nmidpoint\n(let ((test-value (fmidpoint )))\n(cond ((positive? test-value )\n(search fneg-point midpoint ))\n((negative? test-value )\n(search fmidpoint pos-point ))\n(else midpoint ))))))\nWe assume that we are initially given the function ftogether with\npoints at which its values are negative and positive. We ﬁrst compute\nthe midpoint of the two given points. Next we check to see if the given\nintervalissmallenough,andifsowesimplyreturnthemidpointasour\nanswer.Otherwise,wecomputeasatestvaluethevalueof fatthemid-\npoint. If the test value is positive, then we continue the process with a\nnew interval running from the original negative point to the midpoint. Ifthetestvalueisnegative,wecontinuewiththeintervalfromthemid-\npoint to the positive point.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 208, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_sicp_abelson_chunk_0209_35629594", "text": "Ifthetestvalueisnegative,wecontinuewiththeintervalfromthemid-\npoint to the positive point. Finally, there is the possibility that the test\nvalue is 0, in which case the midpoint is itself the root we are searching\nfor. To test whether the endpoints are “close enough” we can use a pro-\ncedure similar to the one used in Section 1.1.7 for computing square\nroots:55\n(define (close-enough? xy) (< ( abs (-xy)) 0.001))\nsearchis awkward to use directly, because we can accidentally give it\npoints at which f’s values do not have the required sign, in which case\n55We have used 0.001 as a representative “small” number to indicate a tolerance for\nthe acceptable error in a calculation. e appropriate tolerance for a real calculation\ndepends upon the problem to be solved and the limitations of the computer and the\nalgorithm. is is oen a very subtle consideration, requiring help from a numerical\nanalyst or some other kind of magician. 90\nwe get a wrong answer.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 209, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_sicp_abelson_chunk_0210_c2a5b63d", "text": "is is oen a very subtle consideration, requiring help from a numerical\nanalyst or some other kind of magician. 90\nwe get a wrong answer. Instead we will use searchvia the following\nprocedure, which checks to see which of the endpoints has a negative\nfunctionvalueandwhichhasapositivevalue,andcallsthe searchpro-\ncedure accordingly. If the function has the same sign on the two given\npoints, the half-interval method cannot be used, in which case the pro-\ncedure signals an error.56\n(define (half-interval-method fab)\n(let ((a-value (fa))\n(b-value (fb)))\n(cond ((and (negative? a-value ) (positive? b-value ))\n(search fab))\n((and (negative? b-value ) (positive?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 210, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 662}}
{"id": "computer_science_sicp_abelson_chunk_0211_02819636", "text": "a-value ) (positive? b-value ))\n(search fab))\n((and (negative? b-value ) (positive? a-value ))\n(search fba))\n(else\n(error \"Values are not ofopposite sign \"ab)))))\ne following example uses the half-interval method to approximate π\nas the root between 2 and 4 of sin x=0:\n(half-interval-method sin 2.0 4.0)\n3.14111328125\nHere is another example, using the half-interval method to search for a\nroot of the equation x3\u00002x\u00003=0 between 1 and 2:\n(half-interval-method (lambda (x) (- (* xxx) (* 2 x) 3))\n1.0\n2.0)\n1.89306640625\n56iscanbeaccomplishedusing error,whichtakesasargumentsanumberofitems\nthat are printed as error messages. 91\nFinding fixed points of functions\nA number xis called a ﬁxed point of a function fifxsatisﬁes the equa-\ntion f(x)=x. For some functions fwe can locate a ﬁxed point by\nbeginning with an initial guess and applying frepeatedly,\nf(x);f(f(x));f(f(f(x))); : : : ;\nuntil the value does not change very much.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 211, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 929}}
{"id": "computer_science_sicp_abelson_chunk_0212_db54079c", "text": "For some functions fwe can locate a ﬁxed point by\nbeginning with an initial guess and applying frepeatedly,\nf(x);f(f(x));f(f(f(x))); : : : ;\nuntil the value does not change very much. Using this idea, we can de-\nvise a procedure fixed-point that takes as inputs a function and an\ninitialguessandproducesanapproximationtoaﬁxedpointofthefunc-\ntion.Weapplythefunctionrepeatedlyuntilweﬁndtwosuccessiveval-\nues whose diﬀerence is less than some prescribed tolerance:\n(define tolerance 0.00001)\n(define (fixed-point ffirst-guess )\n(define (close-enough? v1v2)\n(< ( abs (-v1v2))\ntolerance ))\n(define (try guess )\n(let ((next (fguess )))\n(if(close-enough?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 212, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 647}}
{"id": "computer_science_sicp_abelson_chunk_0213_1b7b23db", "text": "v1v2)\n(< ( abs (-v1v2))\ntolerance ))\n(define (try guess )\n(let ((next (fguess )))\n(if(close-enough? guess next )\nnext\n(try next ))))\n(try first-guess ))\nFor example, we can use this method to approximate the ﬁxed point of\nthe cosine function, starting with 1 as an initial approximation:57\n(fixed-point cos 1.0)\n.7390822985224023\nSimilarly, we can ﬁnd a solution to the equation y=siny+ cosy:\n57Try this during a boring lecture: Set your calculator to radians mode and then\nrepeatedly press the cosbuon until you obtain the ﬁxed point. 92\n(fixed-point (lambda (y) (+ ( sin y) (cos y)))\n1.0)\n1.2587315962971173\neﬁxed-pointprocessisreminiscentoftheprocessweusedforﬁnding\nsquare roots in Section 1.1.7 . Both are based on the idea of repeatedly\nimprovingaguessuntiltheresultsatisﬁessomecriterion.Infact,wecan\nreadily formulate the square-root computation as a ﬁxed-point search. Computing the square root of some number xrequires ﬁnding a ysuch\nthaty2=x.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 213, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_sicp_abelson_chunk_0214_eee4a30a", "text": "Computing the square root of some number xrequires ﬁnding a ysuch\nthaty2=x. Puing this equation into the equivalent form y=x=y,\nwe recognize that we are looking for a ﬁxed point of the function58\ny7!x=y, and we can therefore try to compute square roots as\n(define (sqrt x)\n(fixed-point (lambda (y) (/ xy))\n1.0))\nUnfortunately, this ﬁxed-point search does not converge. Consider an\ninitial guess y1. e next guess is y2=x=y1and the next guess is y3=\nx=y2=x=(x=y1)=y1. is results in an inﬁnite loop in which the two\nguessesy1andy2repeat over and over, oscillating about the answer. One way to control such oscillations is to prevent the guesses from\nchanging so much. Since the answeris always between our guess yand\nx=y, we can make a new guess that is not as far from yasx=yby av-\neragingywith x=y, so that the next guess aer yis1\n2(y+x=y)instead\nofx=y.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 214, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 856}}
{"id": "computer_science_sicp_abelson_chunk_0215_004eb514", "text": "Since the answeris always between our guess yand\nx=y, we can make a new guess that is not as far from yasx=yby av-\neragingywith x=y, so that the next guess aer yis1\n2(y+x=y)instead\nofx=y. e process of making such a sequence of guesses is simply the\nprocess of looking for a ﬁxed point of y7!1\n2(y+x=y):\n(define (sqrt x)\n(fixed-point (lambda (y) (average y(/xy)))\n1.0))\n587!(pronounced“mapsto”)isthemathematician’swayofwriting lambda.y7!x=y\nmeans (lambda (y) (/ x y)) , that is, the function whose value at yisx=y. 93\n(Note that y=1\n2(y+x=y)is a simple transformation of the equation\ny=x=y; to derive it, add yto both sides of the equation and divide by\n2.)\nWith this modiﬁcation, the square-root procedure works. In fact, if\nwe unravel the deﬁnitions, we can see that the sequence of approxi-\nmations to the square root generated here is precisely the same as the\none generated by our original square-root procedure of Section 1.1.7 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 215, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_sicp_abelson_chunk_0216_09580a37", "text": "is approach of averaging successive approximations to a solution, a\ntechnique that we call average damping , oen aids the convergence of\nﬁxed-point searches. Exercise 1.35: Show that the golden ratio ϕ(Section 1.2.2 )\nis a ﬁxed point of the transformation x7!1 + 1 =x, and\nuse this fact to compute ϕby means of the fixed-point\nprocedure. Exercise 1.36: Modify fixed-point so that it prints the\nsequenceofapproximationsitgenerates,usingthe newline\nanddisplay primitives shown in Exercise 1.22 . en ﬁnd\na solution to xx=1000 by ﬁnding a ﬁxed point of x7! log (1000 )=log (x).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 216, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 576}}
{"id": "computer_science_sicp_abelson_chunk_0217_ca1ad2c5", "text": "en ﬁnd\na solution to xx=1000 by ﬁnding a ﬁxed point of x7! log (1000 )=log (x). (Use Scheme’s primitive logprocedure,\nwhich computes natural logarithms.) Compare the number\nofstepsthistakeswithandwithoutaveragedamping.(Note\nthatyoucannotstart fixed-point withaguessof1,asthis\nwould cause division by log (1)=0.)\nExercise 1.37:\na.An inﬁnite continued fraction is an expression of the\n94\nform\nf=N1\nD1+N2\nD2+N3\nD3+: : ::\nAs an example, one can show that the inﬁnite con-\ntinued fraction expansion with the Niand the Diall\nequal to 1 produces 1 =ϕ, whereϕis the golden ratio\n(described in Section 1.2.2 ). One way to approximate\naninﬁnitecontinuedfractionistotruncatetheexpan-\nsionaeragivennumberofterms.Suchatruncation—\naso-called k-term ﬁnite continued fraction —hastheform\nN1\nD1+N2\n:::+Nk\nDk:\nSuppose that nanddare procedures of one argument\n(the term index i) that return the NiandDiof the\nterms of the continued fraction.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 217, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_sicp_abelson_chunk_0218_b3a2e9c7", "text": "Deﬁne a procedure\ncont-frac such that evaluating (cont-frac n d k)\ncomputesthevalueofthe k-termﬁnitecontinuedfrac-\ntion.Checkyourprocedurebyapproximating1 =ϕus-\ning\n(cont-frac (lambda (i) 1.0)\n(lambda (i) 1.0)\nk)\n95\nfor successive values of k. How large must you make\nkin order to get an approximation that is accurate to\n4 decimal places? b.Ifyour cont-frac proceduregeneratesarecursivepro-\ncess, write one that generates an iterative process. If\nit generates an iterative process, write one that gen-\nerates a recursive process. Exercise1.38: In 1737, the Swiss mathematician Leonhard\nEuler published a memoir De Fractionibus Continuis , which\nincluded a continued fraction expansion for e\u00002, where\neis the base of the natural logarithms. In this fraction, the\nNiare all 1, and the Diare successively 1, 2, 1, 1, 4, 1, 1,\n6, 1, 1, 8, : : :. Write a program that uses your cont-frac\nprocedure from Exercise 1.37 to approximate e, based on\nEuler’s expansion.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 218, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 958}}
{"id": "computer_science_sicp_abelson_chunk_0219_d696b5ac", "text": "Write a program that uses your cont-frac\nprocedure from Exercise 1.37 to approximate e, based on\nEuler’s expansion. Exercise 1.39: A continued fraction representation of the\ntangentfunctionwaspublishedin1770bytheGermanmath-\nematician J.H. Lambert:\ntanx=x\n1\u0000x2\n3\u0000x2\n5\u0000: : :;\nwhere xisinradians.Deﬁneaprocedure (tan-cf x k) that\ncomputes an approximation to the tangent function based\non Lambert’s formula. kspeciﬁes the number of terms to\ncompute, as in Exercise 1.37 . 96\n1.3.4Procedures as Returned Values\ne above examples demonstrate how the ability to pass procedures as\nargumentssigniﬁcantlyenhancestheexpressivepowerofourprogram-\nminglanguage.Wecanachieveevenmoreexpressivepowerbycreating\nprocedures whose returned values are themselves procedures. Wecanillustratethisideabylookingagainattheﬁxed-pointexam-\nple described at the end of Section 1.3.3 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 219, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 856}}
{"id": "computer_science_sicp_abelson_chunk_0220_839ddc3c", "text": "Wecanillustratethisideabylookingagainattheﬁxed-pointexam-\nple described at the end of Section 1.3.3 . We formulated a new version\nof the square-root procedure as a ﬁxed-point search, starting with the\nobservation thatpxis a ﬁxed-point of the function y7!x=y. en we\nused average damping to make the approximations converge. Average\ndampingisausefulgeneraltechniqueinitself.Namely,givenafunction\nf, we consider the function whose value at xis equal to the average of\nxandf(x). We can express the idea of average damping by means of the fol-\nlowing procedure:\n(define (average-damp f)\n(lambda (x) (average x(fx))))\naverage-damp is a procedure that takes as its argument a procedure\nfand returns as its value a procedure (produced by the lambda) that,\nwhen applied to a number x, produces the average of xand(f x). For\nexample, applying average-damp to the squareprocedure produces a\nprocedure whose value at some number xis the average of xandx2.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 220, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_sicp_abelson_chunk_0221_891595c5", "text": "For\nexample, applying average-damp to the squareprocedure produces a\nprocedure whose value at some number xis the average of xandx2. Applying this resulting procedure to 10 returns the average of 10 and\n100, or 55:59\n59Observethatthis isa combinationwhose operatoris itselfa combination. Exercise\n1.4alreadydemonstratedtheabilitytoformsuchcombinations,butthatwasonlyatoy\nexample. Here we begin to see the real need for such combinations—when applying a\nprocedure that is obtained as the value returned by a higher-order procedure. 97\n((average-damp square ) 10)\n55\nUsing average-damp , we can reformulate the square-root procedure as\nfollows:\n(define (sqrt x)\n(fixed-point (average-damp (lambda (y) (/ xy)))\n1.0))\nNoticehowthisformulationmakesexplicitthethreeideasinthemethod:\nﬁxed-pointsearch,averagedamping,andthefunction y7!x=y.Itisin-\nstructive to compare this formulation of the square-root method with\nthe original version given in Section 1.1.7 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 221, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_sicp_abelson_chunk_0222_e16617f3", "text": "Bear in mind that these pro-\nceduresexpressthesameprocess,andnoticehowmuchclearertheidea\nbecomes when weexpress the process in terms of these abstractions. In\ngeneral,therearemanywaystoformulateaprocessasaprocedure.Ex-\nperienced programmers know how to choose procedural formulations\nthatareparticularlyperspicuous,andwhereusefulelementsofthepro-\ncess are exposed as separate entities that can be reused in other appli-\ncations. As a simple example of reuse, notice that the cube root of xis a\nﬁxed point of the function y7!x=y2, so we can immediately generalize\nour square-root procedure to one that extracts cube roots:60\n(define (cube-root x)\n(fixed-point (average-damp (lambda (y) (/ x(square y))))\n1.0))\nNewton’s method\nWhenweﬁrstintroducedthesquare-rootprocedure,in Section1.1.7 ,we\nmentioned that this was a special case of Newton’s method . Ifx7!д(x)\n60SeeExercise 1.45 for a further generalization.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 222, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_sicp_abelson_chunk_0223_77b56908", "text": "Ifx7!д(x)\n60SeeExercise 1.45 for a further generalization. 98\nis a diﬀerentiable function, then a solution of the equation д(x)=0 is a\nﬁxed point of the function x7!f(x), where\nf(x)=x\u0000д(x)\nDд(x)\nandDд(x)is the derivative of дevaluated at x. Newton’s method is the\nuse of the ﬁxed-point method we saw above to approximate a solution\nof the equation by ﬁnding a ﬁxed point of the function f:61\nFor many functions дand for suﬃciently good initial guesses for x,\nNewton’s method converges very rapidly to a solution of д(x)=0:62\nIn order to implement Newton’s method as a procedure, we must\nﬁrst express the idea of derivative. Note that “derivative,” like average\ndamping,issomethingthattransformsafunctionintoanotherfunction. For instance, the derivative of the function x7!x3is the function x7!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 223, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 793}}
{"id": "computer_science_sicp_abelson_chunk_0224_7974ad16", "text": "Note that “derivative,” like average\ndamping,issomethingthattransformsafunctionintoanotherfunction. For instance, the derivative of the function x7!x3is the function x7! 3x2:In general, if дis a function and dxis a small number, then the\nderivative Dдofдisthefunctionwhosevalueatanynumber xisgiven\n(in the limit of small dx) by\nDд(x)=д(x+dx)\u0000д(x)\ndx:\nus,wecanexpresstheideaofderivative(taking dxtobe,say,0.00001)\nas the procedure\n(define (deriv g)\n(lambda (x) (/ (- ( g(+xdx)) ( gx))dx)))\n61Elementary calculus books usually describe Newton’s method in terms of the se-\nquenceofapproximations xn+1=xn\u0000д(xn)=Dд(xn).Havinglanguagefortalkingabout\nprocesses and using the idea of ﬁxed points simpliﬁes the description of the method. 62Newton’s method does not always converge to an answer, but it can be shown\nthat in favorable cases each iteration doubles the number-of-digits accuracy of the ap-\nproximation to the solution.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 224, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_sicp_abelson_chunk_0225_e7e74412", "text": "62Newton’s method does not always converge to an answer, but it can be shown\nthat in favorable cases each iteration doubles the number-of-digits accuracy of the ap-\nproximation to the solution. In such cases, Newton’s method will converge much more\nrapidly than the half-interval method. 99\nalong with the deﬁnition\n(define dx0.00001)\nLike average-damp ,derivis a procedure that takes a procedure as ar-\ngument and returns a procedure as value. For example, to approximate\nthe derivative of x7!x3at 5 (whose exact value is 75) we can evaluate\n(define (cube x) (* xxx))\n((deriv cube ) 5)\n75.00014999664018\nWiththeaidof deriv,wecanexpressNewton’smethodasaﬁxed-point\nprocess:\n(define (newton-transform g)\n(lambda (x) (- x(/ ( gx) (( deriv g)x)))))\n(define (newtons-method gguess )\n(fixed-point (newton-transform g)guess ))\nenewton-transform procedure expresses the formula at the begin-\nning of this section, and newtons-method is readily deﬁned in terms of\nthis.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 225, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_sicp_abelson_chunk_0226_6cc753e5", "text": "It takes as arguments a procedure that computes the function for\nwhich we want to ﬁnd a zero, together with an initial guess. For in-\nstance,toﬁndthesquarerootof x,wecanuseNewton’smethodtoﬁnd\na zero of the function y7!y2\u0000xstarting with an initial guess of 1.63\nis provides yet another form of the square-root procedure:\n(define (sqrt x)\n(newtons-method\n(lambda (y) (- ( square y)x)) 1.0))\n63For ﬁnding square roots, Newton’s method converges rapidly to the correct solu-\ntion from any starting point. 100\nAbstractions and first-class procedures\nWe’ve seen two ways to express the square-root computation as an in-\nstance of a more general method, once as a ﬁxed-point search and once\nusing Newton’s method. Since Newton’s method was itself expressed\nas a ﬁxed-point process, we actually saw two ways to compute square\nroots as ﬁxed points. Each method begins with a function and ﬁnds a\nﬁxed point of some transformation of the function.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 226, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 937}}
{"id": "computer_science_sicp_abelson_chunk_0227_a4f0e0a3", "text": "Each method begins with a function and ﬁnds a\nﬁxed point of some transformation of the function. We can express this\ngeneral idea itself as a procedure:\n(define (fixed-point-of-transform gtransform guess )\n(fixed-point (transform g)guess ))\nis very general procedure takes as its arguments a procedure gthat\ncomputes some function, a procedure that transforms g, and an initial\nguess. e returned result is a ﬁxed point of the transformed function.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 227, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 449}}
{"id": "computer_science_sicp_abelson_chunk_0228_02254334", "text": "e returned result is a ﬁxed point of the transformed function. Using this abstraction, we can recast the ﬁrst square-root computa-\ntion from this section (where we look for a ﬁxed point of the average-\ndamped version of y7!x=y) as an instance of this general method:\n(define (sqrt x)\n(fixed-point-of-transform\n(lambda (y) (/ xy))average-damp 1.0))\nSimilarly,wecanexpressthesecondsquare-rootcomputationfromthis\nsection (an instance of Newton’s method that ﬁnds a ﬁxed point of the\nNewton transform of y7!y2\u0000x) as\n(define (sqrt x)\n(fixed-point-of-transform\n(lambda (y) (- ( square y)x))newton-transform 1.0))\nWe began Section 1.3 with the observation that compound procedures\nare a crucial abstraction mechanism, because they permit us to express\ngeneralmethodsofcomputingasexplicitelementsinourprogramming\n101\nlanguage. Now we’ve seen how higher-order procedures permit us to\nmanipulate these general methods to create further abstractions.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 228, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_sicp_abelson_chunk_0229_73fc4905", "text": "Now we’ve seen how higher-order procedures permit us to\nmanipulate these general methods to create further abstractions. Asprogrammers,weshouldbealerttoopportunitiestoidentifythe\nunderlying abstractions in our programs and to build upon them and\ngeneralize them to create more powerful abstractions. is is not to\nsay that one should always write programs in the most abstract way\npossible; expert programmers know how to choose the level of abstrac-\ntion appropriate to their task. But it is important to be able to think in\nterms of these abstractions, so that we can be ready to apply them in\nnew contexts. e signiﬁcance of higher-order procedures is that they\nenable us to represent these abstractions explicitly as elements in our\nprogramminglanguage,sothattheycanbehandledjustlikeothercom-\nputational elements. Ingeneral,programminglanguagesimposerestrictionsontheways\nin which computational elements can be manipulated. Elements with\nthe fewest restrictions are said to have ﬁrst-class status.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 229, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_sicp_abelson_chunk_0230_3f02a29a", "text": "Ingeneral,programminglanguagesimposerestrictionsontheways\nin which computational elements can be manipulated. Elements with\nthe fewest restrictions are said to have ﬁrst-class status. Some of the\n“rights and privileges” of ﬁrst-class elements are:64\n•ey may be named by variables. •ey may be passed as arguments to procedures. •ey may be returned as the results of procedures. •ey may be included in data structures.65\nLisp,unlikeothercommonprogramminglanguages,awardsprocedures\nfullﬁrst-classstatus.isposeschallengesforeﬃcientimplementation,\n64e notion of ﬁrst-class status of programming-language elements is due to the\nBritish computer scientist Christopher Strachey (1916-1975). 65We’ll see examples of this aer we introduce data structures in Chapter 2 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 230, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 766}}
{"id": "computer_science_sicp_abelson_chunk_0231_f14bd192", "text": "65We’ll see examples of this aer we introduce data structures in Chapter 2 . 102\nbut the resulting gain in expressive power is enormous.66\nExercise 1.40: Deﬁne a procedure cubicthat can be used\ntogetherwiththe newtons-method procedureinexpressions\nof the form\n(newtons-method (cubic abc) 1)\nto approximate zeros of the cubic x3+ax2+bx+c. Exercise1.41: Deﬁne a procedure doublethat takes a pro-\ncedure of one argument as argument and returns a proce-\ndure that applies the original procedure twice. For exam-\nple, if incis a procedure that adds 1 to its argument, then\n(double inc) should be a procedure that adds 2. What\nvalue is returned by\n(((double (double double ))inc) 5)\nExercise1.42: Letfandдbetwoone-argumentfunctions. ecomposition faerдis deﬁned to be the function x7! f(д(x)). Deﬁne a procedure compose that implements com-\nposition.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 231, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 846}}
{"id": "computer_science_sicp_abelson_chunk_0232_dfa233a6", "text": "ecomposition faerдis deﬁned to be the function x7! f(д(x)). Deﬁne a procedure compose that implements com-\nposition. For example, if incis a procedure that adds 1 to\nits argument,\n((compose square inc) 6)\n49\n66emajorimplementationcostofﬁrst-classproceduresisthatallowingprocedures\ntobereturnedasvaluesrequiresreservingstorageforaprocedure’sfreevariableseven\nwhile the procedure is not executing. In the Scheme implementation we will study in\nSection 4.1 , these variables are stored in the procedure’s environment. 103\nExercise 1.43: Iffis a numerical function and nis a posi-\ntive integer, then we can form the nthrepeated application\noff, which is deﬁned to be the function whose value at\nxisf(f(: : : (f(x)): : : )). For example, if fis the function\nx7!x+ 1, then the nthrepeated application of fis the\nfunction x7!x+n.Iffistheoperationofsquaringanum-\nber, then the nthrepeated application of fis the function\nthat raises its argument to the 2n-th power.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 232, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_sicp_abelson_chunk_0233_bbe89a7b", "text": "Write a proce-\ndurethattakesasinputsaprocedurethatcomputes fanda\npositive integer nand returns the procedure that computes\nthenthrepeatedapplicationof f.Yourprocedureshouldbe\nable to be used as follows:\n((repeated square 2) 5)\n625\nHint: You may ﬁnd it convenient to use compose fromEx-\nercise 1.42 . Exercise 1.44: e idea of smoothing a function is an im-\nportant concept in signal processing. If fis a function and\ndxissomesmallnumber,thenthesmoothedversionof fis\nthefunctionwhosevalueatapoint xistheaverageof f(x\u0000\ndx),f(x),and f(x+dx).Writeaprocedure smooththattakes\nas input a procedure that computes fand returns a proce-\ndure that computes the smoothed f. It is sometimes valu-\nable to repeatedly smooth a function (that is, smooth the\nsmoothedfunction,andsoon)toobtainthe n-fold smoothed\nfunction. Show how to generate the n-fold smoothed func-\ntionofanygivenfunctionusing smoothandrepeated from\nExercise 1.43 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 233, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_sicp_abelson_chunk_0234_140b06c5", "text": "Show how to generate the n-fold smoothed func-\ntionofanygivenfunctionusing smoothandrepeated from\nExercise 1.43 . 104\nExercise 1.45: We saw in Section 1.3.3 that aempting to\ncompute square roots by naively ﬁnding a ﬁxed point of\ny7!x=ydoes not converge, and that this can be ﬁxed by\naveragedamping.esamemethodworksforﬁndingcube\nroots as ﬁxed points of the average-damped y7!x=y2. Un-\nfortunately, the process does not work for fourth roots—a\nsingle average damp is not enough to make a ﬁxed-point\nsearch for y7!x=y3converge. On the other hand, if we\naverage damp twice (i.e., use the average damp of the av-\nerage damp of y7!x=y3) the ﬁxed-point search does con-\nverge. Do some experiments to determine how many av-\nerage damps are required to compute nthroots as a ﬁxed-\npoint search based upon repeated average damping of y7! x=yn\u00001.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 234, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 837}}
{"id": "computer_science_sicp_abelson_chunk_0235_207416a4", "text": "Do some experiments to determine how many av-\nerage damps are required to compute nthroots as a ﬁxed-\npoint search based upon repeated average damping of y7! x=yn\u00001. Use this to implement a simple procedure for com-\nputing nthrootsusing fixed-point ,average-damp ,andthe\nrepeated procedureof Exercise1.43 .Assumethatanyarith-\nmetic operations you need are available as primitives. Exercise1.46: Several of the numerical methods described\nin this chapter are instances of an extremely general com-\nputational strategy known as iterative improvement . Itera-\ntiveimprovementsaysthat,tocomputesomething,westart\nwithaninitialguessfortheanswer,testiftheguessisgood\nenough,andotherwiseimprovetheguessandcontinuethe\nprocess using the improved guess as the new guess. Write\naprocedure iterative-improve thattakestwoprocedures\nas arguments: a method for telling whether a guess is good\nenough and a method for improving a guess.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 235, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 919}}
{"id": "computer_science_sicp_abelson_chunk_0236_381fdc2d", "text": "Write\naprocedure iterative-improve thattakestwoprocedures\nas arguments: a method for telling whether a guess is good\nenough and a method for improving a guess. iterative-\nimprove should return as its value a procedure that takes a\nguessasargumentandkeepsimprovingtheguessuntilitis\n105\ngood enough. Rewrite the sqrtprocedure of Section 1.1.7\nandthe fixed-point procedureof Section1.3.3 intermsof\niterative-improve . 106\n\nBuilding Abstractions with Data\nWenowcometothedecisivestepofmathematicalabstrac-\ntion: we forget about what the symbols stand for. : : :[e\nmathematician]neednotbeidle;therearemanyoperations\nwhich he may carry out with these symbols, without ever\nhaving to look at the things they stand for. —Hermann Weyl, e Mathematical Way of inking\nW   Chapter 1 on computational processes and\non the role of procedures in program design.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 236, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 863}}
{"id": "computer_science_sicp_abelson_chunk_0237_4934ce27", "text": "—Hermann Weyl, e Mathematical Way of inking\nW   Chapter 1 on computational processes and\non the role of procedures in program design. We saw how to\nuse primitive data (numbers) and primitive operations (arithmetic op-\nerations), how to combine procedures to form compound procedures\nthrough composition, conditionals, and the use of parameters, and how\nto abstract procedures by using define. We saw that a procedure can\nbe regarded as a paern for the local evolution of a process, and we\nclassiﬁed, reasoned about, and performed simple algorithmic analyses\nof some common paerns for processes as embodied in procedures. We\n107\nalso saw that higher-order procedures enhance the power of our lan-\nguage by enabling us to manipulate, and thereby to reason in terms of,\ngeneral methods of computation. is is much of the essence of pro-\ngramming. In this chapter we are going to look at more complex data.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 237, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_sicp_abelson_chunk_0238_006a34a9", "text": "is is much of the essence of pro-\ngramming. In this chapter we are going to look at more complex data. All the\nprocedures in chapter 1 operate on simple numerical data, and simple\ndata are not suﬃcient for many of the problems we wish to address\nusing computation. Programs are typically designed to model complex\nphenomena,andmoreoenthannotonemustconstructcomputational\nobjects that have several parts in order to model real-world phenom-\nena that have several aspects. us, whereas our focus in chapter 1 was\non building abstractions by combining procedures to form compound\nprocedures, we turn in this chapter to another key aspect of any pro-\ngramming language: the means it provides for building abstractions by\ncombining data objects to form compound data . Why do we want compound data in a programming language?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 238, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 821}}
{"id": "computer_science_sicp_abelson_chunk_0239_44cf1db3", "text": "Why do we want compound data in a programming language? For\nthe same reasons that we want compound procedures: to elevate the\nconceptual level at which we can design our programs, to increase the\nmodularity of our designs, and to enhance the expressive power of our\nlanguage.Justastheabilitytodeﬁneproceduresenablesustodealwith\nprocesses at a higher conceptual level than that of the primitive oper-\nations of the language, the ability to construct compound data objects\nenablesustodealwithdataatahigherconceptuallevelthanthatofthe\nprimitive data objects of the language. Consider the task of designing a system to perform arithmetic with\nrational numbers. We could imagine an operation add-rat that takes\ntwo rational numbers and produces their sum. In terms of simple data,\na rational number can be thought of as two integers: a numerator and\na denominator.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 239, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 859}}
{"id": "computer_science_sicp_abelson_chunk_0240_b517bbb7", "text": "In terms of simple data,\na rational number can be thought of as two integers: a numerator and\na denominator. us, we could design a program in which each ratio-\nnal number would be represented by two integers (a numerator and a\n108\ndenominator)andwhere add-rat wouldbeimplementedbytwoproce-\ndures (one producing the numerator of the sum and one producing the\ndenominator).Butthiswouldbeawkward,becausewewouldthenneed\ntoexplicitlykeeptrackofwhichnumeratorscorrespondedtowhichde-\nnominators.Inasystemintendedtoperformmanyoperationsonmany\nrationalnumbers,suchbookkeepingdetailswouldcluertheprograms\nsubstantially, to say nothing of what they would do to our minds. It\nwould be much beer if we could “glue together” a numerator and de-\nnominator to form a pair—a compound data object —that our programs\ncould manipulate in a way that would be consistent with regarding a\nrational number as a single conceptual unit. e use of compound data also enables us to increase the modular-\nity of our programs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 240, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_sicp_abelson_chunk_0241_7feabd54", "text": "e use of compound data also enables us to increase the modular-\nity of our programs. If we can manipulate rational numbers directly as\nobjectsintheirownright,thenwecanseparatethepartofourprogram\nthat deals with rational numbers per se from the details of how rational\nnumbersmayberepresentedaspairsofintegers.egeneraltechnique\nof isolating the parts of a program that deal with how data objects are\nrepresentedfromthepartsofaprogramthatdealwithhowdataobjects\nare used is a powerful design methodology called data abstraction . We\nwill see how data abstraction makes programs much easier to design,\nmaintain, and modify. e use of compound data leads to a real increase in the expressive\npower of our programming language. Consider the idea of forming a\n“linear combination” ax+by. We might like to write a procedure that\nwouldaccept a,b,x,andyasargumentsandreturnthevalueof ax+by.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 241, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 882}}
{"id": "computer_science_sicp_abelson_chunk_0242_5ac44aca", "text": "Consider the idea of forming a\n“linear combination” ax+by. We might like to write a procedure that\nwouldaccept a,b,x,andyasargumentsandreturnthevalueof ax+by. is presents no diﬃculty if the arguments are to be numbers, because\nwe can readily deﬁne the procedure\n(define (linear-combination abxy)\n(+ (* ax) (* by)))\n109\nBut suppose we are not concerned only with numbers. Suppose we\nwould like to express, in procedural terms, the idea that one can form\nlinearcombinationswheneveradditionandmultiplicationaredeﬁned—\nfor rational numbers, complex numbers, polynomials, or whatever. We\ncould express this as a procedure of the form\n(define (linear-combination abxy)\n(add (mul ax) (mul by)))\nwhere addandmulare not the primitive procedures +and*but rather\nmore complex things that will perform the appropriate operations for\nwhatever kinds of data we pass in as the arguments a,b,x, and y.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 242, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_sicp_abelson_chunk_0243_b0637414", "text": "e\nkey point is that the only thing linear-combination should need to\nknow about a,b,x, and yis that the procedures addandmulwill per-\nform the appropriate manipulations. From the perspective of the pro-\ncedure linear-combination , it is irrelevant what a,b,x, and yare and\nevenmoreirrelevanthowtheymighthappentoberepresentedinterms\nof more primitive data. is same example shows why it is important\nthat our programming language provide the ability to manipulate com-\npound objects directly: Without this, there is no way for a procedure\nsuch as linear-combination to pass its arguments along to addand\nmulwithout having to know their detailed structure.1\n1eabilitytodirectlymanipulateproceduresprovidesananalogousincreaseinthe\nexpressive power of a programming language. For example, in Section 1.3.1 we intro-\nduced the sumprocedure, which takes a procedure termas an argument and computes\nthe sum of the values of termover some speciﬁed interval.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 243, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_sicp_abelson_chunk_0244_a4d7c7e6", "text": "For example, in Section 1.3.1 we intro-\nduced the sumprocedure, which takes a procedure termas an argument and computes\nthe sum of the values of termover some speciﬁed interval. In order to deﬁne sum, it\nis crucial that we be able to speak of a procedure such as termas an entity in its own\nright,withoutregardforhow termmightbeexpressedwithmoreprimitiveoperations. Indeed, if we did not have the notion of “a procedure,” it is doubtful that we would ever\neven think of the possibility of deﬁning an operation such as sum. Moreover, insofar as\nperforming the summation is concerned, the details of how termmay be constructed\nfrom more primitive operations are irrelevant. 110\nWe begin this chapter by implementing the rational-number arith-\nmetic system mentioned above. is will form the background for our\ndiscussion of compound data and data abstraction.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 244, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 857}}
{"id": "computer_science_sicp_abelson_chunk_0245_60076ed3", "text": "110\nWe begin this chapter by implementing the rational-number arith-\nmetic system mentioned above. is will form the background for our\ndiscussion of compound data and data abstraction. As with compound\nprocedures, the main issue to be addressed is that of abstraction as a\ntechnique for coping with complexity, and we will see how data ab-\nstraction enables us to erect suitable abstraction barriers between diﬀer-\nent parts of a program. We will see that the key to forming compound data is that a pro-\ngramming language should provide some kind of “glue” so that data\nobjects can be combined to form more complex data objects. ere are\nmanypossiblekindsofglue.Indeed,wewilldiscoverhowtoformcom-\npound data using no special “data” operations at all, only procedures. is will further blur the distinction between “procedure” and “data,”\nwhich was already becoming tenuous toward the end of chapter 1. We\nwillalsoexploresomeconventionaltechniquesforrepresentingsequences\nand trees.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 245, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_sicp_abelson_chunk_0246_6eabb47d", "text": "We\nwillalsoexploresomeconventionaltechniquesforrepresentingsequences\nand trees. One key idea in dealing with compound data is the notion of\nclosure—that the glue we use for combining data objects should allow\nus to combine not only primitive data objects, but compound data ob-\njects as well. Another key idea is that compound data objects can serve\nasconventional interfaces for combining program modules in mix-and-\nmatch ways. We illustrate some of these ideas by presenting a simple\ngraphics language that exploits closure. We will then augment the representational power of our language\nby introducing symbolic expressions —data whose elementary parts can\nbe arbitrary symbols rather than only numbers. We explore various al-\nternatives for representing sets of objects.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 246, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 775}}
{"id": "computer_science_sicp_abelson_chunk_0247_679d56d4", "text": "We explore various al-\nternatives for representing sets of objects. We will ﬁnd that, just as a\ngivennumerical function can be computed by many diﬀerentcomputa-\ntional processes, there are many ways in which a given data structure\ncan be represented in terms of simpler objects, and the choice of rep-\nresentation can have signiﬁcant impact on the time and space require-\n111\nments of processes that manipulate the data. We will investigate these\nideas in the context of symbolic diﬀerentiation, the representation of\nsets, and the encoding of information. Next we will take up the problem of working with data that may be\nrepresenteddiﬀerentlybydiﬀerentpartsofaprogram.isleadstothe\nneedtoimplement generic operations ,whichmusthandlemanydiﬀerent\ntypes of data. Maintaining modularity in the presence of generic oper-\nations requires more powerful abstraction barriers than can be erected\nwith simple data abstraction alone.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 247, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 925}}
{"id": "computer_science_sicp_abelson_chunk_0248_fc54188b", "text": "Maintaining modularity in the presence of generic oper-\nations requires more powerful abstraction barriers than can be erected\nwith simple data abstraction alone. In particular, we introduce data-\ndirected programming as a technique that allows individual data repre-\nsentationstobedesignedinisolationandthencombined additively (i.e.,\nwithout modiﬁcation). To illustrate the power of this approach to sys-\ntem design, we close the chapter by applying what we have learned to\ntheimplementationofapackageforperformingsymbolicarithmeticon\npolynomials, in which the coeﬃcients of the polynomials can be inte-\ngers, rational numbers, complex numbers, and even other polynomials.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 248, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 673}}
{"id": "computer_science_sicp_abelson_chunk_0249_7a6f0606", "text": "2.1Introduction to Data Abstraction\nInSection 1.1.8 , we noted that a procedure used as an element in creat-\ningamorecomplexprocedurecouldberegardednotonlyasacollection\nofparticularoperationsbutalsoasaproceduralabstraction.atis,the\ndetails of how the procedure was implemented could be suppressed,\nand the particular procedure itself could be replaced by any other pro-\ncedure with the same overall behavior. In other words, we could make\nanabstractionthatwouldseparatethewaytheprocedurewouldbeused\nfrom the details of how the procedure would be implemented in terms\nofmoreprimitiveprocedures.eanalogousnotionforcompounddata\niscalled data abstraction .Dataabstractionisamethodologythatenables\n112\nustoisolatehowacompounddataobjectisusedfromthedetailsofhow\nit is constructed from more primitive data objects.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 249, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 809}}
{"id": "computer_science_sicp_abelson_chunk_0250_2ff8eda0", "text": "e basic idea of data abstraction is to structure the programs that\naretousecompounddataobjectssothattheyoperateon“abstractdata.”\nat is, our programs should use data in such a way as to make no as-\nsumptions about the data that are not strictly necessary for performing\nthe task at hand. At the same time, a “concrete” data representation is\ndeﬁnedindependentoftheprogramsthatusethedata.einterfacebe-\ntweenthesetwopartsofoursystemwillbeasetofprocedures,called se-\nlectorsandconstructors , that implement the abstract data in terms of the\nconcrete representation. To illustrate this technique, we will consider\nhow to design a set of procedures for manipulating rational numbers. 2.1.1Example: Arithmetic Operations\nfor Rational Numbers\nSuppose we want to do arithmetic with rational numbers. We want to\nbe able to add, subtract, multiply, and divide them and to test whether\ntwo rational numbers are equal.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 250, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 908}}
{"id": "computer_science_sicp_abelson_chunk_0251_1b6b76df", "text": "We want to\nbe able to add, subtract, multiply, and divide them and to test whether\ntwo rational numbers are equal. Let us begin by assuming that we already have a way of construct-\ning a rational number from a numerator and a denominator. We also\nassume that, given a rational number, we have a way of extracting (or\nselecting)itsnumeratoranditsdenominator.Letusfurtherassumethat\nthe constructor and selectors are available as procedures:\n•(make-rat⟨n⟩⟨d⟩)returns the rational number whose numera-\ntor is the integer⟨n⟩and whose denominator is the integer ⟨d⟩. •(numer⟨x⟩)returns the numerator of the rational number ⟨x⟩. •(denom⟨x⟩)returnsthedenominatoroftherationalnumber ⟨x⟩. 113\nWe are using here a powerful strategy of synthesis: wishful thinking . We haven’t yet said how a rational number is represented, or how the\nprocedures numer,denom, and make-rat should be implemented.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 251, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 882}}
{"id": "computer_science_sicp_abelson_chunk_0252_d9fb937d", "text": "We haven’t yet said how a rational number is represented, or how the\nprocedures numer,denom, and make-rat should be implemented. Even\nso, if we did have these three procedures, we could then add, subtract,\nmultiply, divide, and test equality by using the following relations:\nn1\nd1+n2\nd2=n1d2+n2d1\nd1d2;\nn1\nd1\u0000n2\nd2=n1d2\u0000n2d1\nd1d2;\nn1\nd1\u0001n2\nd2=n1n2\nd1d2;\nn1=d1\nn2=d2=n1d2\nd1n2;\nn1\nd1=n2\nd2if and only if n1d2=n2d1:\nWe can express these rules as procedures:\n(define (add-rat xy)\n(make-rat (+ (* ( numer x) (denom y))\n(* ( numer y) (denom x)))\n(* ( denom x) (denom y))))\n(define (sub-rat xy)\n(make-rat (- (* ( numer x) (denom y))\n(* ( numer y) (denom x)))\n(* ( denom x) (denom y))))\n(define (mul-rat xy)\n(make-rat (* ( numer x) (numer y))\n(* ( denom x) (denom y))))\n(define (div-rat xy)\n(make-rat (* ( numer x) (denom y))\n(* ( denom x) (numer y))))\n114\n(define (equal-rat?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 252, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 870}}
{"id": "computer_science_sicp_abelson_chunk_0253_896620f0", "text": "xy)\n(= (* ( numer x) (denom y))\n(* ( numer y) (denom x))))\nNow we have the operations on rational numbers deﬁned in terms\noftheselectorandconstructorprocedures numer,denom,and make-rat . But we haven’t yet deﬁned these. What we need is some way to glue\ntogether a numerator and a denominator to form a rational number. Pairs\nTo enable us to implement the concrete level of our data abstraction,\nour language provides a compound structure called a pair, which can\nbeconstructed with the primitiveprocedure cons. isproceduretakes\ntwo arguments and returns a compound data object that contains the\ntwoargumentsasparts.Givenapair,wecanextractthepartsusingthe\nprimitiveprocedures carandcdr.2us,wecanuse cons,car,and cdr\nas follows:\n(define x(cons 1 2))\n(car x)\n1\n(cdr x)\n2\nNotice that a pair is a data object that can be given a name and manip-\nulated, just like a primitive data object.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 253, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 884}}
{"id": "computer_science_sicp_abelson_chunk_0254_e3c88686", "text": "Moreover, conscan be used to\nform pairs whose elements are pairs, and so on:\n2ename consstandsfor“construct.”enames carandcdrderivefromtheorig-\ninal implementation of Lisp on the   . at machine had an addressing scheme\nthatallowedonetoreferencethe“address”and“decrement”partsofamemorylocation. carstands for “Contents of Address part of Register” and cdr(pronounced “could-er”)\nstands for “Contents of Decrement part of Register.”\n115\n(define x(cons 1 2))\n(define y(cons 3 4))\n(define z(cons xy))\n(car (car z))\n1\n(car (cdr z))\n3\nInSection 2.2 we will see how this ability to combine pairs means that\npairs can be used as general-purpose building blocks to create all sorts\nof complex data structures. e single compound-data primitive pair,\nimplemented by the procedures cons,car, and cdr, is the only glue we\nneed. Data objects constructed from pairs are called list-structured data. Representing rational numbers\nPairs oﬀer a natural way to complete the rational-number system.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 254, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_sicp_abelson_chunk_0255_b66abb4a", "text": "Data objects constructed from pairs are called list-structured data. Representing rational numbers\nPairs oﬀer a natural way to complete the rational-number system. Sim-\nply represent a rational number as a pair of two integers: a numerator\nand a denominator. en make-rat ,numer, and denomare readily im-\nplemented as follows:3\n3Another way to deﬁne the selectors and constructor is\n(define make-rat cons )\n(define numer car)\n(define denom cdr)\ne ﬁrst deﬁnition associates the name make-rat with the value of the expression\ncons, which is the primitive procedure that constructs pairs. us make-rat andcons\nare names for the same primitive constructor.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 255, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 653}}
{"id": "computer_science_sicp_abelson_chunk_0256_4adc7e2c", "text": "us make-rat andcons\nare names for the same primitive constructor. Deﬁning selectors and constructors in this way is eﬃcient: Instead of make-rat call-\ningcons,make-rat iscons, so there is only one procedure called, not two, when make-\nratiscalled.Ontheotherhand,doingthisdefeatsdebuggingaidsthattraceprocedure\ncalls or put breakpoints on procedure calls: You may want to watch make-rat being\ncalled, but you certainly don’t want to watch every call to cons. We have chosen not to use this style of deﬁnition in this book.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 256, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 522}}
{"id": "computer_science_sicp_abelson_chunk_0257_6aa2b4bb", "text": "We have chosen not to use this style of deﬁnition in this book. 116\n(define (make-rat nd) (cons nd))\n(define (numer x) (car x))\n(define (denom x) (cdr x))\nAlso, in order to display the results of our computations, we can print\nrational numbers by printing the numerator, a slash, and the denomi-\nnator:4\n(define (print-rat x)\n(newline )\n(display (numer x))\n(display \"/\")\n(display (denom x)))\nNow we can try our rational-number procedures:\n(define one-half (make-rat 1 2))\n(print-rat one-half )\n1/2\n(define one-third (make-rat 1 3))\n(print-rat (add-rat one-half one-third ))\n5/6\n(print-rat (mul-rat one-half one-third ))\n1/6\n(print-rat (add-rat one-third one-third ))\n6/9\nAs the ﬁnal example shows, our rational-number implementation does\nnot reduce rational numbers to lowest terms. We can remedy this by\nchanging make-rat . If we have a gcdprocedure like the one in Section\n1.2.5thatproducesthegreatestcommondivisoroftwointegers,wecan\n4display is the Scheme primitive for printing data.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 257, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_sicp_abelson_chunk_0258_d871cdb4", "text": "If we have a gcdprocedure like the one in Section\n1.2.5thatproducesthegreatestcommondivisoroftwointegers,wecan\n4display is the Scheme primitive for printing data. e Scheme primitive newline\nstarts a new line for printing. Neither of these procedures returns a useful value, so\nin the uses of print-rat below, we show only what print-rat prints, not what the\ninterpreter prints as the value returned by print-rat . 117\nusegcdto reduce the numerator and the denominator to lowest terms\nbefore constructing the pair:\n(define (make-rat nd)\n(let ((g(gcd nd)))\n(cons (/ng) (/ dg))))\nNow we have\n(print-rat (add-rat one-third one-third ))\n2/3\nas desired. is modiﬁcation was accomplished by changing the con-\nstructor make-rat without changing any of the procedures (such as\nadd-rat andmul-rat ) that implement the actual operations. Exercise2.1: Deﬁneabeerversionof make-rat thathan-\ndlesbothpositiveandnegativearguments.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 258, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_sicp_abelson_chunk_0259_18481d86", "text": "Exercise2.1: Deﬁneabeerversionof make-rat thathan-\ndlesbothpositiveandnegativearguments. make-rat should\nnormalizethesignsothatiftherationalnumberispositive,\nboth the numerator and denominator are positive, and if\ntherationalnumberisnegative,onlythenumeratorisneg-\native. 2.1.2Abstraction Barriers\nBefore continuing with more examples of compound data and data ab-\nstraction,letusconsidersomeoftheissuesraisedbytherational-number\nexample. We deﬁned the rational-number operations in terms of a con-\nstructor make-rat andselectors numeranddenom.Ingeneral,theunder-\nlying idea of data abstraction is to identify for each type of data object\na basic set of operations in terms of which all manipulations of data\nobjects of that type will be expressed, and then to use only those oper-\nations in manipulating the data. 118\nPrograms that use rational numbers\nRational numbers in problem domain\nadd-rat sub-rat ...", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 259, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_sicp_abelson_chunk_0260_3e65aaf8", "text": "118\nPrograms that use rational numbers\nRational numbers in problem domain\nadd-rat sub-rat ... Rational numbers as numerators and denominators\nmake-rat numer denom\nRational numbers as pairs\ncons car cdr\nHowever pairs are implementedFigure 2.1: Data-abstraction barriers in the rational-\nnumber package. We can envision the structure of the rational-number system as\nshown in Figure 2.1 . e horizontal lines represent abstraction barriers\nthat isolate diﬀerent “levels” of the system. At each level, the barrier\nseparates the programs (above) that use the data abstraction from the\nprograms (below) that implement the data abstraction. Programs that\nuse rational numbers manipulate them solely in terms of the proce-\ndures supplied “for public use” by the rational-number package: add-\nrat,sub-rat ,mul-rat ,div-rat , and equal-rat? . ese, in turn, are\nimplemented solely in terms of the constructor and selectors make-rat ,\nnumer, and denom, which themselvesare implemented in terms of pairs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 260, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_sicp_abelson_chunk_0261_e18e9230", "text": ". ese, in turn, are\nimplemented solely in terms of the constructor and selectors make-rat ,\nnumer, and denom, which themselvesare implemented in terms of pairs. e details of how pairs are implemented are irrelevant to the rest of\nthe rational-number package so long as pairs can be manipulated by\nthe use of cons,car, and cdr. In eﬀect, procedures at each level are the\n119\ninterfaces that deﬁne the abstraction barriers and connect the diﬀerent\nlevels. is simple idea has many advantages. One advantage is that it\nmakes programs much easier to maintain and to modify. Any complex\ndata structure can be represented in a variety of ways with the prim-\nitive data structures provided by a programming language. Of course,\nthe choice of representation inﬂuences the programs that operate on it;\nthus, if the representation were to be changed at some later time, all\nsuch programs might have to be modiﬁed accordingly.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 261, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_sicp_abelson_chunk_0262_b363c37c", "text": "is task could\nbe time-consuming and expensive in the case of large programs unless\nthe dependence on the representation were to be conﬁned by design to\na very few program modules. For example, an alternate way to address the problem of reducing\nrational numbers to lowest terms is to perform the reduction whenever\nweaccessthepartsofarationalnumber,ratherthanwhenweconstruct\nit. is leads to diﬀerent constructor and selector procedures:\n(define (make-rat nd) (cons nd))\n(define (numer x)\n(let ((g(gcd (car x) (cdr x))))\n(/ ( car x)g)))\n(define (denom x)\n(let ((g(gcd (car x) (cdr x))))\n(/ ( cdr x)g)))\ne diﬀerence between this implementation and the previous one lies\nin when we compute the gcd. If in our typical use of rational numbers\nwe access the numerators and denominators of the same rational num-\nbers many times, it would be preferable to compute the gcdwhen the\nrational numbers are constructed.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 262, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_sicp_abelson_chunk_0263_6f0c210c", "text": "If not, we may be beer oﬀ waiting\nuntilaccesstimetocomputethe gcd.Inanycase,whenwechangefrom\n120\none representation to the other, the procedures add-rat ,sub-rat , and\nso on do not have to be modiﬁed at all. Constraining the dependence on the representation to a few in-\nterface procedures helps us design programs as well as modify them,\nbecause it allows us to maintain the ﬂexibility to consider alternate\nimplementations. To continue with our simple example, suppose we\nare designing a rational-number package and we can’t decide initially\nwhether to perform the gcdat construction time or at selection time. e data-abstraction methodology gives us a way to defer that decision\nwithout losing the ability to make progress on the rest of the system. Exercise 2.2: Consider the problem of representing line\nsegments in a plane. Each segment is represented as a pair\nof points: a starting point and an ending point.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 263, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_sicp_abelson_chunk_0264_f9d0e6b2", "text": "Exercise 2.2: Consider the problem of representing line\nsegments in a plane. Each segment is represented as a pair\nof points: a starting point and an ending point. Deﬁne a\nconstructor make-segment andselectors start-segment and\nend-segment that deﬁne the representation of segments in\nterms of points. Furthermore, a point can be represented\nas a pair of numbers: the xcoordinate and the ycoordi-\nnate. Accordingly, specify a constructor make-point and\nselectors x-point andy-point that deﬁne this representa-\ntion.Finally,usingyourselectorsandconstructors,deﬁnea\nprocedure midpoint-segment that takes a line segment as\nargument and returns its midpoint (the point whose coor-\ndinatesaretheaverageofthecoordinatesoftheendpoints).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 264, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 729}}
{"id": "computer_science_sicp_abelson_chunk_0265_a347ed6d", "text": "To try your procedures, you’ll need a way to print points:\n(define (print-point p)\n(newline )\n(display \"(\")\n(display (x-point p))\n(display \",\")\n121\n(display (y-point p))\n(display \")\"))\nExercise 2.3: Implement a representation for rectangles in\naplane.(Hint:Youmaywanttomakeuseof Exercise2.2 .)In\ntermsofyourconstructorsandselectors,createprocedures\nthat compute the perimeter and the area of a given rectan-\ngle. Now implement a diﬀerent representation for rectan-\ngles. Can you design your system with suitable abstraction\nbarriers, so that the same perimeter and area procedures\nwill work using either representation? 2.1.3What Is Meant by Data? We began the rational-number implementation in Section 2.1.1 by im-\nplementing the rational-number operations add-rat ,sub-rat , and so\nonintermsofthreeunspeciﬁedprocedures: make-rat ,numer,and denom.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 265, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 848}}
{"id": "computer_science_sicp_abelson_chunk_0266_e6d2938c", "text": "We began the rational-number implementation in Section 2.1.1 by im-\nplementing the rational-number operations add-rat ,sub-rat , and so\nonintermsofthreeunspeciﬁedprocedures: make-rat ,numer,and denom. Atthatpoint,wecouldthinkoftheoperationsasbeingdeﬁnedinterms\nofdataobjects—numerators,denominators,andrationalnumbers—whose\nbehavior was speciﬁed by the laer three procedures. Butexactlywhatismeantby data?Itisnotenoughtosay“whatever\nis implemented by the given selectors and constructors.” Clearly, not\neveryarbitrarysetofthreeprocedurescanserveasanappropriatebasis\nfor the rational-number implementation. We need to guarantee that, if\nwe construct a rational number xfrom a pair of integers nandd, then\nextracting the numerand the denomofxand dividing them should yield\nthe same result as dividing nbyd.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 266, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 805}}
{"id": "computer_science_sicp_abelson_chunk_0267_b93de85c", "text": "We need to guarantee that, if\nwe construct a rational number xfrom a pair of integers nandd, then\nextracting the numerand the denomofxand dividing them should yield\nthe same result as dividing nbyd. In other words, make-rat ,numer,\nand denommust satisfy the condition that, for any integer nand any\n122\nnon-zero integer d, ifxis(make-rat n d) , then\n(numer x)\n(denom x)=n\nd:\nInfact,thisistheonlycondition make-rat ,numer,and denommustfulﬁll\nin order to form a suitable basis for a rational-number representation. In general, we can think of data as deﬁned by some collection of se-\nlectors and constructors, together with speciﬁed conditions that these\nprocedures must fulﬁll in order to be a valid representation.5\nis point of view can serve to deﬁne not only “high-level” data ob-\njects,suchasrationalnumbers,butlower-levelobjectsaswell.Consider\nthe notion of a pair, which we used in order to deﬁne our rational num-\nbers.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 267, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_sicp_abelson_chunk_0268_e9a26d3b", "text": "We never actually said what a pair was, only that the language\nsupplied procedures cons,car, and cdrfor operating on pairs. But the\nonly thing we need to know about these three operations is that if we\nglue two objects together using conswe can retrieve the objects using\ncarandcdr. at is, the operations satisfy the condition that, for any\nobjects xandy, ifzis(cons x y) then (car z) isxand(cdr z) isy. 5Surprisingly, this idea is very diﬃcult to formulate rigorously. ere are two ap-\nproaches to giving such a formulation. One, pioneered by C. A. R. Hoare (1972) , is\nknown as the method of abstract models . It formalizes the “procedures plus conditions”\nspeciﬁcation as outlined in the rational-number example above. Note that the condi-\ntion on the rational-number representation was stated in terms of facts about integers\n(equality and division). In general, abstract models deﬁne new kinds of data objects\nin terms of previously deﬁned types of data objects.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 268, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_sicp_abelson_chunk_0269_972966cd", "text": "In general, abstract models deﬁne new kinds of data objects\nin terms of previously deﬁned types of data objects. Assertions about data objects can\ntherefore be checked by reducing them to assertions about previously deﬁned data ob-\njects.Anotherapproach,introducedbyZillesat ,byGoguen,atcher,Wagner,and\nWright at (seeatcher et al. 1978 ), and by Guag at Toronto (see Guag 1977 ), is\ncalled algebraic speciﬁcation .Itregardsthe“procedures”aselementsofanabstractalge-\nbraicsystemwhosebehaviorisspeciﬁedbyaxiomsthatcorrespondtoour“conditions,”\nandusesthetechniquesofabstractalgebratocheckassertionsaboutdataobjects.Both\nmethods are surveyed in the paper by Liskov and Zilles (1975) . 123\nIndeed,wementionedthatthesethreeproceduresareincludedasprim-\nitives in our language. However, any triple of procedures that satisﬁes\nthe above condition can be used as the basis for implementing pairs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 269, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 896}}
{"id": "computer_science_sicp_abelson_chunk_0270_df439210", "text": "However, any triple of procedures that satisﬁes\nthe above condition can be used as the basis for implementing pairs. is point is illustrated strikingly by the fact that we could implement\ncons,car, and cdrwithout using any data structures at all but only\nusing procedures. Here are the deﬁnitions:\n(define (cons xy)\n(define (dispatch m)\n(cond ((= m0)x)\n((= m1)y)\n(else (error \"Argument not 0or1:CONS \"m))))\ndispatch )\n(define (car z) (z0))\n(define (cdr z) (z1))\nis use of procedures corresponds to nothing like our intuitive notion\nof what data should be. Nevertheless, all we need to do to show that\nthis is a valid way to represent pairs is to verify that these procedures\nsatisfy the condition given above. esubtlepointtonoticeisthatthevaluereturnedby (cons x y) is\naprocedure—namelytheinternallydeﬁnedprocedure dispatch ,which\ntakesoneargumentandreturnseither xorydependingonwhetherthe\nargument is 0 or 1. Correspondingly, (car z) is deﬁned to apply zto 0.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 270, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_sicp_abelson_chunk_0271_afd1cf69", "text": "Correspondingly, (car z) is deﬁned to apply zto 0. Hence, if zis the procedure formed by (cons x y) , then zapplied to 0\nwill yield x. us, we have shown that (car (cons x y)) yields x, as\ndesired.Similarly, (cdr (cons x y)) appliestheprocedurereturnedby\n(cons x y) to1,whichreturns y.erefore,thisproceduralimplemen-\ntation of pairs is a valid implementation, and if we access pairs using\nonly cons,car,and cdrwecannotdistinguishthisimplementationfrom\none that uses “real” data structures. e point of exhibiting the procedural representation of pairs is not\n124\nthatourlanguageworksthisway(Scheme,andLispsystemsingeneral,\nimplement pairs directly, for eﬃciency reasons) but that it could work\nthisway.eproceduralrepresentation,althoughobscure,isaperfectly\nadequatewaytorepresentpairs,sinceitfulﬁllstheonlyconditionsthat\npairs need to fulﬁll. is example also demonstrates that the ability to\nmanipulate procedures as objects automatically provides the ability to\nrepresentcompound data.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 271, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_sicp_abelson_chunk_0272_fe55605a", "text": "is example also demonstrates that the ability to\nmanipulate procedures as objects automatically provides the ability to\nrepresentcompound data. ismay seem acuriosity now,butprocedu-\nral representations of data will play a central role in our programming\nrepertoire. is style of programming is oen called message passing ,\nand we will be using it as a basic tool in Chapter 3 when we address the\nissues of modeling and simulation. Exercise2.4: Here is an alternative procedural representa-\ntionofpairs.Forthisrepresentation,verifythat (car (cons\nx y))yields xfor any objects xandy.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 272, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 584}}
{"id": "computer_science_sicp_abelson_chunk_0273_49927561", "text": "Exercise2.4: Here is an alternative procedural representa-\ntionofpairs.Forthisrepresentation,verifythat (car (cons\nx y))yields xfor any objects xandy. (define (cons xy)\n(lambda (m) (mxy)))\n(define (car z)\n(z(lambda (pq)p)))\nWhatisthecorrespondingdeﬁnitionof cdr?(Hint:Tover-\nify that this works, make use of the substitution model of\nSection 1.1.5 .)\nExercise2.5: Show that we can represent pairs of nonneg-\native integers using only numbers and arithmetic opera-\ntions if we represent the pair aandbas the integer that is\ntheproduct2a3b.Givethecorrespondingdeﬁnitionsofthe\nprocedures cons,car, and cdr.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 273, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 603}}
{"id": "computer_science_sicp_abelson_chunk_0274_caebc600", "text": "125\nExercise2.6: Incaserepresentingpairsasprocedureswasn’t\nmind-boggling enough, consider that, in a language that\ncanmanipulateprocedures,wecangetbywithoutnumbers\n(at least insofar as nonnegative integers are concerned) by\nimplementing 0 and the operation of adding 1 as\n(define zero (lambda (f) (lambda (x)x)))\n(define (add-1 n)\n(lambda (f) (lambda (x) (f((nf)x)))))\nis representation is known as Church numerals , aer its\ninventor, Alonzo Church, the logician who invented the λ-\ncalculus. Deﬁne oneandtwodirectly (not in terms of zeroandadd-\n1). (Hint: Use substitution to evaluate (add-1 zero) ). Give\na direct deﬁnition of the addition procedure +(not in terms\nof repeated application of add-1). 2.1.4Extended Exercise: Interval Arithmetic\nAlyssa P. Hacker is designing a system to help people solve engineer-\ning problems.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 274, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 831}}
{"id": "computer_science_sicp_abelson_chunk_0275_47abb801", "text": "2.1.4Extended Exercise: Interval Arithmetic\nAlyssa P. Hacker is designing a system to help people solve engineer-\ning problems. One feature she wants to provide in her system is the\nability to manipulate inexact quantities (such as measured parameters\nof physical devices) with known precision, so that when computations\nare done with such approximate quantities the results will be numbers\nof known precision. Electrical engineers will be using Alyssa’s system to compute elec-\ntrical quantities.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 275, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 497}}
{"id": "computer_science_sicp_abelson_chunk_0276_8392da9a", "text": "Electrical engineers will be using Alyssa’s system to compute elec-\ntrical quantities. It is sometimes necessary for them to compute the\nvalueofaparallelequivalentresistance Rpoftworesistors R1,R2using\nthe formula\nRp=1\n1=R1+ 1=R2:\n126\nResistancevaluesareusuallyknownonlyuptosometoleranceguaran-\nteedbythemanufactureroftheresistor.Forexample,ifyoubuyaresis-\ntor labeled “6.8 ohms with 10% tolerance” you can only be sure that the\nresistor has a resistance between 6 :8\u00000:68=6:12 and 6 :8+0 :68=7:48\nohms.us,ifyouhavea6.8-ohm10%resistorinparallelwitha4.7-ohm\n5%resistor,theresistanceofthecombinationcanrangefromabout2.58\nohms (if the two resistors are at the lower bounds) to about 2.97 ohms\n(if the two resistors are at the upper bounds). Alyssa’s idea is to implement “interval arithmetic” as a set of arith-\nmetic operations for combining “intervals” (objects that represent the\nrange of possible values of an inexact quantity).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 276, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_sicp_abelson_chunk_0277_0b7780d3", "text": "Alyssa’s idea is to implement “interval arithmetic” as a set of arith-\nmetic operations for combining “intervals” (objects that represent the\nrange of possible values of an inexact quantity). e result of adding,\nsubtracting, multiplying, or dividing two intervals is itself an interval,\nrepresenting the range of the result. Alyssa postulates the existence of an abstract object called an “in-\nterval” that has two endpoints: a lower bound and an upper bound. She\nalso presumes that, given the endpoints of an interval, she can con-\nstruct the interval using the data constructor make-interval . Alyssa\nﬁrst writes a procedure for adding two intervals.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 277, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 653}}
{"id": "computer_science_sicp_abelson_chunk_0278_8708de9e", "text": "She\nalso presumes that, given the endpoints of an interval, she can con-\nstruct the interval using the data constructor make-interval . Alyssa\nﬁrst writes a procedure for adding two intervals. She reasons that the\nminimum value the sum could be is the sum of the two lower bounds\nandthemaximumvalueitcouldbeisthesumofthetwoupperbounds:\n(define (add-interval xy)\n(make-interval (+ ( lower-bound x) (lower-bound y))\n(+ ( upper-bound x) (upper-bound y))))\nAlyssa also works out the product of two intervals by ﬁnding the min-\nimum and the maximum of the products of the bounds and using them\nas the bounds of the resulting interval.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 278, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 629}}
{"id": "computer_science_sicp_abelson_chunk_0279_ed4978bb", "text": "( minandmaxare primitives that\nﬁnd the minimum or maximum of any number of arguments.)\n(define (mul-interval xy)\n(let ((p1(* ( lower-bound x) (lower-bound y)))\n127\n(p2(* ( lower-bound x) (upper-bound y)))\n(p3(* ( upper-bound x) (lower-bound y)))\n(p4(* ( upper-bound x) (upper-bound y))))\n(make-interval (min p1p2p3p4)\n(max p1p2p3p4))))\nTo divide two intervals, Alyssa multiplies the ﬁrst by the reciprocal of\nthe second. Note that the bounds of the reciprocal interval are the re-\nciprocal of the upper bound and the reciprocal of the lower bound, in\nthat order. (define (div-interval xy)\n(mul-interval\nx\n(make-interval (/ 1.0 ( upper-bound y))\n(/ 1.0 ( lower-bound y)))))\nExercise 2.7: Alyssa’s program is incomplete because she\nhas not speciﬁed the implementation of the interval ab-\nstraction. Here is a deﬁnition of the interval constructor:\n(define (make-interval ab) (cons ab))\nDeﬁneselectors upper-bound andlower-bound tocomplete\nthe implementation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 279, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_sicp_abelson_chunk_0280_9760a38c", "text": "Here is a deﬁnition of the interval constructor:\n(define (make-interval ab) (cons ab))\nDeﬁneselectors upper-bound andlower-bound tocomplete\nthe implementation. Exercise 2.8: Using reasoning analogous to Alyssa’s, de-\nscribe how the diﬀerence of two intervals may be com-\nputed.Deﬁneacorrespondingsubtractionprocedure,called\nsub-interval . Exercise 2.9: ewidthof an interval is half of the diﬀer-\nence between its upper and lower bounds. e width is a\n128\nmeasure of the uncertainty of the number speciﬁed by the\ninterval. For some arithmetic operations the width of the\nresult of combining two intervals is a function only of the\nwidths of the argument intervals, whereas for others the\nwidth of the combination is not a function of the widths of\nthe argument intervals. Show that the width of the sum (or\ndiﬀerence) of two intervals is a function only of the widths\nof the intervals being added (or subtracted). Give examples\nto show that this is not true for multiplication or division.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 280, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_sicp_abelson_chunk_0281_e46522c1", "text": "Give examples\nto show that this is not true for multiplication or division. Exercise 2.10: Ben Bitdiddle, an expert systems program-\nmer, looks over Alyssa’s shoulder and comments that it is\nnot clear what it means to divide by an interval that spans\nzero. Modify Alyssa’s code to check for this condition and\nto signal an error if it occurs. Exercise 2.11: In passing, Ben also cryptically comments:\n“By testing the signs of the endpoints of the intervals, it is\npossible to break mul-interval into nine cases, only one\nof which requires more than two multiplications.” Rewrite\nthis procedure using Ben’s suggestion. Aer debugging her program, Alyssa shows it to a poten-\ntialuser,whocomplainsthatherprogramsolvesthewrong\nproblem.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 281, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 732}}
{"id": "computer_science_sicp_abelson_chunk_0282_ad7b61e5", "text": "Aer debugging her program, Alyssa shows it to a poten-\ntialuser,whocomplainsthatherprogramsolvesthewrong\nproblem. He wants a program that can deal with numbers\nrepresented as a center value and an additive tolerance; for\nexample,hewantstoworkwithintervalssuchas3 :5\u00060:15\nratherthan[3.35,3.65].Alyssareturnstoherdeskandﬁxes\nthis problem by supplying an alternate constructor and al-\nternate selectors:\n129\n(define (make-center-width cw)\n(make-interval (-cw) (+ cw)))\n(define (center i)\n(/ (+ ( lower-bound i) (upper-bound i)) 2))\n(define (width i)\n(/ (- ( upper-bound i) (lower-bound i)) 2))\nUnfortunately, most of Alyssa’s users are engineers. Real\nengineering situations usually involve measurements with\nonlyasmalluncertainty,measuredastheratioofthewidth\nof the interval to the midpoint of the interval. Engineers\nusually specify percentage tolerances on the parameters of\ndevices, as in the resistor speciﬁcations given earlier.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 282, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 932}}
{"id": "computer_science_sicp_abelson_chunk_0283_b2cfc474", "text": "Engineers\nusually specify percentage tolerances on the parameters of\ndevices, as in the resistor speciﬁcations given earlier. Exercise2.12: Deﬁneaconstructor make-center-percent\nthat takes a center and a percentage tolerance and pro-\nduces the desired interval. You must also deﬁne a selector\npercent thatproducesthepercentagetoleranceforagiven\ninterval. e centerselector is the same as the one shown\nabove. Exercise 2.13: Show that under the assumption of small\npercentage tolerances there is a simple formula for the ap-\nproximate percentage tolerance of the product of two in-\ntervals in terms of the tolerances of the factors. You may\nsimplifytheproblembyassumingthatallnumbersarepos-\nitive. Aer considerable work, Alyssa P. Hacker delivers her ﬁn-\nished system. Several years later, aer she has forgoen all\nabout it, she gets a frenzied call from an irate user, Lem E.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 283, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_sicp_abelson_chunk_0284_5eb760ab", "text": "Aer considerable work, Alyssa P. Hacker delivers her ﬁn-\nished system. Several years later, aer she has forgoen all\nabout it, she gets a frenzied call from an irate user, Lem E. Tweakit.ItseemsthatLemhasnoticedthattheformulafor\n130\nparallel resistors can be wrien in two algebraically equiv-\nalent ways:\nR1R2\nR1+R2\nand1\n1=R1+ 1=R2:\nHe has wrien the following two programs, each of which\ncomputes the parallel-resistors formula diﬀerently:\n(define (par1 r1r2)\n(div-interval (mul-interval r1r2)\n(add-interval r1r2)))\n(define (par2 r1r2)\n(let ((one (make-interval 1 1)))\n(div-interval\none (add-interval (div-interval one r1)\n(div-interval one r2)))))\nLem complains that Alyssa’s program gives diﬀerent an-\nswersforthetwowaysofcomputing.isisaseriouscom-\nplaint. Exercise 2.14: Demonstrate that Lem is right. Investigate\nthe behavior of the system on a variety of arithmetic ex-\npressions. Make some intervals AandB, and use them in\ncomputing the expressions A=AandA=B.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 284, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_sicp_abelson_chunk_0285_200c41c8", "text": "Investigate\nthe behavior of the system on a variety of arithmetic ex-\npressions. Make some intervals AandB, and use them in\ncomputing the expressions A=AandA=B. You will get the\nmost insight by using intervals whose width is a small per-\ncentageofthecentervalue.Examinetheresultsofthecom-\nputation in center-percent form (see Exercise 2.12 ). 131\nExercise 2.15: Eva Lu Ator, another user, has also noticed\nthediﬀerentintervalscomputedbydiﬀerentbutalgebraically\nequivalentexpressions.Shesaysthataformulatocompute\nwith intervals using Alyssa’s system will produce tighter\nerrorboundsifitcanbewrieninsuchaformthatnovari-\nablethatrepresentsanuncertainnumberisrepeated.us,\nshe says, par2is a “beer” program for parallel resistances\nthan par1. Is she right? Why? Exercise 2.16: Explain, in general, why equivalent alge-\nbraic expressions may lead to diﬀerent answers.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 285, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 864}}
{"id": "computer_science_sicp_abelson_chunk_0286_8ccc4873", "text": "Is she right? Why? Exercise 2.16: Explain, in general, why equivalent alge-\nbraic expressions may lead to diﬀerent answers. Can you\ndevise an interval-arithmetic package that does not have\nthisshortcoming,oristhistaskimpossible?(Warning:is\nproblem is very diﬃcult.)\n2.2Hierarchical Data and the Closure Property\nAs we have seen, pairs provide a primitive “glue” that we can use to\nconstruct compound data objects. Figure 2.2 shows a standard way to\nvisualize a pair—in this case, the pair formed by (cons 1 2) . In this\nrepresentation, which is called box-and-pointer notation , each object is\nshown as a pointerto a box. e box for a primitive object contains a\nrepresentationoftheobject.Forexample,theboxforanumbercontains\na numeral. e box for a pair is actually a double box, the le part con-\ntaining (a pointer to) the carof the pair and the right part containing\nthecdr. We have already seen that conscan be used to combine not only\nnumbers but pairs as well.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 286, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_sicp_abelson_chunk_0287_3cd31597", "text": "We have already seen that conscan be used to combine not only\nnumbers but pairs as well. (You made use of this fact, or should have,\nin doing Exercise 2.2 andExercise 2.3 .) As a consequence, pairs pro-\nvidea universalbuilding blockfromwhichwecan constructall sortsof\n132\n2\n1Figure2.2: Box-and-pointerrepresentationof (cons 1 2) . 14\n2 33 4\n1 2\n(cons (cons 1 2) (cons (cons 1\n (cons 3 4)) (cons 2 3))\n 4)\nFigure2.3: Two ways to combine 1, 2, 3, and 4 using pairs. data structures. Figure 2.3 shows two ways to use pairs to combine the\nnumbers 1, 2, 3, and 4. e ability to create pairs whose elements are pairs is the essence\nof list structure’s importance as a representational tool. We refer to this\nability as the closure property ofcons.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 287, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 741}}
{"id": "computer_science_sicp_abelson_chunk_0288_b52184a5", "text": "e ability to create pairs whose elements are pairs is the essence\nof list structure’s importance as a representational tool. We refer to this\nability as the closure property ofcons. In general, an operation for com-\nbining data objects satisﬁes the closure property if the results of com-\nbiningthingswiththatoperationcanthemselvesbecombinedusingthe\nsame operation.6Closure is the key to power in any means of combina-\n6e use of the word “closure” here comes from abstract algebra, where a set of\n133\ntion because it permits us to create hierarchical structures—structures\nmade up of parts, which themselves are made up of parts, and so on. From the outset of Chapter 1 , we’ve made essential use of closure\nin dealing with procedures, because all but the very simplest programs\nrely on the fact that the elements of a combination can themselves be\ncombinations. In this section, we take up the consequences of closure\nfor compound data.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 288, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_sicp_abelson_chunk_0289_f7aa43c7", "text": "In this section, we take up the consequences of closure\nfor compound data. We describe some conventional techniques for us-\ning pairs to represent sequences and trees, and we exhibit a graphics\nlanguage that illustrates closure in a vivid way.7\n2.2.1Representing Sequences\nOne of the useful structures we can build with pairs is a sequence —an\nordered collection of data objects. ere are, of course, many ways to\nelements is said to be closed under an operation if applying the operation to elements\nin the set produces an element that is again an element of the set. e Lisp community\nalso (unfortunately) uses the word “closure” to describe a totally unrelated concept: A\nclosureisanimplementationtechniqueforrepresentingprocedureswithfreevariables. We do not use the word “closure” in this second sense in this book. 7e notion that a means of combination should satisfy closure is a straightfor-\nward idea.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 289, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_sicp_abelson_chunk_0290_0ce65ca7", "text": "We do not use the word “closure” in this second sense in this book. 7e notion that a means of combination should satisfy closure is a straightfor-\nward idea. Unfortunately, the data combiners provided in many popular programming\nlanguages do not satisfy closure, or make closure cumbersome to exploit. In Fortran\nor Basic, one typically combines data elements by assembling them into arrays—but\none cannot form arrays whose elements are themselves arrays. Pascal and C admit\nstructures whose elements are structures. However, this requires that the program-\nmer manipulate pointers explicitly, and adhere to the restriction that each ﬁeld of a\nstructure can contain only elements of a prespeciﬁed form. Unlike Lisp with its pairs,\ntheselanguageshavenobuilt-ingeneral-purposegluethatmakesiteasytomanipulate\ncompound data in a uniform way.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 290, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 838}}
{"id": "computer_science_sicp_abelson_chunk_0291_22f22ed2", "text": "Unlike Lisp with its pairs,\ntheselanguageshavenobuilt-ingeneral-purposegluethatmakesiteasytomanipulate\ncompound data in a uniform way. is limitation lies behind Alan Perlis’s comment in\nhis foreword to this book: “In Pascal the plethora of declarable data structures induces\na specialization within functions that inhibits and penalizes casual cooperation. It is\nbeer to have 100 functions operate on one data structure than to have 10 functions\noperate on 10 data structures.”\n134\n1 4 2 3Figure 2.4: e sequence 1, 2, 3, 4 represented as a chain\nof pairs. represent sequences in terms of pairs. One particularly straightforward\nrepresentationisillustratedin Figure2.4 ,wherethesequence1,2,3,4is\nrepresentedasachainofpairs.e carofeachpairisthecorresponding\nitem in the chain, and the cdrof the pair is the next pair in the chain.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 291, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 832}}
{"id": "computer_science_sicp_abelson_chunk_0292_7e433656", "text": "ecdrof the ﬁnal pair signals the end of the sequence by pointing to\na distinguished value that is not a pair, represented in box-and-pointer\ndiagrams as a diagonal line and in programs as the value of the variable\nnil. e entire sequence is constructed by nested consoperations:\n(cons 1\n(cons 2\n(cons 3\n(cons 4nil))))\nSuch a sequence of pairs, formed by nested conses, is called a list,\nand Scheme provides a primitive called listto help in constructing\nlists.8e above sequence could be produced by (list 1 2 3 4) . In\ngeneral,\n(list⟨a1⟩⟨a2⟩: : :⟨an⟩)\n8In this book, we use listto mean a chain of pairs terminated by the end-of-list\nmarker.Incontrast,theterm list structure referstoanydatastructuremadeoutofpairs,\nnot just to lists. 135\nis equivalent to\n(cons⟨a1⟩\n(cons⟨a2⟩\n(cons : : :\n(cons⟨an⟩\nnil): : :)))\nLisp systems conventionally print lists by printing the sequence of el-\nements, enclosed in parentheses.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 292, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 915}}
{"id": "computer_science_sicp_abelson_chunk_0293_f65f4a26", "text": "135\nis equivalent to\n(cons⟨a1⟩\n(cons⟨a2⟩\n(cons : : :\n(cons⟨an⟩\nnil): : :)))\nLisp systems conventionally print lists by printing the sequence of el-\nements, enclosed in parentheses. us, the data object in Figure 2.4 is\nprinted as (1 2 3 4) :\n(define one-through-four (list 1 2 3 4))\none-through-four\n(1 2 3 4)\nBe careful not to confuse the expression (list 1 2 3 4) with the list\n(1 2 3 4) , which is the result obtained when the expression is evalu-\nated. Aempting to evaluate the expression (1 2 3 4) will signal an\nerror when the interpreter tries to apply the procedure 1to arguments\n2,3, and 4. We can think of caras selecting the ﬁrst item in the list, and of\ncdras selecting the sublist consisting of all but the ﬁrst item. Nested\napplications of carand cdrcan be used to extract the second, third,\nand subsequent items in the list.9e constructor consmakes a list like\nthe original one, but with an additional item at the beginning.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 293, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 941}}
{"id": "computer_science_sicp_abelson_chunk_0294_56c6b589", "text": "9Since nested applications of carandcdrare cumbersome to write, Lisp dialects\nprovide abbreviations for them—for instance,\n(cadr⟨arg⟩) = ( car (cdr⟨arg⟩))\ne names of all such procedures start with cand end with r. Each abetween them\nstands for a caroperation and each dfor a cdroperation, to be applied in the same\norderinwhichtheyappearinthename.enames carandcdrpersistbecausesimple\ncombinations like cadrare pronounceable. 136\n(car one-through-four )\n1\n(cdr one-through-four )\n(2 3 4)\n(car (cdr one-through-four ))\n2\n(cons 10one-through-four )\n(10 1 2 3 4)\n(cons 5one-through-four )\n(5 1 2 3 4)\nevalueof nil,usedtoterminatethechainofpairs,canbethoughtof\nasasequenceofnoelements,the empty list .eword nilisacontraction\nof the Latin word nihil, which means “nothing.”10\nList operations\ne use of pairs to represent sequences of elements as lists is accompa-\nniedbyconventionalprogrammingtechniquesformanipulatinglistsby\nsuccessively “ cdring down” the lists.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 294, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_sicp_abelson_chunk_0295_a8ca3c55", "text": "For example, the procedure list-\nreftakes as arguments a list and a number nand returns the nthitem\nof the list. It is customary to number the elements of the list beginning\nwith 0. e method for computing list-ref is the following:\n10It’s remarkable how much energy in the standardization of Lisp dialects has been\ndissipated in arguments that are literally over nothing: Should nilbe an ordinary\nname? Should the value of nilbe a symbol? Should it be a list? Should it be a pair? In Scheme, nilis an ordinary name, which we use in this section as a variable whose\nvalueistheend-of-listmarker(justas trueisanordinaryvariablethathasatruevalue). Other dialects of Lisp, including Common Lisp, treat nilas a special symbol. e au-\nthorsofthisbook,whohaveenduredtoomanylanguagestandardizationbrawls,would\nliketoavoidtheentireissue.Oncewehaveintroducedquotationin Section2.3 ,wewill\ndenote the empty list as '()and dispense with the variable nilentirely. 137\n•Forn=0,list-ref should return the carof the list.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 295, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_sicp_abelson_chunk_0296_af8f83bd", "text": "137\n•Forn=0,list-ref should return the carof the list. •Otherwise, list-ref should return the (n\u00001)-st item of the cdr\nof the list. (define (list-ref items n)\n(if(=n0)\n(car items )\n(list-ref (cdr items ) (- n1))))\n(define squares (list 1 4 9 16 25))\n(list-ref squares 3)\n16\nOen we cdrdown the whole list. To aid in this, Scheme includes a\nprimitivepredicate null?,whichtestswhetheritsargumentistheempty\nlist. e procedure length, which returns the number of items in a list,\nillustrates this typical paern of use:\n(define (length items )\n(if(null? items )\n0\n(+ 1 ( length (cdr items )))))\n(define odds (list 1 3 5 7))\n(length odds )\n4\nelengthprocedure implements a simple recursive plan. e reduc-\ntion step is:\n•elengthof any list is 1 plus the lengthof the cdrof the list. is is applied successively until we reach the base case:\n•elengthof the empty list is 0. 138\nWe could also compute lengthin an iterative style:\n(define (length items )\n(define (length-iter acount )\n(if(null?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 296, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_sicp_abelson_chunk_0297_1c77f26d", "text": "138\nWe could also compute lengthin an iterative style:\n(define (length items )\n(define (length-iter acount )\n(if(null? a)\ncount\n(length-iter (cdr a) (+ 1 count ))))\n(length-iter items 0))\nAnother conventional programming technique is to “ consup” an an-\nswer list while cdring down a list, as in the procedure append, which\ntakestwolistsasargumentsandcombinestheirelementstomakeanew\nlist:\n(append squares odds )\n(1 4 9 16 25 1 3 5 7)\n(append odds squares )\n(1 3 5 7 1 4 9 16 25)\nappendisalsoimplementedusingarecursiveplan.To appendlistslist1\nandlist2, do the following:\n•Iflist1is the empty list, then the result is just list2. •Otherwise, appendthecdroflist1andlist2, and consthecar\noflist1onto the result:\n(define (append list1 list2 )\n(if(null?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 297, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 747}}
{"id": "computer_science_sicp_abelson_chunk_0298_6963cd2f", "text": "•Otherwise, appendthecdroflist1andlist2, and consthecar\noflist1onto the result:\n(define (append list1 list2 )\n(if(null? list1 )\nlist2\n(cons (car list1 ) (append (cdr list1 )list2 ))))\nExercise 2.17: Deﬁne a procedure last-pair that returns\nthelistthatcontainsonlythelastelementofagiven(nonempty)\nlist:\n139\n(last-pair (list 23 72 149 34))\n(34)\nExercise2.18: Deﬁne a procedure reverse that takes a list\nas argument and returns a list of the same elements in re-\nverse order:\n(reverse (list 1 4 9 16 25))\n(25 16 9 4 1)\nExercise 2.19: Consider the change-counting program of\nSection1.2.2 .Itwouldbenicetobeabletoeasilychangethe\ncurrency used by the program, so that we could compute\nthenumberofwaystochangeaBritishpound,forexample. Astheprogramiswrien,theknowledgeofthecurrencyis\ndistributed partly into the procedure first-denomination\nandpartlyintotheprocedure count-change (whichknows\nthat there are ﬁve kinds of U.S. coins).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 298, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 925}}
{"id": "computer_science_sicp_abelson_chunk_0299_04f45a42", "text": "Astheprogramiswrien,theknowledgeofthecurrencyis\ndistributed partly into the procedure first-denomination\nandpartlyintotheprocedure count-change (whichknows\nthat there are ﬁve kinds of U.S. coins). It would be nicer\nto be able to supply a list of coins to be used for making\nchange. We want to rewrite the procedure ccso that its second ar-\ngument is a list of the values of the coins to use rather than\nan integer specifying which coins to use. We could then\nhave lists that deﬁned each kind of currency:\n(define us-coins (list 50 25 10 5 1))\n(define uk-coins (list 100 50 20 10 5 2 1 0.5))\nWe could then call ccas follows:\n(cc100 us-coins )\n292\n140\nTodothiswillrequirechangingtheprogram ccsomewhat. It will still have the same form, but it will access its second\nargument diﬀerently, as follows:\n(define (ccamount coin-values )\n(cond ((= amount 0) 1)\n((or(<amount 0) ( no-more?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 299, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 879}}
{"id": "computer_science_sicp_abelson_chunk_0300_9f59cc33", "text": "It will still have the same form, but it will access its second\nargument diﬀerently, as follows:\n(define (ccamount coin-values )\n(cond ((= amount 0) 1)\n((or(<amount 0) ( no-more? coin-values )) 0)\n(else\n(+ ( ccamount\n(except-first-denomination\ncoin-values ))\n(cc(-amount\n(first-denomination\ncoin-values ))\ncoin-values )))))\nDeﬁnetheprocedures first-denomination ,except-first-\ndenomination , and no-more? in terms of primitive oper-\nations on list structures. Does the order of the list coin-\nvaluesaﬀecttheanswerproducedby cc?Whyorwhynot? Exercise2.20: eprocedures +,*,and listtakearbitrary\nnumbers of arguments. One way to deﬁne such procedures\nis to use define with doed-tail notation . In a procedure\ndeﬁnition,aparameterlistthathasadotbeforethelastpa-\nrameter name indicates that, when the procedure is called,\nthe initial parameters (if any) will have as values the initial\narguments, as usual, but the ﬁnal parameter’s value will be\nalistof any remaining arguments.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 300, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_sicp_abelson_chunk_0301_57bf8326", "text": "For instance, given the\ndeﬁnition\n(define (fxy.z)⟨body⟩)\n141\nthe procedure fcan be called with two or more arguments. If we evaluate\n(f1 2 3 4 5 6)\nthen in the body of f,xwill be 1, ywill be 2, and zwill be\nthe list (3 4 5 6) . Given the deﬁnition\n(define (g.w)⟨body⟩)\ntheprocedure gcanbecalledwithzeroormorearguments. If we evaluate\n(g1 2 3 4 5 6)\nthen in the body of g,wwill be the list (1 2 3 4 5 6) .11\nUse this notation to write a procedure same-parity that\ntakes one or more integers and returns a list of all the ar-\nguments that have the same even-odd parity as the ﬁrst\nargument.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 301, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 588}}
{"id": "computer_science_sicp_abelson_chunk_0302_b99b3122", "text": "For example,\n(same-parity 1 2 3 4 5 6 7)\n(1 3 5 7)\n(same-parity 2 3 4 5 6 7)\n(2 4 6)\n11To deﬁne fandgusing lambdawe would write\n(define f(lambda (xy.z)⟨body⟩))\n(define g(lambda w⟨body⟩))\n142\nMapping over lists\nOneextremelyusefuloperationistoapplysometransformationtoeach\nelementinalistandgeneratethelistofresults.Forinstance,thefollow-\ning procedure scales each number in a list by a given factor:\n(define (scale-list items factor )\n(if(null? items )\nnil\n(cons (* ( car items )factor )\n(scale-list (cdr items )\nfactor ))))\n(scale-list (list 1 2 3 4 5) 10)\n(10 20 30 40 50)\nWe can abstract this general idea and capture it as a common paern\nexpressedasahigher-orderprocedure,justasin Section1.3 .ehigher-\norder procedure here is called map.maptakes as arguments a procedure\nof one argument and a list, and returns a list of the results produced by\napplying the procedure to each element in the list:12\n(define (map proc items )\n(if(null?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 302, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_sicp_abelson_chunk_0303_f3eb2299", "text": "items )\n12Scheme standardly provides a mapprocedure that is more general than the one\ndescribed here. is more general maptakes a procedure of narguments, together with\nnlists, and applies the procedure to all the ﬁrst elements of the lists, all the second\nelements of the lists, and so on, returning a list of the results. For example:\n(map + (list 1 2 3) ( list 40 50 60) ( list 700 800 900))\n(741 852 963)\n(map (lambda (xy) (+ x(* 2 y)))\n(list 1 2 3)\n(list 4 5 6))\n(9 12 15)\n143\nnil\n(cons (proc (car items ))\n(map proc (cdr items )))))\n(map abs (list -10 2.5 -11.6 17))\n(10 2.5 11.6 17)\n(map (lambda (x) (* xx)) ( list 1 2 3 4))\n(1 4 9 16)\nNow we can give a new deﬁnition of scale-list in terms of map:\n(define (scale-list items factor )\n(map (lambda (x) (* xfactor ))\nitems ))\nmapis an important construct, not only because it captures a common\npaern,butbecauseitestablishesahigherlevelofabstractionindealing\nwith lists.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 303, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 925}}
{"id": "computer_science_sicp_abelson_chunk_0304_d92ad59a", "text": "In the original deﬁnition of scale-list , the recursive struc-\ntureoftheprogramdrawsaentiontotheelement-by-elementprocess-\ningofthelist.Deﬁning scale-list intermsof mapsuppressesthatlevel\nof detail and emphasizes that scaling transforms a list of elements to a\nlist of results. e diﬀerence between the two deﬁnitions is not that the\ncomputer is performing a diﬀerent process (it isn’t) but that we think\nabout the process diﬀerently. In eﬀect, maphelps establish an abstrac-\ntion barrier that isolates the implementation of procedures that trans-\nform lists from the details of how the elements of the list are extracted\nand combined. Like the barriers shown in Figure 2.1 , this abstraction\ngives us the ﬂexibility to change the low-level details of how sequences\nare implemented, while preserving the conceptual framework of oper-\nations that transform sequences to sequences. Section 2.2.3 expands on\nthis use of sequences as a framework for organizing programs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 304, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_sicp_abelson_chunk_0305_41aab820", "text": "Section 2.2.3 expands on\nthis use of sequences as a framework for organizing programs. Exercise 2.21: e procedure square-list takes a list of\nnumbers as argument and returns a list of the squares of\n144\nthose numbers. (square-list (list 1 2 3 4))\n(1 4 9 16)\nHere are two diﬀerent deﬁnitions of square-list . Com-\nplete both of them by ﬁlling in the missing expressions:\n(define (square-list items )\n(if(null? items )\nnil\n(cons⟨??⟩⟨??⟩)))\n(define (square-list items )\n(map⟨??⟩⟨??⟩))\nExercise2.22: LouisReasonertriestorewritetheﬁrst square-\nlistprocedure of Exercise 2.21 so that it evolves an itera-\ntive process:\n(define (square-list items )\n(define (iter things answer )\n(if(null? things )\nanswer\n(iter (cdr things )\n(cons (square (car things ))\nanswer ))))\n(iter items nil))\nUnfortunately,deﬁning square-list thiswayproducesthe\nanswer list in the reverse order of the one desired. Why?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 305, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_sicp_abelson_chunk_0306_8f68571b", "text": "Why? Louis then tries to ﬁx his bug by interchanging the argu-\nments to cons:\n(define (square-list items )\n145\n(define (iter things answer )\n(if(null? things )\nanswer\n(iter (cdr things )\n(cons answer\n(square (car things ))))))\n(iter items nil))\nis doesn’t work either. Explain. Exercise2.23: e procedure for-each is similar to map. It\ntakesasargumentsaprocedureandalistofelements.How-\never,ratherthanformingalistoftheresults, for-each just\napplies the procedure to each of the elements in turn, from\nletoright.evaluesreturnedbyapplyingtheprocedure\nto the elements are not used at all— for-each is used with\nproceduresthatperformanaction,suchasprinting.Forex-\nample,\n(for-each (lambda (x)\n(newline )\n(display x))\n(list 57 321 88))\n57\n321\n88\ne value returned by the call to for-each (not illustrated\nabove) can be something arbitrary, such as true. Give an\nimplementation of for-each . 146\n(1 2)4\n1 23(3 4)\n((1 2) 3 4)Figure2.5: Structure formed by (cons (list 1 2) (list\n3 4)).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 306, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_sicp_abelson_chunk_0307_21e40f4c", "text": "Give an\nimplementation of for-each . 146\n(1 2)4\n1 23(3 4)\n((1 2) 3 4)Figure2.5: Structure formed by (cons (list 1 2) (list\n3 4)). 2.2.2Hierarchical Structures\ne representation of sequences in terms of lists generalizes naturally\nto represent sequences whose elements may themselves be sequences. For example, we can regard the object ((1 2) 3 4) constructed by\n(cons (list 1 2) ( list 3 4))\nasalistofthreeitems,theﬁrstofwhichisitselfalist, (1 2).Indeed,this\nissuggestedbytheforminwhichtheresultisprintedbytheinterpreter. Figure 2.5 shows the representation of this structure in terms of pairs. Another way to think of sequences whose elements are sequences\nisas trees.eelementsofthesequencearethebranchesofthetree,and\nelements that are themselves sequences are subtrees. Figure 2.6 shows\nthe structure in Figure 2.5 viewed as a tree.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 307, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 835}}
{"id": "computer_science_sicp_abelson_chunk_0308_2e39f6e9", "text": "Figure 2.6 shows\nthe structure in Figure 2.5 viewed as a tree. Recursionisanaturaltoolfordealingwithtreestructures,sincewe\ncan oen reduce operations on trees to operations on their branches,\nwhichreduceinturntooperationsonthebranchesofthebranches,and\nso on, until we reach the leaves of the tree. As an example, compare the\n147\n((1 2) 3 4)\n(1 2)\n3 4\n1 2Figure2.6: e list structure in Figure 2.5 viewed as a tree. length procedure of Section 2.2.1 with the count-leaves procedure,\nwhich returns the total number of leaves of a tree:\n(define x(cons (list 1 2) ( list 3 4)))\n(length x)\n3\n(count-leaves x)\n4\n(list xx)\n(((1 2) 3 4) ((1 2) 3 4))\n(length (list xx))\n2\n(count-leaves (list xx))\n8\nTo implement count-leaves , recall the recursive plan for computing\nlength:\n•lengthof a list xis 1 plus lengthof the cdrofx. •lengthof the empty list is 0. count-leaves is similar. e value for the empty list is the same:\n•count-leaves of the empty list is 0.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 308, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_sicp_abelson_chunk_0309_13b1ab09", "text": "•lengthof the empty list is 0. count-leaves is similar. e value for the empty list is the same:\n•count-leaves of the empty list is 0. 148\nButinthe reductionstep,wherewestrip oﬀthe carofthelist, wemust\ntakeintoaccountthatthe carmayitselfbeatreewhoseleavesweneed\nto count. us, the appropriate reduction step is\n•count-leaves of a tree xiscount-leaves of the carofxplus\ncount-leaves of the cdrofx. Finally, by taking cars we reach actual leaves, so we need another base\ncase:\n•count-leaves of a leaf is 1. To aid in writing recursive procedures on trees, Scheme provides the\nprimitive predicate pair?, which tests whether its argument is a pair. Here is the complete procedure:13\n(define (count-leaves x)\n(cond ((null? x) 0)\n((not (pair? x)) 1)\n(else (+ ( count-leaves (car x))\n(count-leaves (cdr x))))))\nExercise 2.24: Suppose we evaluate the expression (list\n1 (list 2 (list 3 4))) .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 309, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 884}}
{"id": "computer_science_sicp_abelson_chunk_0310_9a93e979", "text": "x) 0)\n((not (pair? x)) 1)\n(else (+ ( count-leaves (car x))\n(count-leaves (cdr x))))))\nExercise 2.24: Suppose we evaluate the expression (list\n1 (list 2 (list 3 4))) . Give the result printed by the\ninterpreter, the corresponding box-and-pointer structure,\nand the interpretation of this as a tree (as in Figure 2.6 ). Exercise 2.25: Give combinations of cars and cdrs that\nwill pick 7 from each of the following lists:\n13e order of the ﬁrst two clauses in the condmaers, since the empty list satisﬁes\nnull?and also is not a pair.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 310, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 531}}
{"id": "computer_science_sicp_abelson_chunk_0311_9d974abe", "text": "149\n(1 3 (5 7) 9)\n((7))\n(1 (2 (3 (4 (5 (6 7))))))\nExercise 2.26: Suppose we deﬁne xandyto be two lists:\n(define x(list 1 2 3))\n(define y(list 4 5 6))\nWhatresultisprintedbytheinterpreterinresponsetoeval-\nuating each of the following expressions:\n(append xy)\n(cons xy)\n(list xy)\nExercise2.27: Modifyyour reverse procedureof Exercise\n2.18to produce a deep-reverse procedure that takes a list\nas argument and returns as its value the list with its ele-\nments reversed and with all sublists deep-reversed as well. For example,\n(define x(list (list 1 2) ( list 3 4)))\nx\n((1 2) (3 4))\n(reverse x)\n((3 4) (1 2))\n(deep-reverse x)\n((4 3) (2 1))\nExercise2.28: Writeaprocedure fringethattakesasargu-\nment a tree (represented as a list) and returns a list whose\nelements are all the leaves of the tree arranged in le-to-\nright order.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 311, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 821}}
{"id": "computer_science_sicp_abelson_chunk_0312_10ab07d8", "text": "For example,\n150\n(define x(list (list 1 2) ( list 3 4)))\n(fringe x)\n(1 2 3 4)\n(fringe (list xx))\n(1 2 3 4 1 2 3 4)\nExercise 2.29: A binary mobile consists of two branches,\na le branch and a right branch. Each branch is a rod of\na certain length, from which hangs either a weight or an-\nother binary mobile. We can represent a binary mobile us-\ning compound data by constructing it from two branches\n(for example, using list):\n(define (make-mobile left right )\n(list left right ))\nA branch is constructed from a length(which must be a\nnumber)togetherwitha structure ,whichmaybeeithera\nnumber (representing a simple weight) or another mobile:\n(define (make-branch length structure )\n(list length structure ))\na.Write the corresponding selectors left-branch and\nright-branch ,whichreturnthebranchesofamobile,\nandbranch-length andbranch-structure ,whichre-\nturn the components of a branch. b.Usingyourselectors,deﬁneaprocedure total-weight\nthat returns the total weight of a mobile.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 312, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_sicp_abelson_chunk_0313_425f0ef3", "text": "b.Usingyourselectors,deﬁneaprocedure total-weight\nthat returns the total weight of a mobile. c.Amobileissaidtobe balanced ifthetorqueappliedby\nits top-le branch is equal to that applied by its top-\n151\nright branch (that is, if the length of the le rod mul-\ntiplied by the weight hanging from that rod is equal\nto the corresponding product for the right side) and if\neachofthesubmobileshangingoﬀitsbranchesisbal-\nanced. Design a predicate that tests whether a binary\nmobile is balanced. d.Suppose we change the representation of mobiles so\nthat the constructors are\n(define (make-mobile left right ) (cons left right ))\n(define (make-branch length structure )\n(cons length structure ))\nHow much do you need to change your programs to\nconvert to the new representation? Mapping over trees\nJust as mapis a powerful abstraction for dealing with sequences, map\ntogetherwithrecursionisapowerfulabstractionfordealingwithtrees.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 313, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_sicp_abelson_chunk_0314_0146b57f", "text": "Mapping over trees\nJust as mapis a powerful abstraction for dealing with sequences, map\ntogetherwithrecursionisapowerfulabstractionfordealingwithtrees. For instance, the scale-tree procedure, analogous to scale-list of\nSection 2.2.1 , takes as arguments a numeric factor and a tree whose\nleaves are numbers. It returns a tree of the same shape, where each\nnumber is multiplied by the factor. e recursive plan for scale-tree\nis similar to the one for count-leaves :\n(define (scale-tree tree factor )\n(cond ((null? tree )nil)\n((not (pair? tree )) (* tree factor ))\n(else (cons (scale-tree (car tree )factor )\n(scale-tree (cdr tree )factor )))))\n(scale-tree (list 1 (list 2 (list 3 4) 5) ( list 6 7)) 10)\n(10 (20 (30 40) 50) (60 70))\n152\nAnother way to implement scale-tree is to regard the tree as a se-\nquence of sub-trees and use map. We map over the sequence, scaling\neach sub-tree in turn, and return the list of results.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 314, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_sicp_abelson_chunk_0315_2a0c6529", "text": "We map over the sequence, scaling\neach sub-tree in turn, and return the list of results. In the base case,\nwhere the tree is a leaf, we simply multiply by the factor:\n(define (scale-tree tree factor )\n(map (lambda (sub-tree )\n(if(pair? sub-tree )\n(scale-tree sub-tree factor )\n(*sub-tree factor )))\ntree ))\nMany tree operations can be implemented by similar combinations of\nsequence operations and recursion. Exercise2.30: Deﬁne a procedure square-tree analogous\ntothe square-list procedureof Exercise2.21 .atis, square-\ntreeshould behave as follows:\n(square-tree\n(list 1\n(list 2 (list 3 4) 5)\n(list 6 7)))\n(1 (4 (9 16) 25) (36 49))\nDeﬁne square-tree both directly (i.e., without using any\nhigher-order procedures) and also by using mapand recur-\nsion.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 315, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 753}}
{"id": "computer_science_sicp_abelson_chunk_0316_7050b764", "text": "Exercise 2.31: Abstract your answer to Exercise 2.30 to\nproduceaprocedure tree-map withthepropertythat square-\ntreecould be deﬁned as\n(define (square-tree tree ) (tree-map square tree ))\n153\nExercise 2.32: We can represent a set as a list of distinct\nelements, and we can represent the set of all subsets of the\nset as a list of lists. For example, if the set is (1 2 3) , then\nthe set of all subsets is (() (3) (2) (2 3) (1) (1 3)\n(1 2) (1 2 3)) . Complete the following deﬁnition of a\nprocedurethatgeneratesthesetofsubsetsofasetandgive\na clear explanation of why it works:\n(define (subsets s)\n(if(null? s)\n(list nil)\n(let ((rest (subsets (cdr s))))\n(append rest (map⟨??⟩rest )))))\n2.2.3Sequences as Conventional Interfaces\nIn working with compound data, we’ve stressed how data abstraction\npermits us to design programs without becoming enmeshed in the de-\ntails of data representations, and how abstraction preserves for us the\nﬂexibility to experiment with alternative representations.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 316, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_sicp_abelson_chunk_0317_9a78d996", "text": "In this sec-\ntion, we introduce another powerful design principle for working with\ndata structures—the use of conventional interfaces . InSection 1.3 we saw how program abstractions, implemented as\nhigher-order procedures, can capture common paerns in programs\nthat deal with numerical data. Our ability to formulate analogous oper-\nations for working with compound data depends crucially on the style\nin which we manipulate our data structures. Consider, for example, the\nfollowing procedure, analogous to the count-leaves procedure of Sec-\ntion 2.2.2 , which takes a tree as argument and computes the sum of the\nsquares of the leaves that are odd:\n154\n(define (sum-odd-squares tree )\n(cond ((null? tree ) 0)\n((not (pair? tree ))\n(if(odd?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 317, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 740}}
{"id": "computer_science_sicp_abelson_chunk_0318_4d85ecbd", "text": "tree ) 0)\n((not (pair? tree ))\n(if(odd? tree ) (square tree ) 0))\n(else (+ ( sum-odd-squares (car tree ))\n(sum-odd-squares (cdr tree ))))))\nOn the surface, this procedure is very diﬀerent from the following one,\nwhich constructs a list of all the even Fibonacci numbers Fib (k), where\nkis less than or equal to a given integer n:\n(define (even-fibs n)\n(define (next k)\n(if(>kn)\nnil\n(let ((f(fib k)))\n(if(even? f)\n(cons f(next (+k1)))\n(next (+k1))))))\n(next 0))\nDespite the fact that these two procedures are structurally very diﬀer-\nent,amoreabstractdescriptionofthetwocomputationsrevealsagreat\ndeal of similarity. e ﬁrst program\n•enumerates the leaves of a tree;\n•ﬁlters them, selecting the odd ones;\n•squares each of the selected ones; and\n•accumulates the results using +, starting with 0.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 318, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 793}}
{"id": "computer_science_sicp_abelson_chunk_0319_3df88976", "text": "e ﬁrst program\n•enumerates the leaves of a tree;\n•ﬁlters them, selecting the odd ones;\n•squares each of the selected ones; and\n•accumulates the results using +, starting with 0. e second program\n155\nenumerate:\ntree leavesfilter:\nodd?map:\nsquareaccumulate:\n+, 0\nenumerate:\nintegersmap:\nfibfilter:\neven?accumulate:\ncons, ()Figure 2.7: e signal-ﬂow plans for the procedures sum-\nodd-squares (top)and even-fibs (boom)revealthecom-\nmonality between the two programs. •enumerates the integers from 0 to n;\n•computes the Fibonacci number for each integer;\n•ﬁlters them, selecting the even ones; and\n•accumulates the results using cons, starting with the empty list. Asignal-processingengineerwouldﬁnditnaturaltoconceptualizethese\nprocesses in terms of signals ﬂowing through a cascade of stages, each\nof which implements part of the program plan, as shown in Figure 2.7 . Insum-odd-squares , we begin with an enumerator , which generates a\n“signal” consisting of the leaves of a given tree.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 319, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_sicp_abelson_chunk_0320_6190d997", "text": "Insum-odd-squares , we begin with an enumerator , which generates a\n“signal” consisting of the leaves of a given tree. is signal is passed\nthrough a ﬁlter, which eliminates all but the odd elements. e result-\ning signal is in turn passed through a map, which is a “transducer” that\napplies the squareprocedure to each element. e output of the map\nis then fed to an accumulator , which combines the elements using +,\nstarting from an initial 0. e plan for even-fibs is analogous. Unfortunately, the two procedure deﬁnitions above fail to exhibit\nthis signal-ﬂow structure. For instance, if we examine the sum-odd-\n156\nsquares procedure,weﬁndthattheenumerationisimplementedpartly\nby the null?andpair?tests and partly by the tree-recursive structure\noftheprocedure.Similarly,theaccumulationisfoundpartlyinthetests\nandpartly in the addition used in the recursion. In general,thereareno\ndistinctpartsofeitherprocedurethatcorrespondtotheelementsinthe\nsignal-ﬂow description.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 320, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_sicp_abelson_chunk_0321_90fd8751", "text": "In general,thereareno\ndistinctpartsofeitherprocedurethatcorrespondtotheelementsinthe\nsignal-ﬂow description. Our two procedures decompose the computa-\ntions in a diﬀerent way, spreading the enumeration over the program\nand mingling it with the map, the ﬁlter, and the accumulation. If we\ncouldorganizeourprogramstomakethesignal-ﬂowstructuremanifest\nin the procedures we write, this would increase the conceptual clarity\nof the resulting code. Sequence Operations\ne key to organizing programs so as to more clearly reﬂect the signal-\nﬂowstructureistoconcentrateonthe“signals”thatﬂowfromonestage\nin the process to the next. If we represent these signals as lists, then we\ncanuselistoperationstoimplementtheprocessingateachofthestages.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 321, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 733}}
{"id": "computer_science_sicp_abelson_chunk_0322_b369ed11", "text": "If we represent these signals as lists, then we\ncanuselistoperationstoimplementtheprocessingateachofthestages. For instance, we can implement the mapping stages of the signal-ﬂow\ndiagrams using the mapprocedure from Section 2.2.1 :\n(map square (list 1 2 3 4 5))\n(1 4 9 16 25)\nFiltering a sequence to select only those elements that satisfy a given\npredicate is accomplished by\n(define (filter predicate sequence )\n(cond ((null? sequence )nil)\n((predicate (car sequence ))\n(cons (car sequence )\n(filter predicate (cdr sequence ))))\n(else (filter predicate (cdr sequence )))))\n157\nFor example,\n(filter odd? (list 1 2 3 4 5))\n(1 3 5)\nAccumulations can be implemented by\n(define (accumulate opinitial sequence )\n(if(null?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 322, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 717}}
{"id": "computer_science_sicp_abelson_chunk_0323_410df890", "text": "(list 1 2 3 4 5))\n(1 3 5)\nAccumulations can be implemented by\n(define (accumulate opinitial sequence )\n(if(null? sequence )\ninitial\n(op(car sequence )\n(accumulate opinitial (cdr sequence )))))\n(accumulate + 0 ( list 1 2 3 4 5))\n15\n(accumulate * 1 ( list 1 2 3 4 5))\n120\n(accumulate cons nil (list 1 2 3 4 5))\n(1 2 3 4 5)\nAllthatremainstoimplementsignal-ﬂowdiagramsistoenumeratethe\nsequence of elements to be processed. For even-fibs , we need to gen-\nerate the sequence of integers in a given range, which we can do as\nfollows:\n(define (enumerate-interval low high )\n(if(>low high )\nnil\n(cons low (enumerate-interval (+low 1)high ))))\n(enumerate-interval 2 7)\n(2 3 4 5 6 7)\nTo enumerate the leaves of a tree, we can use14\n14is is, in fact, precisely the fringeprocedure from Exercise 2.28 . Here we’ve re-\nnamed it to emphasize that it is part of a family of general sequence-manipulation\nprocedures. 158\n(define (enumerate-tree tree )\n(cond ((null? tree )nil)\n((not (pair?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 323, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_sicp_abelson_chunk_0324_605ff68b", "text": "Here we’ve re-\nnamed it to emphasize that it is part of a family of general sequence-manipulation\nprocedures. 158\n(define (enumerate-tree tree )\n(cond ((null? tree )nil)\n((not (pair? tree )) ( list tree ))\n(else (append (enumerate-tree (car tree ))\n(enumerate-tree (cdr tree ))))))\n(enumerate-tree (list 1 (list 2 (list 3 4)) 5))\n(1 2 3 4 5)\nNow we can reformulate sum-odd-squares and even-fibs as in the\nsignal-ﬂowdiagrams.For sum-odd-squares ,weenumeratethesequence\nof leaves of the tree, ﬁlter this to keep only the odd numbers in the se-\nquence, square each element, and sum the results:\n(define (sum-odd-squares tree )\n(accumulate\n+ 0 ( map square (filter odd? (enumerate-tree tree )))))\nForeven-fibs , we enumerate the integers from 0 to n, generate the Fi-\nbonacci number for each of these integers, ﬁlter the resulting sequence\nto keep only the even elements, and accumulate the results into a list:\n(define (even-fibs n)\n(accumulate\ncons\nnil\n(filter even?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 324, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_sicp_abelson_chunk_0325_3e0ab491", "text": "(map fib (enumerate-interval 0n)))))\ne value of expressing programs as sequence operations is that this\nhelps us make program designs that are modular, that is, designs that\nareconstructedbycombiningrelativelyindependentpieces.Wecanen-\ncourage modular design by providing a library of standard components\ntogether with a conventional interface for connecting the components\nin ﬂexible ways. 159\nModular construction is a powerful strategy for controlling com-\nplexityinengineeringdesign.Inrealsignal-processingapplications,for\nexample, designers regularly build systems by cascading elements se-\nlected from standardized families of ﬁlters and transducers. Similarly,\nsequence operations provide a library of standard program elements\nthat we can mix and match.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 325, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 762}}
{"id": "computer_science_sicp_abelson_chunk_0326_f9c51ab1", "text": "Similarly,\nsequence operations provide a library of standard program elements\nthat we can mix and match. For instance, we can reuse pieces from the\nsum-odd-squares and even-fibs procedures in a program that con-\nstructs a list of the squares of the ﬁrst n+ 1 Fibonacci numbers:\n(define (list-fib-squares n)\n(accumulate\ncons\nnil\n(map square (map fib (enumerate-interval 0n)))))\n(list-fib-squares 10)\n(0 1 1 4 9 25 64 169 441 1156 3025)\nWe can rearrange the pieces and use them in computing the product of\nthe squares of the odd integers in a sequence:\n(define (product-of-squares-of-odd-elements sequence )\n(accumulate * 1 ( map square (filter odd? sequence ))))\n(product-of-squares-of-odd-elements (list 1 2 3 4 5))\n225\nWecanalsoformulateconventionaldata-processingapplicationsinterms\nofsequenceoperations.Supposewehaveasequenceofpersonnelrecords\nandwewanttoﬁndthesalaryofthehighest-paidprogrammer.Assume\nthat we have a selector salarythat returns the salary of a record, and a\npredicate programmer?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 326, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_sicp_abelson_chunk_0327_0da15f46", "text": "that tests if a record is for a programmer. en\nwe can write\n(define (salary-of-highest-paid-programmer records )\n(accumulate max 0 (map salary (filter programmer? records ))))\n160\nese examples give just a hint of the vast range of operations that can\nbe expressed as sequence operations.15\nSequences, implemented here as lists, serve as a conventional in-\nterface that permits us to combine processing modules. Additionally,\nwhen we uniformly represent structures as sequences, we have local-\nizedthedata-structuredependenciesinourprogramstoasmallnumber\nof sequence operations. By changing these, we can experiment with al-\nternativerepresentationsofsequences,whileleavingtheoveralldesign\nof our programs intact. We will exploit this capability in Section 3.5 ,\nwhen we generalize the sequence-processing paradigm to admit inﬁ-\nnite sequences.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 327, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 845}}
{"id": "computer_science_sicp_abelson_chunk_0328_014c3c57", "text": "We will exploit this capability in Section 3.5 ,\nwhen we generalize the sequence-processing paradigm to admit inﬁ-\nnite sequences. Exercise 2.33: Fill in the missing expressions to complete\nthe following deﬁnitions of some basic list-manipulation\noperations as accumulations:\n(define (map psequence )\n(accumulate (lambda (xy)⟨??⟩)nil sequence ))\n(define (append seq1 seq2 )\n(accumulate cons⟨??⟩⟨??⟩))\n(define (length sequence )\n(accumulate⟨??⟩0sequence ))\n15Richard Waters(1979) developedaprogramthatautomaticallyanalyzestraditional\nFortranprograms,viewingthemintermsofmaps,ﬁlters,andaccumulations.Hefound\nthat fully 90 percent of the code in the Fortran Scientiﬁc Subroutine Package ﬁts neatly\ninto this paradigm. One of the reasons for the success of Lisp as a programming lan-\nguageisthatlistsprovideastandardmediumforexpressingorderedcollectionssothat\nthey can be manipulated using higher-order operations. e programming language\nAPL owes much of its power and appeal to a similar choice.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 328, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_sicp_abelson_chunk_0329_49da8fd5", "text": "e programming language\nAPL owes much of its power and appeal to a similar choice. In APL all data are repre-\nsentedasarrays,andthereisauniversalandconvenientsetofgenericoperatorsforall\nsorts of array operations. 161\nExercise2.34: Evaluatingapolynomialin xatagivenvalue\nofxcanbeformulatedasanaccumulation.Weevaluatethe\npolynomial\nanxn+an\u00001xn\u00001+\u0001\u0001\u0001+a1x+a0\nusing a well-known algorithm called Horner’s rule , which\nstructures the computation as\n(: : : (anx+an\u00001)x+\u0001\u0001\u0001+a1)x+a0:\nIn other words, we start with an, multiply by x, add an\u00001,\nmultiply by x, and so on, until we reach a0.16\nFill in the following template to produce a procedure that\nevaluates a polynomial using Horner’s rule. Assume that\nthecoeﬃcientsofthepolynomialarearrangedinasequence,\nfrom a0through an. (define (horner-eval xcoefficient-sequence )\n(accumulate (lambda (this-coeff higher-terms )⟨??⟩)\n0\ncoefficient-sequence ))\n16According to Knuth 1981 , this rule was formulated by W. G.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 329, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_sicp_abelson_chunk_0330_59b8e4a4", "text": "(define (horner-eval xcoefficient-sequence )\n(accumulate (lambda (this-coeff higher-terms )⟨??⟩)\n0\ncoefficient-sequence ))\n16According to Knuth 1981 , this rule was formulated by W. G. Horner early in the\nnineteenthcentury,butthemethodwasactuallyusedbyNewtonoverahundredyears\nearlier. Horner’s rule evaluates the polynomial using fewer additions and multipli-\ncations than does the straightforward method of ﬁrst computing anxn, then adding\nan\u00001xn\u00001, and so on. In fact, it is possible to prove that any algorithm for evaluating\narbitrary polynomials must use at least as many additions and multiplications as does\nHorner’srule,andthusHorner’sruleisanoptimalalgorithmforpolynomialevaluation. is was proved (for the number of additions) by A. M. Ostrowski in a 1954 paper that\nessentially founded the modern study of optimal algorithms. e analogous statement\nfor multiplications was proved by V. Y. Pan in 1966.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 330, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 912}}
{"id": "computer_science_sicp_abelson_chunk_0331_9d8627ef", "text": "M. Ostrowski in a 1954 paper that\nessentially founded the modern study of optimal algorithms. e analogous statement\nfor multiplications was proved by V. Y. Pan in 1966. e book by Borodin and Munro\n(1975)provides an overview of these and other results about optimal algorithms. 162\nForexample,tocompute1+3 x+5x3+x5atx=2youwould\nevaluate\n(horner-eval 2 (list 1 3 0 5 0 1))\nExercise 2.35: Redeﬁne count-leaves fromSection 2.2.2\nas an accumulation:\n(define (count-leaves t)\n(accumulate⟨??⟩⟨??⟩(map⟨??⟩⟨??⟩)))\nExercise 2.36: e procedure accumulate-n is similar to\naccumulate except that it takes as its third argument a se-\nquence of sequences, which are all assumed to have the\nsame number of elements. It applies the designated accu-\nmulation procedure to combine all the ﬁrst elements of the\nsequences,allthesecondelementsofthesequences,andso\non, and returns a sequence of the results.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 331, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_sicp_abelson_chunk_0332_9a73ff6e", "text": "It applies the designated accu-\nmulation procedure to combine all the ﬁrst elements of the\nsequences,allthesecondelementsofthesequences,andso\non, and returns a sequence of the results. For instance, if s\nisasequencecontainingfoursequences, ((1 2 3) (4 5 6)\n(7 8 9) (10 11 12)), thenthevalueof (accumulate-n +\n0 s)shouldbethesequence (22 26 30) .Fillinthemissing\nexpressions in the following deﬁnition of accumulate-n :\n(define (accumulate-n opinit seqs )\n(if(null? (car seqs ))\nnil\n(cons (accumulate opinit⟨??⟩)\n(accumulate-n opinit⟨??⟩))))\nExercise 2.37: Suppose we represent vectors v=(vi)as\nsequencesofnumbers,andmatrices m=(mij)assequences\n163\nofvectors(therowsofthematrix).Forexample,thematrix\n0BBBBBBBB@1 2 3 4\n4 5 6 6\n6 7 8 91CCCCCCCCA\nis represented as the sequence ((1 2 3 4) (4 5 6 6)\n(6 7 8 9)) .Withthisrepresentation,wecanusesequence\noperations to concisely express the basic matrix and vector\noperations.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 332, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_sicp_abelson_chunk_0333_35164456", "text": "ese operations (which are described in any\nbook on matrix algebra) are the following:\n(dot-product v w) returns the sum Σiviwi;\n(matrix-*-vector m v) returns the vector t;\nwhere ti=Σjmijvj;\n(matrix-*-matrix m n) returns the matrix p;\nwhere pij=Σkmiknkj;\n(transpose m) returns the matrix n;\nwhere nij=mji:\nWe can deﬁne the dot product as17\n(define (dot-product vw)\n(accumulate + 0 ( map *vw)))\nFill in the missing expressions in the following procedures\nfor computing the other matrix operations. (e procedure\naccumulate-n is deﬁned in Exercise 2.36 .)\n(define (matrix-*-vector mv)\n(map⟨??⟩m))\n17is deﬁnition uses the extended version of mapdescribed in Footnote 12 . 164\n(define (transpose mat)\n(accumulate-n⟨??⟩⟨??⟩mat))\n(define (matrix-*-matrix mn)\n(let ((cols (transpose n)))\n(map⟨??⟩m)))\nExercise2.38: eaccumulate procedureisalsoknownas\nfold-right ,becauseitcombinestheﬁrstelementofthese-\nquence with the result of combining all the elements to the\nright.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 333, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_sicp_abelson_chunk_0334_d27a6ad3", "text": "ere is also a fold-left , which is similar to fold-\nright,exceptthatitcombineselementsworkingintheop-\nposite direction:\n(define (fold-left opinitial sequence )\n(define (iter result rest )\n(if(null? rest )\nresult\n(iter (opresult (car rest ))\n(cdr rest ))))\n(iter initial sequence ))\nWhat are the values of\n(fold-right / 1 ( list 1 2 3))\n(fold-left / 1 ( list 1 2 3))\n(fold-right list nil (list 1 2 3))\n(fold-left list nil (list 1 2 3))\nGive a property that opshould satisfy to guarantee that\nfold-right andfold-left will produce the same values\nfor any sequence.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 334, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 562}}
{"id": "computer_science_sicp_abelson_chunk_0335_c780c93b", "text": "165\nExercise2.39: Completethefollowingdeﬁnitionsof reverse\n(Exercise2.18 )intermsof fold-right andfold-left from\nExercise 2.38 :\n(define (reverse sequence )\n(fold-right (lambda (xy)⟨??⟩)nil sequence ))\n(define (reverse sequence )\n(fold-left (lambda (xy)⟨??⟩)nil sequence ))\nNested Mappings\nWe can extend the sequence paradigm to include many computations\nthat are commonly expressed using nested loops.18Consider this prob-\nlem:Givenapositiveinteger n,ﬁndallorderedpairsofdistinctpositive\nintegers iandj, where 1\u0014j<i\u0014n, such that i+jis prime. For\nexample, if nis 6, then the pairs are the following:\ni 2 3 4 4 5 6 6\nj1 2 1 3 2 1 5\ni+j3 5 5 7 7 7 11\nA natural way to organize this computation is to generate the sequence\nof all ordered pairs of positive integers less than or equal to n, ﬁlter to\nselect those pairs whose sum is prime, and then, for each pair (i;j)that\npasses through the ﬁlter, produce the triple (i;j;i+j).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 335, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_sicp_abelson_chunk_0336_ba356429", "text": "Here is a way to generate the sequence of pairs: For each integer\ni\u0014n, enumerate the integers j<i, and for each such iandjgener-\nate the pair (i;j). In terms of sequence operations, we map along the\n18is approach to nested mappings was shown to us by David Turner, whose lan-\nguagesKRCandMirandaprovideelegantformalismsfordealingwiththeseconstructs. e examples in this section (see also Exercise 2.42 ) are adapted from Turner 1981 . In\nSection 3.5.3 , we’ll see how this approach generalizes to inﬁnite sequences. 166\nsequence (enumerate-interval 1 n) . For each iin this sequence, we\nmap along the sequence (enumerate-interval 1 (- i 1)) . For each\njin this laer sequence, we generate the pair (list i j) . is gives\nus a sequence of pairs for each i.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 336, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 756}}
{"id": "computer_science_sicp_abelson_chunk_0337_cba92270", "text": "For each iin this sequence, we\nmap along the sequence (enumerate-interval 1 (- i 1)) . For each\njin this laer sequence, we generate the pair (list i j) . is gives\nus a sequence of pairs for each i. Combining all the sequences for all\nthei(by accumulating with append) produces the required sequence of\npairs:19\n(accumulate\nappend nil (map (lambda (i)\n(map (lambda (j) (list ij))\n(enumerate-interval 1 (- i1))))\n(enumerate-interval 1n)))\ne combination of mapping and accumulating with appendis so com-\nmon in this sort of program that we will isolate it as a separate proce-\ndure:\n(define (flatmap proc seq)\n(accumulate append nil (map proc seq)))\nNow ﬁlter this sequence of pairs to ﬁnd those whose sum is prime. e\nﬁlterpredicateiscalledforeachelementofthesequence;itsargumentis\na pair and it must extract the integers from the pair. us, the predicate\nto apply to each element in the sequence is\n(define (prime-sum? pair )\n(prime?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 337, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_sicp_abelson_chunk_0338_98726497", "text": "us, the predicate\nto apply to each element in the sequence is\n(define (prime-sum? pair )\n(prime? (+ ( car pair ) (cadr pair ))))\nFinally, generate the sequence of results by mapping over the ﬁltered\npairsusingthefollowingprocedure,whichconstructsatripleconsisting\nof the two elements of the pair along with their sum:\n19We’re representing a pair here as a list of two elements rather than as a Lisp pair. us, the “pair” (i;j)is represented as (list i j) , not (cons i j) . 167\n(define (make-pair-sum pair )\n(list (car pair ) (cadr pair ) (+ ( car pair ) (cadr pair ))))\nCombining all these steps yields the complete procedure:\n(define (prime-sum-pairs n)\n(map make-pair-sum\n(filter prime-sum? (flatmap\n(lambda (i)\n(map (lambda (j) (list ij))\n(enumerate-interval 1 (- i1))))\n(enumerate-interval 1n)))))\nNested mappings are also useful for sequences other than those that\nenumerate intervals.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 338, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_sicp_abelson_chunk_0339_2aa62699", "text": "(flatmap\n(lambda (i)\n(map (lambda (j) (list ij))\n(enumerate-interval 1 (- i1))))\n(enumerate-interval 1n)))))\nNested mappings are also useful for sequences other than those that\nenumerate intervals. Suppose we wish to generate all the permutations\nof a set S; that is, all the ways of ordering the items in the set. For in-\nstance,thepermutationsof {1;2;3}are {1;2;3},{1;3;2},{2;1;3},{2;3;1},\n{3;1;2},and {3;2;1}.Hereisaplanforgeneratingthepermutationsof S:\nForeachitem xinS,recursivelygeneratethesequenceofpermutations\nofS\u0000x,20and adjoin xto the front of each one. is yields, for each x\ninS, the sequence of permutations of Sthat begin with x. Combining\nthese sequences for all xgives all the permutations of S:21\n(define (permutations s)\n(if(null? s) ; empty set? (list nil) ; sequence containing empty set\n(flatmap (lambda (x)\n(map (lambda (p) (cons xp))\n(permutations (remove xs))))\ns)))\n20e set S\u0000xis the set of all elements of S, excluding x.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 339, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_sicp_abelson_chunk_0340_79f15e59", "text": "s) ; empty set? (list nil) ; sequence containing empty set\n(flatmap (lambda (x)\n(map (lambda (p) (cons xp))\n(permutations (remove xs))))\ns)))\n20e set S\u0000xis the set of all elements of S, excluding x. 21Semicolons in Scheme code are used to introduce comments . Everything from the\nsemicolon to the end of the line is ignored by the interpreter. In this book we don’t use\nmany comments; we try to make our programs self-documenting by using descriptive\nnames. 168\nNotice how this strategy reduces the problem of generating permuta-\ntions of Sto the problem of generating the permutations of sets with\nfewer elements than S. In the terminal case, we work our way down to\nthe empty list, which represents a set of no elements. For this, we gen-\nerate (list nil) , which is a sequence with one item, namely the set\nwith no elements. e removeprocedure used in permutations returns\nall the items in a given sequence except for a given item.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 340, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_sicp_abelson_chunk_0341_76c56910", "text": "e removeprocedure used in permutations returns\nall the items in a given sequence except for a given item. is can be\nexpressed as a simple ﬁlter:\n(define (remove item sequence )\n(filter (lambda (x) (not (=xitem )))\nsequence ))\nExercise2.40: Deﬁneaprocedure unique-pairs that,given\nan integer n, generates the sequence of pairs (i;j)with 1\u0014\nj<i\u0014n. Use unique-pairs to simplify the deﬁnition of\nprime-sum-pairs given above. Exercise2.41: Write a procedure to ﬁnd all ordered triples\nof distinct positive integers i,j, and kless than or equal to\na given integer nthat sum to a given integer s.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 341, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 591}}
{"id": "computer_science_sicp_abelson_chunk_0342_6dc097b2", "text": "Exercise2.41: Write a procedure to ﬁnd all ordered triples\nof distinct positive integers i,j, and kless than or equal to\na given integer nthat sum to a given integer s. Exercise2.42: e“eight-queenspuzzle”askshowtoplace\neight queens on a chessboard so that no queen is in check\nfromanyother(i.e.,notwoqueensareinthesamerow,col-\numn,ordiagonal).Onepossiblesolutionisshownin Figure\n2.8.Onewaytosolvethepuzzleistoworkacrosstheboard,\nplacingaqueenineachcolumn.Oncewehaveplaced k\u00001\nqueens, we must place the kthqueen in a position where it\ndoes not check any of the queens already on the board. We\ncan formulate this approach recursively: Assume that we\n169\nFigure 2.8: A solution to the eight-queens puzzle. have already generated the sequence of all possible ways\ntoplace k\u00001queensintheﬁrst k\u00001columnsoftheboard. For each of these ways, generate an extended set of posi-\ntions by placing a queen in each row of the kthcolumn.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 342, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_sicp_abelson_chunk_0343_88b415e1", "text": "For each of these ways, generate an extended set of posi-\ntions by placing a queen in each row of the kthcolumn. Now ﬁlter these, keeping only the positions for which the\nqueen in the kthcolumn is safe with respect to the other\nqueens. is produces the sequence of all ways to place k\nqueens in the ﬁrst kcolumns. By continuing this process,\nwe will produce not only one solution, but all solutions to\nthe puzzle. We implement this solution as a procedure queens, which\nreturns a sequence of all solutions to the problem of plac-\ningnqueens on an n\u0002nchessboard. queenshas an inter-\nnal procedure queen-cols that returns the sequence of all\nways to place queens in the ﬁrst kcolumns of the board. 170\n(define (queens board-size )\n(define (queen-cols k)\n(if(=k0)\n(list empty-board )\n(filter\n(lambda (positions ) (safe?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 343, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 816}}
{"id": "computer_science_sicp_abelson_chunk_0344_5c55174e", "text": "170\n(define (queens board-size )\n(define (queen-cols k)\n(if(=k0)\n(list empty-board )\n(filter\n(lambda (positions ) (safe? kpositions ))\n(flatmap\n(lambda (rest-of-queens )\n(map (lambda (new-row )\n(adjoin-position\nnew-row krest-of-queens ))\n(enumerate-interval 1board-size )))\n(queen-cols (-k1))))))\n(queen-cols board-size ))\nIn this procedure rest-of-queens is a way to place k\u00001\nqueensintheﬁrst k\u00001columns,and new-row isaproposed\nrow in which to place the queen for the kthcolumn. Com-\nplete the program by implementing the representation for\nsets of board positions, including the procedure adjoin-\nposition , which adjoins a new row-column position to a\nsetofpositions,and empty-board ,whichrepresentsanempty\nset of positions. You must also write the procedure safe?,\nwhich determines for a set of positions, whether the queen\nin the kthcolumn is safe with respect to the others.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 344, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 880}}
{"id": "computer_science_sicp_abelson_chunk_0345_ebe7cdc3", "text": "You must also write the procedure safe?,\nwhich determines for a set of positions, whether the queen\nin the kthcolumn is safe with respect to the others. (Note\nthat we need only check whether the new queen is safe—\nthe other queens are already guaranteed safe with respect\nto each other.)\nExercise2.43: Louis Reasoner is having a terrible time do-\ningExercise2.42 .His queensprocedureseemstowork,but\nit runs extremely slowly. (Louis never does manage to wait\n171\nlongenoughforittosolveeventhe6 \u00026case.)WhenLouis\nasks Eva Lu Ator for help, she points out that he has inter-\nchanged the order of the nested mappings in the flatmap ,\nwriting it as\n(flatmap\n(lambda (new-row )\n(map (lambda (rest-of-queens )\n(adjoin-position new-row krest-of-queens ))\n(queen-cols (-k1))))\n(enumerate-interval 1board-size ))\nExplainwhythisinterchangemakestheprogramrunslowly. Estimate how long it will take Louis’s program to solve the\neight-queenspuzzle,assumingthattheprogramin Exercise\n2.42solves the puzzle in time T.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 345, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_sicp_abelson_chunk_0346_15616765", "text": "Estimate how long it will take Louis’s program to solve the\neight-queenspuzzle,assumingthattheprogramin Exercise\n2.42solves the puzzle in time T. 2.2.4Example: A Picture Language\nis section presents a simple language for drawing pictures that il-\nlustrates the power of data abstraction and closure, and also exploits\nhigher-order procedures in an essential way. e language is designed\nto make it easy to experiment with paerns such as the ones in Fig-\nure 2.9, which are composed of repeated elements that are shied and\nscaled.22In this language, the data objects being combined are repre-\nsented as procedures rather than as list structure. Just as cons, which\nsatisﬁestheclosureproperty,allowedustoeasilybuildarbitrarilycom-\nplicated list structure, the operations in this language, which also sat-\n22epicturelanguageisbasedonthelanguagePeterHendersoncreatedtoconstruct\nimages like M.C. Escher’s “Square Limit” woodcut (see Henderson 1982 ).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 346, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_sicp_abelson_chunk_0347_4d0586b0", "text": "Escher’s “Square Limit” woodcut (see Henderson 1982 ). e woodcut\nincorporates a repeated scaled paern, similar to the arrangements drawn using the\nsquare-limit procedure in this section. 172\nFigure 2.9: Designs generated with the picture language. isfytheclosureproperty,allowustoeasilybuildarbitrarilycomplicated\npaerns. The picture language\nWhen we began our study of programming in Section 1.1 , we empha-\nsized the importance of describing a language by focusing on the lan-\nguage’s primitives, its means of combination, and its means of abstrac-\ntion. We’ll follow that framework here. Partoftheeleganceofthispicturelanguageisthatthereisonlyone\nkindofelement,calleda painter.Apainterdrawsanimagethatisshied\nand scaled to ﬁt within a designated parallelogram-shaped frame. For\nexample, there’s a primitive painter we’ll call wavethat makes a crude\nline drawing, as shown in Figure 2.10 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 347, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_sicp_abelson_chunk_0348_8fc1f79c", "text": "For\nexample, there’s a primitive painter we’ll call wavethat makes a crude\nline drawing, as shown in Figure 2.10 . e actual shape of the drawing\ndependsontheframe—allfourimagesinﬁgure2.10areproducedbythe\n173\nFigure 2.10: Images produced by the wavepainter, with\nrespect to four diﬀerent frames. e frames, shown with\ndoed lines, are not part of the images. same wavepainter, but with respect to four diﬀerent frames. Painters\ncan be more elaborate than this: e primitive painter called rogers\npaints a picture of ’s founder, William Barton Rogers, as shown in\nFigure 2.11 .23e four images in ﬁgure 2.11 are drawn with respect to\n23William Barton Rogers (1804-1882) was the founder and ﬁrst president of . A geologist and talented teacher, he taught at William and Mary College and at the\nUniversity of Virginia.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 348, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 821}}
{"id": "computer_science_sicp_abelson_chunk_0349_a6a0a070", "text": "A geologist and talented teacher, he taught at William and Mary College and at the\nUniversity of Virginia. In 1859 he moved to Boston, where he had more time for re-\nsearch, worked on a plan for establishing a “polytechnic institute,” and served as Mas-\nsachuses’s ﬁrst State Inspector of Gas Meters. Whenwas established in 1861, Rogers was elected its ﬁrst president. Rogers\nespoused an ideal of “useful learning” that was diﬀerent from the university education\nofthetime,withitsoveremphasisontheclassics,which,ashewrote,“standintheway\nof the broader, higher and more practical instruction and discipline of the natural and\nsocial sciences.” is education was likewise to be diﬀerent from narrow trade-school\n174\nthe same four frames as the waveimages in ﬁgure 2.10. To combine images, we use various operations that construct new\npainters from given painters. For example, the besideoperation takes\ntwopaintersandproducesanew,compoundpainterthatdrawstheﬁrst\neducation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 349, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_sicp_abelson_chunk_0350_efbc4af8", "text": "For example, the besideoperation takes\ntwopaintersandproducesanew,compoundpainterthatdrawstheﬁrst\neducation. In Rogers’s words:\ne world-enforced distinction between the practical and the scientiﬁc\nworker is uerly futile, and the whole experience of modern times has\ndemonstrated its uer worthlessness. Rogers served as president of until 1870, when he resigned due to ill health. In 1878 the second president of , John Runkle, resigned under the pressure of a\nﬁnancial crisis brought on by the Panic of 1873 and strain of ﬁghting oﬀ aempts by\nHarvard to take over . Rogers returned to hold the oﬃce of president until 1881. Rogerscollapsedanddiedwhileaddressing ’sgraduatingclassatthecommence-\nment exercises of 1882. Runkle quoted Rogers’s last words in a memorial address de-\nlivered that same year:\n“As I stand here today and see what the Institute is, : : :I call to mind\nthe beginnings of science.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 350, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_sicp_abelson_chunk_0351_1e2b6c0c", "text": "Runkle quoted Rogers’s last words in a memorial address de-\nlivered that same year:\n“As I stand here today and see what the Institute is, : : :I call to mind\nthe beginnings of science. I remember one hundred and ﬁy years ago\nStephen Hales published a pamphlet on the subject of illuminating gas,\nin which he stated that his researches had demonstrated that 128 grains\nof bituminous coal – ” “Bituminous coal,” these were his last words on\nearth. Here he bent forward, as if consulting some notes on the table\nbeforehim,thenslowlyregaininganerectposition,threwuphishands,\nand was translated from the scene of his earthly labors and triumphs\nto “the tomorrow of death,” where the mysteries of life are solved, and\nthe disembodied spirit ﬁnds unending satisfaction in contemplating the\nnew and still unfathomable mysteries of the inﬁnite future. In the words of Francis A.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 351, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 870}}
{"id": "computer_science_sicp_abelson_chunk_0352_4d1808f4", "text": "In the words of Francis A. Walker ( ’s third president):\nAll his life he had borne himself most faithfully and heroically, and he\ndied as so good a knight would surely have wished, in harness, at his\npost, and in the very part and act of public duty. 175\nFigure2.11: ImagesofWilliamBartonRogers,founderand\nﬁrstpresidentof ,paintedwithrespecttothesamefour\nframes as in Figure 2.10 (original image from Wikimedia\nCommons). painter’simageinthelehalfoftheframeandthesecondpainter’sim-\nageintherighthalfoftheframe.Similarly, belowtakestwopaintersand\nproducesacompoundpainterthatdrawstheﬁrstpainter’simagebelow\nthe second painter’s image. Some operations transform a single painter\nto produce a new painter. For example, flip-vert takes a painter and\nproduces a painter that draws its image upside-down, and flip-horiz\nproduces a painter that draws the original painter’s image le-to-right\nreversed.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 352, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_sicp_abelson_chunk_0353_ae0bbc2c", "text": "For example, flip-vert takes a painter and\nproduces a painter that draws its image upside-down, and flip-horiz\nproduces a painter that draws the original painter’s image le-to-right\nreversed. Figure 2.12 shows the drawing of a painter called wave4that is built\nup in two stages starting from wave:\n(define wave2 (beside wave (flip-vert wave )))\n(define wave4 (below wave2 wave2 ))\n176\nFigure 2.12: Creating a complex ﬁgure, starting from the\nwavepainter of Figure 2.10 . Inbuildingupacompleximageinthismannerweareexploitingthe\nfactthatpaintersareclosedunderthelanguage’smeansofcombination. ebesideorbelowoftwopaintersisitselfapainter;therefore,wecan\nuseitasanelementinmakingmorecomplexpainters.Aswithbuilding\nup list structure using cons, the closure of our data under the means of\ncombination is crucial to the ability to create complex structures while\nusing only a few operations. Once we can combine painters, we would like to be able to abstract\ntypical paerns of combining painters.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 353, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_sicp_abelson_chunk_0354_e3270fdb", "text": "Once we can combine painters, we would like to be able to abstract\ntypical paerns of combining painters. We will implement the painter\noperations as Scheme procedures.is means that wedon’t need a spe-\ncial abstraction mechanism in the picture language: Since the means of\ncombination are ordinary Scheme procedures, we automatically have\nthe capability to do anything with painter operations that we can do\nwith procedures. For example, we can abstract the paern in wave4as\n(define (flipped-pairs painter )\n(let ((painter2 (beside painter (flip-vert painter ))))\n(below painter2 painter2 )))\nand deﬁne wave4as an instance of this paern:\n(define wave4 (flipped-pairs wave ))\n177\nright-split\nidentity\nright-split\nright-split nright-splitcorner-splitup-\nsplit\nn- -1up-\nsplit\nright-splitidentityn- -1 n- -1\nn- -1\nn- -1\ncorner-split nn- -1\nn- -1Figure 2.13: Recursive plans for right-split andcorner-split .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 354, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 906}}
{"id": "computer_science_sicp_abelson_chunk_0355_695f749c", "text": "Wecanalsodeﬁnerecursiveoperations.Here’sonethatmakespainters\nsplit and branch towards the right as shown in Figure 2.13 andFigure\n2.14:\n(define (right-split painter n)\n(if(=n0)\npainter\n(let ((smaller (right-split painter (-n1))))\n(beside painter (below smaller smaller )))))\nWe can produce balanced paerns by branching upwards as well as\ntowards the right (see exercise Exercise 2.44 and ﬁgures Figure 2.13 and\nFigure 2.14 ):\n(define (corner-split painter n)\n(if(=n0)\npainter\n178\n(let ((up(up-split painter (-n1)))\n(right (right-split painter (-n1))))\n(let ((top-left (beside upup))\n(bottom-right (below right right ))\n(corner (corner-split painter (-n1))))\n(beside (below painter top-left )\n(below bottom-right corner ))))))\nBy placing four copies of a corner-split appropriately, we obtain a\npaern called square-limit , whose application to waveandrogersis\nshown in Figure 2.9 :\n(define (square-limit painter n)\n(let ((quarter (corner-split painter n)))\n(let ((half (beside (flip-horiz quarter )quarter )))\n(below (flip-vert half )half ))))\nExercise2.44: Deﬁnetheprocedure up-split usedby corner-\nsplit.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 355, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1107}}
{"id": "computer_science_sicp_abelson_chunk_0356_6e8f60c8", "text": "It is similar to right-split , except that it switches\nthe roles of belowandbeside. Higher-order operations\nIn addition to abstracting paerns of combining painters, we can work\nat a higher level, abstracting paerns of combining painter operations. at is, we can view the painter operations as elements to manipulate\nand can write means of combination for these elements—procedures\nthat take painter operations as arguments and create new painter oper-\nations. For example, flipped-pairs andsquare-limit each arrange four\ncopies of a painter’s image in a square paern; they diﬀer only in how\n179\n(right-split wave 4) (right-split rogers 4)\n(corner-split wave 4) (corner-split rogers 4)Figure 2.14: e recursive operations right-split and\ncorner-split applied to the painters waveand rogers. Combining four corner-split ﬁgures produces symmet-\nricsquare-limit designs as shown in Figure 2.9 . 180\nthey orient the copies.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 356, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_sicp_abelson_chunk_0357_25668a0f", "text": "Combining four corner-split ﬁgures produces symmet-\nricsquare-limit designs as shown in Figure 2.9 . 180\nthey orient the copies. One way to abstract this paern of painter com-\nbinationiswiththefollowingprocedure,whichtakesfourone-argument\npainter operations and produces a painter operation that transforms a\ngiven painter with those four operations and arranges the results in a\nsquare. tl,tr,bl, and brare the transformations to apply to the top\nle copy, the top right copy, the boom le copy, and the boom right\ncopy, respectively.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 357, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 538}}
{"id": "computer_science_sicp_abelson_chunk_0358_6418e311", "text": "tl,tr,bl, and brare the transformations to apply to the top\nle copy, the top right copy, the boom le copy, and the boom right\ncopy, respectively. (define (square-of-four tltrblbr)\n(lambda (painter )\n(let ((top (beside (tlpainter ) (trpainter )))\n(bottom (beside (blpainter ) (brpainter ))))\n(below bottom top))))\nen flipped-pairs can be deﬁned in terms of square-of-four as\nfollows:24\n(define (flipped-pairs painter )\n(let ((combine4 (square-of-four identity flip-vert\nidentity flip-vert )))\n(combine4 painter )))\nandsquare-limit can be expressed as25\n(define (square-limit painter n)\n(let ((combine4 (square-of-four flip-horiz identity\nrotate180 flip-vert )))\n24Equivalently, we could write\n(define flipped-pairs\n(square-of-four identity flip-vert identity flip-vert ))\n25rotate180 rotates a painter by 180 degrees (see Exercise 2.50 ). Instead of ro-\ntate180 we could say (compose flip-vert flip-horiz) , using the compose pro-\ncedure from Exercise 1.42 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 358, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_sicp_abelson_chunk_0359_3674a07b", "text": "Instead of ro-\ntate180 we could say (compose flip-vert flip-horiz) , using the compose pro-\ncedure from Exercise 1.42 . 181\n(combine4 (corner-split painter n))))\nExercise2.45: right-split andup-split canbeexpressed\nas instances of a general spliing operation. Deﬁne a pro-\ncedure splitwith the property that evaluating\n(define right-split (split beside below ))\n(define up-split (split below beside ))\nproduces procedures right-split andup-split with the\nsame behaviors as the ones already deﬁned. Frames\nBeforewecanshowhowtoimplementpaintersandtheirmeansofcom-\nbination, we must ﬁrst consider frames. A frame can be described by\nthree vectors—an origin vector and two edge vectors. e origin vector\nspeciﬁes the oﬀset of the frame’s origin from some absolute origin in\nthe plane, and the edge vectors specify the oﬀsets of the frame’s cor-\nners from its origin. If the edges are perpendicular, the frame will be\nrectangular. Otherwise the frame will be a more general parallelogram.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 359, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_sicp_abelson_chunk_0360_a46bea86", "text": "If the edges are perpendicular, the frame will be\nrectangular. Otherwise the frame will be a more general parallelogram. Figure 2.15 shows a frame and its associated vectors. In accordance\nwithdataabstraction,weneednotbespeciﬁcyetabouthowframesare\nrepresented, other than to say that there is a constructor make-frame ,\nwhich takes three vectors and produces a frame, and three correspond-\ning selectors origin-frame ,edge1-frame , and edge2-frame (seeExer-\ncise 2.47 ). We will use coordinates in the unit square (0\u0014x;y\u00141)to specify\nimages. With each frame, we associate a frame coordinate map , which\nwill be used to shi and scale images to ﬁt the frame. e map trans-\nforms the unit square into the frame by mapping the vector v=(x;y)\n182\nframe\nedge1\nvectorframe\nedge2\nvector\nframe\norigin\nvector(0, 0) point on \ndisplay screenFigure 2.15: A frame is described by three vectors — an\norigin and two edges.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 360, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_sicp_abelson_chunk_0361_30254593", "text": "to the vector sum\nOrigin (Frame )+x\u0001Edge1(Frame )+y\u0001Edge2(Frame ):\nFor example, (0, 0) is mapped to the origin of the frame, (1, 1) to the\nvertex diagonally opposite the origin, and (0.5, 0.5) to the center of the\nframe. We can create a frame’s coordinate map with the following pro-\ncedure:26\n(define (frame-coord-map frame )\n(lambda (v)\n(add-vect\n(origin-frame frame )\n26frame-coord-map uses the vector operations described in Exercise 2.46 below,\nwhich we assume have been implemented using some representation for vectors. Be-\ncause of data abstraction, it doesn’t maer what this vector representation is, so long\nas the vector operations behave correctly. 183\n(add-vect (scale-vect (xcor-vect v) (edge1-frame frame ))\n(scale-vect (ycor-vect v) (edge2-frame frame ))))))\nObservethatapplying frame-coord-map toaframereturnsaprocedure\nthat,givenavector,returnsavector.Iftheargumentvectorisintheunit\nsquare, the result vector will be in the frame.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 361, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_sicp_abelson_chunk_0362_ed8916e6", "text": "For example,\n((frame-coord-map a-frame ) (make-vect 0 0))\nreturns the same vector as\n(origin-frame a-frame )\nExercise 2.46: A two-dimensional vector vrunning from\nthe origin to a point can be represented asa pair consisting\nof an x-coordinate and a y-coordinate. Implement a data\nabstraction for vectors by giving a constructor make-vect\nand corresponding selectors xcor-vect andycor-vect . In\nterms of your selectors and constructor, implement proce-\ndures add-vect ,sub-vect , and scale-vect that perform\ntheoperationsvectoraddition,vectorsubtraction,andmul-\ntiplying a vector by a scalar:\n(x1;y1)+(x2;y2)=(x1+x2;y1+y2);\n(x1;y1)\u0000(x2;y2)=(x1\u0000x2;y1\u0000y2);\ns\u0001(x;y)=(sx;sy):\nExercise2.47: Herearetwopossibleconstructorsforframes:\n(define (make-frame origin edge1 edge2 )\n(list origin edge1 edge2 ))\n(define (make-frame origin edge1 edge2 )\n(cons origin (cons edge1 edge2 )))\nFor each constructor supply the appropriate selectors to\nproduce an implementation for frames.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 362, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_sicp_abelson_chunk_0363_f2fa799a", "text": "184\nPainters\nApainterisrepresentedasaprocedurethat,givenaframeasargument,\ndraws a particular image shied and scaled to ﬁt the frame. at is to\nsay, if pis a painter and fis a frame, then we produce p’s image in fby\ncalling pwith fas argument. e details of how primitive painters are implemented depend on\nthe particular characteristics of the graphics system and the type of im-\nage to be drawn. For instance, suppose we have a procedure draw-line\nthat draws a line on the screen between two speciﬁed points. en we\ncancreatepaintersforlinedrawings,suchasthe wavepainterin Figure\n2.10, from lists of line segments as follows:27\n(define (segments->painter segment-list )\n(lambda (frame )\n(for-each\n(lambda (segment )\n(draw-line\n((frame-coord-map frame )\n(start-segment segment ))\n((frame-coord-map frame )\n(end-segment segment ))))\nsegment-list )))\nesegmentsaregivenusingcoordinateswithrespecttotheunitsquare.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 363, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_sicp_abelson_chunk_0364_f151a835", "text": "For each segment in the list, the painter transforms the segment end-\npoints with the frame coordinate map and draws a line between the\ntransformed points. Representing painters as procedures erects a powerful abstraction\nbarrier in the picture language. We can create and intermix all sorts of\n27segments->painter uses the representation for line segments described in Exer-\ncise 2.48 below. It also uses the for-each procedure described in Exercise 2.23 . 185\nprimitive painters, based on a variety of graphics capabilities. e de-\ntailsoftheirimplementationdo notmaer.Any procedurecanserveas\na painter, provided that it takes a frame as argument and draws some-\nthing scaled to ﬁt the frame.28\nExercise 2.48: A directed line segment in the plane can be\nrepresented as a pair of vectors—the vector running from\nthe origin to the start-point of the segment, and the vector\nrunning from the origin to the end-point of the segment.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 364, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 931}}
{"id": "computer_science_sicp_abelson_chunk_0365_a26c7700", "text": "Use your vector representation from Exercise 2.46 to de-\nﬁnearepresentationforsegmentswithaconstructor make-\nsegment and selectors start-segment andend-segment . Exercise 2.49: Usesegments->painter to deﬁne the fol-\nlowing primitive painters:\na.e painter that draws the outline of the designated\nframe. b.epainterthatdrawsan“X”byconnectingopposite\ncorners of the frame. c.e painter that draws a diamond shape by connect-\ning the midpoints of the sides of the frame. d.ewavepainter. 28For example, the rogerspainter of Figure 2.11 was constructed from a gray-level\nimage. For each point in a given frame, the rogerspainter determines the point in the\nimage that is mapped to it under the frame coordinate map, and shades it accordingly. By allowing diﬀerent types of painters, we are capitalizing on the abstract data idea\ndiscussedin Section2.1.3 ,wherewearguedthatarational-numberrepresentationcould\nbe anything at all that satisﬁes an appropriate condition.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 365, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_sicp_abelson_chunk_0366_120cd31f", "text": "Here we’re using the fact\nthat a painter can be implemented in any way at all, so long as it draws something\nin the designated frame. Section 2.1.3 also showed how pairs could be implemented as\nprocedures. Painters are our second example of a procedural representation for data. 186\nTransforming and combining painters\nAn operation on painters (such as flip-vert orbeside) works by cre-\nating a painter that invokes the original painters with respect to frames\nderivedfromtheargumentframe.us,forexample, flip-vert doesn’t\nhavetoknowhowapainterworksinordertoﬂipit—itjusthastoknow\nhowtoturnaframeupsidedown:eﬂippedpainterjustusestheorig-\ninal painter, but in the inverted frame. Painteroperationsarebasedontheprocedure transform-painter ,\nwhich takes as arguments a painter and information on how to trans-\nform a frame and produces a new painter.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 366, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 847}}
{"id": "computer_science_sicp_abelson_chunk_0367_d3eeb3aa", "text": "Painteroperationsarebasedontheprocedure transform-painter ,\nwhich takes as arguments a painter and information on how to trans-\nform a frame and produces a new painter. e transformed painter,\nwhen called on a frame, transforms the frame and calls the original\npainteronthetransformedframe.eargumentsto transform-painter\nare points (represented as vectors) that specify the corners of the new\nframe: When mapped into the frame, the ﬁrst point speciﬁes the new\nframe’s origin and the other two specify the ends of its edge vectors. us,argumentswithintheunitsquarespecifyaframecontainedwithin\nthe original frame.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 367, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 612}}
{"id": "computer_science_sicp_abelson_chunk_0368_0426b748", "text": "us,argumentswithintheunitsquarespecifyaframecontainedwithin\nthe original frame. (define (transform-painter painter origin corner1 corner2 )\n(lambda (frame )\n(let ((m(frame-coord-map frame )))\n(let ((new-origin (morigin )))\n(painter (make-frame\nnew-origin\n(sub-vect (mcorner1 )new-origin )\n(sub-vect (mcorner2 )new-origin )))))))\nHere’s how to ﬂip painter images vertically:\n(define (flip-vert painter )\n(transform-painter painter\n(make-vect 0.0 1.0) ; new origin\n187\n(make-vect 1.0 1.0) ; new end of edge1\n(make-vect 0.0 0.0))) ; new end of edge2\nUsing transform-painter , we can easily deﬁne new transformations.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 368, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 614}}
{"id": "computer_science_sicp_abelson_chunk_0369_d0cae4ca", "text": "Forexample,wecandeﬁneapainterthatshrinksitsimagetotheupper-\nright quarter of the frame it is given:\n(define (shrink-to-upper-right painter )\n(transform-painter\npainter (make-vect 0.5 0.5)\n(make-vect 1.0 0.5) ( make-vect 0.5 1.0)))\nOther transformations rotate images counterclockwise by 90 degrees29\n(define (rotate90 painter )\n(transform-painter painter\n(make-vect 1.0 0.0)\n(make-vect 1.0 1.0)\n(make-vect 0.0 0.0)))\nor squash images towards the center of the frame:30\n(define (squash-inwards painter )\n(transform-painter painter\n(make-vect 0.0 0.0)\n(make-vect 0.65 0.35)\n(make-vect 0.35 0.65)))\nFrame transformation is also the key to deﬁning means of combining\ntwo or more painters. e beside procedure, for example, takes two\npainters, transforms them to paint in the le and right halves of an\nargument frame respectively, and produces a new, compound painter. 29rotate90 is a pure rotation only for square frames, because it also stretches and\nshrinks the image to ﬁt into the rotated frame.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 369, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_sicp_abelson_chunk_0370_c49eeda8", "text": "29rotate90 is a pure rotation only for square frames, because it also stretches and\nshrinks the image to ﬁt into the rotated frame. 30e diamond-shaped images in Figure 2.10 andFigure 2.11 were created with\nsquash-inwards applied to waveandrogers. 188\nWhen the compound painter is given a frame, it calls the ﬁrst trans-\nformed painter to paint in the le half of the frame and calls the second\ntransformed painter to paint in the right half of the frame:\n(define (beside painter1 painter2 )\n(let ((split-point (make-vect 0.5 0.0)))\n(let ((paint-left\n(transform-painter\npainter1\n(make-vect 0.0 0.0)\nsplit-point\n(make-vect 0.0 1.0)))\n(paint-right\n(transform-painter\npainter2\nsplit-point\n(make-vect 1.0 0.0)\n(make-vect 0.5 1.0))))\n(lambda (frame )\n(paint-left frame )\n(paint-right frame )))))\nObserve how the painter data abstraction, and in particular the repre-\nsentation of painters as procedures, makes besideeasy to implement.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 370, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 929}}
{"id": "computer_science_sicp_abelson_chunk_0371_e18d0a64", "text": "ebesideprocedure need not know anything about the details of the\ncomponent painters other than that each painter will draw something\nin its designated frame. Exercise2.50: Deﬁnethetransformation flip-horiz ,which\nﬂips painters horizontally, and transformations that rotate\npainters counterclockwise by 180 degrees and 270 degrees. Exercise2.51: Deﬁnethe belowoperationforpainters. below\ntakestwopaintersasarguments.eresultingpainter,given\n189\na frame, draws with the ﬁrst painter in the boom of the\nframe and with the second painter in the top. Deﬁne below\nin two diﬀerent ways—ﬁrst by writing a procedure that is\nanalogous to the besideprocedure given above, and again\nin terms of besideand suitable rotation operations (from\nExercise 2.50 ). Levels of language for robust design\ne picture language exercises some of the critical ideas we’ve intro-\nduced about abstraction with procedures and data.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 371, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 903}}
{"id": "computer_science_sicp_abelson_chunk_0372_71263020", "text": "Levels of language for robust design\ne picture language exercises some of the critical ideas we’ve intro-\nduced about abstraction with procedures and data. e fundamental\ndataabstractions,painters,areimplementedusingproceduralrepresen-\ntations, which enables the language to handle diﬀerent basic drawing\ncapabilities in a uniform way. e means of combination satisfy the\nclosure property, which permits us to easily build up complex designs. Finally, all the tools for abstracting procedures are available to us for\nabstracting means of combination for painters. We have also obtained a glimpse of another crucial idea about lan-\nguages and program design. is is the approach of stratiﬁed design ,\nthe notion that a complex system should be structured as a sequence\nof levels that are described using a sequence of languages. Each level is\nconstructed by combining parts that are regarded as primitive at that\nlevel, and the parts constructed at each level are used as primitives at\nthe next level.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 372, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_sicp_abelson_chunk_0373_8ed1f907", "text": "Each level is\nconstructed by combining parts that are regarded as primitive at that\nlevel, and the parts constructed at each level are used as primitives at\nthe next level. e language used at each level of a stratiﬁed design has\nprimitives,meansofcombination,andmeansofabstractionappropriate\nto that level of detail. Stratiﬁed design pervades the engineering of complex systems. For\nexample, in computer engineering, resistors and transistors are com-\nbined (and described using a language of analog circuits) to produce\nparts such as and-gates and or-gates, which form the primitives of a\n190\nlanguage for digital-circuit design.31ese parts are combined to build\nprocessors,busstructures,andmemorysystems,whichareinturncom-\nbined to form computers, using languages appropriate to computer ar-\nchitecture. Computers are combined to form distributed systems, using\nlanguages appropriate for describing network interconnections, and so\non.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 373, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_sicp_abelson_chunk_0374_552ad204", "text": "Computers are combined to form distributed systems, using\nlanguages appropriate for describing network interconnections, and so\non. As a tiny example of stratiﬁcation, our picture language uses prim-\nitive elements (primitive painters) that are created using a language\nthat speciﬁes points and lines to provide the lists of line segments for\nsegments->painter , or the shading details for a painter like rogers. e bulk of our description of the picture language focused on com-\nbining these primitives, using geometric combiners such as besideand\nbelow. We also worked at a higher level, regarding besideandbelow\nas primitives to be manipulated in a language whose operations, such\nassquare-of-four , capture common paerns of combining geometric\ncombiners. Stratiﬁed design helps make programs robust, that is, it makes it\nlikelythatsmallchangesinaspeciﬁcationwillrequirecorrespondingly\nsmallchangesintheprogram.Forinstance,supposewewantedtochange\nthe image based on waveshown in Figure 2.9 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 374, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_sicp_abelson_chunk_0375_e6710fb1", "text": "We could work at the\nlowest level to change the detailed appearance of the waveelement;\nwe could work at the middle level to change the way corner-split\nreplicates the wave; we could work at the highest level to change how\nsquare-limit arranges the four copies of the corner. In general, each\nlevel of a stratiﬁed design provides a diﬀerent vocabulary for express-\ning the characteristics of the system, and a diﬀerent kind of ability to\nchange it. 31Section 3.3.4 describes one such language. 191\nExercise 2.52: Make changes to the square limit of wave\nshown in Figure 2.9 by working at each of the levels de-\nscribed above. In particular:\na.Add some segments to the primitive wavepainter of\nExercise 2.49 (to add a smile, for example). b.Changethepaernconstructedby corner-split (for\nexample, by using only one copy of the up-split and\nright-split images instead of two). c.Modifytheversionof square-limit thatuses square-\nof-four so as to assemble the corners in a diﬀerent\npaern.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 375, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_sicp_abelson_chunk_0376_011ea13b", "text": "c.Modifytheversionof square-limit thatuses square-\nof-four so as to assemble the corners in a diﬀerent\npaern. (For example, you might make the big Mr. Rogers look outward from each corner of the square.)\n2.3Symbolic Data\nAllthecompounddataobjectswehaveusedsofarwereconstructedul-\ntimately from numbers. In this section we extend the representational\ncapability of our language by introducing the ability to work with arbi-\ntrary symbols as data. 2.3.1otation\nIf we can form compound data using symbols, we can have lists such as\n(abcd)\n(23 45 17)\n((Norah 12) ( Molly 9) ( Anna 7) ( Lauren 6) ( Charlotte 4))\nLists containing symbols can look just like the expressions of our lan-\nguage:\n192\n(* (+ 23 45)\n(+x9))\n(define (fact n)\n(if(=n1) 1 (* n(fact (-n1)))))\nInordertomanipulatesymbolsweneedanewelementinourlanguage:\nthe ability to quotea data object. Suppose we want to construct the list\n(a b).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 376, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 898}}
{"id": "computer_science_sicp_abelson_chunk_0377_58dbca0b", "text": "Suppose we want to construct the list\n(a b). We can’t accomplish this with (list a b) , because this expres-\nsion constructs a list of the valuesofaandbrather than the symbols\nthemselves.isissueiswellknowninthecontextofnaturallanguages,\nwherewordsandsentencesmayberegardedeitherassemanticentities\nor as character strings (syntactic entities). e common practice in nat-\nural languages is to use quotation marks to indicate that a word or a\nsentence is to be treated literally as a string of characters. For instance,\nthe ﬁrst leer of “John” is clearly “J.” If we tell somebody “say your\nname aloud,” we expect to hear that person’s name.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 377, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 639}}
{"id": "computer_science_sicp_abelson_chunk_0378_e7dbfebc", "text": "For instance,\nthe ﬁrst leer of “John” is clearly “J.” If we tell somebody “say your\nname aloud,” we expect to hear that person’s name. However, if we tell\nsomebody “say ‘your name’ aloud,” we expect to hear the words “your\nname.”Notethatweareforcedtonestquotationmarkstodescribewhat\nsomebody else might say.32\nWe can follow this same practice to identify lists and symbols that\nare to be treated as data objects rather than as expressions to be evalu-\n32Allowing quotation in a language wreaks havoc with the ability to reason about\nthe language in simple terms, because it destroys the notion that equals can be sub-\nstituted for equals. For example, three is one plus two, but the word “three” is not the\nphrase “one plus two.” otation is powerful because it gives us a way to build expres-\nsionsthatmanipulateotherexpressions(aswewillseewhenwewriteaninterpreterin\nChapter 4 ).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 378, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 881}}
{"id": "computer_science_sicp_abelson_chunk_0379_562c071b", "text": "But allowing statements in a language that talk about other statements in\nthatlanguagemakesitverydiﬃculttomaintainanycoherentprincipleofwhat“equals\ncan be substituted for equals” should mean. For example, if we know that the evening\nstar is the morning star, then from the statement “the evening star is Venus” we can\ndeduce “the morning star is Venus.” However, given that “John knows that the evening\nstar is Venus” we cannot infer that “John knows that the morning star is Venus.”\n193\nated. However, our format for quoting diﬀers from that of natural lan-\nguagesinthatweplaceaquotationmark(traditionally,thesinglequote\nsymbol ') only at the beginning of the object to be quoted.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 379, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 681}}
{"id": "computer_science_sicp_abelson_chunk_0380_9872d190", "text": "However, our format for quoting diﬀers from that of natural lan-\nguagesinthatweplaceaquotationmark(traditionally,thesinglequote\nsymbol ') only at the beginning of the object to be quoted. We can get\naway with this in Scheme syntax because we rely on blanks and paren-\nthesestodelimitobjects.us,themeaningofthesinglequotecharacter\nis to quote the next object.33\nNow we can distinguish between symbols and their values:\n(define a1)\n(define b2)\n(list ab)\n(1 2)\n(list 'a'b)\n(a b)\n(list 'ab)\n(a 2)\notation also allows us to type in compound objects, using the con-\nventional printed representation for lists:34\n33e single quote is diﬀerent from the double quote we have been using to enclose\ncharacter strings to be printed. Whereas the single quote can be used to denote lists or\nsymbols, the double quote is used only with character strings. In this book, the only\nuse for character strings is as items to be printed.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 380, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_sicp_abelson_chunk_0381_f24cdaf8", "text": "Whereas the single quote can be used to denote lists or\nsymbols, the double quote is used only with character strings. In this book, the only\nuse for character strings is as items to be printed. 34Strictly, our use of the quotation mark violates the general rule that all compound\nexpressions in our language should be delimited by parentheses and look like lists. We\ncan recover this consistency by introducing a special form quote, which serves the\nsame purpose as the quotation mark. us, we would type (quote a) instead of 'a,\nand we would type (quote (a b c)) instead of '(a b c) . is is precisely how\nthe interpreter works. e quotation mark is just a single-character abbreviation for\nwrapping the next complete expression with quoteto form (quote⟨expression⟩). is is important because it maintains the principle that any expression seen by the\ninterpreter can be manipulated as a data object.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 381, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_sicp_abelson_chunk_0382_20126869", "text": "is is important because it maintains the principle that any expression seen by the\ninterpreter can be manipulated as a data object. For instance, we could construct the\nexpression (car '(a b c)) ,whichisthesameas (car (quote (a b c))) ,byevaluating\n(list 'car (list 'quote '(a b c))) . 194\n(car '(abc))\na\n(cdr '(abc))\n(b c)\nIn keeping with this, we can obtain the empty list by evaluating '(),\nand thus dispense with the variable nil. Oneadditionalprimitiveusedinmanipulatingsymbolsis eq?,which\ntakes two symbols as arguments and tests whether they are the same.35\nUsing eq?,wecanimplementausefulprocedurecalled memq.istakes\ntwoarguments,asymbolandalist.Ifthesymbolisnotcontainedinthe\nlist(i.e.,isnot eq?toanyiteminthelist),then memqreturnsfalse.Other-\nwise,itreturnsthesublistofthelistbeginningwiththeﬁrstoccurrence\nof the symbol:\n(define (memq item x)\n(cond ((null? x)false )\n((eq?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 382, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 885}}
{"id": "computer_science_sicp_abelson_chunk_0383_9ad207df", "text": "x)false )\n((eq? item (car x))x)\n(else (memq item (cdr x)))))\nFor example, the value of\n(memq 'apple '(pear banana prune ))\nis false, whereas the value of\n(memq 'apple '(x(apple sauce )yapple pear ))\nis(apple pear) . Exercise2.53: Whatwouldtheinterpreterprintinresponse\nto evaluating each of the following expressions? 35Wecanconsidertwosymbolstobe“thesame”iftheyconsistofthesamecharacters\nin the same order. Such a deﬁnition skirts a deep issue that we are not yet ready to\naddress: the meaning of “sameness” in a programming language. We will return to this\ninChapter 3 (Section 3.1.3 ). 195\n(list 'a'b'c)\n(list (list 'george ))\n(cdr '((x1x2) (y1y2)))\n(cadr '((x1x2) (y1y2)))\n(pair? (car '(ashort list )))\n(memq 'red '((red shoes ) (blue socks )))\n(memq 'red '(red shoes blue socks ))\nExercise 2.54: Two lists are said to be equal?if they con-\ntain equal elements arranged in the same order. For exam-\nple,\n(equal? '(this isalist )'(this isalist ))\nis true, but\n(equal?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 383, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_sicp_abelson_chunk_0384_23b4153a", "text": "For exam-\nple,\n(equal? '(this isalist )'(this isalist ))\nis true, but\n(equal? '(this isalist )'(this (isa)list ))\nis false. To be more precise, we can deﬁne equal? recur-\nsively in terms of the basic eq?equality of symbols by say-\ning that aandbareequal?if they are both symbols and\nthe symbols are eq?, or if they are both lists such that (car\na)isequal?to(car b) and(cdr a) isequal?to(cdr b) . Using this idea, implement equal?as a procedure.36\nExercise 2.55: Eva Lu Ator types to the interpreter the ex-\npression\n36In practice, programmers use equal? to compare lists that contain numbers as\nwell as symbols. Numbers are not considered to be symbols. e question of whether\ntwo numerically equal numbers (as tested by =) are also eq?is highly implementation-\ndependent. A beer deﬁnition of equal?(such as the one that comes as a primitive in\nScheme) would also stipulate that if aandbare both numbers, then aandbareequal? if they are numerically equal.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 384, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_sicp_abelson_chunk_0385_fea4316a", "text": "A beer deﬁnition of equal?(such as the one that comes as a primitive in\nScheme) would also stipulate that if aandbare both numbers, then aandbareequal? if they are numerically equal. 196\n(car ''abracadabra )\nTo her surprise, the interpreter prints back quote. Explain. 2.3.2Example: Symbolic Diﬀerentiation\nAs an illustration of symbol manipulation and a further illustration of\ndataabstraction,considerthedesignofaprocedurethatperformssym-\nbolic diﬀerentiation of algebraic expressions. We would like the proce-\ndure to take as arguments an algebraic expression and a variable and to\nreturn the derivative of the expression with respect to the variable. For\nexample, if the arguments to the procedure are ax2+bx+candx, the\nprocedure should return 2 ax+b. Symbolic diﬀerentiation is of special\nhistorical signiﬁcance in Lisp. It was one of the motivating examples\nbehind the development of a computer language for symbol manipula-\ntion.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 385, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 937}}
{"id": "computer_science_sicp_abelson_chunk_0386_0856d30f", "text": "Symbolic diﬀerentiation is of special\nhistorical signiﬁcance in Lisp. It was one of the motivating examples\nbehind the development of a computer language for symbol manipula-\ntion. Furthermore, it marked the beginning of the line of research that\nled to the development of powerful systems for symbolic mathematical\nwork, which are currently being used by a growing number of applied\nmathematicians and physicists. In developing the symbolic-diﬀerentiation program, we will follow\nthe same strategy of data abstraction that we followed in developing\nthe rational-number system of Section 2.1.1 . at is, we will ﬁrst de-\nﬁneadiﬀerentiationalgorithmthatoperatesonabstractobjectssuchas\n“sums,” “products,” and “variables” without worrying about how these\naretoberepresented.Onlyaerwardwillweaddresstherepresentation\nproblem.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 386, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 823}}
{"id": "computer_science_sicp_abelson_chunk_0387_03afba06", "text": "The diﬀerentiation program with abstract data\nInordertokeepthingssimple,wewillconsideraverysimplesymbolic-\ndiﬀerentiationprogramthathandlesexpressionsthatarebuiltupusing\n197\nonlytheoperationsofadditionandmultiplicationwithtwoarguments. Diﬀerentiation of any such expression can be carried out by applying\nthe following reduction rules:\ndc\ndx=0;forca constant or a variable different from x;\ndx\ndx=1;\nd(u+v)\ndx=du\ndx+dv\ndx;\nd(uv)\ndx=udv\ndx+vdu\ndx:\nObserve that the laer two rules are recursive in nature. at is, to ob-\ntainthederivativeofasumweﬁrstﬁndthederivativesofthetermsand\nadd them. Each of the terms may in turn be an expression that needs\nto be decomposed. Decomposing into smaller and smaller pieces will\neventually produce pieces that are either constants or variables, whose\nderivatives will be either 0 or 1. To embody these rules in a procedure we indulge in a lile wishful\nthinking, as we did in designing the rational-number implementation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 387, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 957}}
{"id": "computer_science_sicp_abelson_chunk_0388_1f01ef25", "text": "To embody these rules in a procedure we indulge in a lile wishful\nthinking, as we did in designing the rational-number implementation. If we had a means for representing algebraic expressions, we should\nbe able to tell whether an expression is a sum, a product, a constant,\nor a variable. We should be able to extract the parts of an expression. For a sum, for example we want to be able to extract the addend (ﬁrst\nterm)andtheaugend(secondterm).Weshouldalsobeabletoconstruct\nexpressions from parts. Let us assume that we already have procedures\nto implement the following selectors, constructors, and predicates:\n(variable? e) Isea variable? (same-variable? v1v2)Arev1andv2the same variable? 198\n(sum? e) Isea sum? (addend e) Addend of the sum e. (augend e) Augend of the sum e. (make-sum a1a2) Construct the sum of a1anda2. (product? e) Isea product? (multiplier e) Multiplier of the product e. (multiplicand e) Multiplicand of the product e. (make-product m1m2)Construct the product of m1andm2.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 388, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_sicp_abelson_chunk_0389_ab5afaaa", "text": "(product? e) Isea product? (multiplier e) Multiplier of the product e. (multiplicand e) Multiplicand of the product e. (make-product m1m2)Construct the product of m1andm2. Usingthese,andtheprimitivepredicate number? ,whichidentiﬁesnum-\nbers,wecanexpressthediﬀerentiationrulesasthefollowingprocedure:\n(define (deriv exp var)\n(cond ((number? exp) 0)\n((variable? exp) (if(same-variable? exp var) 1 0))\n((sum? exp) (make-sum (deriv (addend exp)var)\n(deriv (augend exp)var)))\n((product? exp)\n(make-sum\n(make-product (multiplier exp)\n(deriv (multiplicand exp)var))\n(make-product (deriv (multiplier exp)var)\n(multiplicand exp))))\n(else\n(error \"unknown expression type :DERIV \"exp))))\nis derivprocedure incorporates the complete diﬀerentiation algo-\nrithm. Since it is expressed in terms of abstract data, it will work no\nmaerhowwechoose torepresentalgebraicexpressions,as longaswe\ndesign a proper set of selectors and constructors. is is the issue we\nmust address next.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 389, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_sicp_abelson_chunk_0390_5df4e27b", "text": "is is the issue we\nmust address next. 199\nRepresenting algebraic expressions\nWe can imagine many ways to use list structure to represent algebraic\nexpressions. For example, we could use lists of symbols that mirror\nthe usual algebraic notation, representing ax+bas the list (a * x +\nb). However, one especially straightforward choice is to use the same\nparenthesized preﬁx notation that Lisp uses for combinations; that is,\nto represent ax+bas(+ (* a x) b) . en our data representation for\nthe diﬀerentiation problem is as follows:\n•e variables are symbols. ey are identiﬁed by the primitive\npredicate symbol? :\n(define (variable? x) (symbol? x))\n•Two variables are the same if the symbols representing them are\neq?:\n(define (same-variable? v1v2)\n(and (variable? v1) (variable? v2) (eq? v1v2)))\n•Sums and products are constructed as lists:\n(define (make-sum a1a2) (list '+a1a2))\n(define (make-product m1m2) (list '*m1m2))\n•A sum is a list whose ﬁrst element is the symbol +:\n(define (sum? x) (and (pair?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 390, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1007}}
{"id": "computer_science_sicp_abelson_chunk_0391_3b107f0e", "text": "x) (and (pair? x) (eq? (car x)'+)))\n•e addend is the second item of the sum list:\n(define (addend s) (cadr s))\n200\n•e augend is the third item of the sum list:\n(define (augend s) (caddr s))\n•A product is a list whose ﬁrst element is the symbol *:\n(define (product? x) (and (pair? x) (eq? (car x)'*)))\n•e multiplier is the second item of the product list:\n(define (multiplier p) (cadr p))\n•e multiplicand is the third item of the product list:\n(define (multiplicand p) (caddr p))\nus, we need only combine these with the algorithm as embodied by\nderivinordertohaveaworkingsymbolic-diﬀerentiationprogram.Let\nus look at some examples of its behavior:\n(deriv '(+x3)'x)\n(+ 1 0)\n(deriv '(*xy)'x)\n(+ (* x 0) (* 1 y))\n(deriv '(* (* xy) (+ x3)) 'x)\n(+ (* (* x y) (+ 1 0))\n(* (+ (* x 0) (* 1 y))\n(+ x 3)))\ne program produces answers that are correct; however, they are un-\nsimpliﬁed. It is true that\nd(xy)\ndx=x\u00010 + 1\u0001y;\n201\nbut we would like the program to know that x\u00010=0, 1\u0001y=y, and\n0+y=y.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 391, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_sicp_abelson_chunk_0392_c1bdb4af", "text": "It is true that\nd(xy)\ndx=x\u00010 + 1\u0001y;\n201\nbut we would like the program to know that x\u00010=0, 1\u0001y=y, and\n0+y=y. e answer for the second example should have been simply\ny. As the third example shows, this becomes a serious issue when the\nexpressions are complex. Ourdiﬃcultyismuchliketheoneweencounteredwiththerational-\nnumberimplementation:wehaven’treducedanswerstosimplestform. Toaccomplishtherational-numberreduction,weneededtochangeonly\nthe constructorsand the selectors of the implementation. Wecan adopt\na similar strategy here. We won’t change derivat all. Instead, we will\nchange make-sum sothat if both summands arenumbers, make-sum will\nadd them and return their sum. Also, if one of the summands is 0, then\nmake-sum will return the other summand. (define (make-sum a1a2)\n(cond ((=number? a10)a2)\n((=number? a20)a1)\n((and (number? a1) (number? a2))\n(+a1a2))\n(else (list '+a1a2))))\nisusestheprocedure =number? ,whichcheckswhetheranexpression\nis equal to a given number:\n(define (=number?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 392, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_sicp_abelson_chunk_0393_9c44eae6", "text": "a10)a2)\n((=number? a20)a1)\n((and (number? a1) (number? a2))\n(+a1a2))\n(else (list '+a1a2))))\nisusestheprocedure =number? ,whichcheckswhetheranexpression\nis equal to a given number:\n(define (=number? exp num) (and (number? exp) (= exp num)))\nSimilarly,wewillchange make-product tobuildintherulesthat0times\nanything is 0 and 1 times anything is the thing itself:\n(define (make-product m1m2)\n(cond ((or(=number? m10) (= number? m20)) 0)\n((=number? m11)m2)\n((=number? m21)m1)\n((and (number? m1) (number?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 393, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 499}}
{"id": "computer_science_sicp_abelson_chunk_0394_dbd217e3", "text": "m10) (= number? m20)) 0)\n((=number? m11)m2)\n((=number? m21)m1)\n((and (number? m1) (number? m2)) (* m1m2))\n(else (list '*m1m2))))\n202\nHere is how this version works on our three examples:\n(deriv '(+x3)'x)\n1\n(deriv '(*xy)'x)\ny\n(deriv '(* (* xy) (+ x3)) 'x)\n(+ (* x y) (* y (+ x 3)))\nAlthough this is quite an improvement, the third example shows that\nthere is still a long way to go before we get a program that puts ex-\npressions into a form that we might agree is “simplest.” e problem\nof algebraic simpliﬁcation is complex because, among other reasons, a\nform that may be simplest for one purpose may not be for another. Exercise2.56: Show how to extend the basic diﬀerentiator\nto handle more kinds of expressions. For instance, imple-\nment the diﬀerentiation rule\nd(un)\ndx=nun\u00001du\ndx\nby adding a new clause to the derivprogram and deﬁning\nappropriateprocedures exponentiation? ,base,exponent ,\nand make-exponentiation .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 394, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_sicp_abelson_chunk_0395_6aa7dbb8", "text": ",base,exponent ,\nand make-exponentiation . (You may use the symbol **\nto denote exponentiation.) Build in the rules that anything\nraised to the power 0 is 1 and anything raised to the power\n1 is the thing itself. Exercise 2.57: Extend the diﬀerentiation program to han-\ndlesumsandproductsofarbitrarynumbersof(twoormore)\nterms. en the last example above could be expressed as\n(deriv '(*xy(+x3)) 'x)\n203\nTrytodothisbychangingonlytherepresentationforsums\nandproducts,withoutchangingthe derivprocedureatall. For example, the addendof a sum would be the ﬁrst term,\nand the augendwould be the sum of the rest of the terms.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 395, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 617}}
{"id": "computer_science_sicp_abelson_chunk_0396_ca6295d4", "text": "For example, the addendof a sum would be the ﬁrst term,\nand the augendwould be the sum of the rest of the terms. Exercise 2.58: Suppose we want to modify the diﬀerentia-\ntion program so that it works with ordinary mathematical\nnotation,inwhich +and*areinﬁxratherthanpreﬁxopera-\ntors.Sincethediﬀerentiationprogramisdeﬁnedintermsof\nabstractdata,wecanmodifyittoworkwithdiﬀerentrepre-\nsentationsofexpressionssolelybychangingthepredicates,\nselectors,andconstructorsthatdeﬁnetherepresentationof\nthe algebraic expressions on which the diﬀerentiator is to\noperate. a.Showhowtodothisinordertodiﬀerentiatealgebraic\nexpressions presented in inﬁx form, such as (x + (3\n* (x + (y + 2)))) .Tosimplifythetask,assumethat\n+and*always take two arguments and that expres-\nsions are fully parenthesized. b.eproblembecomessubstantiallyharderifweallow\nstandard algebraic notation, such as (x + 3 * (x +\ny + 2)) , which drops unnecessary parentheses and\nassumes that multiplication is done before addition.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 396, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_sicp_abelson_chunk_0397_6569660c", "text": "b.eproblembecomessubstantiallyharderifweallow\nstandard algebraic notation, such as (x + 3 * (x +\ny + 2)) , which drops unnecessary parentheses and\nassumes that multiplication is done before addition. Can you design appropriate predicates, selectors, and\nconstructorsforthisnotationsuchthatourderivative\nprogram still works? 204\n2.3.3Example: Representing Sets\nInthepreviousexampleswebuiltrepresentationsfortwokindsofcom-\npound data objects: rational numbers and algebraic expressions. In one\nof these examples we had the choice of simplifying (reducing) the ex-\npressions at either construction time or selection time, but other than\nthat the choice of a representation for these structures in terms of lists\nwas straightforward. When we turn to the representation of sets, the\nchoice of a representation is not so obvious. Indeed, there are a num-\nber of possible representations, and they diﬀer signiﬁcantly from one\nanother in several ways. Informally, a set is simply a collection of distinct objects.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 397, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_sicp_abelson_chunk_0398_e593fa3b", "text": "Indeed, there are a num-\nber of possible representations, and they diﬀer signiﬁcantly from one\nanother in several ways. Informally, a set is simply a collection of distinct objects. To give\na more precise deﬁnition we can employ the method of data abstrac-\ntion. at is, we deﬁne “set” by specifying the operations that are to be\nused on sets. ese are union-set ,intersection-set ,element-of-\nset?,and adjoin-set .element-of-set? isapredicatethatdetermines\nwhether a given element is a member of a set. adjoin-set takes an ob-\nject and a set as arguments and returns a set that contains the elements\nof the original set and also the adjoined element. union-set computes\nthe union of two sets, which is the set containing each element that\nappears in either argument. intersection-set computes the intersec-\ntion of two sets, which is the set containing only elements that appear\nin both arguments.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 398, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 898}}
{"id": "computer_science_sicp_abelson_chunk_0399_49321858", "text": "intersection-set computes the intersec-\ntion of two sets, which is the set containing only elements that appear\nin both arguments. From the viewpoint of data abstraction, we are free\ntodesignanyrepresentationthatimplementstheseoperationsinaway\nconsistent with the interpretations given above.37\n37If we want to be more formal, we can specify “consistent with the interpretations\ngiven above” to mean that the operations satisfy a collection of rules such as these:\n\u000fFor any set Sand any object x,(element-of-set? x (adjoin-set x S)) is true\n(informally: “Adjoining an object to a set produces a set that contains the object”). \u000fFor any sets SandTand any object x,(element-of-set? x (union-set S T)) is\n205\nSets as unordered lists\nOne way to represent a set is as a list of its elements in which no el-\nement appears more than once. e empty set is represented by the\nempty list. In this representation, element-of-set? is similar to the\nprocedure memqofSection 2.3.1 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 399, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_sicp_abelson_chunk_0400_e91809cd", "text": "e empty set is represented by the\nempty list. In this representation, element-of-set? is similar to the\nprocedure memqofSection 2.3.1 . It uses equal?instead of eq?so that\nthe set elements need not be symbols:\n(define (element-of-set? xset)\n(cond ((null? set)false )\n((equal? x(car set))true )\n(else (element-of-set? x(cdr set)))))\nUsing this, we can write adjoin-set . If the object to be adjoined is al-\nready in the set, we just return the set. Otherwise, we use consto add\nthe object to the list that represents the set:\n(define (adjoin-set xset)\n(if(element-of-set? xset)\nset\n(cons xset)))\nForintersection-set wecanusearecursivestrategy.Ifweknowhow\nto form the intersection of set2and the cdrofset1, we only need to\ndecide whether to include the carofset1in this. But this depends on\nwhether (car set1) is also in set2. Here is the resulting procedure:\n(define (intersection-set set1 set2 )\n(cond ((or(null? set1 ) (null? set2 ))'())\n((element-of-set?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 400, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 957}}
{"id": "computer_science_sicp_abelson_chunk_0401_8836ca67", "text": "But this depends on\nwhether (car set1) is also in set2. Here is the resulting procedure:\n(define (intersection-set set1 set2 )\n(cond ((or(null? set1 ) (null? set2 ))'())\n((element-of-set? (car set1 )set2 )\n(cons (car set1 ) (intersection-set (cdr set1 )set2 )))\n(else (intersection-set (cdr set1 )set2 ))))\nequal to (or (element-of-set? x S) (element-of-set? x T)) (informally: “e\nelements of (union S T) are the elements that are in Sor in T”). \u000fFor any object x,(element-of-set? x '()) is false (informally: “No object is an\nelement of the empty set”). 206\nIndesigningarepresentation,oneoftheissuesweshouldbeconcerned\nwith is eﬃciency. Consider the number of steps required by our set\noperations. Since they all use element-of-set? , the speed of this oper-\nation has a major impact on the eﬃciency of the set implementation as\na whole. Now, in order to check whether an object is a member of a set,\nelement-of-set? may have to scan the entire set.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 401, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_sicp_abelson_chunk_0402_275c312c", "text": "Now, in order to check whether an object is a member of a set,\nelement-of-set? may have to scan the entire set. (In the worst case,\ntheobjectturnsoutnottobeintheset.)Hence,ifthesethas nelements,\nelement-of-set? might take up to nsteps. us, the number of steps\nrequired grows as Θ(n). e number of steps required by adjoin-set ,\nwhich uses this operation, also grows as Θ(n). For intersection-set ,\nwhich does an element-of-set? check for each element of set1, the\nnumber of steps required grows as the product of the sizes of the sets\ninvolved,or Θ(n2)fortwosetsofsize n.esamewillbetrueof union-\nset. Exercise2.59: Implement the union-set operation for the\nunordered-list representation of sets. Exercise2.60: Wespeciﬁedthatasetwouldberepresented\nas a list with no duplicates. Now suppose we allow dupli-\ncates. For instance, the set {1;2;3}could be represented as\nthe list (2 3 2 1 3 2 2) . Design procedures element-\nof-set?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 402, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_sicp_abelson_chunk_0403_efbfb7f8", "text": "Now suppose we allow dupli-\ncates. For instance, the set {1;2;3}could be represented as\nthe list (2 3 2 1 3 2 2) . Design procedures element-\nof-set? ,adjoin-set ,union-set , and intersection-set\nthatoperateonthisrepresentation.Howdoestheeﬃciency\nof each compare with the corresponding procedure for the\nnon-duplicaterepresentation?Arethereapplicationsforwhich\nyouwouldusethisrepresentationinpreferencetothenon-\nduplicate one? 207\nSets as ordered lists\nOne way to speed up our set operations is to change the representation\nso that the set elements are listed in increasing order. To do this, we\nneed some way to compare two objects so that we can say which is\nbigger. For example, we could compare symbols lexicographically, or\nwe could agree on some method for assigning a unique number to an\nobject and then compare the elements by comparing the corresponding\nnumbers.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 403, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 871}}
{"id": "computer_science_sicp_abelson_chunk_0404_05705eb6", "text": "To keep our discussion simple, we will consider only the case\nwhere the set elements are numbers, so that we can compare elements\nusing >and<.Wewillrepresentasetofnumbersbylistingitselements\nin increasing order. Whereas our ﬁrst representation above allowed us\nto represent the set {1;3;6;10}by listing the elements in any order, our\nnew representation allows only the list (1 3 6 10) . Oneadvantageoforderingshowsupin element-of-set? :Incheck-\ningforthepresenceofanitem,wenolongerhavetoscantheentireset. If we reach a set element that is larger than the item we are looking for,\nthen we know that the item is not in the set:\n(define (element-of-set? xset)\n(cond ((null? set)false )\n((= x(car set))true )\n((< x(car set))false )\n(else (element-of-set? x(cdr set)))))\nHow many steps does this save? In the worst case, the item we are\nlooking for may be the largest one in the set, so the number of steps\nis the same as for the unordered representation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 404, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_sicp_abelson_chunk_0405_25ea23bd", "text": "x(cdr set)))))\nHow many steps does this save? In the worst case, the item we are\nlooking for may be the largest one in the set, so the number of steps\nis the same as for the unordered representation. On the other hand, if\nwe search for items of many diﬀerent sizes we can expect that some-\ntimes we will be able to stop searching at a point near the beginning of\nthe list and that other times we will still need to examine most of the\nlist. On the average we should expect to have to examine about half of\n208\nthe items in the set. us, the average number of steps required will be\nabout n=2. is is still Θ(n)growth, but it does save us, on the average,\na factor of 2 in number of steps over the previous implementation. We obtain a more impressive speedup with intersection-set . In\nthe unordered representation this operation required Θ(n2)steps, be-\ncause we performed a complete scan of set2for each element of set1. But with the ordered representation, we can use a more clever method.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 405, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_sicp_abelson_chunk_0406_a56f437c", "text": "But with the ordered representation, we can use a more clever method. Begin by comparing the initial elements, x1andx2, of the two sets. If\nx1equals x2,thenthatgivesanelementoftheintersection,andtherest\nof the intersection is the intersection of the cdr-s of the two sets. Sup-\npose, however, that x1is less than x2. Since x2is the smallest element\ninset2, we can immediately conclude that x1cannot appear anywhere\ninset2and hence is not in the intersection. Hence, the intersection is\nequal to the intersection of set2with the cdrofset1. Similarly, if x2\nislessthan x1,thentheintersectionisgivenbytheintersectionof set1\nwith the cdrofset2. Here is the procedure:\n(define (intersection-set set1 set2 )\n(if(or(null? set1 ) (null?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 406, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 728}}
{"id": "computer_science_sicp_abelson_chunk_0407_e514d4cf", "text": "Similarly, if x2\nislessthan x1,thentheintersectionisgivenbytheintersectionof set1\nwith the cdrofset2. Here is the procedure:\n(define (intersection-set set1 set2 )\n(if(or(null? set1 ) (null? set2 ))\n'()\n(let ((x1(car set1 )) ( x2(car set2 )))\n(cond ((= x1x2)\n(cons x1(intersection-set (cdr set1 )\n(cdr set2 ))))\n((< x1x2)\n(intersection-set (cdr set1 )set2 ))\n((< x2x1)\n(intersection-set set1 (cdr set2 )))))))\nTo estimate the number of steps required by this process, observe that\nat each step we reduce the intersection problem to computing inter-\nsections of smaller sets—removing the ﬁrst element from set1orset2\n209\nor both. us, the number of steps required is at most the sum of the\nsizes of set1andset2, rather than the product of the sizes as with the\nunorderedrepresentation.isis Θ(n)growthratherthan Θ(n2)—acon-\nsiderable speedup, even for sets of moderate size. Exercise 2.61: Give an implementation of adjoin-set us-\ning the ordered representation. By analogy with element-\nof-set?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 407, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_sicp_abelson_chunk_0408_2f1e7873", "text": "Exercise 2.61: Give an implementation of adjoin-set us-\ning the ordered representation. By analogy with element-\nof-set? show how to take advantage of the ordering to\nproduceaprocedurethatrequiresontheaverageabouthalf\nas many steps as with the unordered representation. Exercise 2.62: Give a Θ(n)implementation of union-set\nfor sets represented as ordered lists. Sets as binary trees\nWe can do beer than the ordered-list representation by arranging the\nset elements in the form of a tree. Each node of the tree holds one ele-\nmentoftheset,calledthe“entry”atthatnode,andalinktoeachoftwo\nother (possibly empty) nodes. e “le” link points to elements smaller\nthan the one at the node, and the “right” link to elements greater than\nthe one at the node. Figure 2.16 shows some trees that represent the set\n{1;3;5;7;9;11}. e same set may be represented by a tree in a number\nof diﬀerent ways.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 408, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 889}}
{"id": "computer_science_sicp_abelson_chunk_0409_ccd6b816", "text": "Figure 2.16 shows some trees that represent the set\n{1;3;5;7;9;11}. e same set may be represented by a tree in a number\nof diﬀerent ways. e only thing we require for a valid representation\nis that all elements in the le subtree be smaller than the node entry\nand that all elements in the right subtree be larger. eadvantageofthetreerepresentationisthis:Supposewewantto\ncheckwhetheranumber xiscontainedinaset.Webeginbycomparing\nxwith the entry in the top node. If xis less than this, we know that we\nneed only search the le subtree; if xis greater, we need only search\nthe right subtree. Now, if the tree is “balanced,” each of these subtrees\n210\n7 3 5\n3 9 1 7 9 3\n1 11 5 9 1 7 11\n115Figure 2.16: Various binary trees that represent the set\n{1;3;5;7;9;11}. will be about half the size of the original. us, in one step we have\nreduced the problem of searching a tree of size nto searching a tree\nof size n=2.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 409, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 912}}
{"id": "computer_science_sicp_abelson_chunk_0410_14c203bd", "text": "will be about half the size of the original. us, in one step we have\nreduced the problem of searching a tree of size nto searching a tree\nof size n=2. Since the size of the tree is halved at each step, we should\nexpect that the number of steps needed to search a tree of size ngrows\nasΘ(logn).38For large sets, this will be a signiﬁcant speedup over the\nprevious representations. Wecanrepresenttreesbyusinglists.Eachnodewillbealistofthree\nitems:theentryatthenode,thelesubtree,andtherightsubtree.Ale\nor a right subtree of the empty list will indicate that there is no subtree\nconnected there. We can describe this representation by the following\nprocedures:39\n38Halving the size of the problem at each step is the distinguishing characteristic of\nlogarithmic growth, as we saw with the fast-exponentiation algorithm of Section 1.2.4\nand the half-interval search method of Section 1.3.3 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 410, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 889}}
{"id": "computer_science_sicp_abelson_chunk_0411_7b05a9d3", "text": "39We are representing sets in terms of trees, and trees in terms of lists—in eﬀect, a\ndata abstraction built upon a data abstraction. We can regard the procedures entry,\nleft-branch ,right-branch , and make-tree as a way of isolating the abstraction of a\n“binary tree” from the particular way we might wish to represent such a tree in terms\nof list structure. 211\n(define (entry tree ) (car tree ))\n(define (left-branch tree ) (cadr tree ))\n(define (right-branch tree ) (caddr tree ))\n(define (make-tree entry left right )\n(list entry left right ))\nNow we can write the element-of-set? procedure using the strategy\ndescribed above:\n(define (element-of-set? xset)\n(cond ((null? set)false )\n((= x(entry set))true )\n((< x(entry set))\n(element-of-set? x(left-branch set)))\n((> x(entry set))\n(element-of-set? x(right-branch set)))))\nAdjoining an item to a set is implemented similarly and also requires\nΘ(logn)steps.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 411, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_sicp_abelson_chunk_0412_0ce21c49", "text": "x(left-branch set)))\n((> x(entry set))\n(element-of-set? x(right-branch set)))))\nAdjoining an item to a set is implemented similarly and also requires\nΘ(logn)steps. To adjoin an item x, we compare xwith the node en-\ntry to determine whether xshould be added to the right or to the le\nbranch, and having adjoined xto the appropriate branch we piece this\nnewlyconstructedbranchtogetherwiththeoriginalentryandtheother\nbranch.If xisequaltotheentry,wejustreturnthenode.Ifweareasked\nto adjoin xto an empty tree, we generate a tree that has xas the entry\nand empty right and le branches. Here is the procedure:\n(define (adjoin-set xset)\n(cond ((null?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 412, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 644}}
{"id": "computer_science_sicp_abelson_chunk_0413_54992557", "text": "Here is the procedure:\n(define (adjoin-set xset)\n(cond ((null? set) (make-tree x'()'()))\n((= x(entry set))set)\n((< x(entry set))\n(make-tree (entry set)\n(adjoin-set x(left-branch set))\n(right-branch set)))\n((> x(entry set))\n212\n(make-tree (entry set) (left-branch set)\n(adjoin-set x(right-branch set))))))\ne above claim that searching the tree can be performed in a logarith-\nmic number of steps rests on the assumption that the tree is “balanced,”\ni.e., that the le and the right subtree of every tree have approximately\nthe same number of elements, so that each subtree contains about half\nthe elements of its parent. But how can we be certain that the trees we\nconstructwillbebalanced?Evenifwestartwithabalancedtree,adding\nelementswith adjoin-set mayproduceanunbalancedresult.Sincethe\npositionofanewlyadjoinedelementdependsonhowtheelementcom-\npareswiththeitemsalreadyintheset,wecanexpectthatifweaddele-\nments “randomly” the tree will tend to be balanced on the average. But\nthis is not a guarantee.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 413, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_sicp_abelson_chunk_0414_5e5775c7", "text": "But\nthis is not a guarantee. For example, if we start with an empty set and\nadjoin the numbers 1 through 7 in sequence we end up with the highly\nunbalanced tree shown in Figure 2.17 . In this tree all the le subtrees\nareempty,soithasnoadvantageoverasimpleorderedlist.Onewayto\nsolvethisproblemistodeﬁneanoperationthattransformsanarbitrary\ntree into a balanced tree with the same elements. en we can perform\nthis transformation aer every few adjoin-set operations to keep our\nset in balance. ere are also other ways to solve this problem, most of\nwhich involve designing new data structures for which searching and\ninsertion both can be done in Θ(logn)steps.40\nExercise 2.63: Each of the following two procedures con-\nverts a binary tree to a list. (define (tree->list-1 tree )\n(if(null? tree )\n40Examples of such structures include B-treesand red-black trees . ere is a large\nliterature on data structures devoted to this problem. See Cormen et al. 1990 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 414, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_sicp_abelson_chunk_0415_9b9b116a", "text": "tree )\n40Examples of such structures include B-treesand red-black trees . ere is a large\nliterature on data structures devoted to this problem. See Cormen et al. 1990 . 213\n1\n2\n3\n4\n5\n6\n7Figure 2.17: Unbalanced tree produced by adjoining 1\nthrough 7 in sequence. '()\n(append (tree->list-1 (left-branch tree ))\n(cons (entry tree )\n(tree->list-1\n(right-branch tree ))))))\n(define (tree->list-2 tree )\n(define (copy-to-list tree result-list )\n(if(null? tree )\nresult-list\n(copy-to-list (left-branch tree )\n(cons (entry tree )\n(copy-to-list\n(right-branch tree )\nresult-list )))))\n(copy-to-list tree '()))\na.Do the two procedures produce the same result for\neverytree?Ifnot,howdotheresultsdiﬀer?Whatlists\n214\ndo the two procedures produce for the trees in Figure\n2.16? b.Dothetwoprocedureshavethesameorderofgrowth\nin the number of steps required to convert a balanced\ntreewith nelementstoalist?Ifnot,whichonegrows\nmore slowly?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 415, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_sicp_abelson_chunk_0416_15aadeff", "text": "b.Dothetwoprocedureshavethesameorderofgrowth\nin the number of steps required to convert a balanced\ntreewith nelementstoalist?Ifnot,whichonegrows\nmore slowly? Exercise 2.64: e following procedure list->tree con-\nverts an ordered list to a balanced binary tree. e helper\nprocedure partial-tree takes as arguments an integer n\nand list of at least nelements and constructs a balanced\ntreecontainingtheﬁrst nelementsofthelist.eresultre-\nturnedby partial-tree isapair(formedwith cons)whose\ncaris the constructed tree and whose cdris the list of ele-\nments not included in the tree.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 416, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 579}}
{"id": "computer_science_sicp_abelson_chunk_0417_66c41f64", "text": "(define (list->tree elements )\n(car (partial-tree elements (length elements ))))\n(define (partial-tree elts n)\n(if(=n0)\n(cons '()elts )\n(let ((left-size (quotient (-n1) 2)))\n(let ((left-result\n(partial-tree elts left-size )))\n(let ((left-tree (car left-result ))\n(non-left-elts (cdr left-result ))\n(right-size (-n(+left-size 1))))\n(let ((this-entry (car non-left-elts ))\n(right-result\n(partial-tree\n(cdr non-left-elts )\nright-size )))\n215\n(let ((right-tree (car right-result ))\n(remaining-elts\n(cdr right-result )))\n(cons (make-tree this-entry\nleft-tree\nright-tree )\nremaining-elts ))))))))\na.Write a short paragraph explaining as clearly as you\ncanhow partial-tree works.Drawthetreeproduced\nbylist->tree for the list (1 3 5 7 9 11) . b.Whatistheorderofgrowthinthenumberofstepsre-\nquired by list->tree to convert a list of nelements?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 417, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 833}}
{"id": "computer_science_sicp_abelson_chunk_0418_c5e83774", "text": "b.Whatistheorderofgrowthinthenumberofstepsre-\nquired by list->tree to convert a list of nelements? Exercise 2.65: Use the results of Exercise 2.63 andExer-\ncise 2.64 to give Θ(n)implementations of union-set and\nintersection-set for sets implemented as (balanced) bi-\nnary trees.41\nSets and information retrieval\nWe have examined options for using lists to represent sets and have\nseen how the choice of representation for a data object can have a large\nimpact on the performance of the programs that use the data. Another\nreason for concentrating on sets is that the techniques discussed here\nappear again and again in applications involving information retrieval. Consideradatabasecontainingalargenumberofindividualrecords,\nsuch as the personnel ﬁles for a company or the transactions in an ac-\ncounting system. A typical data-management system spends a large\n41Exercise 2.63 through Exercise 2.65 are due to Paul Hilﬁnger.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 418, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_sicp_abelson_chunk_0419_40c08b1e", "text": "A typical data-management system spends a large\n41Exercise 2.63 through Exercise 2.65 are due to Paul Hilﬁnger. 216\namount of time accessing or modifying the data in the records and\nthereforerequiresaneﬃcientmethodforaccessingrecords.isisdone\nby identifying a part of each record to serve as an identifying key. A\nkeycanbeanythingthatuniquelyidentiﬁestherecord.Forapersonnel\nﬁle, it might be an employee’s number. For an accounting system, it\nmightbeatransactionnumber.Whateverthekeyis,whenwedeﬁnethe\nrecord as a data structure we should include a keyselector procedure\nthat retrieves the key associated with a given record. Now we represent the data base as a set of records. To locate the\nrecord with a given key we use a procedure lookup, which takes as\narguments a key and a data base and which returns the record that has\nthat key, or false if there is no such record. lookupis implemented in\nalmost the same way as element-of-set? .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 419, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 941}}
{"id": "computer_science_sicp_abelson_chunk_0420_967826fe", "text": "lookupis implemented in\nalmost the same way as element-of-set? . For example, if the set of\nrecords is implemented as an unordered list, we could use\n(define (lookup given-key set-of-records )\n(cond ((null? set-of-records )false )\n((equal? given-key (key (car set-of-records )))\n(car set-of-records ))\n(else (lookup given-key (cdr set-of-records )))))\nOf course, there are beer ways to represent large sets than as un-\norderedlists.Information-retrievalsystemsinwhichrecordshavetobe\n“randomlyaccessed”aretypicallyimplementedbyatree-basedmethod,\nsuch as the binary-tree representation discussed previously. In design-\ning such a system the methodology of data abstraction can be a great\nhelp. e designer can create an initial implementation using a sim-\nple, straightforward representation such as unordered lists. is will be\nunsuitable for the eventual system, but it can be useful in providing a\n“quick and dirty” data base with which to test the rest of the system.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 420, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_sicp_abelson_chunk_0421_f41dc6db", "text": "is will be\nunsuitable for the eventual system, but it can be useful in providing a\n“quick and dirty” data base with which to test the rest of the system. Later on, the data representation can be modiﬁed to be more sophisti-\n217\ncated.Ifthedatabaseisaccessedintermsofabstractselectorsandcon-\nstructors, this change in representation will not require any changes to\nthe rest of the system. Exercise2.66: Implementthe lookupprocedureforthecase\nwhere the set of records is structured as a binary tree, or-\ndered by the numerical values of the keys. 2.3.4Example: Huﬀman Encoding Trees\nis section provides practice in the use of list structure and data ab-\nstractiontomanipulatesetsandtrees.eapplicationistomethodsfor\nrepresenting data as sequences of ones and zeros (bits). For example,\nthestandard code used to represent text in computers encodes\neach character as a sequence of seven bits. Using seven bits allows us\nto distinguish 27, or 128, possible diﬀerent characters.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 421, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_sicp_abelson_chunk_0422_6d8aee14", "text": "Using seven bits allows us\nto distinguish 27, or 128, possible diﬀerent characters. In general, if we\nwant to distinguish ndiﬀerent symbols, we will need to use log2nbits\nper symbol. If all our messages are made up of the eight symbols A, B,\nC, D, E, F, G, and H, we can choose a code with three bits per character,\nfor example\nA 000 C 010 E 100 G 110\nB 001 D 011 F 101 H 111\nWith this code, the message\nBACADAEAFABBAAAGAH\nis encoded as the string of 54 bits\n001000010000011000100000101000001001000000000110000111\n218\nCodes such as and the A-through-H code above are known as\nﬁxed-length codes, because they represent each symbol in the message\nwiththesamenumberofbits.Itissometimesadvantageoustouse variable-\nlengthcodes, in which diﬀerent symbols may be represented by diﬀer-\nent numbers of bits. For example, Morse code does not use the same\nnumber of dots and dashes for each leer of the alphabet. In particular,\nE, the most frequent leer, is represented by a single dot.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 422, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_sicp_abelson_chunk_0423_23e0edc7", "text": "For example, Morse code does not use the same\nnumber of dots and dashes for each leer of the alphabet. In particular,\nE, the most frequent leer, is represented by a single dot. In general, if\nour messages are such that some symbols appear very frequently and\nsome very rarely, we can encode data more eﬃciently (i.e., using fewer\nbits per message) if we assign shorter codes to the frequent symbols. Consider the following alternative code for the leers A through H:\nA 0 C 1010 E 1100 G 1110\nB 100 D 1011 F 1101 H 1111\nWith this code, the same message as above is encoded as the string\n100010100101101100011010100100000111001111\nis string contains 42 bits, so it saves more than 20% in space in com-\nparison with the ﬁxed-length code shown above. One of the diﬃculties of using a variable-length code is knowing\nwhen you have reached the end of a symbol in reading a sequence of\nzeros and ones.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 423, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 898}}
{"id": "computer_science_sicp_abelson_chunk_0424_38691d52", "text": "One of the diﬃculties of using a variable-length code is knowing\nwhen you have reached the end of a symbol in reading a sequence of\nzeros and ones. Morse code solves this problem by using a special sep-\narator code (in this case, a pause) aer the sequence of dots and dashes\nforeachleer.Anothersolutionistodesignthecodeinsuchawaythat\nnocompletecodeforanysymbolisthebeginning(or preﬁx)ofthecode\nfor another symbol. Such a code is called a preﬁx code . In the example\nabove, A is encoded by 0 and B is encoded by 100, so no other symbol\ncan have a code that begins with 0 or with 100. 219\nIngeneral,wecanaainsigniﬁcantsavingsifweusevariable-length\npreﬁx codes that take advantage of the relative frequencies of the sym-\nbols in the messages to be encoded. One particular scheme for doing\nthis is called the Huﬀman encoding method, aer its discoverer, David\nHuﬀman. A Huﬀman code can be represented as a binary tree whose\nleaves are the symbols that are encoded.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 424, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_sicp_abelson_chunk_0425_563cdf2f", "text": "A Huﬀman code can be represented as a binary tree whose\nleaves are the symbols that are encoded. At each non-leaf node of the\ntree there is a set containing all the symbols in the leaves that lie below\nthe node. In addition, each symbol at a leaf is assigned a weight (which\nis its relative frequency), and each non-leaf node contains a weight that\nis the sum of all the weights of the leaves lying below it. e weights\narenotusedintheencodingorthedecodingprocess.Wewillseebelow\nhow they are used to help construct the tree. Figure2.18 showstheHuﬀmantreefortheA-through-Hcodegiven\nabove. e weights at the leaves indicate that the tree was designed for\nmessages in which A appears with relative frequency 8, B with relative\nfrequency 3, and the other leers each with relative frequency 1. Given a Huﬀman tree, we can ﬁnd the encoding of any symbol by\nstarting at the root and moving down until we reach the leaf that holds\nthe symbol.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 425, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_sicp_abelson_chunk_0426_51c4a3ba", "text": "Given a Huﬀman tree, we can ﬁnd the encoding of any symbol by\nstarting at the root and moving down until we reach the leaf that holds\nthe symbol. Each time we move down a le branch we add a 0 to the\ncode, and each time we move down a right branch we add a 1. (We\ndecide which branch to follow by testing to see which branch either\nis the leaf node for the symbol or contains the symbol in its set.) For\nexample, starting from the root of the tree in Figure 2.18 , we arrive at\ntheleafforDbyfollowingarightbranch,thenalebranch,thenaright\nbranch, then a right branch; hence, the code for D is 1011. TodecodeabitsequenceusingaHuﬀmantree,webeginattheroot\nand use the successive zeros and ones of the bit sequence to determine\nwhether to move down the le or the right branch.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 426, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 773}}
{"id": "computer_science_sicp_abelson_chunk_0427_45565e05", "text": "TodecodeabitsequenceusingaHuﬀmantree,webeginattheroot\nand use the successive zeros and ones of the bit sequence to determine\nwhether to move down the le or the right branch. Each time we come\nto a leaf, we have generated a new symbol in the message, at which\n220\n{A B C D E F G H} 17\n{B C D E F G H} 9\nA 8\n{B C D} 5\n{C D} 2\nD 1 C 1B 3{E F G H} 4\n{G H} 2{E F} 2\nE 1 F 1\nH 1 G 1Figure 2.18: A Huﬀman encoding tree. point we start over from the root of the tree to ﬁnd the next symbol. For example, suppose we are given the tree above and the sequence\n10001010. Starting at the root, we move down the right branch, (since\ntheﬁrstbitofthestringis1),thendownthelebranch(sincethesecond\nbit is 0), then down the le branch (since the third bit is also 0). is\nbrings us to the leaf for B, so the ﬁrst symbol of the decoded message is\nB. Now we start again at the root, and we make a le move because the\nnext bit in the string is 0. is brings us to the leaf for A.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 427, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_sicp_abelson_chunk_0428_ae0fc947", "text": "Now we start again at the root, and we make a le move because the\nnext bit in the string is 0. is brings us to the leaf for A. en we start\nagain at the root with the rest of the string 1010, so we move right, le,\nright, le and reach C. us, the entire message is BAC. Generating Huﬀman trees\nGiven an “alphabet” of symbols and their relative frequencies, how do\nwe construct the “best” code? (In other words, which tree will encode\nmessages with the fewest bits?) Huﬀman gave an algorithm for doing\n221\nthis and showed that the resulting code is indeed the best variable-\nlength code for messages where the relative frequency of the symbols\nmatches the frequencies with which the code was constructed. We will\nnot prove this optimality of Huﬀman codes here, but we will show how\nHuﬀman trees are constructed.42\nealgorithmforgeneratingaHuﬀmantreeisverysimple.eidea\nis to arrange the tree so that the symbols with the lowest frequency\nappear farthest away from the root.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 428, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_sicp_abelson_chunk_0429_8ae2749a", "text": "Begin with the set of leaf nodes,\ncontaining symbols and their frequencies, as determined by the initial\ndatafromwhichthecodeistobeconstructed.Nowﬁndtwoleaveswith\nthe lowest weights and merge them to produce a node that has these\ntwo nodes as its le and right branches. e weight of the new node is\nthe sum of the two weights. Remove the two leaves from the original\nset and replace them by this new node. Now continue this process. At\neach step, merge two nodes with the smallest weights, removing them\nfrom the set and replacing them with a node that has these two as its\nle and right branches. e process stops when there is only one node\nle, which is the root of the entire tree.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 429, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 686}}
{"id": "computer_science_sicp_abelson_chunk_0430_82536e4f", "text": "e process stops when there is only one node\nle, which is the root of the entire tree. Here is how the Huﬀman tree\nofFigure 2.18 was generated:\nInitial leaves {(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)}\nMerge {(A 8) (B 3) ({C D} 2) (E 1) (F 1) (G 1) (H 1)}\nMerge {(A 8) (B 3) ({C D} 2) ({E F} 2) (G 1) (H 1)}\nMerge {(A 8) (B 3) ({C D} 2) ({E F} 2) ({G H} 2)}\nMerge {(A 8) (B 3) ({C D} 2) ({E F G H} 4)}\nMerge {(A 8) ({B C D} 5) ({E F G H} 4)}\nMerge {(A 8) ({B C D E F G H} 9)}\nFinal merge {({A B C D E F G H} 17)}\n42SeeHamming 1980 for a discussion of the mathematical properties of Huﬀman\ncodes. 222\nealgorithmdoesnotalwaysspecifyauniquetree,becausetheremay\nnotbeuniquesmallest-weightnodesateachstep.Also,thechoiceofthe\norder in which the two nodes are merged (i.e., which will be the right\nbranch and which will be the le branch) is arbitrary.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 430, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 854}}
{"id": "computer_science_sicp_abelson_chunk_0431_ff5635ae", "text": "Representing Huﬀman trees\nIn the exercises below we will work with a system that uses Huﬀman\ntrees to encode and decode messages and generates Huﬀman trees ac-\ncording to the algorithm outlined above. We will begin by discussing\nhow trees are represented. Leaves of the tree are represented by a list consisting of the symbol\nleaf, the symbol at the leaf, and the weight:\n(define (make-leaf symbol weight ) (list 'leaf symbol weight ))\n(define (leaf? object ) (eq? (car object )'leaf ))\n(define (symbol-leaf x) (cadr x))\n(define (weight-leaf x) (caddr x))\nA general tree will be a list of a le branch, a right branch, a set of\nsymbols, and a weight. e set of symbols will be simply a list of the\nsymbols,ratherthansomemoresophisticatedsetrepresentation.When\nwe make a tree by merging two nodes, we obtain the weight of the\ntree as the sum of the weights of the nodes, and the set of symbols as\nthe union of the sets of symbols for the nodes.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 431, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 943}}
{"id": "computer_science_sicp_abelson_chunk_0432_3a2a1dd3", "text": "Since our symbol sets\nare represented as lists, we can form the union by using the append\nprocedure we deﬁned in Section 2.2.1 :\n(define (make-code-tree left right )\n(list left\nright\n(append (symbols left ) (symbols right ))\n(+ ( weight left ) (weight right ))))\n223\nIf we make a tree in this way, we have the following selectors:\n(define (left-branch tree ) (car tree ))\n(define (right-branch tree ) (cadr tree ))\n(define (symbols tree )\n(if(leaf? tree )\n(list (symbol-leaf tree ))\n(caddr tree )))\n(define (weight tree )\n(if(leaf? tree )\n(weight-leaf tree )\n(cadddr tree )))\ne procedures symbols andweightmust do something slightly diﬀer-\nent depending on whether they are called with a leaf or a general tree. ese are simple examples of generic procedures (procedures that can\nhandle more than one kind of data), which we will have much more to\nsay about in Section 2.4 andSection 2.5 . The decoding procedure\ne following procedure implements the decoding algorithm.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 432, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_sicp_abelson_chunk_0433_c007eeba", "text": "The decoding procedure\ne following procedure implements the decoding algorithm. It takes\nas arguments a list of zeros and ones, together with a Huﬀman tree. (define (decode bits tree )\n(define (decode-1 bits current-branch )\n(if(null? bits )\n'()\n(let ((next-branch\n(choose-branch (car bits )current-branch )))\n(if(leaf? next-branch )\n(cons (symbol-leaf next-branch )\n(decode-1 (cdr bits )tree ))\n(decode-1 (cdr bits )next-branch )))))\n(decode-1 bits tree ))\n224\n(define (choose-branch bit branch )\n(cond ((= bit 0) ( left-branch branch ))\n((= bit 1) ( right-branch branch ))\n(else (error \"bad bit:CHOOSE-BRANCH \"bit))))\neprocedure decode-1 takestwoarguments:thelistofremainingbits\nand the current position in the tree. It keeps moving “down” the tree,\nchoosingaleorarightbranchaccordingtowhetherthenextbitinthe\nlist is a zero or a one.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 433, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 838}}
{"id": "computer_science_sicp_abelson_chunk_0434_ca55d561", "text": "It keeps moving “down” the tree,\nchoosingaleorarightbranchaccordingtowhetherthenextbitinthe\nlist is a zero or a one. (is is done with the procedure choose-branch .)\nWhen it reaches a leaf, it returns the symbol at that leaf as the next\nsymbol in the message by consing it onto the result of decoding the\nrest of the message, starting at the root of the tree. Note the error check\nin the ﬁnal clause of choose-branch , which complains if the procedure\nﬁnds something other than a zero or a one in the input data. Sets of weighted elements\nInourrepresentationoftrees,eachnon-leafnodecontainsasetofsym-\nbols, which we have represented as a simple list. However, the tree-\ngenerating algorithm discussed above requires that we also work with\nsets of leaves and trees, successively merging the two smallest items. Since we will be required to repeatedly ﬁnd the smallest item in a set, it\nis convenient to use an ordered representation for this kind of set.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 434, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_sicp_abelson_chunk_0435_d0dd003b", "text": "Since we will be required to repeatedly ﬁnd the smallest item in a set, it\nis convenient to use an ordered representation for this kind of set. We will represent a set of leaves and trees as a list of elements, ar-\nranged in increasing order of weight. e following adjoin-set pro-\ncedure for constructing sets is similar to the one described in Exercise\n2.61; however, items are compared by their weights, and the element\nbeing added to the set is never already in it. (define (adjoin-set xset)\n(cond ((null? set) (list x))\n((< ( weight x) (weight (car set))) ( cons xset))\n225\n(else (cons (car set)\n(adjoin-set x(cdr set))))))\ne following procedure takes a list of symbol-frequency pairs such as\n((A 4) (B 2) (C 1) (D 1)) and constructs an initial ordered set of\nleaves, ready to be merged according to the Huﬀman algorithm:\n(define (make-leaf-set pairs )\n(if(null?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 435, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 868}}
{"id": "computer_science_sicp_abelson_chunk_0436_43253af7", "text": "pairs )\n'()\n(let ((pair (car pairs )))\n(adjoin-set (make-leaf (car pair ); symbol\n(cadr pair )); frequency\n(make-leaf-set (cdr pairs ))))))\nExercise 2.67: Deﬁne an encoding tree and a sample mes-\nsage:\n(define sample-tree\n(make-code-tree (make-leaf 'A4)\n(make-code-tree\n(make-leaf 'B2)\n(make-code-tree\n(make-leaf 'D1)\n(make-leaf 'C1)))))\n(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))\nUse the decodeprocedure to decode the message, and give\nthe result. Exercise2.68: eencodeprocedure takes as arguments a\nmessage and a tree and produces the list of bits that gives\nthe encoded message. 226\n(define (encode message tree )\n(if(null? message )\n'()\n(append (encode-symbol (car message )tree )\n(encode (cdr message )tree ))))\nencode-symbol is a procedure, which you must write, that\nreturns the list of bits that encodes a given symbol accord-\ning to a given tree. You should design encode-symbol so\nthat it signals an error if the symbol is not in the tree at all.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 436, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_sicp_abelson_chunk_0437_2c2ea80d", "text": "You should design encode-symbol so\nthat it signals an error if the symbol is not in the tree at all. Testyourprocedurebyencodingtheresultyouobtainedin\nExercise 2.67 with the sample tree and seeing whether it is\nthe same as the original sample message. Exercise 2.69: e following procedure takes as its argu-\nment a list of symbol-frequency pairs (where no symbol\nappears in more than one pair) and generates a Huﬀman\nencoding tree according to the Huﬀman algorithm. (define (generate-huffman-tree pairs )\n(successive-merge (make-leaf-set pairs )))\nmake-leaf-set is the procedure given above that trans-\nformsthelistofpairsintoanorderedsetofleaves.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 437, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 648}}
{"id": "computer_science_sicp_abelson_chunk_0438_59d320ae", "text": "(define (generate-huffman-tree pairs )\n(successive-merge (make-leaf-set pairs )))\nmake-leaf-set is the procedure given above that trans-\nformsthelistofpairsintoanorderedsetofleaves. successive-\nmergeis the procedure you must write, using make-code-\ntreeto successively merge the smallest-weight elements\nof the set until there is only one element le, which is the\ndesiredHuﬀmantree.(isprocedureisslightlytricky,but\nnotreallycomplicated.Ifyouﬁndyourselfdesigningacom-\nplex procedure, then you are almost certainly doing some-\nthing wrong. You can take signiﬁcant advantage of the fact\nthat we are using an ordered set representation.)\n227\nExercise 2.70: e following eight-symbol alphabet with\nassociated relative frequencies was designed to eﬃciently\nencode the lyrics of 1950s rock songs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 438, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 791}}
{"id": "computer_science_sicp_abelson_chunk_0439_f041ce99", "text": "(Note that the “sym-\nbols” of an “alphabet” need not be individual leers.)\nA 2 GET 2 SHA 3 WAH 1\nBOOM 1 JOB 2 NA 16 YIP 9\nUsegenerate-huffman-tree (Exercise 2.69 ) to generate a\ncorrespondingHuﬀmantree,anduse encode(Exercise2.68 )\nto encode the following message:\nGet a job\nSha na na na na na na na na\nGet a job\nSha na na na na na na na na\nWah yip yip yip yip yip yip yip yip yip\nSha boom\nHow many bits are required for the encoding? What is the\nsmallestnumberofbitsthatwouldbeneededtoencodethis\nsong if we used a ﬁxed-length code for the eight-symbol\nalphabet? Exercise 2.71: Suppose we have a Huﬀman tree for an al-\nphabet of nsymbols, and that the relative frequencies of\nthe symbols are 1 ;2;4; : : : ;2n\u00001. Sketch the tree for n=5;\nforn=10. In such a tree (for general n) how many bits\narerequiredtoencodethemostfrequentsymbol?eleast\nfrequent symbol? 228\nExercise 2.72: Consider the encoding procedure that you\ndesigned in Exercise 2.68 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 439, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_sicp_abelson_chunk_0440_e59ba2c7", "text": "In such a tree (for general n) how many bits\narerequiredtoencodethemostfrequentsymbol?eleast\nfrequent symbol? 228\nExercise 2.72: Consider the encoding procedure that you\ndesigned in Exercise 2.68 . What is the order of growth in\nthe number of steps needed to encode a symbol? Be sure\nto include the number of steps needed to search the sym-\nbol list at each node encountered. To answer this question\nin general is diﬃcult. Consider the special case where the\nrelativefrequenciesofthe nsymbolsareasdescribedin Ex-\nercise2.71 ,andgivetheorderofgrowth(asafunctionof n)\nof the number of steps needed to encode the most frequent\nand least frequent symbols in the alphabet. 2.4Multiple Representations for Abstract Data\nWe have introduced data abstraction, a methodology for structuring\nsystemsinsuchawaythatmuchofaprogramcanbespeciﬁedindepen-\ndent of the choices involved in implementing the data objects that the\nprogram manipulates.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 440, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_sicp_abelson_chunk_0441_8a667e2d", "text": "For example, we saw in Section 2.1.1 how to sep-\narate the task of designing a program that uses rational numbers from\nthe task of implementing rational numbers in terms of the computer\nlanguage’s primitive mechanisms for constructing compound data. e\nkey idea was to erect an abstraction barrier—in this case, the selec-\ntors and constructors for rational numbers ( make-rat ,numer,denom)—\nthat isolates the way rational numbers are used from their underlying\nrepresentation in terms of list structure. A similar abstraction barrier\nisolates the details of the procedures that perform rational arithmetic\n(add-rat ,sub-rat ,mul-rat , and div-rat ) from the “higher-level” pro-\nceduresthatuserationalnumbers.eresultingprogramhasthestruc-\nture shown in Figure 2.1 . ese data-abstraction barriers are powerful tools for controlling\n229\ncomplexity.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 441, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 848}}
{"id": "computer_science_sicp_abelson_chunk_0442_3c490bd6", "text": "ese data-abstraction barriers are powerful tools for controlling\n229\ncomplexity. By isolating the underlying representations of data objects,\nwe can divide the task of designing a large program into smaller tasks\nthatcanbeperformedseparately.Butthiskindofdataabstractionisnot\nyet powerful enough, because it may not always make sense to speak\nof “the underlying representation” for a data object. For one thing, there might be more than one useful representation\nforadataobject,andwemightliketodesignsystemsthatcandealwith\nmultiple representations. To take a simple example, complex numbers\nmayberepresentedintwoalmostequivalentways:inrectangularform\n(real and imaginary parts) and in polar form (magnitude and angle). Sometimes rectangular form is more appropriate and sometimes polar\nform is more appropriate.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 442, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 812}}
{"id": "computer_science_sicp_abelson_chunk_0443_39af39a3", "text": "Sometimes rectangular form is more appropriate and sometimes polar\nform is more appropriate. Indeed, it is perfectly plausible to imagine a\nsystem in which complex numbers are represented in both ways, and\nin which the procedures for manipulating complex numbers work with\neither representation. Moreimportantly,programmingsystemsareoendesignedbymany\npeople working over extended periods of time, subject to requirements\nthat change over time. In such an environment, it is simply not possi-\nble for everyone to agree in advance on choices of data representation. So in addition to the data-abstraction barriers that isolate representa-\ntion from use, we need abstraction barriers that isolate diﬀerent de-\nsign choices from each other and permit diﬀerent choices to coexist in\na single program.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 443, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 796}}
{"id": "computer_science_sicp_abelson_chunk_0444_aa437439", "text": "Furthermore, since large programs are oen created\nby combining pre-existing modules that were designed in isolation, we\nneedconventionsthatpermitprogrammerstoincorporatemodulesinto\nlargersystems additively ,thatis,withouthavingtoredesignorreimple-\nment these modules. In this section, we will learn how to cope with data that may be\nrepresented in diﬀerent ways by diﬀerent parts of a program. is re-\n230\nquires constructing generic procedures —procedures that can operate on\ndatathatmayberepresentedinmorethanoneway.Ourmaintechnique\nfor building generic procedures will be to work in terms of data objects\nthathave type tags ,thatis,dataobjectsthatincludeexplicitinformation\nabout how they are to be processed. We will also discuss data-directed\nprogramming, a powerful and convenient implementation strategy for\nadditively assembling systems with generic operations. We begin with the simple complex-number example.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 444, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 919}}
{"id": "computer_science_sicp_abelson_chunk_0445_cd1563db", "text": "We begin with the simple complex-number example. We will see\nhow type tags and data-directed style enable us to design separate rect-\nangular and polar representations for complex numbers while main-\ntainingthenotionofanabstract“complex-number”dataobject.Wewill\naccomplishthisbydeﬁningarithmeticproceduresforcomplexnumbers\n(add-complex ,sub-complex ,mul-complex , and div-complex ) in terms\nof generic selectors that access parts of a complex number independent\nof how the number is represented. e resulting complex-number sys-\ntem, as shown in Figure 2.19 , contains two diﬀerent kinds of abstrac-\ntion barriers. e “horizontal” abstraction barriers play the same role\nas the ones in Figure 2.1 . ey isolate “higher-level” operations from\n“lower-level” representations. In addition, there is a “vertical” barrier\nthat gives us the ability to separately design and install alternative rep-\nresentations.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 445, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 905}}
{"id": "computer_science_sicp_abelson_chunk_0446_9dd6fdf8", "text": "In addition, there is a “vertical” barrier\nthat gives us the ability to separately design and install alternative rep-\nresentations. InSection 2.5 we will show how to use type tags and data-directed\nstyle to develop a generic arithmetic package. is provides procedures\n(add,mul, and so on) that can be used to manipulate all sorts of “num-\nbers”andcanbeeasilyextendedwhenanewkindofnumberisneeded. InSection 2.5.3 , we’ll show how to use generic arithmetic in a system\nthat performs symbolic algebra. 231\nadd-complex sub-complex mul-complex div-complexPrograms that use complex numbers\nComplex-arithmetic package\nRectangular\nrepresentationPolar\nrepresentation\nList structure and primitive machine arithmeticFigure 2.19: Data-abstraction barriers in the complex-\nnumber system. 2.4.1Representations for Complex Numbers\nWe will develop a system that performs arithmetic operations on com-\nplexnumbersasasimplebutunrealisticexampleofaprogramthatuses\ngeneric operations.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 446, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_sicp_abelson_chunk_0447_83498220", "text": "2.4.1Representations for Complex Numbers\nWe will develop a system that performs arithmetic operations on com-\nplexnumbersasasimplebutunrealisticexampleofaprogramthatuses\ngeneric operations. We begin by discussing two plausible representa-\ntions for complex numbers as ordered pairs: rectangular form (real part\nand imaginary part) and polar form (magnitude and angle).43Section\n2.4.2will show how both representations can be made to coexist in a\nsingle system through the use of type tags and generic operations. Like rational numbers, complex numbers are naturally represented\nas ordered pairs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 447, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 595}}
{"id": "computer_science_sicp_abelson_chunk_0448_ab90f805", "text": "Like rational numbers, complex numbers are naturally represented\nas ordered pairs. e set of complex numbers can be thought of as a\ntwo-dimensionalspacewithtwoorthogonalaxes,the“real”axisandthe\n43Inactualcomputationalsystems,rectangularformispreferabletopolarformmost\nof the time because of roundoﬀ errors in conversion between rectangular and polar\nform.isiswhythecomplex-numberexampleisunrealistic.Nevertheless,itprovides\na clear illustration of the design of a system using generic operations and a good intro-\nduction to the more substantial systems to be developed later in this chapter. 232\nImaginary\nRealz = x + iy = reiA\nAy\nxrFigure 2.20: Complex numbers as points in the plane. “imaginary”axis.(See Figure2.20 .)Fromthispointofview,thecomplex\nnumber z=x+iy(where i2=\u00001) can be thought of as the point in the\nplane whose real coordinate is xand whose imaginary coordinate is y.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 448, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_sicp_abelson_chunk_0449_1fccf1e5", "text": "“imaginary”axis.(See Figure2.20 .)Fromthispointofview,thecomplex\nnumber z=x+iy(where i2=\u00001) can be thought of as the point in the\nplane whose real coordinate is xand whose imaginary coordinate is y. Additionofcomplexnumbersreducesinthisrepresentationtoaddition\nof coordinates:\nReal-part (z1+z2)=Real-part (z1)+ Real-part (z2);\nImaginary-part (z1+z2)=Imaginary-part (z1)+ Imaginary-part (z2):\nWhen multiplying complex numbers, it is more natural to think in\nterms of representing a complex number in polar form, as a magnitude\nandanangle( randAinFigure2.20 ).eproductoftwocomplexnum-\nbers is the vector obtained by stretching one complex number by the\nlength of the other and then rotating it through the angle of the other:\nMagnitude (z1\u0001z2)=Magnitude (z1)\u0001Magnitude (z2);\nAngle (z1\u0001z2)=Angle (z1)+ Angle (z2):\nus,therearetwodiﬀerentrepresentationsforcomplexnumbers,which\n233\nareappropriatefordiﬀerentoperations.Yet,fromtheviewpointofsome-\nonewritingaprogramthatusescomplexnumbers,theprincipleofdata\nabstraction suggests that all the operations for manipulating complex\nnumbers should be available regardless of which representation is used\nby the computer.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 449, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1159}}
{"id": "computer_science_sicp_abelson_chunk_0450_b29296b6", "text": "For example, it is oen useful to be able to ﬁnd the\nmagnitude of a complex number that is speciﬁed by rectangular coor-\ndinates. Similarly, it is oen useful to be able to determine the real part\nof a complex number that is speciﬁed by polar coordinates. To design such a system, we can follow the same data-abstraction\nstrategy we followed in designing the rational-number package in Sec-\ntion 2.1.1 . Assume that the operations on complex numbers are imple-\nmented in terms of four selectors: real-part ,imag-part ,magnitude\nand angle. Also assume that we have two procedures for construct-\ning complex numbers: make-from-real-imag returns a complex num-\nber with speciﬁed real and imaginary parts, and make-from-mag-ang\nreturns a complex number with speciﬁed magnitude and angle. ese\nprocedures have the property that, for any complex number z, both\n(make-from-real-imag (real-part z) (imag-part z))\nand\n(make-from-mag-ang (magnitude z) (angle z))\nproduce complex numbers that are equal to z.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 450, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 997}}
{"id": "computer_science_sicp_abelson_chunk_0451_efff0d71", "text": "Using these constructors and selectors, we can implement arith-\nmetic on complex numbers using the “abstract data” speciﬁed by the\nconstructors and selectors, just as we did for rational numbers in Sec-\ntion 2.1.1 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 451, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 215}}
{"id": "computer_science_sicp_abelson_chunk_0452_be9033e9", "text": "As shown in the formulas above, we can add and subtract\ncomplex numbers in terms of real and imaginary parts while multiply-\ning and dividing complex numbers in terms of magnitudes and angles:\n234\n(define (add-complex z1z2)\n(make-from-real-imag (+ ( real-part z1) (real-part z2))\n(+ ( imag-part z1) (imag-part z2))))\n(define (sub-complex z1z2)\n(make-from-real-imag (- ( real-part z1) (real-part z2))\n(- ( imag-part z1) (imag-part z2))))\n(define (mul-complex z1z2)\n(make-from-mag-ang (* ( magnitude z1) (magnitude z2))\n(+ ( angle z1) (angle z2))))\n(define (div-complex z1z2)\n(make-from-mag-ang (/ ( magnitude z1) (magnitude z2))\n(- ( angle z1) (angle z2))))\nTo complete the complex-number package, we must choose a represen-\ntation and we must implement the constructors and selectors in terms\nof primitive numbers and primitive list structure.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 452, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 843}}
{"id": "computer_science_sicp_abelson_chunk_0453_0993c72f", "text": "ere are two obvi-\nouswaystodothis:Wecanrepresentacomplexnumberin“rectangular\nform” as a pair (real part, imaginary part) or in “polar form” as a pair\n(magnitude, angle). Which shall we choose? In order to make the diﬀerent choices concrete, imagine that there\nare two programmers, Ben Bitdiddle and Alyssa P. Hacker, who are\nindependently designing representations for the complex-number sys-\ntem. Ben chooses to represent complex numbers in rectangular form. With this choice, selecting the real and imaginary parts of a complex\nnumber is straightforward, as is constructing a complex number with\ngiven real and imaginary parts.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 453, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 630}}
{"id": "computer_science_sicp_abelson_chunk_0454_8438c4a8", "text": "With this choice, selecting the real and imaginary parts of a complex\nnumber is straightforward, as is constructing a complex number with\ngiven real and imaginary parts. To ﬁnd the magnitude and the angle, or\nto construct a complex number with a given magnitude and angle, he\nuses the trigonometric relations\nx=rcosA; r=√\nx2+y2;\ny=rsinA; A=arctan (y;x);\nwhichrelatetherealandimaginaryparts (x;y)tothemagnitudeandthe\n235\nangle (r;A).44Ben’s representation is therefore given by the following\nselectors and constructors:\n(define (real-part z) (car z))\n(define (imag-part z) (cdr z))\n(define (magnitude z)\n(sqrt (+ ( square (real-part z))\n(square (imag-part z)))))\n(define (angle z)\n(atan (imag-part z) (real-part z)))\n(define (make-from-real-imag xy) (cons xy))\n(define (make-from-mag-ang ra)\n(cons (*r(cos a)) (* r(sin a))))\nAlyssa,incontrast,choosestorepresentcomplexnumbersinpolarform.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 454, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_sicp_abelson_chunk_0455_0e317b45", "text": "For her, selecting the magnitude and angle is straightforward, but she\nhas to use the trigonometric relations to obtain the real and imaginary\nparts. Alyssa’s representation is:\n(define (real-part z) (* ( magnitude z) (cos (angle z))))\n(define (imag-part z) (* ( magnitude z) (sin (angle z))))\n(define (magnitude z) (car z))\n(define (angle z) (cdr z))\n(define (make-from-real-imag xy)\n(cons (sqrt (+ ( square x) (square y)))\n(atan yx)))\n(define (make-from-mag-ang ra) (cons ra))\nedisciplineofdataabstractionensuresthatthesameimplementation\nofadd-complex ,sub-complex ,mul-complex ,and div-complex willwork\nwith either Ben’s representation or Alyssa’s representation. 44e arctangent function referred to here, computed by Scheme’s atanprocedure,\nis deﬁned so as to take two arguments yandxand to return the angle whose tangent\nisy=x. e signs of the arguments determine the quadrant of the angle.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 455, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 897}}
{"id": "computer_science_sicp_abelson_chunk_0456_9c96eee6", "text": "e signs of the arguments determine the quadrant of the angle. 236\n2.4.2Tagged data\nOne way to view data abstraction is as an application of the “princi-\npleofleastcommitment.”Inimplementingthecomplex-numbersystem\ninSection 2.4.1 , we can use either Ben’s rectangular representation or\nAlyssa’spolar representation.e abstraction barrier formed bythe se-\nlectorsandconstructorspermitsustodefertothelastpossiblemoment\nthe choice of a concrete representation for our data objects and thus\nretain maximum ﬂexibility in our system design. e principle of least commitment can be carried to even further\nextremes.Ifwedesire,wecanmaintaintheambiguityofrepresentation\neven aerwe have designed the selectors and constructors, and elect\nto use both Ben’s representation andAlyssa’s representation. If both\nrepresentations are included in a single system, however, we will need\nsome way to distinguish data in polar form from data in rectangular\nform.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 456, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_sicp_abelson_chunk_0457_520887b9", "text": "If both\nrepresentations are included in a single system, however, we will need\nsome way to distinguish data in polar form from data in rectangular\nform. Otherwise, if we were asked, for instance, to ﬁnd the magnitude\nof the pair (3, 4), we wouldn’t know whether to answer 5 (interpreting\nthe number in rectangular form) or 3 (interpreting the number in polar\nform).Astraightforwardwaytoaccomplishthisdistinctionistoinclude\natype tag—the symbol rectangular orpolar—as part of each complex\nnumber. en when we need to manipulate a complex number we can\nuse the tag to decide which selector to apply. In order to manipulate tagged data, we will assume that we have\nprocedures type-tag andcontents that extract from a data object the\ntag and the actual contents (the polar or rectangular coordinates, in the\ncase of a complex number). We will also postulate a procedure attach-\ntagthat takes a tag and contents and produces a tagged data object.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 457, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 941}}
{"id": "computer_science_sicp_abelson_chunk_0458_104d4e7e", "text": "We will also postulate a procedure attach-\ntagthat takes a tag and contents and produces a tagged data object. A\nstraightforward way to implement this is to use ordinary list structure:\n(define (attach-tag type-tag contents )\n(cons type-tag contents ))\n237\n(define (type-tag datum )\n(if(pair? datum )\n(car datum )\n(error \"Bad tagged datum :TYPE-TAG \"datum )))\n(define (contents datum )\n(if(pair? datum )\n(cdr datum )\n(error \"Bad tagged datum :CONTENTS \"datum )))\nUsing these procedures, we can deﬁne predicates rectangular? and\npolar?, which recognize rectangular and polar numbers, respectively:\n(define (rectangular? z)\n(eq? (type-tag z)'rectangular ))\n(define (polar? z) (eq? (type-tag z)'polar ))\nWith type tags, Ben and Alyssa can now modify their code so that their\ntwo diﬀerent representations can coexist in the same system. When-\neverBenconstructsacomplexnumber,hetagsitasrectangular.When-\never Alyssa constructs a complex number, she tags it as polar.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 458, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_sicp_abelson_chunk_0459_a10c2504", "text": "When-\neverBenconstructsacomplexnumber,hetagsitasrectangular.When-\never Alyssa constructs a complex number, she tags it as polar. In addi-\ntion, Ben and Alyssa must make sure that the names of their proce-\ndures do not conﬂict. One way to do this is for Ben to append the suﬃx\nrectangular to the name of each of his representation procedures and\nfor Alyssa to append polarto the names of hers.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 459, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 392}}
{"id": "computer_science_sicp_abelson_chunk_0460_4d590036", "text": "One way to do this is for Ben to append the suﬃx\nrectangular to the name of each of his representation procedures and\nfor Alyssa to append polarto the names of hers. Here is Ben’s revised\nrectangular representation from Section 2.4.1 :\n(define (real-part-rectangular z) (car z))\n(define (imag-part-rectangular z) (cdr z))\n(define (magnitude-rectangular z)\n(sqrt (+ ( square (real-part-rectangular z))\n(square (imag-part-rectangular z)))))\n(define (angle-rectangular z)\n(atan (imag-part-rectangular z)\n(real-part-rectangular z)))\n238\n(define (make-from-real-imag-rectangular xy)\n(attach-tag 'rectangular (cons xy)))\n(define (make-from-mag-ang-rectangular ra)\n(attach-tag 'rectangular\n(cons (*r(cos a)) (* r(sin a)))))\nand here is Alyssa’s revised polar representation:\n(define (real-part-polar z)\n(* ( magnitude-polar z) (cos (angle-polar z))))\n(define (imag-part-polar z)\n(* ( magnitude-polar z) (sin (angle-polar z))))\n(define (magnitude-polar z) (car z))\n(define (angle-polar z) (cdr z))\n(define (make-from-real-imag-polar xy)\n(attach-tag 'polar\n(cons (sqrt (+ ( square x) (square y)))\n(atan yx))))\n(define (make-from-mag-ang-polar ra)\n(attach-tag 'polar (cons ra)))\nEachgenericselectorisimplementedasaprocedurethatchecksthetag\nof its argument and calls the appropriate procedure for handling data\nof that type.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 460, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1313}}
{"id": "computer_science_sicp_abelson_chunk_0461_9c69b7f4", "text": "For example, to obtain the real part of a complex number,\nreal-part examines the tag to determine whether to use Ben’s real-\npart-rectangular orAlyssa’s real-part-polar .Ineithercase,weuse\ncontents to extract the bare, untagged datum and send this to the rect-\nangular or polar procedure as required:\n(define (real-part z)\n(cond ((rectangular? z)\n(real-part-rectangular (contents z)))\n((polar? z)\n(real-part-polar (contents z)))\n(else (error \"Unknown type :REAL-PART \"z))))\n239\n(define (imag-part z)\n(cond ((rectangular? z)\n(imag-part-rectangular (contents z)))\n((polar? z)\n(imag-part-polar (contents z)))\n(else (error \"Unknown type :IMAG-PART \"z))))\n(define (magnitude z)\n(cond ((rectangular? z)\n(magnitude-rectangular (contents z)))\n((polar? z)\n(magnitude-polar (contents z)))\n(else (error \"Unknown type :MAGNITUDE \"z))))\n(define (angle z)\n(cond ((rectangular? z)\n(angle-rectangular (contents z)))\n((polar?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 461, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 908}}
{"id": "computer_science_sicp_abelson_chunk_0462_e8cae22a", "text": "z)\n(magnitude-polar (contents z)))\n(else (error \"Unknown type :MAGNITUDE \"z))))\n(define (angle z)\n(cond ((rectangular? z)\n(angle-rectangular (contents z)))\n((polar? z)\n(angle-polar (contents z)))\n(else (error \"Unknown type :ANGLE \"z))))\nTo implement the complex-number arithmetic operations, we can use\nthesameprocedures add-complex ,sub-complex ,mul-complex ,and div-\ncomplex fromSection 2.4.1 , because the selectors they call are generic,\nandsowillworkwitheitherrepresentation.Forexample,theprocedure\nadd-complex is still\n(define (add-complex z1z2)\n(make-from-real-imag (+ ( real-part z1) (real-part z2))\n(+ ( imag-part z1) (imag-part z2))))\nFinally, we must choose whether to construct complex numbers using\nBen’s representation or Alyssa’s representation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 462, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 760}}
{"id": "computer_science_sicp_abelson_chunk_0463_05ecbafa", "text": "One reasonable choice\nis to construct rectangular numbers whenever we have real and imag-\ninary parts and to construct polar numbers whenever we have magni-\ntudes and angles:\n240\nadd-complex sub-complex mul-complex div-complexPrograms that use complex numbers\nComplex-arithmetic package\nRectangular\nrepresentationPolar\nrepresentation\nList structure and primitive machine arithmeticreal-part\nimag-partmagnitude\nangleFigure 2.21: Structure of the generic complex-arithmetic system. (define (make-from-real-imag xy)\n(make-from-real-imag-rectangular xy))\n(define (make-from-mag-ang ra)\n(make-from-mag-ang-polar ra))\ne resulting complex-number system has the structure shown in Fig-\nure 2.21 . e system has been decomposed into three relatively inde-\npendentparts:thecomplex-number-arithmeticoperations,Alyssa’spo-\nlar implementation, and Ben’s rectangular implementation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 463, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 869}}
{"id": "computer_science_sicp_abelson_chunk_0464_70341419", "text": "e system has been decomposed into three relatively inde-\npendentparts:thecomplex-number-arithmeticoperations,Alyssa’spo-\nlar implementation, and Ben’s rectangular implementation. e polar\nand rectangular implementations could have been wrien by Ben and\nAlyssa working separately, and both of these can be used as underly-\ning representations by a third programmer implementing the complex-\narithmetic procedures in terms of the abstract constructor/selector in-\nterface. Since each data object is tagged with its type, the selectors operate\nonthedatainagenericmanner.atis,eachselectorisdeﬁnedtohave\nabehaviorthatdependsupontheparticulartypeofdataitisappliedto. 241\nNotice the general mechanism for interfacing the separate representa-\ntions: Within a given representation implementation (say, Alyssa’s po-\nlar package) a complex number is an untyped pair (magnitude, angle). Whenagenericselectoroperatesonanumberof polartype,itstripsoﬀ\nthe tag and passes the contents on to Alyssa’s code.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 464, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_sicp_abelson_chunk_0465_01eac07f", "text": "Whenagenericselectoroperatesonanumberof polartype,itstripsoﬀ\nthe tag and passes the contents on to Alyssa’s code. Conversely, when\nAlyssa constructs a number for general use, she tags it with a type so\nthat it can be appropriately recognized by the higher-level procedures. is discipline of stripping oﬀ and aaching tags as data objects are\npassed from level to level can be an important organizational strategy,\nas we shall see in Section 2.5 . 2.4.3Data-Directed Programming and Additivity\ne general strategy of checking the type of a datum and calling an\nappropriate procedure is called dispatching on type . is is a powerful\nstrategy for obtaining modularity in system design. On the other hand,\nimplementing the dispatch as in Section 2.4.2 has two signiﬁcant weak-\nnesses. One weakness is that the generic interface procedures ( real-\npart,imag-part ,magnitude , and angle) must know about all the dif-\nferent representations.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 465, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_sicp_abelson_chunk_0466_e027efbb", "text": "One weakness is that the generic interface procedures ( real-\npart,imag-part ,magnitude , and angle) must know about all the dif-\nferent representations. For instance, suppose we wanted to incorporate\na new representation for complex numbers into our complex-number\nsystem. We would need to identify this new representation with a type,\nand then add a clause to each of the generic interface procedures to\ncheck for the new type and apply the appropriate selector for that rep-\nresentation. Another weakness of the technique is that even though the indi-\nvidual representations can be designed separately, we must guarantee\nthat no two procedures in the entire system have the same name. is\nis why Ben and Alyssa had to change the names of their original proce-\ndures from Section 2.4.1 . 242\neissueunderlyingbothoftheseweaknessesisthatthetechnique\nfor implementing generic interfaces is not additive.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 466, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 903}}
{"id": "computer_science_sicp_abelson_chunk_0467_5aba932d", "text": "242\neissueunderlyingbothoftheseweaknessesisthatthetechnique\nfor implementing generic interfaces is not additive. e person imple-\nmenting the generic selector procedures must modify those procedures\neach time a new representation is installed, and the people interfacing\nthe individual representations must modify their code to avoid name\nconﬂicts. In each of these cases, the changes that must be made to the\ncode are straightforward, but they must be made nonetheless, and this\nis a source of inconvenience and error. is is not much of a problem\nfor the complex-number system as it stands, but suppose there were\nnottwobuthundredsofdiﬀerentrepresentationsforcomplexnumbers. And suppose that there were many generic selectors to be maintained\nin the abstract-data interface. Suppose, in fact, that no one program-\nmer knew all the interface procedures or all the representations. e\nproblem is real and must be addressed in such programs as large-scale\ndata-base-management systems.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 467, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_sicp_abelson_chunk_0468_51876cd6", "text": "e\nproblem is real and must be addressed in such programs as large-scale\ndata-base-management systems. What we need is a means for modularizing the system design even\nfurther.isisprovidedbytheprogrammingtechniqueknownas data-\ndirected programming . To understand how data-directed programming\nworks, begin with the observation that whenever we deal with a set of\ngeneric operations that are common to a set of diﬀerent types we are,\nin eﬀect, dealing with a two-dimensional table that contains the possi-\nble operations on one axis and the possible types on the other axis. e\nentries in the table are the procedures that implement each operation\nfor each type of argument presented. In the complex-number system\ndeveloped in the previous section, the correspondence between opera-\ntion name, data type, and actual procedure was spread out among the\nvarious conditional clauses in the generic interface procedures. But the\nsame information could have been organized in a table, as shown in\nFigure 2.22 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 468, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_sicp_abelson_chunk_0469_f6eaa035", "text": "But the\nsame information could have been organized in a table, as shown in\nFigure 2.22 . 243\nreal-part\nimag-part\nmagnitude\nanglereal-part-polar\nimag-part-polar\nmagnitude-polar\nangle-polarreal-part-rectangular\nimag-part-rectangular\nmagnitude-rectangular\nangle-rectangularTypes\nPolar RectangularOperationsFigure 2.22: Table of operations for the complex-number system. Data-directedprogrammingisthetechniqueofdesigningprograms\nto work with such a table directly. Previously, we implemented the\nmechanism that interfaces the complex-arithmetic code with the two\nrepresentation packages as a set of procedures that each perform an\nexplicitdispatchontype.Herewewillimplementtheinterfaceasasin-\ngle procedure that looks up the combination of the operation name and\nargument type in the table to ﬁnd the correct procedure to apply, and\nthen applies it to the contents of the argument.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 469, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_sicp_abelson_chunk_0470_d3b31119", "text": "If we do this, then to\nadd a new representation package to the system we need not change\nany existing procedures; we need only add new entries to the table. To implement this plan, assume that we have two procedures, put\nandget, for manipulating the operation-and-type table:\n•(put⟨op⟩⟨type⟩⟨item⟩)installs the⟨item⟩in the table, indexed\nby the⟨op⟩and the⟨type⟩. •(get⟨op⟩⟨type⟩)looks up the⟨op⟩,⟨type⟩entry in the table and\nreturnstheitemfoundthere.Ifnoitemisfound, getreturnsfalse. For now, we can assume that putandgetare included in our language. InChapter 3 (Section 3.3.3 ) we will see how to implement these and\n244\nother operations for manipulating tables. Hereishowdata-directedprogrammingcanbeusedinthecomplex-\nnumber system. Ben, who developed the rectangular representation,\nimplements his code just as he did originally.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 470, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 833}}
{"id": "computer_science_sicp_abelson_chunk_0471_c4f7037c", "text": "Hereishowdata-directedprogrammingcanbeusedinthecomplex-\nnumber system. Ben, who developed the rectangular representation,\nimplements his code just as he did originally. He deﬁnes a collection\nof procedures, or a package, and interfaces these to the rest of the sys-\ntem by adding entries to the table that tell the system how to operate\non rectangular numbers.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 471, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 360}}
{"id": "computer_science_sicp_abelson_chunk_0472_be447fb2", "text": "He deﬁnes a collection\nof procedures, or a package, and interfaces these to the rest of the sys-\ntem by adding entries to the table that tell the system how to operate\non rectangular numbers. is is accomplished by calling the following\nprocedure:\n(define (install-rectangular-package )\n;; internal procedures\n(define (real-part z) (car z))\n(define (imag-part z) (cdr z))\n(define (make-from-real-imag xy) (cons xy))\n(define (magnitude z)\n(sqrt (+ ( square (real-part z))\n(square (imag-part z)))))\n(define (angle z)\n(atan (imag-part z) (real-part z)))\n(define (make-from-mag-ang ra)\n(cons (*r(cos a)) (* r(sin a))))\n;; interface to the rest of the system\n(define (tag x) (attach-tag 'rectangular x))\n(put 'real-part '(rectangular )real-part )\n(put 'imag-part '(rectangular )imag-part )\n(put 'magnitude '(rectangular )magnitude )\n(put 'angle '(rectangular )angle )\n(put 'make-from-real-imag 'rectangular\n(lambda (xy) (tag (make-from-real-imag xy))))\n(put 'make-from-mag-ang 'rectangular\n(lambda (ra) (tag (make-from-mag-ang ra))))\n'done )\n245\nNotice that the internal procedures here are the same procedures from\nSection 2.4.1 that Ben wrote when he was working in isolation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 472, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1173}}
{"id": "computer_science_sicp_abelson_chunk_0473_39ec4725", "text": "No\nchanges are necessary in order to interface them to the rest of the sys-\ntem. Moreover, since these procedure deﬁnitions are internal to the in-\nstallationprocedure,Benneedn’tworryaboutnameconﬂictswithother\nprocedures outside the rectangular package. To interface these to the\nrest of the system, Ben installs his real-part procedure under the op-\nerationname real-part andthetype (rectangular) ,andsimilarlyfor\nthe other selectors.45e interface also deﬁnes the constructors to be\nused by the external system.46ese are identical to Ben’s internally\ndeﬁned constructors, except that they aach the tag.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 473, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 606}}
{"id": "computer_science_sicp_abelson_chunk_0474_ef801033", "text": "Alyssa’s polar package is analogous:\n(define (install-polar-package )\n;; internal procedures\n(define (magnitude z) (car z))\n(define (angle z) (cdr z))\n(define (make-from-mag-ang ra) (cons ra))\n(define (real-part z) (* ( magnitude z) (cos (angle z))))\n(define (imag-part z) (* ( magnitude z) (sin (angle z))))\n(define (make-from-real-imag xy)\n(cons (sqrt (+ ( square x) (square y)))\n(atan yx)))\n;; interface to the rest of the system\n(define (tag x) (attach-tag 'polar x))\n(put 'real-part '(polar )real-part )\n(put 'imag-part '(polar )imag-part )\n(put 'magnitude '(polar )magnitude )\n45We use the list (rectangular) rather than the symbol rectangular to allow for\nthe possibility of operations with multiple arguments, not all of the same type. 46etypetheconstructorsareinstalledunderneedn’tbealistbecauseaconstructor\nis always used to make an object of one particular type.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 474, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 874}}
{"id": "computer_science_sicp_abelson_chunk_0475_673b16e4", "text": "46etypetheconstructorsareinstalledunderneedn’tbealistbecauseaconstructor\nis always used to make an object of one particular type. 246\n(put 'angle '(polar )angle )\n(put 'make-from-real-imag 'polar\n(lambda (xy) (tag (make-from-real-imag xy))))\n(put 'make-from-mag-ang 'polar\n(lambda (ra) (tag (make-from-mag-ang ra))))\n'done )\nEven though Ben and Alyssa both still use their original procedures\ndeﬁned with the same names as each other’s (e.g., real-part ), these\ndeﬁnitions are now internal to diﬀerent procedures (see Section 1.1.8 ),\nso there is no name conﬂict. e complex-arithmetic selectors access the table by means of a\ngeneral “operation” procedure called apply-generic , which applies a\ngeneric operation to some arguments.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 475, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 733}}
{"id": "computer_science_sicp_abelson_chunk_0476_75fe9566", "text": "e complex-arithmetic selectors access the table by means of a\ngeneral “operation” procedure called apply-generic , which applies a\ngeneric operation to some arguments. apply-generic looks in the ta-\nbleunderthenameoftheoperationandthetypesoftheargumentsand\napplies the resulting procedure if one is present:47\n(define (apply-generic op.args )\n(let ((type-tags (map type-tag args )))\n(let ((proc (get optype-tags )))\n(ifproc\n(apply proc (map contents args ))\n(error\n47apply-generic usesthedoed-tailnotationdescribedin Exercise2.20 ,becausedif-\nferentgenericoperationsmaytakediﬀerentnumbersofarguments.In apply-generic ,\nophas as its value the ﬁrst argument to apply-generic andargshas as its value a list\nof the remaining arguments. apply-generic alsousestheprimitiveprocedure apply,whichtakestwoarguments,\na procedure and a list. applyapplies the procedure, using the elements in the list as\narguments. For example,\n(apply + (list 1 2 3 4))\nreturns 10.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 476, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_sicp_abelson_chunk_0477_7ab9cf72", "text": "applyapplies the procedure, using the elements in the list as\narguments. For example,\n(apply + (list 1 2 3 4))\nreturns 10. 247\n\"Nomethod for these types :APPLY-GENERIC \"\n(list optype-tags ))))))\nUsing apply-generic , we can deﬁne our generic selectors as follows:\n(define (real-part z) (apply-generic 'real-part z))\n(define (imag-part z) (apply-generic 'imag-part z))\n(define (magnitude z) (apply-generic 'magnitude z))\n(define (angle z) (apply-generic 'angle z))\nObserve that these do not change at all if a new representation is added\nto the system.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 477, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 551}}
{"id": "computer_science_sicp_abelson_chunk_0478_3edc08a3", "text": "Wecanalsoextractfromthetabletheconstructorstobeusedbythe\nprograms external to the packages in making complex numbers from\nrealandimaginarypartsandfrommagnitudesandangles.Asin Section\n2.4.2, we construct rectangular numbers whenever we have real and\nimaginaryparts,andpolarnumberswheneverwehavemagnitudesand\nangles:\n(define (make-from-real-imag xy)\n((get 'make-from-real-imag 'rectangular )xy))\n(define (make-from-mag-ang ra)\n((get 'make-from-mag-ang 'polar )ra))\nExercise 2.73: Section 2.3.2 described a program that per-\nforms symbolic diﬀerentiation:\n(define (deriv exp var)\n(cond ((number? exp) 0)\n((variable? exp)\n(if(same-variable? exp var) 1 0))\n((sum? exp)\n(make-sum (deriv (addend exp)var)\n(deriv (augend exp)var)))\n248\n((product?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 478, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 738}}
{"id": "computer_science_sicp_abelson_chunk_0479_b5cfa5d0", "text": "exp) 0)\n((variable? exp)\n(if(same-variable? exp var) 1 0))\n((sum? exp)\n(make-sum (deriv (addend exp)var)\n(deriv (augend exp)var)))\n248\n((product? exp)\n(make-sum (make-product\n(multiplier exp)\n(deriv (multiplicand exp)var))\n(make-product\n(deriv (multiplier exp)var)\n(multiplicand exp))))\n⟨more rules can be added here ⟩\n(else (error \"unknown expression type :\nDERIV \"exp))))\nWe can regard this program as performing a dispatch on\nthe type of the expression to be diﬀerentiated. In this situ-\nation the “type tag” of the datum is the algebraic operator\nsymbol (such as +) and the operation being performed is\nderiv. We can transform this program into data-directed\nstyle by rewriting the basic derivative procedure as\n(define (deriv exp var)\n(cond ((number? exp) 0)\n((variable? exp) (if(same-variable? exp var) 1 0))\n(else ((get 'deriv (operator exp))\n(operands exp)var))))\n(define (operator exp) (car exp))\n(define (operands exp) (cdr exp))\na.Explain what was done above.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 479, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_sicp_abelson_chunk_0480_6a559bb7", "text": "exp) (if(same-variable? exp var) 1 0))\n(else ((get 'deriv (operator exp))\n(operands exp)var))))\n(define (operator exp) (car exp))\n(define (operands exp) (cdr exp))\na.Explain what was done above. Why can’t we assim-\nilate the predicates number? andvariable? into the\ndata-directed dispatch? b.Writetheproceduresforderivativesofsumsandprod-\nucts,andtheauxiliarycoderequiredtoinstallthemin\nthe table used by the program above. 249\nc.Choose any additional diﬀerentiation rule that you\nlike,suchastheoneforexponents( Exercise2.56 ),and\ninstall it in this data-directed system. d.In this simple algebraic manipulator the type of an\nexpression is the algebraic operator that binds it to-\ngether. Suppose, however, we indexed the procedures\nintheoppositeway,sothatthedispatchlinein deriv\nlooked like\n((get (operator exp)'deriv ) (operands exp)var)\nWhatcorrespondingchangestothederivativesystem\nare required?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 480, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_sicp_abelson_chunk_0481_77d5e50a", "text": "Exercise 2.74: Insatiable Enterprises, Inc., is a highly de-\ncentralizedconglomeratecompanyconsistingofalargenum-\nberofindependentdivisionslocatedallovertheworld.e\ncompany’scomputerfacilitieshavejustbeeninterconnected\nbymeansofaclevernetwork-interfacingschemethatmakes\nthe entire network appear to any user to be a single com-\nputer. Insatiable’s president, in her ﬁrst aempt to exploit\nthe ability of the network to extract administrative infor-\nmation from division ﬁles, is dismayed to discover that, al-\nthoughallthedivisionﬁleshavebeenimplementedasdata\nstructuresinScheme,theparticulardatastructureusedvaries\nfrom division to division. A meeting of division managers\nishastilycalledtosearchforastrategytointegratetheﬁles\nthat will satisfy headquarters’ needs while preserving the\nexisting autonomy of the divisions. Show how such a strategy can be implemented with data-\ndirected programming.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 481, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_sicp_abelson_chunk_0482_4616c93b", "text": "Show how such a strategy can be implemented with data-\ndirected programming. As an example, suppose that each\n250\ndivision’s personnel records consist of a single ﬁle, which\ncontains a set of records keyed on employees’ names. e\nstructure of the set varies from division to division. Fur-\nthermore, each employee’s record is itself a set (structured\ndiﬀerentlyfromdivisiontodivision)thatcontainsinforma-\ntion keyed under identiﬁers such as address andsalary. In particular:\na.Implement for headquarters a get-record procedure\nthat retrieves a speciﬁed employee’s record from a\nspeciﬁed personnel ﬁle. e procedure should be ap-\nplicabletoanydivision’sﬁle.Explainhowtheindivid-\nual divisions’ ﬁles should be structured. In particular,\nwhat type information must be supplied? b.Implement for headquarters a get-salary procedure\nthat returns the salary information from a given em-\nployee’srecordfromanydivision’spersonnelﬁle.How\nshould the record be structured in order to make this\noperation work?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 482, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 997}}
{"id": "computer_science_sicp_abelson_chunk_0483_603c9332", "text": "c.Implementforheadquartersa find-employee-record\nprocedure. is should search all the divisions’ ﬁles\nfortherecordofagivenemployeeandreturntherecord. Assume that this procedure takes as arguments an\nemployee’s name and a list of all the divisions’ ﬁles. d.WhenInsatiabletakesoveranewcompany,whatchanges\nmustbemadeinordertoincorporatethenewperson-\nnel information into the central system? 251\nMessage passing\ne key idea of data-directed programming is to handle generic opera-\ntions in programs by dealing explicitly with operation-and-type tables,\nsuch as the table in Figure 2.22 . e style of programming we used in\nSection2.4.2 organizedtherequireddispatchingontypebyhavingeach\noperationtakecareofitsowndispatching.Ineﬀect,thisdecomposesthe\noperation-and-type table into rows, with each generic operation proce-\ndure representing a row of the table.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 483, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 853}}
{"id": "computer_science_sicp_abelson_chunk_0484_5ca86075", "text": "An alternative implementation strategy is to decompose the table\nintocolumnsand,insteadofusing“intelligentoperations”thatdispatch\non data types, to work with “intelligent data objects” that dispatch on\noperation names. We can do this by arranging things so that a data\nobject, such as a rectangular number, is represented as a procedure that\ntakes as input the required operation name and performs the operation\nindicated. In such a discipline, make-from-real-imag could be wrien\nas\n(define (make-from-real-imag xy)\n(define (dispatch op)\n(cond ((eq? op'real-part )x)\n((eq? op'imag-part )y)\n((eq? op'magnitude ) (sqrt (+ ( square x) (square y))))\n((eq?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 484, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 652}}
{"id": "computer_science_sicp_abelson_chunk_0485_1d3fe94e", "text": "op'real-part )x)\n((eq? op'imag-part )y)\n((eq? op'magnitude ) (sqrt (+ ( square x) (square y))))\n((eq? op'angle ) (atan yx))\n(else (error \"Unknown op:MAKE-FROM-REAL-IMAG \"op))))\ndispatch )\ne corresponding apply-generic procedure, which applies a generic\noperation to an argument, now simply feeds the operation’s name to\nthe data object and lets the object do the work:48\n48One limitation of this organization is it permits only generic procedures of one\nargument. 252\n(define (apply-generic oparg) (arg op))\nNote that the value returned by make-from-real-imag is a procedure—\nthe internal dispatch procedure. is is the procedure that is invoked\nwhen apply-generic requests an operation to be performed.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 485, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 704}}
{"id": "computer_science_sicp_abelson_chunk_0486_c0c6dce1", "text": "is is the procedure that is invoked\nwhen apply-generic requests an operation to be performed. isstyleofprogrammingiscalled message passing .enamecomes\nfromtheimagethatadataobjectisanentitythatreceivestherequested\noperation name as a “message.” We have already seen an example of\nmessagepassingin Section2.1.3 ,wherewesawhow cons,car,and cdr\ncould be deﬁned with no data objects but only procedures. Here we see\nthat message passing is not a mathematical trick but a useful technique\nfororganizingsystemswithgenericoperations.Intheremainderofthis\nchapterwewillcontinuetousedata-directedprogramming,ratherthan\nmessage passing, to discuss generic arithmetic operations. In Chapter 3\nwe will return to message passing, and we will see that it can be a pow-\nerful tool for structuring simulation programs. Exercise2.75: Implementtheconstructor make-from-mag-\nanginmessage-passingstyle.isprocedureshouldbeanal-\nogoustothe make-from-real-imag proceduregivenabove.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 486, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_sicp_abelson_chunk_0487_4aa2ba8e", "text": "Exercise2.75: Implementtheconstructor make-from-mag-\nanginmessage-passingstyle.isprocedureshouldbeanal-\nogoustothe make-from-real-imag proceduregivenabove. Exercise 2.76: As a large system with generic operations\nevolves, new types of data objects or new operations may\nbe needed. For each of the three strategies—generic opera-\ntionswithexplicitdispatch,data-directedstyle,andmessage-\npassing-style—describethechangesthatmustbemadetoa\nsysteminordertoaddnewtypesornewoperations.Which\norganization would be most appropriate for a system in\nwhich new types must oen be added? Which would be\nmost appropriate for a system in which new operations\nmust oen be added? 253\n2.5Systems with Generic Operations\nIn the previous section, we saw how to design systems in which data\nobjects can be represented in more than one way. e key idea is to\nlink the code that speciﬁes the data operations to the several represen-\ntations by means of generic interface procedures.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 487, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_sicp_abelson_chunk_0488_077dda5c", "text": "e key idea is to\nlink the code that speciﬁes the data operations to the several represen-\ntations by means of generic interface procedures. Now we will see how\nto use this same idea not only to deﬁne operations that are genericover\ndiﬀerent representations but also to deﬁne operations that are generic\nover diﬀerent kinds of arguments. We have already seen several dif-\nferent packages of arithmetic operations: the primitive arithmetic ( +,-,\n*,/) built into our language, the rational-number arithmetic ( add-rat ,\nsub-rat ,mul-rat ,div-rat ) ofSection 2.1.1 , and the complex-number\narithmetic that we implemented in Section 2.4.3 . We will now use data-\ndirectedtechniquestoconstructapackageofarithmeticoperationsthat\nincorporates all the arithmetic packages we have already constructed. Figure 2.23 shows the structure of the system we shall build. Notice\nthe abstraction barriers.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 488, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_sicp_abelson_chunk_0489_e77eca5e", "text": "Figure 2.23 shows the structure of the system we shall build. Notice\nthe abstraction barriers. From the perspective of someone using “num-\nbers,” there is a single procedure addthat operates on whatever num-\nbers are supplied. addis part of a generic interface that allows the sep-\narate ordinary-arithmetic, rational-arithmetic, and complex-arithmetic\npackages to be accessed uniformly by programs that use numbers. Any\nindividual arithmetic package (such as the complex package) may it-\nselfbeaccessedthroughgenericprocedures(suchas add-complex )that\ncombine packages designed for diﬀerent representations (such as rect-\nangular and polar). Moreover, the structure of the system is additive, so\nthat one can design the individual arithmetic packages separately and\ncombine them to produce a generic arithmetic system.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 489, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 819}}
{"id": "computer_science_sicp_abelson_chunk_0490_756b65f0", "text": "Moreover, the structure of the system is additive, so\nthat one can design the individual arithmetic packages separately and\ncombine them to produce a generic arithmetic system. 254\nadd sub mul div\nadd-complex\nmul-complexsub-complex\ndiv-complexPrograms that use numbers\nGeneric arithmetic package\nComplex arithmetic\nRectangular Polarsub-rat\ndiv-ratadd-rat\nmul-rat\nRational\narithmeticOrdinary\narithmetic\nList structure and primitive machine arithmetic+ - - */Figure 2.23: Generic arithmetic system. 2.5.1Generic Arithmetic Operations\netaskofdesigninggenericarithmeticoperationsisanalogoustothat\nof designing the generic complex-number operations. We would like,\nfor instance, to have a generic addition procedure addthat acts like or-\ndinary primitive addition +on ordinary numbers, like add-rat on ra-\ntional numbers, and like add-complex on complex numbers.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 490, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 858}}
{"id": "computer_science_sicp_abelson_chunk_0491_ab150aa6", "text": "We can\nimplement add, and the other generic arithmetic operations, by follow-\ningthe samestrategyweusedin Section2.4.3 toimplement thegeneric\nselectorsforcomplexnumbers.Wewillaachatypetagtoeachkindof\nnumber and cause the generic procedure to dispatch to an appropriate\npackage according to the data type of its arguments. e generic arithmetic procedures are deﬁned as follows:\n(define (add xy) (apply-generic 'add xy))\n255\n(define (sub xy) (apply-generic 'sub xy))\n(define (mul xy) (apply-generic 'mul xy))\n(define (div xy) (apply-generic 'div xy))\nWe begin by installing a package for handling ordinary numbers, that\nis, the primitive numbers of our language. We will tag these with the\nsymbol scheme-number . e arithmetic operations in this package are\nthe primitive arithmetic procedures (so there is no need to deﬁne extra\nprocedures to handle the untagged numbers).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 491, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 873}}
{"id": "computer_science_sicp_abelson_chunk_0492_262856ad", "text": "e arithmetic operations in this package are\nthe primitive arithmetic procedures (so there is no need to deﬁne extra\nprocedures to handle the untagged numbers). Since these operations\neach take two arguments, they are installed in the table keyed by the\nlist(scheme-number scheme-number) :\n(define (install-scheme-number-package )\n(define (tag x) (attach-tag 'scheme-number x))\n(put 'add '(scheme-number scheme-number )\n(lambda (xy) (tag (+xy))))\n(put 'sub '(scheme-number scheme-number )\n(lambda (xy) (tag (-xy))))\n(put 'mul '(scheme-number scheme-number )\n(lambda (xy) (tag (*xy))))\n(put 'div '(scheme-number scheme-number )\n(lambda (xy) (tag (/xy))))\n(put 'make 'scheme-number (lambda (x) (tag x)))\n'done )\nUsersoftheScheme-numberpackagewillcreate(tagged)ordinarynum-\nbers by means of the procedure:\n(define (make-scheme-number n)\n((get 'make 'scheme-number )n))\nNow that the framework of the generic arithmetic system is in place,\nwe can readily include new kinds of numbers.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 492, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_sicp_abelson_chunk_0493_3d2450be", "text": "Here is a package that\nperforms rational arithmetic.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 493, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 52}}
{"id": "computer_science_sicp_abelson_chunk_0494_7f0f15eb", "text": "Notice that, as a beneﬁt of additivity, we\n256\ncan use without modiﬁcation the rational-number code from Section\n2.1.1as the internal procedures in the package:\n(define (install-rational-package )\n;; internal procedures\n(define (numer x) (car x))\n(define (denom x) (cdr x))\n(define (make-rat nd)\n(let ((g(gcd nd)))\n(cons (/ng) (/ dg))))\n(define (add-rat xy)\n(make-rat (+ (* ( numer x) (denom y))\n(* ( numer y) (denom x)))\n(* ( denom x) (denom y))))\n(define (sub-rat xy)\n(make-rat (- (* ( numer x) (denom y))\n(* ( numer y) (denom x)))\n(* ( denom x) (denom y))))\n(define (mul-rat xy)\n(make-rat (* ( numer x) (numer y))\n(* ( denom x) (denom y))))\n(define (div-rat xy)\n(make-rat (* ( numer x) (denom y))\n(* ( denom x) (numer y))))\n;; interface to rest of the system\n(define (tag x) (attach-tag 'rational x))\n(put 'add '(rational rational )\n(lambda (xy) (tag (add-rat xy))))\n(put 'sub '(rational rational )\n(lambda (xy) (tag (sub-rat xy))))\n(put 'mul '(rational rational )\n(lambda (xy) (tag (mul-rat xy))))\n(put 'div '(rational rational )\n(lambda (xy) (tag (div-rat xy))))\n257\n(put 'make 'rational\n(lambda (nd) (tag (make-rat nd))))\n'done )\n(define (make-rational nd)\n((get 'make 'rational )nd))\nWe can install a similar package to handle complex numbers, using the\ntagcomplex .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 494, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1273}}
{"id": "computer_science_sicp_abelson_chunk_0495_1e9f12c6", "text": "In creating the package, we extract from the table the op-\nerations make-from-real-imag andmake-from-mag-ang that were de-\nﬁned by the rectangular and polar packages. Additivity permits us to\nuse, as the internal operations, the same add-complex ,sub-complex ,\nmul-complex , and div-complex procedures from Section 2.4.1 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 495, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 322}}
{"id": "computer_science_sicp_abelson_chunk_0496_c030f1da", "text": "Additivity permits us to\nuse, as the internal operations, the same add-complex ,sub-complex ,\nmul-complex , and div-complex procedures from Section 2.4.1 . (define (install-complex-package )\n;; imported procedures from rectangular and polar packages\n(define (make-from-real-imag xy)\n((get 'make-from-real-imag 'rectangular )xy))\n(define (make-from-mag-ang ra)\n((get 'make-from-mag-ang 'polar )ra))\n;; internal procedures\n(define (add-complex z1z2)\n(make-from-real-imag (+ ( real-part z1) (real-part z2))\n(+ ( imag-part z1) (imag-part z2))))\n(define (sub-complex z1z2)\n(make-from-real-imag (- ( real-part z1) (real-part z2))\n(- ( imag-part z1) (imag-part z2))))\n(define (mul-complex z1z2)\n(make-from-mag-ang (* ( magnitude z1) (magnitude z2))\n(+ ( angle z1) (angle z2))))\n(define (div-complex z1z2)\n(make-from-mag-ang (/ ( magnitude z1) (magnitude z2))\n(- ( angle z1) (angle z2))))\n;; interface to rest of the system\n(define (tag z) (attach-tag 'complex z))\n258\n(put 'add '(complex complex )\n(lambda (z1z2) (tag (add-complex z1z2))))\n(put 'sub '(complex complex )\n(lambda (z1z2) (tag (sub-complex z1z2))))\n(put 'mul '(complex complex )\n(lambda (z1z2) (tag (mul-complex z1z2))))\n(put 'div '(complex complex )\n(lambda (z1z2) (tag (div-complex z1z2))))\n(put 'make-from-real-imag 'complex\n(lambda (xy) (tag (make-from-real-imag xy))))\n(put 'make-from-mag-ang 'complex\n(lambda (ra) (tag (make-from-mag-ang ra))))\n'done )\nPrograms outside the complex-number package can construct complex\nnumbers either from real and imaginary parts or from magnitudes and\nangles.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 496, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1556}}
{"id": "computer_science_sicp_abelson_chunk_0497_93fa2abd", "text": "Notice howthe underlying procedures,originally deﬁned in the\nrectangular and polar packages, are exported to the complex package,\nand exported from there to the outside world. (define (make-complex-from-real-imag xy)\n((get 'make-from-real-imag 'complex )xy))\n(define (make-complex-from-mag-ang ra)\n((get 'make-from-mag-ang 'complex )ra))\nWhat we have here is a two-level tag system. A typical complex num-\nber, such as 3 + 4 iin rectangular form, would be represented as shown\ninFigure 2.24 . e outer tag ( complex ) is used to direct the number to\nthe complex package. Once within the complex package, the next tag\n(rectangular ) is used to direct the number to the rectangular package. In a large and complicated system there might be many levels, each in-\nterfaced with the next by means of generic operations. As a data object\nis passed “downward,” the outer tag that is used to direct it to the ap-\n259\n3 4 complex rectangularFigure 2.24: Representation of 3 + 4 iin rectangular form.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 497, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 990}}
{"id": "computer_science_sicp_abelson_chunk_0498_581f9d9c", "text": "As a data object\nis passed “downward,” the outer tag that is used to direct it to the ap-\n259\n3 4 complex rectangularFigure 2.24: Representation of 3 + 4 iin rectangular form. propriate package is stripped oﬀ (by applying contents ) and the next\nlevel of tag (if any) becomes visible to be used for further dispatching. Intheabovepackages,weused add-rat ,add-complex ,andtheother\narithmetic procedures exactly as originally wrien. Once these deﬁni-\ntions are internal to diﬀerent installation procedures, however, they no\nlonger need names that are distinct from each other: we could simply\nname them add,sub,mul, and divin both packages. Exercise2.77: Louis Reasoner tries to evaluate the expres-\nsion (magnitude z) where zis the object shown in Figure\n2.24.Tohissurprise,insteadoftheanswer5hegetsanerror\nmessage from apply-generic , saying there is no method\nfor the operation magnitude on the types (complex) . He\nshows this interaction to Alyssa P.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 498, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_sicp_abelson_chunk_0499_097eeb94", "text": "He\nshows this interaction to Alyssa P. Hacker, who says “e\nproblem is that the complex-number selectors were never\ndeﬁnedfor complex numbers,justfor polarandrectangular\nnumbers. All you have to do to make this work is add the\nfollowing to the complex package:”\n(put 'real-part '(complex )real-part )\n(put 'imag-part '(complex )imag-part )\n(put 'magnitude '(complex )magnitude )\n(put 'angle '(complex )angle )\n260\nDescribe in detail why this works. As an example, trace\nthrough all the procedures called in evaluating the expres-\nsion (magnitude z) where zis the object shown in Figure\n2.24. In particular, how many times is apply-generic in-\nvoked? What procedure is dispatched to in each case? Exercise2.78: einternalproceduresinthe scheme-number\npackageareessentiallynothingmorethancallstotheprim-\nitiveprocedures +,-,etc.Itwasnotpossibletousetheprim-\nitives of the language directly because our type-tag system\nrequires that each data object have a type aached to it.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 499, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_sicp_abelson_chunk_0500_ded46293", "text": "In\nfact, however, all Lisp implementations do have a type sys-\ntem, which they use internally. Primitive predicates such\nassymbol? and number? determine whether data objects\nhave particular types. Modify the deﬁnitions of type-tag ,\ncontents , and attach-tag fromSection 2.4.2 so that our\ngeneric system takes advantage of Scheme’s internal type\nsystem.atistosay,thesystemshouldworkasbeforeex-\ncept that ordinary numbers should be represented simply\nas Scheme numbers rather than as pairs whose caris the\nsymbol scheme-number . Exercise2.79: Deﬁneagenericequalitypredicate equ?that\nteststheequalityoftwonumbers,andinstallitinthegeneric\narithmetic package. is operation should work for ordi-\nnary numbers, rational numbers, and complex numbers. Exercise2.80: Deﬁne a generic predicate =zero?that tests\nif its argument is zero, and install it in the generic arith-\nmetic package. is operation should work for ordinary\nnumbers, rational numbers, and complex numbers.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 500, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_sicp_abelson_chunk_0501_a86cccf6", "text": "is operation should work for ordinary\nnumbers, rational numbers, and complex numbers. 261\n2.5.2Combining Data of Diﬀerent Types\nWe have seen how to deﬁne a uniﬁed arithmetic system that encom-\npassesordinarynumbers,complexnumbers,rationalnumbers,andany\nothertypeofnumberwemightdecidetoinvent,butwehaveignoredan\nimportant issue. e operations we have deﬁned so far treat the diﬀer-\nentdatatypesasbeingcompletelyindependent.us,thereareseparate\npackages for adding, say, two ordinary numbers, or two complex num-\nbers.Whatwehavenotyetconsideredisthefactthatitismeaningfulto\ndeﬁneoperationsthatcrossthetypeboundaries,suchastheadditionof\na complex number to an ordinary number. We have gone to great pains\ntointroduce barriersbetweenparts ofour programsso thattheycanbe\ndeveloped and understood separately. We would like to introduce the\ncross-type operations in some carefully controlled way, so that we can\nsupport them without seriously violating our module boundaries.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 501, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_sicp_abelson_chunk_0502_6a821676", "text": "We would like to introduce the\ncross-type operations in some carefully controlled way, so that we can\nsupport them without seriously violating our module boundaries. Onewaytohandlecross-typeoperationsistodesignadiﬀerentpro-\ncedure for each possible combination of types for which the operation\nis valid. For example, we could extend the complex-number package so\nthat it provides a procedure for adding complex numbers to ordinary\nnumbers and installs this in the table using the tag (complex scheme-\nnumber) :49\n;; to be included in the complex package\n(define (add-complex-to-schemenum zx)\n(make-from-real-imag (+ ( real-part z)x) (imag-part z)))\n(put 'add '(complex scheme-number )\n(lambda (zx) (tag (add-complex-to-schemenum zx))))\nis technique works, but it is cumbersome. With such a system, the\ncost of introducing a new type is not just the construction of the pack-\n49Wealsohavetosupplyanalmostidenticalproceduretohandlethetypes (scheme-\nnumber complex) .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 502, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_sicp_abelson_chunk_0503_86e40518", "text": "With such a system, the\ncost of introducing a new type is not just the construction of the pack-\n49Wealsohavetosupplyanalmostidenticalproceduretohandlethetypes (scheme-\nnumber complex) . 262\nage of procedures for that type but also the construction and installa-\ntion of the procedures that implement the cross-type operations. is\ncan easily be much more code than is needed to deﬁne the operations\non the type itself. e method also undermines our ability to combine\nseparate packages additively, or at least to limit the extent to which the\nimplementors of the individual packages need to take account of other\npackages. For instance, in the example above, it seems reasonable that\nhandlingmixedoperationsoncomplexnumbersandordinarynumbers\nshould be the responsibility of the complex-number package. Combin-\ningrationalnumbersandcomplexnumbers,however,mightbedoneby\nthecomplexpackage,bytherationalpackage,orbysomethirdpackage\nthat uses operations extracted from these two packages.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 503, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_sicp_abelson_chunk_0504_bfb8cd0a", "text": "Combin-\ningrationalnumbersandcomplexnumbers,however,mightbedoneby\nthecomplexpackage,bytherationalpackage,orbysomethirdpackage\nthat uses operations extracted from these two packages. Formulating\ncoherent policies on the division of responsibility among packages can\nbeanoverwhelmingtaskindesigningsystemswithmanypackagesand\nmany cross-type operations. Coercion\nIn the general situation of completely unrelated operations acting on\ncompletelyunrelatedtypes,implementingexplicitcross-typeoperations,\ncumbersome though it may be, is the best that one can hope for. For-\ntunately, we can usually do beer by taking advantage of additional\nstructurethatmaybelatentinourtypesystem.Oenthediﬀerentdata\ntypesarenotcompletelyindependent,andtheremaybewaysbywhich\nobjectsofonetypemaybeviewedasbeingofanothertype.isprocess\niscalled coercion.Forexample,ifweareaskedtoarithmeticallycombine\nan ordinary number with a complex number, we can view the ordinary\nnumber as a complex number whose imaginary part is zero.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 504, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_sicp_abelson_chunk_0505_31221a68", "text": "is trans-\nforms the problem to that of combining two complex numbers, which\ncanbehandledintheordinarywaybythecomplex-arithmeticpackage. 263\nIn general, we can implement this idea by designing coercion pro-\ncedures that transform an object of one type into an equivalent object\nofanothertype.Hereisatypicalcoercionprocedure,whichtransforms\na given ordinary number to a complex number with that real part and\nzero imaginary part:\n(define (scheme-number->complex n)\n(make-complex-from-real-imag (contents n) 0))\nWeinstallthesecoercionproceduresinaspecialcoerciontable,indexed\nunder the names of the two types:\n(put-coercion 'scheme-number\n'complex\nscheme-number->complex )\n(Weassumethatthereare put-coercion andget-coercion procedures\navailableformanipulatingthistable.)Generallysomeoftheslotsinthe\ntable will be empty, because it is not generally possible to coerce an ar-\nbitrary data object of each type into all other types.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 505, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_sicp_abelson_chunk_0506_40f6cfbe", "text": "For example, there\nis no way to coerce an arbitrary complex number to an ordinary num-\nber, so there will be no general complex->scheme-number procedure\nincluded in the table. Once the coercion table has been set up, we can handle coercion\nin a uniform manner by modifying the apply-generic procedure of\nSection2.4.3 .Whenaskedtoapplyanoperation,weﬁrstcheckwhether\nthe operation is deﬁned for the arguments’ types, just as before. If so,\nwe dispatch to the procedure found in the operation-and-type table. Otherwise, we try coercion. For simplicity, we consider only the case\nwhere there are two arguments.50We check the coercion table to see\nif objects of the ﬁrst type can be coerced to the second type. If so, we\n50SeeExercise 2.82 for generalizations. 264\ncoerce the ﬁrst argument and try the operation again.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 506, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 813}}
{"id": "computer_science_sicp_abelson_chunk_0507_3dd203ff", "text": "If so, we\n50SeeExercise 2.82 for generalizations. 264\ncoerce the ﬁrst argument and try the operation again. If objects of the\nﬁrst type cannot in general be coerced to the second type, we try the\ncoercion the other way around to see if there is a way to coerce the\nsecond argument to the type of the ﬁrst argument. Finally, if there is no\nknown way to coerce either type to the other type, we give up.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 507, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 401}}
{"id": "computer_science_sicp_abelson_chunk_0508_bbb1f836", "text": "Finally, if there is no\nknown way to coerce either type to the other type, we give up. Here is\nthe procedure:\n(define (apply-generic op.args )\n(let ((type-tags (map type-tag args )))\n(let ((proc (get optype-tags )))\n(ifproc\n(apply proc (map contents args ))\n(if(= ( length args ) 2)\n(let ((type1 (car type-tags ))\n(type2 (cadr type-tags ))\n(a1(car args ))\n(a2(cadr args )))\n(let ((t1->t2 (get-coercion type1 type2 ))\n(t2->t1 (get-coercion type2 type1 )))\n(cond (t1->t2\n(apply-generic op(t1->t2 a1)a2))\n(t2->t1\n(apply-generic opa1(t2->t1 a2)))\n(else (error \"Nomethod for these types \"\n(list optype-tags ))))))\n(error \"Nomethod for these types \"\n(list optype-tags )))))))\niscoercionschemehasmanyadvantagesoverthemethodofdeﬁning\nexplicitcross-typeoperations,asoutlinedabove.Althoughwestillneed\nto write coercion procedures to relate the types (possibly n2procedures\nfor a system with ntypes), we need to write only one procedure for\neach pair of types rather than a diﬀerent procedure for each collection\n265\nof types and each generic operation.51What we are counting on here\nis the fact that the appropriate transformation between types depends\nonly on the types themselves, not on the operation to be applied.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 508, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1209}}
{"id": "computer_science_sicp_abelson_chunk_0509_3b6b0869", "text": "On the other hand, there may be applications for which our coer-\ncion scheme is not general enough. Even when neither of the objects to\nbe combined can be converted to the type of the other it may still be\npossible to perform the operation by converting both objects to a third\ntype. In order to deal with such complexity and still preserve modular-\nity in our programs, it is usually necessary to build systems that take\nadvantage of still further structure in the relations among types, as we\ndiscuss next. Hierarchies of types\ne coercion scheme presented above relied on the existence of natural\nrelations between pairs of types. Oen there is more “global” structure\nin how the diﬀerent types relate to each other. For instance, suppose\nwe are building a generic arithmetic system to handle integers, rational\nnumbers, real numbers, and complex numbers.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 509, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 858}}
{"id": "computer_science_sicp_abelson_chunk_0510_d16a7ea6", "text": "For instance, suppose\nwe are building a generic arithmetic system to handle integers, rational\nnumbers, real numbers, and complex numbers. In such a system, it is\nquite natural to regard an integer as a special kind of rational number,\nwhich is in turn a special kind of real number, which is in turn a special\nkindofcomplexnumber.Whatweactuallyhaveisaso-called hierarchy\nof types, in which, for example, integers are a subtype of rational num-\n51If we are clever, we can usually get by with fewer than n2coercion procedures. For instance, if we know how to convert from type 1 to type 2 and from type 2 to\ntype 3, then we can use this knowledge to convert from type 1 to type 3. is can\ngreatly decrease the number of coercion procedures we need to supply explicitly when\nwe add a new type to the system.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 510, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 805}}
{"id": "computer_science_sicp_abelson_chunk_0511_c57b1adb", "text": "is can\ngreatly decrease the number of coercion procedures we need to supply explicitly when\nwe add a new type to the system. If we are willing to build the required amount of\nsophistication into our system, we can have it search the “graph” of relations among\ntypes and automatically generate those coercion procedures that can be inferred from\nthe ones that are supplied explicitly. 266\ncomplex\nreal\nrational\nintegerFigure 2.25: A tower of types. bers (i.e., any operation that can be applied to a rational number can\nautomatically be applied to an integer). Conversely, we say that ratio-\nnal numbers form a supertype of integers. e particular hierarchy we\nhave here is of a very simple kind, in which each type has at most one\nsupertype and at most one subtype. Such a structure, called a tower, is\nillustrated in Figure 2.25 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 511, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 832}}
{"id": "computer_science_sicp_abelson_chunk_0512_bfdafdf1", "text": "e particular hierarchy we\nhave here is of a very simple kind, in which each type has at most one\nsupertype and at most one subtype. Such a structure, called a tower, is\nillustrated in Figure 2.25 . If we have a tower structure, then we can greatly simplify the prob-\nlem of adding a new type to the hierarchy, for we need only specify\nhow the new type is embedded in the next supertype above it and how\nit is the supertype of the type below it. For example, if we want to add\nan integer to a complex number, we need not explicitly deﬁne a special\ncoercionprocedure integer->complex .Instead,wedeﬁnehowaninte-\ngercanbetransformedintoarationalnumber,howarationalnumberis\ntransformed into a real number, and how a real number is transformed\ninto a complex number. We then allow the system to transform the in-\nteger into a complex number through these steps and then add the two\ncomplex numbers.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 512, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 893}}
{"id": "computer_science_sicp_abelson_chunk_0513_70b4fbd0", "text": "We then allow the system to transform the in-\nteger into a complex number through these steps and then add the two\ncomplex numbers. We can redesign our apply-generic procedure in the following\nway:Foreachtype,weneedtosupplya raiseprocedure,which“raises”\n267\nobjects of that type one level in the tower. en when the system is re-\nquired to operate on objects of diﬀerent types it can successively raise\nthe lower types until all the objects are at the same level in the tower. (Exercise 2.83 andExercise 2.84 concern the details of implementing\nsuch a strategy.)\nAnother advantage of a tower is that we can easily implement the\nnotion that every type “inherits” all operations deﬁned on a supertype. Forinstance,ifwedonotsupplyaspecialprocedureforﬁndingthereal\npart of an integer, we should nevertheless expect that real-part will\nbe deﬁned for integers by virtue of the fact that integers are a subtype\nof complex numbers.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 513, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_sicp_abelson_chunk_0514_4c69f166", "text": "In a tower, we can arrange for this to happen in a\nuniform way by modifying apply-generic . If the required operation is\nnot directly deﬁned for the type of the object given, we raise the object\ntoitssupertypeandtryagain.Wethuscrawlupthetower,transforming\nour argument as we go, until we either ﬁnd a level at which the desired\noperation can be performed or hit the top (in which case we give up). Yet another advantage of a tower over a more general hierarchy is\nthat it gives us a simple way to “lower” a data object to the simplest\nrepresentation. For example, if we add 2 + 3 ito 4\u00003i, it would be nice\nto obtain the answer as the integer 6 rather than as the complex num-\nber 6 + 0 i.Exercise 2.85 discusses a way to implement such a lowering\noperation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 514, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 758}}
{"id": "computer_science_sicp_abelson_chunk_0515_ca1d26a0", "text": "(e trick is that we need a general way to distinguish those\nobjects that can be lowered, such as 6+0 i, from those that cannot, such\nas 6 + 2 i.)\nInadequacies of hierarchies\nIf the data types in our system can be naturally arranged in a tower,\nthis greatly simpliﬁes the problems of dealing with generic operations\nondiﬀerenttypes,aswehaveseen.Unfortunately,thisisusuallynotthe\ncase.Figure2.26 illustratesamorecomplexarrangementofmixedtypes,\n268\npolygon\nquadrilateral\nkitetrapezoid\nparallelogram\nrectangle rhombus\nsquaretriangle\nisosceles\ntriangleright\ntriangle\nisosceles\nright triangleequilateral\ntriangleFigure 2.26: Relations among types of geometric ﬁgures. this one showing relations among diﬀerent types of geometric ﬁgures. We see that, in general, a type may have more than one subtype. Tri-\nangles and quadrilaterals, for instance, are both subtypes of polygons. In addition, a type may have more than one supertype.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 515, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_sicp_abelson_chunk_0516_f9860a8b", "text": "We see that, in general, a type may have more than one subtype. Tri-\nangles and quadrilaterals, for instance, are both subtypes of polygons. In addition, a type may have more than one supertype. For example,\nan isosceles right triangle may be regarded either as an isosceles trian-\ngle or as a right triangle. is multiple-supertypes issue is particularly\nthorny,sinceitmeansthatthereisnouniquewayto“raise”atypeinthe\nhierarchy. Finding the “correct” supertype in which to apply an opera-\ntiontoanobjectmayinvolveconsiderablesearchingthroughtheentire\ntype network on the part of a procedure such as apply-generic . Since\nthere generally are multiple subtypes for a type, there is a similar prob-\nlem in coercing a value “down” the type hierarchy.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 516, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 745}}
{"id": "computer_science_sicp_abelson_chunk_0517_b989be2d", "text": "Since\nthere generally are multiple subtypes for a type, there is a similar prob-\nlem in coercing a value “down” the type hierarchy. Dealing with large\nnumbers of interrelated types while still preserving modularity in the\n269\ndesign of large systems is very diﬃcult, and is an area of much current\nresearch.52\nExercise2.81: LouisReasonerhasnoticedthat apply-generic\nmay try to coerce the arguments to each other’s type even\nif they already have the same type. erefore, he reasons,\nwe need to put procedures in the coercion table to coerce\narguments of each type to their own type.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 517, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 581}}
{"id": "computer_science_sicp_abelson_chunk_0518_6276480d", "text": "erefore, he reasons,\nwe need to put procedures in the coercion table to coerce\narguments of each type to their own type. For example, in\naddition to the scheme-number->complex coercion shown\nabove, he would do:\n(define (scheme-number->scheme-number n)n)\n(define (complex->complex z)z)\n(put-coercion 'scheme-number\n'scheme-number\nscheme-number->scheme-number )\n(put-coercion 'complex 'complex complex->complex )\n52is statement, which also appears in the ﬁrst edition of this book, is just as true\nnow as it was when we wrote it twelve years ago. Developing a useful, general frame-\nwork for expressing the relations among diﬀerent types of entities (what philosophers\ncall “ontology”) seems intractably diﬃcult. e main diﬀerence between the confu-\nsion that existed ten years ago and the confusion that exists now is that now a va-\nriety of inadequate ontological theories have been embodied in a plethora of corre-\nspondingly inadequate programming languages.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 518, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_sicp_abelson_chunk_0519_b620e71d", "text": "For example, much of the complexity\nof object-oriented programming languages—and the subtle and confusing diﬀerences\namong contemporary object-oriented languages—centers on the treatment of generic\noperationsoninterrelatedtypes.Ourowndiscussionofcomputationalobjectsin Chap-\nter 3avoids these issues entirely. Readers familiar with object-oriented programming\nwill notice that we have much to say in chapter 3 about local state, but we do not even\nmention“classes”or“inheritance.”Infact,wesuspectthattheseproblemscannotbead-\nequately addressed in terms of computer-language design alone, without also drawing\non work in knowledge representation and automated reasoning.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 519, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 669}}
{"id": "computer_science_sicp_abelson_chunk_0520_7e807c02", "text": "270\na.WithLouis’scoercionproceduresinstalled,whathap-\npens if apply-generic is called with two arguments\noftype scheme-number ortwoargumentsoftype complex\nforanoperationthatisnotfoundinthetableforthose\ntypes?Forexample,assumethatwe’vedeﬁnedageneric\nexponentiation operation:\n(define (exp xy) (apply-generic 'exp xy))\nand have put a procedure for exponentiation in the\nScheme-number package but not in any other pack-\nage:\n;; following added to Scheme-number package\n(put 'exp '(scheme-number scheme-number )\n(lambda (xy) (tag (expt xy))))\n; using primitive expt\nWhat happens if we call expwith two complex num-\nbers as arguments? b.Is Louis correct that something had to be done about\ncoercion with arguments of the same type, or does\napply-generic work correctly as is? c.Modify apply-generic so that it doesn’t try coercion\nif the two arguments have the same type. Exercise 2.82: Show how to generalize apply-generic to\nhandle coercion in the general case of multiple arguments.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 520, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_sicp_abelson_chunk_0521_462073c0", "text": "Exercise 2.82: Show how to generalize apply-generic to\nhandle coercion in the general case of multiple arguments. One strategy is to aempt to coerce all the arguments to\nthe type of the ﬁrst argument, then to the type of the sec-\nond argument, and so on. Give an example of a situation\n271\nwhere this strategy (and likewise the two-argument ver-\nsion given above) is not suﬃciently general. (Hint: Con-\nsider the case where there are some suitable mixed-type\noperations present in the table that will not be tried.)\nExercise 2.83: Suppose you are designing a generic arith-\nmetic system for dealing with the tower of types shown in\nFigure 2.25 : integer, rational, real, complex. For each type\n(except complex), design a procedure that raises objects of\nthat type one level in the tower. Show how to install a\ngeneric raiseoperation that will work for each type (ex-\ncept complex).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 521, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 882}}
{"id": "computer_science_sicp_abelson_chunk_0522_5723459c", "text": "For each type\n(except complex), design a procedure that raises objects of\nthat type one level in the tower. Show how to install a\ngeneric raiseoperation that will work for each type (ex-\ncept complex). Exercise 2.84: Using the raiseoperation of Exercise 2.83 ,\nmodify the apply-generic procedure so that it coerces its\narguments to have the same type by the method of succes-\nsive raising, as discussed in this section. You will need to\ndevise a way to test which of two types is higher in the\ntower. Do this in a manner that is “compatible” with the\nrest of the system and will not lead to problems in adding\nnew levels to the tower. Exercise 2.85: is section mentioned a method for “sim-\nplifying” a data object by lowering it in the tower of types\nas far as possible. Design a procedure dropthat accom-\nplishes this for the tower described in Exercise 2.83 . e\nkey is to decide, in some general way, whether an object\ncan be lowered.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 522, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_sicp_abelson_chunk_0523_0ff64877", "text": "Design a procedure dropthat accom-\nplishes this for the tower described in Exercise 2.83 . e\nkey is to decide, in some general way, whether an object\ncan be lowered. For example, the complex number 1 :5 + 0i\ncan be lowered as far as real, the complex number 1 + 0 i\ncan be lowered as far as integer , and the complex number\n272\n2+3icannot be lowered at all. Here is a plan for determin-\ning whether an object can be lowered: Begin by deﬁning\na generic operation project that “pushes” an object down\nin the tower. For example, projecting a complex number\nwould involve throwing away the imaginary part. en a\nnumber can be dropped if, when we project it and raise\nthe result back to the type we started with, we end up with\nsomethingequaltowhatwestartedwith.Showhowtoim-\nplementthisideaindetail,bywritinga dropprocedurethat\ndrops an object as far as possible.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 523, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 859}}
{"id": "computer_science_sicp_abelson_chunk_0524_43646a5a", "text": "You will need to design\nthevariousprojectionoperations53andinstall project asa\ngenericoperationinthesystem.Youwillalsoneedtomake\nuse of a generic equality predicate, such as described in\nExercise 2.79 . Finally, use dropto rewrite apply-generic\nfromExercise 2.84 so that it “simpliﬁes” its answers. Exercise 2.86: Suppose we want to handle complex num-\nberswhoserealparts,imaginaryparts,magnitudes,andan-\ngles can be either ordinary numbers, rational numbers, or\nother numbers we might wish to add to the system. De-\nscribe and implement the changes to the system needed to\naccommodate this. You will have to deﬁne operations such\nassineandcosinethataregenericoverordinarynumbers\nand rational numbers. 53A real number can be projected to an integer using the roundprimitive, which\nreturns the closest integer to its argument.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 524, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 825}}
{"id": "computer_science_sicp_abelson_chunk_0525_3455bc0a", "text": "53A real number can be projected to an integer using the roundprimitive, which\nreturns the closest integer to its argument. 273\n2.5.3Example: Symbolic Algebra\ne manipulation of symbolic algebraic expressions is a complex pro-\ncess that illustrates many of the hardest problems that occur in the de-\nsign of large-scale systems. An algebraic expression, in general, can\nbe viewed as a hierarchical structure, a tree of operators applied to\noperands. We can construct algebraic expressions by starting with a\nset of primitive objects, such as constants and variables, and combining\nthese by means of algebraic operators, such as addition and multipli-\ncation. As in other languages, we form abstractions that enable us to\nrefertocompoundobjectsinsimpleterms.Typicalabstractionsinsym-\nbolic algebra are ideas such as linear combination, polynomial, rational\nfunction, or trigonometric function. We can regard these as compound\n“types,” which are oen useful for directing the processing of expres-\nsions.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 525, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_sicp_abelson_chunk_0526_b8931517", "text": "We can regard these as compound\n“types,” which are oen useful for directing the processing of expres-\nsions. For example, we could describe the expression\nx2sin (y2+ 1 )+xcos2y+ cos (y3\u00002y2)\nas a polynomial in xwith coeﬃcients that are trigonometric functions\nof polynomials in ywhose coeﬃcients are integers. We will not aempt to develop a complete algebraic-manipulation\nsystemhere.Suchsystemsareexceedinglycomplexprograms,embody-\ning deep algebraic knowledge and elegant algorithms. What we will do\nis look at a simple but important part of algebraic manipulation: the\narithmetic of polynomials. We will illustrate the kinds of decisions the\ndesigner of such a system faces, and how to apply the ideas of abstract\ndata and generic operations to help organize this eﬀort.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 526, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 775}}
{"id": "computer_science_sicp_abelson_chunk_0527_2e98c467", "text": "We will illustrate the kinds of decisions the\ndesigner of such a system faces, and how to apply the ideas of abstract\ndata and generic operations to help organize this eﬀort. Arithmetic on polynomials\nOur ﬁrst task in designing a system for performing arithmetic on poly-\nnomialsistodecidejustwhatapolynomialis.Polynomialsarenormally\n274\ndeﬁned relative to certain variables (the indeterminates of the polyno-\nmial). For simplicity, we will restrict ourselves to polynomials having\njustoneindeterminate( univariate polynomials ).54Wewilldeﬁneapoly-\nnomial to be a sum of terms, each of which is either a coeﬃcient, a\npower of the indeterminate, or a product of a coeﬃcient and a power\nof the indeterminate. A coeﬃcient is deﬁned as an algebraic expression\nthat is not dependent upon the indeterminate of the polynomial. For\nexample,\n5x2+ 3x+ 7\nis a simple polynomial in x, and\n(y2+ 1 )x3+(2y)x+ 1\nis a polynomial in xwhose coeﬃcients are polynomials in y.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 527, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 955}}
{"id": "computer_science_sicp_abelson_chunk_0528_cd1a9703", "text": "For\nexample,\n5x2+ 3x+ 7\nis a simple polynomial in x, and\n(y2+ 1 )x3+(2y)x+ 1\nis a polynomial in xwhose coeﬃcients are polynomials in y. Alreadyweareskirtingsomethornyissues.Istheﬁrstofthesepoly-\nnomials the same as the polynomial 5 y2+ 3y+ 7, or not? A reasonable\nanswer might be “yes, if we are considering a polynomial purely as a\nmathematical function, but no, if we are considering a polynomial to\nbe a syntactic form.” e second polynomial is algebraically equivalent\nto a polynomial in ywhose coeﬃcients are polynomials in x. Should\noursystemrecognizethis,ornot?Furthermore,thereareotherwaysto\nrepresent a polynomial—for example, as a product of factors, or (for a\nunivariate polynomial) as the set of roots, or as a listing of the values of\nthe polynomial at a speciﬁed set of points.55We can ﬁnesse these ques-\n54On the other hand, we will allow polynomials whose coeﬃcients are themselves\npolynomials in other variables.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 528, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 929}}
{"id": "computer_science_sicp_abelson_chunk_0529_67705c27", "text": "is will give us essentially the same representational\npower as a full multivariate system, although it does lead to coercion problems, as\ndiscussed below. 55Forunivariatepolynomials,givingthevalueofapolynomialatagivensetofpoints\ncanbeaparticularlygoodrepresentation.ismakespolynomialarithmeticextremely\n275\ntions by deciding that in our algebraic-manipulation system a “polyno-\nmial” will be a particular syntactic form, not its underlying mathemat-\nical meaning. Nowwemustconsiderhowtogoaboutdoingarithmeticonpolyno-\nmials. In this simple system, we will consider only addition and multi-\nplication.Moreover,wewillinsistthattwopolynomialstobecombined\nmust have the same indeterminate. Wewillapproachthedesignofoursystembyfollowingthefamiliar\ndiscipline of data abstraction. We will represent polynomials using a\ndatastructurecalleda poly,whichconsistsofavariableandacollection\nof terms.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 529, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 889}}
{"id": "computer_science_sicp_abelson_chunk_0530_be2e2dd9", "text": "Wewillapproachthedesignofoursystembyfollowingthefamiliar\ndiscipline of data abstraction. We will represent polynomials using a\ndatastructurecalleda poly,whichconsistsofavariableandacollection\nof terms. We assume that we have selectors variable andterm-list\nthat extract those parts from a poly and a constructor make-poly that\nassemblesapolyfromagivenvariableandatermlist.Avariablewillbe\njust a symbol, so we can use the same-variable? procedure of Section\n2.3.2tocomparevariables.efollowingproceduresdeﬁneadditionand\nmultiplication of polys:\n(define (add-poly p1p2)\n(if(same-variable? (variable p1) (variable p2))\n(make-poly (variable p1)\n(add-terms (term-list p1) (term-list p2)))\n(error \"Polys not insame var:ADD-POLY \"(list p1p2))))\n(define (mul-poly p1p2)\n(if(same-variable? (variable p1) (variable p2))\n(make-poly (variable p1)\n(mul-terms (term-list p1) (term-list p2)))\n(error \"Polys not insame var:MUL-POLY \"(list p1p2))))\nsimple.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 530, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_sicp_abelson_chunk_0531_cb309d68", "text": "(variable p1) (variable p2))\n(make-poly (variable p1)\n(mul-terms (term-list p1) (term-list p2)))\n(error \"Polys not insame var:MUL-POLY \"(list p1p2))))\nsimple. To obtain, for example, the sum of two polynomials represented in this way,\nwe need only add the values of the polynomials at corresponding points. To transform\nback to a more familiar representation, we can use the Lagrange interpolation formula,\nwhich shows how to recover the coeﬃcients of a polynomial of degree ngiven the\nvalues of the polynomial at n+ 1 points. 276\nToincorporatepolynomialsintoourgenericarithmeticsystem,weneed\ntosupplythemwithtypetags.We’llusethetag polynomial ,andinstall\nappropriate operations on tagged polynomials in the operation table.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 531, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 724}}
{"id": "computer_science_sicp_abelson_chunk_0532_76d2e8db", "text": "276\nToincorporatepolynomialsintoourgenericarithmeticsystem,weneed\ntosupplythemwithtypetags.We’llusethetag polynomial ,andinstall\nappropriate operations on tagged polynomials in the operation table. We’llembedallourcodeinaninstallationprocedureforthepolynomial\npackage, similar to the ones in Section 2.5.1 :\n(define (install-polynomial-package )\n;; internal procedures\n;; representation of poly\n(define (make-poly variable term-list ) (cons variable term-list ))\n(define (variable p) (car p))\n(define (term-list p) (cdr p))\n⟨procedures same-variable? and variable?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 532, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 564}}
{"id": "computer_science_sicp_abelson_chunk_0533_be4a06d6", "text": "and variable? from section 2.3.2 ⟩\n;; representation of terms and term lists\n⟨procedures adjoin-term : : :coeff from text below ⟩\n(define (add-poly p1p2): : :)\n⟨procedures used by add-poly⟩\n(define (mul-poly p1p2): : :)\n⟨procedures used by mul-poly⟩\n;; interface to rest of the system\n(define (tag p) (attach-tag 'polynomial p))\n(put 'add '(polynomial polynomial )\n(lambda (p1p2) (tag (add-poly p1p2))))\n(put 'mul '(polynomial polynomial )\n(lambda (p1p2) (tag (mul-poly p1p2))))\n(put 'make 'polynomial\n(lambda (var terms ) (tag (make-poly var terms ))))\n'done )\nPolynomial addition is performed termwise. Terms of the same order\n(i.e.,withthesamepoweroftheindeterminate)mustbecombined.is\nisdonebyforminganewtermofthesameorderwhosecoeﬃcientisthe\nsum of the coeﬃcients of the addends. Terms in one addend for which\n277\nthere are no terms of the same order in the other addend are simply\naccumulated into the sum polynomial being constructed.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 533, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_sicp_abelson_chunk_0534_af2e0d45", "text": "Terms in one addend for which\n277\nthere are no terms of the same order in the other addend are simply\naccumulated into the sum polynomial being constructed. In order to manipulate term lists, we will assume that we have a\nconstructor the-empty-termlist that returns an empty term list and\na constructor adjoin-term that adjoins a new term to a term list. We\nwillalsoassumethatwehaveapredicate empty-termlist? thattellsifa\ngiventermlistisempty,aselector first-term thatextractsthehighest-\norder term from a term list, and a selector rest-terms that returns all\nbut the highest-order term. To manipulate terms, we will suppose that\nwe have a constructor make-term that constructs a term with given or-\nder and coeﬃcient, and selectors orderandcoeffthat return, respec-\ntively, the order and the coeﬃcient of the term. ese operations allow\nus to consider both terms and term lists as data abstractions, whose\nconcrete representations we can worry about separately.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 534, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_sicp_abelson_chunk_0535_8325af6e", "text": "ese operations allow\nus to consider both terms and term lists as data abstractions, whose\nconcrete representations we can worry about separately. Here is the procedure that constructs the term list for the sum of\ntwo polynomials:56\n(define (add-terms L1L2)\n(cond ((empty-termlist? L1)L2)\n((empty-termlist? L2)L1)\n(else\n(let ((t1(first-term L1))\n(t2(first-term L2)))\n(cond ((> ( order t1) (order t2))\n(adjoin-term\nt1(add-terms (rest-terms L1)L2)))\n((< ( order t1) (order t2))\n56is operation is very much like the ordered union-set operation we developed\ninExercise 2.62 . In fact, if we think of the terms of the polynomial as a set ordered\naccording to the power of the indeterminate, then the program that produces the term\nlist for a sum is almost identical to union-set .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 535, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 776}}
{"id": "computer_science_sicp_abelson_chunk_0536_dcf8f7cf", "text": "278\n(adjoin-term\nt2(add-terms L1(rest-terms L2))))\n(else\n(adjoin-term\n(make-term (order t1)\n(add (coeff t1) (coeff t2)))\n(add-terms (rest-terms L1)\n(rest-terms L2)))))))))\ne most important point to note here is that we used the generic ad-\ndition procedure addto add together the coeﬃcients of the terms being\ncombined. is has powerful consequences, as we will see below. In order to multiply two term lists, we multiply each term of the\nﬁrst list by all the terms of the other list, repeatedly using mul-term-\nby-all-terms , which multiplies a given term by all terms in a given\nterm list. e resulting term lists (one for each term of the ﬁrst list) are\naccumulated into a sum. Multiplying two terms forms a term whose\norder is the sum of the orders of the factors and whose coeﬃcient is the\nproduct of the coeﬃcients of the factors:\n(define (mul-terms L1L2)\n(if(empty-termlist?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 536, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 882}}
{"id": "computer_science_sicp_abelson_chunk_0537_aca52eec", "text": "Multiplying two terms forms a term whose\norder is the sum of the orders of the factors and whose coeﬃcient is the\nproduct of the coeﬃcients of the factors:\n(define (mul-terms L1L2)\n(if(empty-termlist? L1)\n(the-empty-termlist )\n(add-terms (mul-term-by-all-terms (first-term L1)L2)\n(mul-terms (rest-terms L1)L2))))\n(define (mul-term-by-all-terms t1L)\n(if(empty-termlist? L)\n(the-empty-termlist )\n(let ((t2(first-term L)))\n(adjoin-term\n(make-term (+ ( order t1) (order t2))\n(mul (coeff t1) (coeff t2)))\n(mul-term-by-all-terms t1(rest-terms L))))))\n279\nis is really all there is to polynomial addition and multiplication. No-\ntice that, since we operate on terms using the generic procedures add\nand mul, our polynomial package is automatically able to handle any\ntype of coeﬃcient that is known about by the generic arithmetic pack-\nage.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 537, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 835}}
{"id": "computer_science_sicp_abelson_chunk_0538_97bdc5e4", "text": "If we include a coercion mechanism such as one of those discussed\ninSection2.5.2 ,thenwealsoareautomaticallyabletohandleoperations\non polynomials of diﬀerent coeﬃcient types, such as\n[3x2+(2 + 3i)x+ 7 ]\u0001[\nx4+2\n3x2+(5 + 3i)]\n:\nBecauseweinstalledthepolynomialadditionandmultiplicationproce-\ndures add-poly andmul-poly in the generic arithmetic system as the\naddandmuloperations for type polynomial , our system is also auto-\nmatically able to handle polynomial operations such as\n[\n(y+ 1 )x2+(y2+ 1 )x+(y\u00001)]\n\u0001[\n(y\u00002)x+(y3+ 7 )]\n:\ne reason is that when the system tries to combine coeﬃcients, it will\ndispatch through addand mul. Since the coeﬃcients are themselves\npolynomials (in y), these will be combined using add-poly and mul-\npoly. e result is a kind of “data-directed recursion” in which, for ex-\nample, a call to mul-poly will result in recursive calls to mul-poly in\norder to multiply the coeﬃcients.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 538, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 910}}
{"id": "computer_science_sicp_abelson_chunk_0539_6bce5960", "text": "e result is a kind of “data-directed recursion” in which, for ex-\nample, a call to mul-poly will result in recursive calls to mul-poly in\norder to multiply the coeﬃcients. If the coeﬃcients of the coeﬃcients\nwere themselves polynomials (as might be used to represent polynomi-\nals in three variables), the data direction would ensure that the system\nwouldfollowthroughanotherlevelofrecursivecalls,andsoonthrough\nas many levels as the structure of the data dictates.57\n57To make this work completely smoothly, we should also add to our generic arith-\nmetic system the ability to coerce a “number” to a polynomial by regarding it as a\n280\nRepresenting term lists\nFinally, we must confront the job of implementing a good representa-\ntion for term lists. A term list is, in eﬀect, a set of coeﬃcients keyed\nby the order of the term. Hence, any of the methods for representing\nsets, as discussed in Section 2.3.3 , can be applied to this task.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 539, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_sicp_abelson_chunk_0540_f0578db6", "text": "A term list is, in eﬀect, a set of coeﬃcients keyed\nby the order of the term. Hence, any of the methods for representing\nsets, as discussed in Section 2.3.3 , can be applied to this task. On the\nother hand, our procedures add-terms and mul-terms always access\nterm lists sequentially from highest to lowest order. us, we will use\nsome kind of ordered list representation. How should we structure the list that represents a term list? One\nconsideration is the “density” of the polynomials we intend to manip-\nulate. A polynomial is said to be denseif it has nonzero coeﬃcients in\ntermsofmostorders.Ifithasmanyzerotermsitissaidtobe sparse.For\nexample,\nA:x5+ 2x4+ 3x2\u00002x\u00005\nis a dense polynomial, whereas\nB:x100+ 2x2+ 1\nis sparse. etermlistsofdensepolynomialsaremosteﬃcientlyrepresented\nas lists of the coeﬃcients. For example, Aabove would be nicely rep-\nresented as (1 2 0 3 -2 -5) .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 540, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 883}}
{"id": "computer_science_sicp_abelson_chunk_0541_93bad72e", "text": "etermlistsofdensepolynomialsaremosteﬃcientlyrepresented\nas lists of the coeﬃcients. For example, Aabove would be nicely rep-\nresented as (1 2 0 3 -2 -5) . e order of a term in this representa-\ntion is the length of the sublist beginning with that term’s coeﬃcient,\npolynomial of degree zero whose coeﬃcient is the number. is is necessary if we are\ngoing to perform operations such as\n[x2+(y+ 1 )x+ 5 ]+[x2+ 2x+ 1 ];\nwhich requires adding the coeﬃcient y+ 1 to the coeﬃcient 2. 281\ndecrementedby1.58iswouldbeaterriblerepresentationforasparse\npolynomial such as B: ere would be a giant list of zeros punctuated\nbyafewlonelynonzeroterms.Amorereasonablerepresentationofthe\nterm list of a sparse polynomial is as a list of the nonzero terms, where\neach term is a list containing the order of the term and the coeﬃcient\nfor that order. In such a scheme, polynomial Bis eﬃciently represented\nas((100 1) (2 2) (0 1)) .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 541, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 915}}
{"id": "computer_science_sicp_abelson_chunk_0542_023d7e75", "text": "In such a scheme, polynomial Bis eﬃciently represented\nas((100 1) (2 2) (0 1)) . As most polynomial manipulations are\nperformed on sparse polynomials, we will use this method. We will as-\nsume that term lists are represented as lists of terms, arranged from\nhighest-order to lowest-order term. Once we have made this decision,\nimplementing the selectors and constructors for terms and term lists is\nstraightforward:59\n(define (adjoin-term term term-list )\n(if(=zero? (coeff term ))\nterm-list\n(cons term term-list )))\n(define (the-empty-termlist )'())\n(define (first-term term-list ) (car term-list ))\n(define (rest-terms term-list ) (cdr term-list ))\n(define (empty-termlist? term-list ) (null? term-list ))\n(define (make-term order coeff ) (list order coeff ))\n58In these polynomial examples, we assume that we have implemented the generic\narithmetic system using the type mechanism suggested in Exercise 2.78 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 542, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 912}}
{"id": "computer_science_sicp_abelson_chunk_0543_f40b2de2", "text": "us, coeﬃ-\ncients that are ordinary numbers will be represented as the numbers themselves rather\nthan as pairs whose caris the symbol scheme-number . 59Although we are assuming that term lists are ordered, we have implemented ad-\njoin-term to simply consthe new term onto the existing term list. We can get away\nwith this so long as weguarantee that the procedures(such as add-terms )that use ad-\njoin-term alwayscallitwithahigher-ordertermthanappearsinthelist.Ifwedidnot\nwant to make such a guarantee, we could have implemented adjoin-term to be simi-\nlar to the adjoin-set constructor for the ordered-list representation of sets ( Exercise\n2.61). 282\n(define (order term ) (car term ))\n(define (coeff term ) (cadr term ))\nwhere =zero?is as deﬁned in Exercise 2.80 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 543, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 767}}
{"id": "computer_science_sicp_abelson_chunk_0544_89af3ea2", "text": "282\n(define (order term ) (car term ))\n(define (coeff term ) (cadr term ))\nwhere =zero?is as deﬁned in Exercise 2.80 . (See also Exercise 2.87 be-\nlow.)\nUsers of the polynomial package will create (tagged) polynomials\nby means of the procedure:\n(define (make-polynomial var terms )\n((get 'make 'polynomial )var terms ))\nExercise2.87: Install =zero?forpolynomialsinthegeneric\narithmetic package. is will allow adjoin-term to work\nfor polynomials with coeﬃcients that are themselves poly-\nnomials. Exercise 2.88: Extend the polynomial system to include\nsubtraction of polynomials. (Hint: You may ﬁnd it helpful\nto deﬁne a generic negation operation.)\nExercise2.89: Deﬁneproceduresthatimplementtheterm-\nlistrepresentationdescribedaboveasappropriatefordense\npolynomials. Exercise2.90: Suppose we want to have a polynomial sys-\ntem that is eﬃcient for both sparse and dense polynomials. Onewaytodothisistoallowbothkindsofterm-listrepre-\nsentations in our system.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 544, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 958}}
{"id": "computer_science_sicp_abelson_chunk_0545_32d9902c", "text": "Exercise2.90: Suppose we want to have a polynomial sys-\ntem that is eﬃcient for both sparse and dense polynomials. Onewaytodothisistoallowbothkindsofterm-listrepre-\nsentations in our system. e situation is analogous to the\ncomplex-numberexampleof Section2.4 ,whereweallowed\nboth rectangular and polar representations. To do this we\nmust distinguish diﬀerent types of term lists and make the\noperations on term lists generic. Redesign the polynomial\n283\nsystemtoimplementthisgeneralization.isisamajoref-\nfort, not a local change. Exercise 2.91: A univariate polynomial can be divided by\nanother one to produce a polynomial quotient and a poly-\nnomial remainder. For example,\nx5\u00001\nx2\u00001=x3+x;remainder x\u00001:\nDivision can be performed via long division. at is, divide\nthehighest-ordertermofthedividendbythehighest-order\nterm of the divisor. e result is the ﬁrst term of the quo-\ntient.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 545, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 884}}
{"id": "computer_science_sicp_abelson_chunk_0546_ec4d6739", "text": "at is, divide\nthehighest-ordertermofthedividendbythehighest-order\nterm of the divisor. e result is the ﬁrst term of the quo-\ntient. Next, multiply the result by the divisor, subtract that\nfromthedividend,andproducetherestoftheanswerbyre-\ncursively dividing the diﬀerence by the divisor. Stop when\nthe order of the divisor exceeds the order of the dividend\nand declare the dividend to be the remainder. Also, if the\ndividend ever becomes zero, return zero as both quotient\nand remainder. We can design a div-poly procedure on the model of add-\npolyandmul-poly . e procedure checks to see if the two\npolys have the same variable. If so, div-poly strips oﬀ the\nvariable and passes the problem to div-terms , which per-\nformsthedivisionoperationontermlists. div-poly ﬁnally\nreaachesthevariabletotheresultsuppliedby div-terms . It is convenient to design div-terms to compute both the\nquotient and the remainder of a division.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 546, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 925}}
{"id": "computer_science_sicp_abelson_chunk_0547_1eb88e3c", "text": "div-poly ﬁnally\nreaachesthevariabletotheresultsuppliedby div-terms . It is convenient to design div-terms to compute both the\nquotient and the remainder of a division. div-terms can\ntake two term lists as arguments and return a list of the\nquotient term list and the remainder term list. 284\nComplete the following deﬁnition of div-terms by ﬁlling\ninthemissingexpressions.Usethistoimplement div-poly ,\nwhichtakestwopolysasargumentsandreturnsalistofthe\nquotient and remainder polys. (define (div-terms L1L2)\n(if(empty-termlist?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 547, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 527}}
{"id": "computer_science_sicp_abelson_chunk_0548_7d83d5ef", "text": "(define (div-terms L1L2)\n(if(empty-termlist? L1)\n(list (the-empty-termlist ) (the-empty-termlist ))\n(let ((t1(first-term L1))\n(t2(first-term L2)))\n(if(> ( order t2) (order t1))\n(list (the-empty-termlist )L1)\n(let ((new-c (div (coeff t1) (coeff t2)))\n(new-o (- ( order t1) (order t2))))\n(let ((rest-of-result\n⟨compute rest of result recursively ⟩))\n⟨form complete result ⟩))))))\nHierarchies of types in symbolic algebra\nOur polynomial system illustrates how objects of one type (polynomi-\nals) may in fact be complex objects that have objects of many diﬀerent\ntypes as parts. is poses no real diﬃculty in deﬁning generic opera-\ntions. We need only install appropriate generic operations for perform-\ning the necessary manipulations of the parts of the compound types. In fact, we saw that polynomials form a kind of “recursive data abstrac-\ntion,”inthatpartsofapolynomialmaythemselvesbepolynomials.Our\ngenericoperationsandourdata-directedprogrammingstylecanhandle\nthis complication without much trouble.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 548, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_sicp_abelson_chunk_0549_1a725c96", "text": "On the other hand, polynomial algebra is a system for which the\ndata types cannot be naturally arranged in a tower. For instance, it is\npossible to have polynomials in xwhose coeﬃcients are polynomials\niny. It is also possible to have polynomials in ywhose coeﬃcients are\n285\npolynomials in x. Neither of these types is “above” the other in any\nnatural way, yet it is oen necessary to add together elements from\neach set. ere are several ways to do this. One possibility is to convert\none polynomial to the type of the other by expanding and rearrang-\ning terms so that both polynomials have the same principal variable. One can impose a towerlike structure on this by ordering the variables\nand thus always converting any polynomial to a “canonical form” with\nthe highest-priority variable dominant and the lower-priority variables\nburied in the coeﬃcients.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 549, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 860}}
{"id": "computer_science_sicp_abelson_chunk_0550_4d368305", "text": "is strategy works fairly well, except that\ntheconversionmayexpandapolynomialunnecessarily,makingithard\nto read and perhaps less eﬃcient to work with. e tower strategy is\ncertainly not natural for this domain or for any domain where the user\ncaninventnewtypesdynamicallyusingoldtypesinvariouscombining\nforms, such as trigonometric functions, power series, and integrals. It should not be surprising that controlling coercion is a serious\nproblem in the design of large-scale algebraic-manipulation systems. Muchofthecomplexityofsuchsystemsisconcernedwithrelationships\namong diverse types. Indeed, it is fair to say that we do not yet com-\npletely understand coercion. In fact, we do not yet completely under-\nstand the concept of a data type. Nevertheless, what we know provides\nus with powerful structuring and modularity principles to support the\ndesign of large systems.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 550, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 874}}
{"id": "computer_science_sicp_abelson_chunk_0551_cf3ddddf", "text": "Nevertheless, what we know provides\nus with powerful structuring and modularity principles to support the\ndesign of large systems. Exercise 2.92: By imposing an ordering on variables, ex-\ntend the polynomial package so that addition and multipli-\ncation of polynomials works for polynomials in diﬀerent\nvariables. (is is not easy!)\n286\nExtended exercise: Rational functions\nWe can extend our generic arithmetic system to include rational func-\ntions.eseare“fractions”whosenumeratoranddenominatorarepoly-\nnomials, such as\nx+ 1\nx3\u00001:\nesystemshouldbeabletoadd,subtract,multiply,anddividerational\nfunctions, and to perform such computations as\nx+ 1\nx3\u00001+x\nx2\u00001=x3+ 2x2+ 3x+ 1\nx4+x3\u0000x\u00001:\n(Here the sum has been simpliﬁed by removing common factors.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 551, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 746}}
{"id": "computer_science_sicp_abelson_chunk_0552_0ba69938", "text": "Ordi-\nnary “cross multiplication” would have produced a fourth-degree poly-\nnomial over a ﬁh-degree polynomial.)\nIf we modify our rational-arithmetic package so that it uses generic\noperations, then it will do what we want, except for the problem of\nreducing fractions to lowest terms. Exercise 2.93: Modify the rational-arithmetic package to\nusegenericoperations,butchange make-rat sothatitdoes\nnot aempt to reduce fractions to lowest terms. Test your\nsystem by calling make-rational on two polynomials to\nproduce a rational function:\n(define p1(make-polynomial 'x'((2 1) (0 1))))\n(define p2(make-polynomial 'x'((3 1) (0 1))))\n(define rf(make-rational p2p1))\nNow add rfto itself, using add. You will observe that this\nadditionproceduredoesnotreducefractionstolowestterms. 287\nWecanreducepolynomialfractionstolowesttermsusingthesameidea\nwe used with integers: modifying make-rat to divide both the numera-\ntor and the denominator by their greatest common divisor.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 552, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_sicp_abelson_chunk_0553_f429be07", "text": "287\nWecanreducepolynomialfractionstolowesttermsusingthesameidea\nwe used with integers: modifying make-rat to divide both the numera-\ntor and the denominator by their greatest common divisor. e notion\nof “greatest common divisor” makes sense for polynomials. In fact, we\ncan compute the of two polynomials using essentially the same\nEuclid’s Algorithm that works for integers.60e integer version is\n(define (gcd ab)\n(if(=b0)\na\n(gcd b(remainder ab))))\nUsing this, we could make the obvious modiﬁcation to deﬁne a \noperation that works on term lists:\n(define (gcd-terms ab)\n(if(empty-termlist? b)\na\n(gcd-terms b(remainder-terms ab))))\nwhere remainder-terms picks out the remainder component of the list\nreturned by the term-list division operation div-terms that was imple-\nmented in Exercise 2.91 . 60e fact that Euclid’s Algorithm works for polynomials is formalized in algebra\nby saying that polynomials form a kind of algebraic domain called a Euclidean ring .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 553, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_sicp_abelson_chunk_0554_c6e63e3e", "text": "60e fact that Euclid’s Algorithm works for polynomials is formalized in algebra\nby saying that polynomials form a kind of algebraic domain called a Euclidean ring . A\nEuclidean ring is a domain that admits addition, subtraction, and commutative mul-\ntiplication, together with a way of assigning to each element xof the ring a positive\ninteger “measure” m(x)with the properties that m(xy)\u0015m(x)for any nonzero xand\nyand that, given any xandy, there exists a qsuch thaty=qx+rand either r=0\norm(r)<m(x). From an abstract point of view, this is what is needed to prove that\nEuclid’s Algorithm works. For the domain of integers, the measure mof an integer is\nthe absolute value of the integer itself. For the domain of polynomials, the measure of\na polynomial is its degree. 288\nExercise2.94: Using div-terms , implement the procedure\nremainder-terms andusethistodeﬁne gcd-terms asabove. Now write a procedure gcd-poly that computes the poly-\nnomialof two polys.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 554, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_sicp_abelson_chunk_0555_e8a7ae22", "text": "288\nExercise2.94: Using div-terms , implement the procedure\nremainder-terms andusethistodeﬁne gcd-terms asabove. Now write a procedure gcd-poly that computes the poly-\nnomialof two polys. (e procedure should signal an\nerrorifthetwopolysarenotinthesamevariable.)Installin\nthesystemagenericoperation greatest-common-divisor\nthat reduces to gcd-poly for polynomials and to ordinary\ngcdfor ordinary numbers. As a test, try\n(define p1(make-polynomial\n'x'((4 1) (3 -1) (2 -2) (1 2))))\n(define p2(make-polynomial 'x'((3 1) (1 -1))))\n(greatest-common-divisor p1p2)\nand check your result by hand. Exercise 2.95: Deﬁne P1,P2, and P3to be the polynomials\nP1:x2\u00002x+ 1;\nP2: 11 x2+ 7;\nP3: 13 x+ 5:\nNow deﬁne Q1to be the product of P1andP2andQ2to\nbe the product of P1andP3, and use greatest-common-\ndivisor (Exercise 2.94 ) to compute the ofQ1andQ2.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 555, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 841}}
{"id": "computer_science_sicp_abelson_chunk_0556_304e44bf", "text": "Notethattheanswerisnotthesameas P1.isexamplein-\ntroducesnonintegeroperationsintothecomputation,caus-\ning diﬃculties with the algorithm.61To understand\n61In an implementation like Scheme, this produces a polynomial that is indeed\na divisor of Q1andQ2, but with rational coeﬃcients. In many other Scheme systems,\nin which division of integers can produce limited-precision decimal numbers, we may\nfail to get a valid divisor. 289\nwhat is happening, try tracing gcd-terms while comput-\ning theor try performing the division by hand. Wecansolvetheproblemexhibitedin Exercise2.95 ifweusethefollow-\ning modiﬁcation of the algorithm (which really works only in the\ncase of polynomials with integer coeﬃcients). Before performing any\npolynomial division in the computation, we multiply the dividend\nbyanintegerconstantfactor,chosentoguaranteethatnofractionswill\narise during the division process.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 556, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 904}}
{"id": "computer_science_sicp_abelson_chunk_0557_3bb9f4a4", "text": "Before performing any\npolynomial division in the computation, we multiply the dividend\nbyanintegerconstantfactor,chosentoguaranteethatnofractionswill\narise during the division process. Our answer will thus diﬀer from the\nactualby an integer constant factor, but this does not maer in the\ncaseofreducingrationalfunctionstolowestterms;the willbeused\nto divide both the numerator and denominator, so the integer constant\nfactor will cancel out. More precisely, if PandQare polynomials, let O1be the order of P\n(i.e.,theorderofthelargesttermof P)andlet O2betheorderof Q.Letc\nbetheleadingcoeﬃcientof Q.enitcanbeshownthat,ifwemultiply\nPby the integerizing factor c1+O1\u0000O2, the resulting polynomial can be\ndividedby Qbyusingthe div-terms algorithmwithoutintroducingany\nfractions. e operation of multiplying the dividend by this constant\nand then dividing is sometimes called the pseudodivision ofPbyQ. e\nremainder of the division is called the pseudoremainder .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 557, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_sicp_abelson_chunk_0558_e837c88f", "text": "e operation of multiplying the dividend by this constant\nand then dividing is sometimes called the pseudodivision ofPbyQ. e\nremainder of the division is called the pseudoremainder . Exercise 2.96:\na.Implementtheprocedure pseudoremainder-terms ,which\nis just like remainder-terms except that it multiplies\nthedividendbytheintegerizingfactordescribedabove\nbefore calling div-terms . Modify gcd-terms to use\npseudoremainder-terms , and verify that greatest-\ncommon-divisor now produces an answer with inte-\nger coeﬃcients on the example in Exercise 2.95 . 290\nb.enow has integer coeﬃcients, but they are\nlarger than those of P1. Modify gcd-terms so that it\nremoves common factors from the coeﬃcients of the\nanswer by dividing all the coeﬃcients by their (inte-\nger) greatest common divisor. us, here is how to reduce a rational function to lowest terms:\n•Compute the of the numerator and denominator, using the\nversion of gcd-terms fromExercise 2.96 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 558, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 958}}
{"id": "computer_science_sicp_abelson_chunk_0559_9c4e0027", "text": "us, here is how to reduce a rational function to lowest terms:\n•Compute the of the numerator and denominator, using the\nversion of gcd-terms fromExercise 2.96 . •When you obtain the , multiply both numerator and denomi-\nnator by the same integerizing factor before dividing through by\nthe,sothatdivisionbythe willnotintroduceanynonin-\ntegercoeﬃcients.Asthefactoryoucanusetheleadingcoeﬃcient\nof theraised to the power 1+ O1\u0000O2, where O2is the order\noftheandO1isthemaximumoftheordersofthenumerator\nand denominator. is will ensure that dividing the numerator\nand denominator by the will not introduce any fractions. •e result of this operation will be a numerator and denominator\nwith integer coeﬃcients. e coeﬃcients will normally be very\nlargebecauseofalloftheintegerizingfactors,sothelaststepisto\nremovetheredundantfactorsbycomputingthe(integer)greatest\ncommon divisor of all the coeﬃcients of the numerator and the\ndenominator and dividing through by this factor.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 559, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_sicp_abelson_chunk_0560_add09732", "text": "Exercise 2.97:\na.Implementthisalgorithmasaprocedure reduce-terms\nthat takes two term lists nanddas arguments and re-\n291\nturns a list nn,dd, which are nanddreduced to low-\nest terms via the algorithm given above. Also write a\nprocedure reduce-poly , analogous to add-poly , that\nchecks to see if the two polys have the same variable. If so, reduce-poly strips oﬀ the variable and passes\ntheproblemto reduce-terms ,thenreaachesthevari-\nable to the two term lists supplied by reduce-terms .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 560, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 489}}
{"id": "computer_science_sicp_abelson_chunk_0561_29028124", "text": "If so, reduce-poly strips oﬀ the variable and passes\ntheproblemto reduce-terms ,thenreaachesthevari-\nable to the two term lists supplied by reduce-terms . b.Deﬁne a procedure analogous to reduce-terms that\ndoes what the original make-rat did for integers:\n(define (reduce-integers nd)\n(let ((g(gcd nd)))\n(list (/ng) (/ dg))))\nand deﬁne reduce as a generic operation that calls\napply-generic todispatchtoeither reduce-poly (for\npolynomial arguments)or reduce-integers (forscheme-\nnumberarguments).Youcannoweasilymaketherational-\narithmetic package reduce fractions to lowest terms\nbyhaving make-rat callreducebeforecombiningthe\ngiven numerator and denominator to form a ratio-\nnal number. e system now handles rational expres-\nsions in either integers or polynomials.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 561, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 768}}
{"id": "computer_science_sicp_abelson_chunk_0562_ded8965d", "text": "e system now handles rational expres-\nsions in either integers or polynomials. To test your\nprogram, try the example at the beginning of this ex-\ntended exercise:\n(define p1(make-polynomial 'x'((1 1) (0 1))))\n(define p2(make-polynomial 'x'((3 1) (0 -1))))\n(define p3(make-polynomial 'x'((1 1))))\n(define p4(make-polynomial 'x'((2 1) (0 -1))))\n(define rf1 (make-rational p1p2))\n(define rf2 (make-rational p3p4))\n292\n(add rf1 rf2)\nSeeifyougetthecorrectanswer,correctlyreducedto\nlowest terms. ecomputation is at the heart of any system that does opera-\ntions on rational functions. e algorithm used above, although mathe-\nmaticallystraightforward,isextremelyslow.eslownessisduepartly\nto the large number of division operations and partly to the enormous\nsize of the intermediate coeﬃcients generated by the pseudodivisions.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 562, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 827}}
{"id": "computer_science_sicp_abelson_chunk_0563_60f5da0a", "text": "One of the active areas in the development of algebraic-manipulation\nsystems is the design of beer algorithms for computing polynomial\ns.62\n62One extremely eﬃcient and elegant method for computing polynomial s was\ndiscovered by Richard Zippel (1979) . e method is a probabilistic algorithm, as is the\nfast test for primality that we discussed in Chapter 1 . Zippel’s book ( Zippel 1993 ) de-\nscribes this method, together with other ways to compute polynomial s. 293\n\nModularity, Objects, and State\nMεταβάλλον ὰναπαύεται\n(Even while it changes, it stands still.)\n—Heraclitus\nPlus ça change, plus c’est la même chose. —Alphonse Karr\nT   introducedthebasicelementsfromwhich\nprograms are made. We saw how primitive procedures and primi-\ntive data are combined to construct compound entities, and we learned\nthat abstraction is vital in helping us to cope with the complexity of\nlargesystems.Butthesetoolsarenotsuﬃcientfordesigningprograms.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 563, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_sicp_abelson_chunk_0564_8c26f088", "text": "Eﬀective programsynthesis also requires organizational principles that\ncan guide us in formulating the overall design of a program. In partic-\nular, we need strategies to help us structure large systems so that they\n294\nwill be modular , that is, so that they can be divided “naturally” into co-\nherent parts that can be separately developed and maintained. One powerful design strategy, which is particularly appropriate to\nthe construction of programs for modeling physical systems, is to base\nthestructureofourprogramsonthestructureofthesystembeingmod-\neled. For each object in the system, we construct a corresponding com-\nputational object. For each system action, we deﬁne a symbolic opera-\ntioninourcomputationalmodel.Ourhopeinusingthisstrategyisthat\nextending the model to accommodate new objects or new actions will\nrequire no strategic changes to the program, only the addition of the\nnew symbolic analogs of those objects or actions.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 564, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_sicp_abelson_chunk_0565_d7c0017a", "text": "If we have been suc-\ncessful in our system organization, then to add a new feature or debug\nan old one we will have to work on only a localized part of the system. To a large extent, then, the way we organize a large program is dic-\ntated by our perception of the system to be modeled. In this chapter we\nwill investigate two prominent organizational strategies arising from\ntwo rather diﬀerent “world views” of the structure of systems. e ﬁrst\norganizational strategy concentrates on objects, viewing a large system\nas a collection of distinct objects whose behaviors may change over\ntime.Analternativeorganizationalstrategyconcentratesonthe streams\nof information that ﬂow in the system, much as an electrical engineer\nviews a signal-processing system.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 565, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 755}}
{"id": "computer_science_sicp_abelson_chunk_0566_b2ca1226", "text": "Boththeobject-basedapproachandthestream-processingapproach\nraisesigniﬁcantlinguisticissuesinprogramming.Withobjects,wemust\nbeconcernedwithhowacomputationalobjectcanchangeandyetmain-\ntainitsidentity.iswillforceustoabandonouroldsubstitutionmodel\nof computation ( Section 1.1.5 ) in favor of a more mechanistic but less\ntheoretically tractable environment model of computation. e diﬃcul-\ntiesofdealingwithobjects,change,andidentityareafundamentalcon-\n295\nsequenceoftheneedtograpplewithtimeinourcomputationalmodels. ese diﬃculties become even greater when we allow the possibility of\nconcurrent execution of programs. e stream approach can be most\nfullyexploitedwhenwedecouplesimulatedtimeinourmodelfromthe\norder of the events that take place in the computer during evaluation. Wewillaccomplishthisusingatechniqueknownas delayed evaluation . 3.1Assignment and Local State\nWeordinarilyviewtheworldaspopulatedbyindependentobjects,each\nof which has a state that changes over time.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 566, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_sicp_abelson_chunk_0567_a7709099", "text": "Wewillaccomplishthisusingatechniqueknownas delayed evaluation . 3.1Assignment and Local State\nWeordinarilyviewtheworldaspopulatedbyindependentobjects,each\nof which has a state that changes over time. An object is said to “have\nstate” if its behavior is inﬂuenced by its history. A bank account, for\nexample, has state in that the answer to the question “Can I withdraw\n$100?” depends upon the history of deposit and withdrawal transac-\ntions. We can characterize an object’s state by one or more state vari-\nables, which among them maintain enough information about history\nto determine the object’s current behavior. In a simple banking system,\nwecouldcharacterizethestateofanaccountbyacurrentbalancerather\nthan by remembering the entire history of account transactions. In a system composed of many objects, the objects are rarely com-\npletely independent. Each may inﬂuence the states of others through\ninteractions, which serve to couple the state variables of one object to\nthose of other objects.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 567, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_sicp_abelson_chunk_0568_7b07619c", "text": "Each may inﬂuence the states of others through\ninteractions, which serve to couple the state variables of one object to\nthose of other objects. Indeed, the view that a system is composed of\nseparate objects is most useful when the state variables of the system\ncan be grouped into closely coupled subsystems that are only loosely\ncoupled to other subsystems. is view of a system can be a powerful framework for organizing\ncomputational models of the system. For such a model to be modular, it\nshouldbedecomposedintocomputationalobjectsthatmodeltheactual\n296\nobjects in the system. Each computational object must have its own lo-\ncal state variables describing the actual object’s state. Since the states of\nobjects in the system being modeled change over time, the state vari-\nables of the corresponding computational objects must also change.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 568, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 844}}
{"id": "computer_science_sicp_abelson_chunk_0569_6779190b", "text": "Since the states of\nobjects in the system being modeled change over time, the state vari-\nables of the corresponding computational objects must also change. If\nwe choose to model the ﬂow of time in the system by the elapsed time\nin the computer, then we must have a way to construct computational\nobjects whose behaviors change as our programs run. In particular, if\nwe wish to model state variables by ordinary symbolic names in the\nprogramming language, then the language must provide an assignment\noperator to enable us to change the value associated with a name. 3.1.1Local State Variables\nToillustratewhatwemeanbyhavingacomputationalobjectwithtime-\nvarying state, let us model the situation of withdrawing money from a\nbank account. We will do this using a procedure withdraw , which takes\nas argument an amountto be withdrawn. If there is enough money in\nthe account to accommodate the withdrawal, then withdraw should re-\nturn the balance remaining aer the withdrawal.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 569, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_sicp_abelson_chunk_0570_1d784dff", "text": "If there is enough money in\nthe account to accommodate the withdrawal, then withdraw should re-\nturn the balance remaining aer the withdrawal. Otherwise, withdraw\nshould return the message Insuﬃcient funds . For example, if we begin\nwith $100 in the account, we should obtain the following sequence of\nresponses using withdraw :\n(withdraw 25)\n75\n(withdraw 25)\n50\n(withdraw 60)\n\"Insufficient funds\"\n(withdraw 15)\n35\n297\nObserve that the expression (withdraw 25) , evaluated twice, yields\ndiﬀerent values. is is a new kind of behavior for a procedure.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 570, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 551}}
{"id": "computer_science_sicp_abelson_chunk_0571_10d2587f", "text": "is is a new kind of behavior for a procedure. Until\nnow, all our procedures could be viewed as speciﬁcations for comput-\ningmathematicalfunctions.Acalltoaprocedurecomputedthevalueof\nthe function applied to the given arguments, and two calls to the same\nprocedure with the same arguments always produced the same result.1\nTo implement withdraw , we can use a variable balance to indicate\nthebalanceofmoneyintheaccountanddeﬁne withdraw asaprocedure\nthataccesses balance .e withdraw procedurecheckstoseeif balance\nis at least as large as the requested amount. If so, withdraw decrements\nbalance byamountand returns the new value of balance . Otherwise,\nwithdraw returnsthe Insuﬃcient funds message.Herearethedeﬁnitions\nofbalance andwithdraw :\n(define balance 100)\n(define (withdraw amount )\n(if(>= balance amount )\n(begin (set! balance (-balance amount ))\nbalance )\n\"Insufficient funds \"))\nDecrementing balance is accomplished by the expression\n(set!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 571, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_sicp_abelson_chunk_0572_91dc7b48", "text": "balance (-balance amount ))\nbalance )\n\"Insufficient funds \"))\nDecrementing balance is accomplished by the expression\n(set! balance (-balance amount ))\nis uses the set!special form, whose syntax is\n(set!⟨name⟩⟨new-value⟩)\n1Actually, this is not quite true. One exception was the random-number generator\ninSection1.2.6 .Anotherexceptioninvolvedtheoperation/typetablesweintroducedin\nSection 2.4.3 , where the values of two calls to getwith the same arguments depended\noninterveningcallsto put.Ontheotherhand,untilweintroduceassignment,wehave\nno way to create such procedures ourselves. 298\nHere⟨name⟩isasymboland⟨new-value⟩isanyexpression. set!changes\n⟨name⟩sothatitsvalueistheresultobtainedbyevaluating ⟨new-value⟩.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 572, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 714}}
{"id": "computer_science_sicp_abelson_chunk_0573_b4cd9ec8", "text": "298\nHere⟨name⟩isasymboland⟨new-value⟩isanyexpression. set!changes\n⟨name⟩sothatitsvalueistheresultobtainedbyevaluating ⟨new-value⟩. In the case at hand, we are changing balance so that its new value will\nbetheresultofsubtracting amountfromthepreviousvalueof balance .2\nwithdraw alsousesthe beginspecialformtocausetwoexpressions\nto be evaluated in the case where the iftest is true: ﬁrst decrementing\nbalance andthenreturningthevalueof balance .Ingeneral,evaluating\nthe expression\n(begin⟨exp 1⟩⟨exp2⟩: : :⟨exp k⟩)\ncauses the expressions ⟨exp1⟩through⟨expk⟩to be evaluated in se-\nquence and the value of the ﬁnal expression ⟨expk⟩to be returned as\nthe value of the entire beginform.3\nAlthough withdraw worksasdesired,thevariable balance presents\na problem.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 573, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 753}}
{"id": "computer_science_sicp_abelson_chunk_0574_9d1a7ae6", "text": "As speciﬁed above, balance is a name deﬁned in the global\nenvironmentandisfreelyaccessibletobeexaminedormodiﬁedbyany\nprocedure.Itwouldbemuchbeerifwecouldsomehowmake balance\ninternal to withdraw , so that withdraw would be the only procedure\nthatcouldaccess balance directlyandanyotherprocedurecouldaccess\nbalance only indirectly (through calls to withdraw ). is would more\naccurately model the notion that balance is a local state variable used\n2e value of a set!expression is implementation-dependent. set!should be used\nonly for its eﬀect, not for its value. ename set!reﬂectsanamingconventionusedinScheme:Operationsthatchange\nthe values of variables (or that change data structures, as we will see in Section 3.3 ) are\ngiven names that end with an exclamation point. is is similar to the convention of\ndesignating predicates by names that end with a question mark. 3We have already used beginimplicitly in our programs, because in Scheme the\nbody of a procedure can be a sequence of expressions.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 574, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_sicp_abelson_chunk_0575_aa36ef4b", "text": "3We have already used beginimplicitly in our programs, because in Scheme the\nbody of a procedure can be a sequence of expressions. Also, the ⟨consequent⟩part of\neach clause in a condexpression can be a sequence of expressions rather than a single\nexpression. 299\nbywithdraw to keep track of the state of the account. We can make balance internal to withdraw by rewriting the deﬁ-\nnition as follows:\n(define new-withdraw\n(let ((balance 100))\n(lambda (amount )\n(if(>= balance amount )\n(begin (set! balance (-balance amount ))\nbalance )\n\"Insufficient funds \"))))\nWhat we have done here is use letto establish an environment with a\nlocal variable balance , bound to the initial value 100. Within this local\nenvironment, we use lambdato create a procedure that takes amountas\nan argument and behaves like our previous withdraw procedure.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 575, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 832}}
{"id": "computer_science_sicp_abelson_chunk_0576_77f54cd8", "text": "Within this local\nenvironment, we use lambdato create a procedure that takes amountas\nan argument and behaves like our previous withdraw procedure. is\nprocedure—returned as the result of evaluating the letexpression—is\nnew-withdraw , which behaves in precisely the same way as withdraw\nbut whose variable balance is not accessible by any other procedure.4\nCombining set!with local variables is the general programming\ntechnique we will use for constructing computational objects with lo-\ncal state. Unfortunately, using this technique raises a serious problem:\nWhen we ﬁrst introduced procedures, we also introduced the substi-\ntution model of evaluation ( Section 1.1.5 ) to provide an interpretation\nof what procedure application means. We said that applying a proce-\ndureshouldbeinterpretedasevaluatingthebodyoftheprocedurewith\nthe formal parameters replaced by their values.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 576, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 879}}
{"id": "computer_science_sicp_abelson_chunk_0577_3a36c692", "text": "We said that applying a proce-\ndureshouldbeinterpretedasevaluatingthebodyoftheprocedurewith\nthe formal parameters replaced by their values. e trouble is that, as\n4In programming-language jargon, the variable balance is said to be encapsulated\nwithin the new-withdraw procedure. Encapsulation reﬂects the general system-design\nprinciple known as the hiding principle : One can make a system more modular and ro-\nbustbyprotectingpartsofthesystemfromeachother;thatis,byprovidinginformation\naccess only to those parts of the system that have a “need to know.”\n300\nsoon as we introduce assignment into our language, substitution is no\nlonger an adequate model of procedure application. (We will see why\nthis is so in Section 3.1.3 .) As a consequence, we technically have at\nthis point no way to understand why the new-withdraw procedure be-\nhaves as claimed above. In order to really understand a procedure such\nasnew-withdraw ,wewillneedtodevelopanewmodelofprocedureap-\nplication.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 577, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_sicp_abelson_chunk_0578_5adc6379", "text": "In order to really understand a procedure such\nasnew-withdraw ,wewillneedtodevelopanewmodelofprocedureap-\nplication. In Section 3.2 we will introduce such a model, together with\nan explanation of set!and local variables. First, however, we examine\nsome variations on the theme established by new-withdraw . e following procedure, make-withdraw , creates “withdrawal pro-\ncessors.”eformalparameter balance inmake-withdraw speciﬁesthe\ninitial amount of money in the account.5\n(define (make-withdraw balance )\n(lambda (amount )\n(if(>= balance amount )\n(begin (set! balance (-balance amount ))\nbalance )\n\"Insufficient funds \")))\nmake-withdraw can be used as follows to create two objects W1andW2:\n(define W1(make-withdraw 100))\n(define W2(make-withdraw 100))\n(W150)\n50\n(W270)\n30\n5In contrast with new-withdraw above, we do not have to use letto make balance\na local variable, since formal parameters are already local.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 578, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_sicp_abelson_chunk_0579_535666cf", "text": "is will be clearer aer the\ndiscussion of the environment model of evaluation in Section 3.2 . (See also Exercise\n3.10.)\n301\n(W240)\n\"Insufficient funds\"\n(W140)\n10\nObserve that W1andW2are completely independent objects, each with\nitsownlocalstatevariable balance .Withdrawalsfromonedonotaﬀect\nthe other. We can also create objects that handle deposits as well as with-\ndrawals, and thus we can represent simple bank accounts. Here is a\nprocedure that returns a “bank-account object” with a speciﬁed initial\nbalance:\n(define (make-account balance )\n(define (withdraw amount )\n(if(>= balance amount )\n(begin (set! balance (-balance amount ))\nbalance )\n\"Insufficient funds \"))\n(define (deposit amount )\n(set! balance (+balance amount ))\nbalance )\n(define (dispatch m)\n(cond ((eq? m'withdraw )withdraw )\n((eq? m'deposit )deposit )\n(else (error \"Unknown request :MAKE-ACCOUNT \"\nm))))\ndispatch )\nEach call to make-account sets up an environment with a local state\nvariable balance .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 579, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_sicp_abelson_chunk_0580_ebe4b64b", "text": "m'withdraw )withdraw )\n((eq? m'deposit )deposit )\n(else (error \"Unknown request :MAKE-ACCOUNT \"\nm))))\ndispatch )\nEach call to make-account sets up an environment with a local state\nvariable balance . Within this environment, make-account deﬁnes pro-\ncedures deposit andwithdraw that access balance and an additional\nprocedure dispatch that takes a “message” as input and returns one of\n302\nthe two local procedures. e dispatch procedure itself is returned as\nthe value that represents the bank-account object. is is precisely the\nmessage-passing style of programming that we saw in Section 2.4.3 , al-\nthough here we are using it in conjunction with the ability to modify\nlocal variables. make-account can be used as follows:\n(define acc (make-account 100))\n((acc 'withdraw ) 50)\n50\n((acc 'withdraw ) 60)\n\"Insufficient funds\"\n((acc 'deposit ) 40)\n90\n((acc 'withdraw ) 60)\n30\nEach call to accreturns the locally deﬁned deposit orwithdraw pro-\ncedure, which is then applied to the speciﬁed amount.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 580, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 997}}
{"id": "computer_science_sicp_abelson_chunk_0581_a01755bd", "text": "As was the case\nwith make-withdraw , another call to make-account\n(define acc2 (make-account 100))\nwill produce a completely separate account object, which maintains its\nown local balance . Exercise 3.1: Anaccumulator is a procedure that is called\nrepeatedly with a single numeric argument and accumu-\nlates its arguments into a sum. Each time it is called, it\nreturns the currently accumulated sum. Write a procedure\nmake-accumulator thatgeneratesaccumulators,eachmain-\ntaininganindependentsum.einputto make-accumulator\nshould specify the initial value of the sum; for example\n303\n(define A(make-accumulator 5))\n(A10)\n15\n(A10)\n25\nExercise 3.2: In soware-testing applications, it is useful\nto be able to count the number of times a given procedure\nis called during the course of a computation. Write a pro-\ncedure make-monitored that takes as input a procedure, f,\nthat itself takes one input.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 581, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_sicp_abelson_chunk_0582_e95f3406", "text": "Write a pro-\ncedure make-monitored that takes as input a procedure, f,\nthat itself takes one input. e result returned by make-\nmonitored is a third procedure, say mf, that keeps track\nof the number of times it has been called by maintaining\nan internal counter. If the input to mfis the special symbol\nhow-many-calls? ,then mfreturnsthevalueofthecounter. If the input is the special symbol reset-count , then mfre-\nsets the counter to zero.For any other input, mfreturns the\nresultofcalling fonthatinputandincrementsthecounter. For instance, we could make a monitored version of the\nsqrtprocedure:\n(define s(make-monitored sqrt ))\n(s100)\n10\n(s'how-many-calls?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 582, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 660}}
{"id": "computer_science_sicp_abelson_chunk_0583_bb4c010a", "text": "For instance, we could make a monitored version of the\nsqrtprocedure:\n(define s(make-monitored sqrt ))\n(s100)\n10\n(s'how-many-calls? )\n1\nExercise 3.3: Modify the make-account procedure so that\nitcreatespassword-protectedaccounts.atis, make-account\nshould take a symbol as an additional argument, as in\n(define acc (make-account 100 'secret-password ))\n304\ne resulting account object should process a request only\nif it is accompanied by the password with which the ac-\ncountwascreated,andshouldotherwisereturnacomplaint:\n((acc 'secret-password 'withdraw ) 40)\n60\n((acc 'some-other-password 'deposit ) 50)\n\"Incorrect password\"\nExercise 3.4: Modify the make-account procedure of Ex-\nercise 3.3 by adding another local state variable so that, if\nan account is accessed more than seven consecutive times\nwithanincorrectpassword,itinvokestheprocedure call-\nthe-cops .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 583, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 863}}
{"id": "computer_science_sicp_abelson_chunk_0584_0c8244ce", "text": "3.1.2The Benefits of Introducing Assignment\nAs we shall see, introducing assignment into our programming lan-\nguageleadsusintoathicketofdiﬃcultconceptualissues.Nevertheless,\nviewing systems as collections of objects with local state is a powerful\ntechnique for maintaining a modular design. As a simple example, con-\nsider the design of a procedure randthat, whenever it is called, returns\nan integer chosen at random. It is not at all clear what is meant by “chosen at random.” What we\npresumablywantisforsuccessivecallsto randtoproduceasequenceof\nnumbers that has statistical properties of uniform distribution. We will\nnot discuss methods for generating suitable sequences here.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 584, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 681}}
{"id": "computer_science_sicp_abelson_chunk_0585_fc6b72b1", "text": "We will\nnot discuss methods for generating suitable sequences here. Rather, let\nusassumethatwehaveaprocedure rand-update thathastheproperty\nthat if we start with a given number x1and form\nx2= (rand-update x1)\nx3= (rand-update x2)\n305\nthenthesequenceofvalues x1,x2,x3,: : :willhavethedesiredstatistical\nproperties.6\nWe can implement randas a procedure with a local state variable\nxthat is initialized to some ﬁxed value random-init . Each call to rand\ncomputes rand-update of the current value of x, returns this as the\nrandom number, and also stores this as the new value of x. (define rand (let ((xrandom-init ))\n(lambda ()\n(set! x(rand-update x))\nx)))\nOf course, we could generate the same sequence of random numbers\nwithoutusingassignmentbysimplycalling rand-update directly.How-\never, this would mean that any part of our program that used random\nnumbers would have to explicitly remember the current value of xto\nbe passed as an argument to rand-update .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 585, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_sicp_abelson_chunk_0586_3d88aabc", "text": "To realize what an annoy-\nance this would be, consider using random numbers to implement a\ntechnique called Monte Carlo simulation . e Monte Carlo method consists of choosing sample experiments\nat random from a large set and then making deductions on the basis of\n6One common way to implement rand-update is to use the rule that xis updated\ntoax+bmodulo m, where a,b, and mare appropriately chosen integers. Chapter 3\nofKnuth 1981 includes an extensive discussion of techniques for generating sequences\nof random numbers and establishing their statistical properties. Notice that the rand-\nupdateprocedure computes a mathematical function: Given the same input twice, it\nproduces the same output. erefore, the number sequence produced by rand-update\ncertainly is not “random,” if by “random” we insist that each number in the sequence\nis unrelated to the preceding number.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 586, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 874}}
{"id": "computer_science_sicp_abelson_chunk_0587_466cd0f2", "text": "erefore, the number sequence produced by rand-update\ncertainly is not “random,” if by “random” we insist that each number in the sequence\nis unrelated to the preceding number. e relation between “real randomness” and so-\ncalled pseudo-random sequences,whichareproducedbywell-determinedcomputations\nand yet have suitable statistical properties, is a complex question involving diﬃcult\nissuesinmathematicsandphilosophy.Kolmogorov,Solomonoﬀ,andChaitinhavemade\ngreat progress in clarifying these issues; a discussion can be found in Chaitin 1975 . 306\nthe probabilities estimated from tabulating the results of those experi-\nments. For example, we can approximate πusing the fact that 6 =π2is\nthe probability that two integers chosen at random will have no fac-\ntors in common; that is, that their greatest common divisor will be 1.7\nTo obtain the approximation to π, we perform a large number of ex-\nperiments.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 587, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_sicp_abelson_chunk_0588_8bceec84", "text": "In each experiment we choose two integers at random and\nperform a test to see if their is 1. e fraction of times that the test\nis passed gives us our estimate of 6 =π2, and from this we obtain our\napproximation to π. e heart of our program is a procedure monte-carlo , which takes\nas arguments the number of times to try an experiment, together with\nthe experiment, represented as a no-argument procedure that will re-\nturneithertrueorfalseeachtimeitisrun. monte-carlo runstheexper-\niment for the designated number of trials and returns a number telling\nthe fraction of the trials in which the experiment was found to be true. (define (estimate-pi trials )\n(sqrt (/ 6 ( monte-carlo trials cesaro-test ))))\n(define (cesaro-test )\n(= ( gcd (rand ) (rand )) 1))\n(define (monte-carlo trials experiment )\n(define (iter trials-remaining trials-passed )\n(cond ((= trials-remaining 0)\n(/trials-passed trials ))\n((experiment )\n(iter (-trials-remaining 1)\n(+trials-passed 1)))\n(else\n7is theorem is due to E.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 588, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_sicp_abelson_chunk_0589_5c9fe3f6", "text": "Cesàro. See section 4.5.2 of Knuth 1981 for a discussion\nand a proof. 307\n(iter (-trials-remaining 1)\ntrials-passed ))))\n(iter trials 0))\nNowletustrythesamecomputationusing rand-update directlyrather\nthan rand, the way we would be forced to proceed if we did not use\nassignment to model local state:\n(define (estimate-pi trials )\n(sqrt (/ 6 ( random-gcd-test trials random-init ))))\n(define (random-gcd-test trials initial-x )\n(define (iter trials-remaining trials-passed x)\n(let ((x1(rand-update x)))\n(let ((x2(rand-update x1)))\n(cond ((= trials-remaining 0)\n(/trials-passed trials ))\n((= ( gcd x1x2) 1)\n(iter (-trials-remaining 1)\n(+trials-passed 1)\nx2))\n(else\n(iter (-trials-remaining 1)\ntrials-passed\nx2))))))\n(iter trials 0initial-x ))\nWhile the program is still simple, it betrays some painful breaches of\nmodularity.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 589, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 823}}
{"id": "computer_science_sicp_abelson_chunk_0590_569647e9", "text": "In our ﬁrst version of the program, using rand, we can ex-\npresstheMonteCarlomethoddirectlyasageneral monte-carlo proce-\ndure that takes as an argument an arbitrary experiment procedure. In\nour second version of the program, with no local state for the random-\nnumbergenerator, random-gcd-test mustexplicitlymanipulatetheran-\ndom numbers x1and x2and recycle x2through the iterative loop as\nthe new input to rand-update . is explicit handling of the random\n308\nnumbersintertwinesthestructureofaccumulatingtestresultswiththe\nfact that our particular experiment uses two random numbers, whereas\notherMonteCarloexperimentsmightuseonerandomnumberorthree. Even the top-level procedure estimate-pi has to be concerned with\nsupplying an initial random number. e fact that the random-number\ngenerator’sinsidesareleakingoutintootherpartsoftheprogrammakes\nitdiﬃcultforustoisolatetheMonteCarloideasothatitcanbeapplied\nto other tasks.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 590, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_sicp_abelson_chunk_0591_db9286c8", "text": "e fact that the random-number\ngenerator’sinsidesareleakingoutintootherpartsoftheprogrammakes\nitdiﬃcultforustoisolatetheMonteCarloideasothatitcanbeapplied\nto other tasks. In the ﬁrst version of the program, assignment encapsu-\nlates the state of the random-number generator within the randproce-\ndure,sothatthedetailsofrandom-numbergenerationremainindepen-\ndent of the rest of the program. e general phenomenon illustrated by the Monte Carlo example is\nthis: From the point of view of one part of a complex process, the other\nparts appear to change with time. ey have hidden time-varying local\nstate. If we wish to write computer programs whose structure reﬂects\nthis decomposition, we make computational objects (such as bank ac-\ncounts and random-number generators) whose behavior changes with\ntime.Wemodelstatewithlocalstatevariables,andwemodelthechanges\nof state with assignments to those variables.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 591, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 905}}
{"id": "computer_science_sicp_abelson_chunk_0592_c08512a7", "text": "It is tempting to conclude this discussion by saying that, by intro-\nducing assignment and the technique of hiding state in local variables,\nwe are able to structure systems in a more modular fashion than if all\nstatehadtobemanipulatedexplicitly,bypassingadditionalparameters. Unfortunately, as we shall see, the story is not so simple. Exercise 3.5: Monte Carlo integration is a method of esti-\nmating deﬁnite integrals by means of Monte Carlo simula-\ntion. Consider computing the area of a region of space de-\nscribed by a predicate P(x;y)that is true for points (x;y)\nin the region and false for points not in the region. For\n309\nexample, the region contained within a circle of radius 3\ncentered at (5, 7) is described by the predicate that tests\nwhether (x\u00005)2+(y\u00007)2\u001432. To estimate the area of the\nregion described by such a predicate, begin by choosing a\nrectanglethatcontainstheregion.Forexample,arectangle\nwith diagonally opposite corners at (2, 4) and (8, 10) con-\ntains the circle above.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 592, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_sicp_abelson_chunk_0593_7074e2a1", "text": "e desired integral is the area of\nthat portion of the rectangle that lies in the region. We can\nestimate the integral by picking, at random, points (x;y)\nthat lie in the rectangle, and testing P(x;y)for each point\nto determine whether the point lies in the region. If we try\nthis with many points, then the fraction of points that fall\nin the region should give an estimate of the proportion of\ntherectanglethatliesintheregion.Hence,multiplyingthis\nfraction by the area of the entire rectangle should produce\nan estimate of the integral. ImplementMonteCarlointegrationasaprocedure estimate-\nintegral that takes as arguments a predicate P, upper and\nlower bounds x1,x2,y1, and y2for the rectangle, and the\nnumber of trials to perform in order to produce the esti-\nmate. Your procedure should use the same monte-carlo\nprocedurethatwasusedabovetoestimate π.Useyour estimate-\nintegral to produce an estimate of πby measuring the\narea of a unit circle.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 593, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_sicp_abelson_chunk_0594_137144e4", "text": "Your procedure should use the same monte-carlo\nprocedurethatwasusedabovetoestimate π.Useyour estimate-\nintegral to produce an estimate of πby measuring the\narea of a unit circle. You will ﬁnd it useful to have a procedure that returns a\nnumber chosen at random from a given range. e follow-\ningrandom-in-range procedure implements this in terms\nof the random procedure used in Section 1.2.6 , which re-\n310\nturns a nonnegative number less than its input.8\n(define (random-in-range low high )\n(let ((range (-high low)))\n(+low (random range ))))\nExercise3.6: Itisusefultobeabletoresetarandom-number\ngeneratortoproduceasequencestartingfromagivenvalue. Design a new randprocedure that is called with an ar-\ngument that is either the symbol generate or the symbol\nresetandbehavesasfollows: (rand 'generate) produces\na new random number; ((rand 'reset)⟨new-value⟩)re-\nsetstheinternalstatevariabletothedesignated ⟨new-value⟩. us,byreseingthestate,onecangeneraterepeatablese-\nquences.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 594, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_sicp_abelson_chunk_0595_82ea2bd9", "text": "us,byreseingthestate,onecangeneraterepeatablese-\nquences. ese are very handy to have when testing and\ndebugging programs that use random numbers. 3.1.3The Costs of Introducing Assignment\nAs we have seen, the set!operation enables us to model objects that\nhave local state. However, this advantage comes at a price. Our pro-\ngramming language can no longer be interpreted in terms of the sub-\nstitution model of procedure application that we introduced in Section\n1.1.5. Moreover, no simple model with “nice” mathematical properties\ncan be an adequate framework for dealing with objects and assignment\nin programming languages. So long as we do not use assignments, two evaluations of the same\nprocedure with the same arguments will produce the same result, so\n8Scheme provides such a procedure. If randomis given an exact integer (as in\nSection 1.2.6 ) it returns an exact integer, but if it is given a decimal value (as in this\nexercise) it returns a decimal value.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 595, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_sicp_abelson_chunk_0596_53aef891", "text": "If randomis given an exact integer (as in\nSection 1.2.6 ) it returns an exact integer, but if it is given a decimal value (as in this\nexercise) it returns a decimal value. 311\nthat procedures can be viewed as computing mathematical functions. Programming without any use of assignments, as we did throughout\nthe ﬁrst two chapters of this book, is accordingly known as functional\nprogramming . Tounderstandhowassignmentcomplicatesmaers,considerasim-\npliﬁed version of the make-withdraw procedure of Section 3.1.1 that\ndoes not bother to check for an insuﬃcient amount:\n(define (make-simplified-withdraw balance )\n(lambda (amount )\n(set!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 596, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 636}}
{"id": "computer_science_sicp_abelson_chunk_0597_fab47c76", "text": "balance (-balance amount ))\nbalance ))\n(define W(make-simplified-withdraw 25))\n(W20)\n5\n(W10)\n-5\nCompare this procedure with the following make-decrementer proce-\ndure, which does not use set!:\n(define (make-decrementer balance )\n(lambda (amount )\n(-balance amount )))\nmake-decrementer returns a procedure that subtracts its input from a\ndesignated amount balance , but there is no accumulated eﬀect over\nsuccessive calls, as with make-simplified-withdraw :\n(define D(make-decrementer 25))\n(D20)\n5\n(D10)\n15\n312\nWe can use the substitution model to explain how make-decrementer\nworks. For instance, let us analyze the evaluation of the expression\n((make-decrementer 25) 20)\nWe ﬁrst simplify the operator of the combination by substituting 25 for\nbalance inthebodyof make-decrementer .isreducestheexpression\nto\n((lambda (amount ) (- 25 amount )) 20)\nNow we apply the operator by substituting 20 for amountin the body\nof the lambdaexpression:\n(- 25 20)\ne ﬁnal answer is 5.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 597, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_sicp_abelson_chunk_0598_1fa2581a", "text": "Observe,however,whathappensifweaemptasimilarsubstitution\nanalysis with make-simplified-withdraw :\n((make-simplified-withdraw 25) 20)\nWeﬁrstsimplifytheoperatorbysubstituting25for balance inthebody\nofmake-simplified-withdraw . is reduces the expression to9\n((lambda (amount ) (set! balance (- 25 amount )) 25) 20)\nNow we apply the operator by substituting 20 for amountin the body\nof the lambdaexpression:\n(set! balance (- 25 20)) 25\nIf we adhered to the substitution model, we would have to say that the\nmeaningoftheprocedureapplicationistoﬁrstset balance to5andthen\n9We don’t substitute for the occurrence of balance in the set!expression because\nthe⟨name⟩in a set!is not evaluated. If we did substitute for it, we would get (set! 25 (- 25 amount)) , which makes no sense. 313\nreturn 25 as the value of the expression. is gets the wrong answer.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 598, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 847}}
{"id": "computer_science_sicp_abelson_chunk_0599_c0a74ec7", "text": "If we did substitute for it, we would get (set! 25 (- 25 amount)) , which makes no sense. 313\nreturn 25 as the value of the expression. is gets the wrong answer. In\nordertogetthecorrectanswer,wewouldhavetosomehowdistinguish\nthe ﬁrst occurrence of balance (before the eﬀect of the set!) from the\nsecond occurrence of balance (aer the eﬀect of the set!), and the\nsubstitution model cannot do this. e trouble here is that substitution is based ultimately on the no-\ntion that the symbols in our language are essentially names for values. But as soon as we introduce set!and the idea that the value of a vari-\nable can change, a variable can no longer be simply a name. Now a\nvariablesomehowreferstoaplacewhereavaluecanbestored,andthe\nvalue stored at this place can change. In Section 3.2 we will see how\nenvironments play this role of “place” in our computational model.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 599, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 870}}
{"id": "computer_science_sicp_abelson_chunk_0600_a2a83888", "text": "Now a\nvariablesomehowreferstoaplacewhereavaluecanbestored,andthe\nvalue stored at this place can change. In Section 3.2 we will see how\nenvironments play this role of “place” in our computational model. Sameness and change\ne issue surfacing here is more profound than the mere breakdown of\naparticularmodelofcomputation.Assoonasweintroducechangeinto\nourcomputationalmodels,manynotionsthatwerepreviouslystraight-\nforward become problematical. Consider the concept of two things be-\ning “the same.”\nSuppose we call make-decrementer twice with the same argument\nto create two procedures:\n(define D1(make-decrementer 25))\n(define D2(make-decrementer 25))\nAreD1andD2thesame?Anacceptableanswerisyes,because D1andD2\nhave the same computational behavior—each is a procedure that sub-\ntracts its input from 25. In fact, D1could be substituted for D2in any\ncomputation without changing the result.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 600, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 887}}
{"id": "computer_science_sicp_abelson_chunk_0601_57e7a670", "text": "In fact, D1could be substituted for D2in any\ncomputation without changing the result. Contrastthiswithmakingtwocallsto make-simplified-withdraw :\n314\n(define W1(make-simplified-withdraw 25))\n(define W2(make-simplified-withdraw 25))\nAre W1and W2the same? Surely not, because calls to W1and W2have\ndistinct eﬀects, as shown by the following sequence of interactions:\n(W120)\n5\n(W120)\n-15\n(W220)\n5\nEven though W1andW2are “equal” in the sense that they are both cre-\nated by evaluating the same expression, (make-simplified-withdraw\n25), it is not true that W1could be substituted for W2in any expression\nwithout changing the result of evaluating the expression. Alanguagethatsupportstheconceptthat“equalscanbesubstituted\nfor equals” in an expression without changing the value of the expres-\nsion is said to be referentially transparent . Referential transparency is\nviolated when we include set!in our computer language.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 601, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_sicp_abelson_chunk_0602_563278e4", "text": "Referential transparency is\nviolated when we include set!in our computer language. is makes\nittrickytodeterminewhenwecansimplifyexpressionsbysubstituting\nequivalent expressions. Consequently, reasoning about programs that\nuse assignment becomes drastically more diﬃcult. Onceweforgoreferentialtransparency,thenotionofwhatitmeans\nfor computational objects to be “the same” becomes diﬃcult to capture\ninaformalway.Indeed,themeaningof“same”intherealworldthatour\nprograms model is hardly clear in itself. In general, we can determine\nthat two apparently identical objects are indeed “the same one” only by\nmodifying one object and then observing whether the other object has\nchangedinthesameway.Buthowcanwetellifanobjecthas“changed”\nother than by observing the “same” object twice and seeing whether\n315\nsome property of the object diﬀers from one observation to the next?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 602, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 869}}
{"id": "computer_science_sicp_abelson_chunk_0603_555a854f", "text": "us, we cannot determine “change” without some a priori notion of\n“sameness,” and we cannot determine sameness without observing the\neﬀects of change. As an example of how this issue arises in programming, consider\nthe situation where Peter and Paul have a bank account with $100 in it. ere is a substantial diﬀerence between modeling this as\n(define peter-acc (make-account 100))\n(define paul-acc (make-account 100))\nand modeling it as\n(define peter-acc (make-account 100))\n(define paul-acc peter-acc )\nIn the ﬁrst situation, the two bank accounts are distinct. Transactions\nmade by Peter will not aﬀect Paul’s account, and vice versa. In the sec-\nond situation, however, we have deﬁned paul-acc to be the same thing\naspeter-acc . In eﬀect, Peter and Paul now have a joint bank account,\nand if Peter makes a withdrawal from peter-acc Paul will observe less\nmoney in paul-acc . ese two similar but distinct situations can cause\nconfusion in building computational models.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 603, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_sicp_abelson_chunk_0604_08a39cc6", "text": "ese two similar but distinct situations can cause\nconfusion in building computational models. With the shared account,\nin particular, it can be especially confusing that there is one object (the\nbank account) that has two diﬀerent names ( peter-acc andpaul-acc );\nif we are searching for all the places in our program where paul-acc\ncan be changed, we must remember to look also at things that change\npeter-acc .10\n10ephenomenonofasinglecomputationalobjectbeingaccessedbymorethanone\nname is known as aliasing. e joint bank account situation illustrates a very simple\nexample of an alias. In Section 3.3 we will see much more complex examples, such as\n“distinct” compound data structures that share parts.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 604, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 707}}
{"id": "computer_science_sicp_abelson_chunk_0605_c9ed3e28", "text": "e joint bank account situation illustrates a very simple\nexample of an alias. In Section 3.3 we will see much more complex examples, such as\n“distinct” compound data structures that share parts. Bugs can occur in our programs\n316\nWith reference to the above remarks on “sameness” and “change,”\nobserve that if Peter and Paul could only examine their bank balances,\nandcouldnotperformoperationsthatchangedthebalance,thentheis-\nsueofwhetherthetwoaccountsaredistinctwouldbemoot.Ingeneral,\nso long as we never modify data objects, we can regard a compound\ndataobjecttobepreciselythetotalityofitspieces.Forexample,aratio-\nnal number is determined by giving its numerator and its denominator. Butthisviewisnolongervalidinthepresenceofchange,whereacom-\npounddataobjecthasan“identity”thatissomethingdiﬀerentfromthe\npieces of which it is composed.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 605, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 839}}
{"id": "computer_science_sicp_abelson_chunk_0606_fd2becec", "text": "Butthisviewisnolongervalidinthepresenceofchange,whereacom-\npounddataobjecthasan“identity”thatissomethingdiﬀerentfromthe\npieces of which it is composed. A bank account is still “the same” bank\naccount even if we change the balance by making a withdrawal; con-\nversely, we could have two diﬀerent bank accounts with the same state\ninformation. is complication is a consequence, not of our program-\nminglanguage,butofourperceptionofabankaccountasanobject.We\ndo not, for example, ordinarily regard a rational number as a change-\nable object with identity, such that we could change the numerator and\nstill have “the same” rational number. Pitfalls of imperative programming\nIn contrast to functional programming, programming that makes ex-\ntensive use of assignment is known as imperative programming . In ad-\ndition to raising complications about computational models, programs\nwrien in imperative style are susceptible to bugs that cannot occur in\nfunctional programs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 606, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_sicp_abelson_chunk_0607_164d5e84", "text": "In ad-\ndition to raising complications about computational models, programs\nwrien in imperative style are susceptible to bugs that cannot occur in\nfunctional programs. For example, recall the iterative factorial program\nif we forget that a change to an object may also, as a “side eﬀect,” change a “diﬀerent”\nobject because the two “diﬀerent” objects are actually a single object appearing under\ndiﬀerent aliases. ese so-called side-eﬀect bugs are so diﬃcult to locate and to analyze\nthat some people have proposed that programming languages be designed in such a\nway as to not allow side eﬀects or aliasing ( Lampson et al. 1981 ;Morris et al. 1980 ).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 607, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 654}}
{"id": "computer_science_sicp_abelson_chunk_0608_bedbf205", "text": "1981 ;Morris et al. 1980 ). 317\nfromSection 1.2.1 :\n(define (factorial n)\n(define (iter product counter )\n(if(>counter n)\nproduct\n(iter (*counter product ) (+ counter 1))))\n(iter 1 1))\nInstead of passing arguments in the internal iterative loop, we could\nadopt a more imperative style by using explicit assignment to update\nthe values of the variables product andcounter :\n(define (factorial n)\n(let ((product 1)\n(counter 1))\n(define (iter )\n(if(>counter n)\nproduct\n(begin (set! product (*counter product ))\n(set! counter (+counter 1))\n(iter ))))\n(iter )))\nis does not change the results produced by the program, but it does\nintroduceasubtletrap.Howdowedecidetheorderoftheassignments? Asithappens,theprogramiscorrectaswrien.Butwritingtheassign-\nments in the opposite order\n(set! counter (+counter 1))\n(set! product (*counter product ))\nwould have produced a diﬀerent, incorrect result.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 608, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 887}}
{"id": "computer_science_sicp_abelson_chunk_0609_02d9a4d5", "text": "Asithappens,theprogramiscorrectaswrien.Butwritingtheassign-\nments in the opposite order\n(set! counter (+counter 1))\n(set! product (*counter product ))\nwould have produced a diﬀerent, incorrect result. In general, program-\nmingwithassignmentforcesustocarefullyconsidertherelativeorders\noftheassignmentstomakesurethateachstatementisusingthecorrect\n318\nversion of the variables that have been changed. is issue simply does\nnot arise in functional programs.11\ne complexity of imperative programs becomes even worse if we\nconsider applications in which several processes execute concurrently. We will return to this in Section 3.4 . First, however, we will address the\nissue of providing a computational model for expressions that involve\nassignment,andexploretheusesofobjectswithlocalstateindesigning\nsimulations. Exercise3.7: Considerthebankaccountobjectscreatedby\nmake-account , with the password modiﬁcation described\ninExercise 3.3 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 609, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_sicp_abelson_chunk_0610_43a46344", "text": "Exercise3.7: Considerthebankaccountobjectscreatedby\nmake-account , with the password modiﬁcation described\ninExercise 3.3 . Suppose that our banking system requires\ntheabilitytomakejointaccounts.Deﬁneaprocedure make-\njointthataccomplishesthis. make-joint shouldtakethree\narguments. e ﬁrst is a password-protected account. e\nsecondargumentmustmatchthepasswordwithwhichthe\naccountwasdeﬁnedinorderforthe make-joint operation\nto proceed. e third argument is a new password. make-\njointis to create an additional access to the original ac-\ncount using the new password. For example, if peter-acc\nis a bank account with password open-sesame , then\n(define paul-acc\n(make-joint peter-acc 'open-sesame 'rosebud ))\n11In view of this, it is ironic that introductory programming is most oen taught\nin a highly imperative style. is may be a vestige of a belief, common throughout\nthe 1960s and 1970s, that programs that call procedures must inherently be less eﬃ-\ncient than programs that perform assignments.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 610, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_sicp_abelson_chunk_0611_01f71ff3", "text": "is may be a vestige of a belief, common throughout\nthe 1960s and 1970s, that programs that call procedures must inherently be less eﬃ-\ncient than programs that perform assignments. ( Steele 1977 debunks this argument.)\nAlternatively it may reﬂect a view that step-by-step assignment is easier for beginners\nto visualize than procedure call. Whatever the reason, it oen saddles beginning pro-\ngrammers with “should I set this variable before or aer that one” concerns that can\ncomplicate programming and obscure the important ideas. 319\nwillallowonetomaketransactionson peter-acc usingthe\nname paul-acc and the password rosebud . You may wish\ntomodifyyoursolutionto Exercise3.3 toaccommodatethis\nnew feature. Exercise 3.8: When we deﬁned the evaluation model in\nSection 1.1.3 , we said that the ﬁrst step in evaluating an\nexpression is to evaluate its subexpressions. But we never\nspeciﬁed the order in which the subexpressions should be\nevaluated (e.g., le to right or right to le).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 611, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_sicp_abelson_chunk_0612_de01c948", "text": "But we never\nspeciﬁed the order in which the subexpressions should be\nevaluated (e.g., le to right or right to le). When we in-\ntroduce assignment, the order in which the arguments to a\nprocedureareevaluatedcanmakeadiﬀerencetotheresult. Deﬁne a simple procedure fsuch that evaluating\n(+ ( f0) ( f1))\nwillreturn0iftheargumentsto +areevaluatedfromleto\nright but will return 1 if the arguments are evaluated from\nright to le. 3.2The Environment Model of Evaluation\nWhen we introduced compound procedures in Chapter 1 , we used the\nsubstitution model of evaluation ( Section 1.1.5 ) to deﬁne what is meant\nby applying a procedure to arguments:\n•To apply a compound procedure to arguments, evaluate the body\noftheprocedurewitheachformalparameterreplacedbythecor-\nresponding argument. Onceweadmitassignmentintoourprogramminglanguage,suchadef-\ninition is no longer adequate.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 612, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 871}}
{"id": "computer_science_sicp_abelson_chunk_0613_f3669ccd", "text": "Onceweadmitassignmentintoourprogramminglanguage,suchadef-\ninition is no longer adequate. In particular, Section 3.1.3 argued that, in\n320\nthepresenceofassignment,avariablecannolongerbeconsideredtobe\nmerely a name for a value. Rather, a variable must somehow designate\na“place”inwhichvaluescanbestored.Inournewmodelofevaluation,\nthese places will be maintained in structures called environments . An environment is a sequence of frames. Each frame is a table (pos-\nsiblyempty)of bindings ,whichassociatevariablenameswiththeircor-\nresponding values. (A single frame may contain at most one binding\nfor any variable.) Each frame also has a pointer to its enclosing environ-\nment, unless, for the purposes of discussion, the frame is considered to\nbeglobal. e value of a variable with respect to an environment is the\nvalue given by the binding of the variable in the ﬁrst frame in the en-\nvironment that contains a binding for that variable.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 613, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_sicp_abelson_chunk_0614_a7167422", "text": "e value of a variable with respect to an environment is the\nvalue given by the binding of the variable in the ﬁrst frame in the en-\nvironment that contains a binding for that variable. If no frame in the\nsequencespeciﬁesabindingforthevariable,thenthevariableissaidto\nbeunbound in the environment. Figure3.1 showsasimpleenvironmentstructureconsistingofthree\nframes,labeledI,II,andIII.Inthediagram,A,B,C,andDarepointersto\nenvironments. C and D point to the same environment. e variables z\nandxareboundinframeII,while yandxareboundinframeI.evalue\nofxin environment D is 3. e value of xwith respect to environment\nB is also 3. is is determined as follows: We examine the ﬁrst frame in\nthe sequence (frame III) and do not ﬁnd a binding for x, so we proceed\nto the enclosing environment D and ﬁnd the binding in frame I. On the\notherhand,thevalueof xinenvironmentAis7,becausetheﬁrstframe\nin the sequence (frame II) contains a binding of xto 7.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 614, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_sicp_abelson_chunk_0615_abee8457", "text": "On the\notherhand,thevalueof xinenvironmentAis7,becausetheﬁrstframe\nin the sequence (frame II) contains a binding of xto 7. With respect to\nenvironment A, the binding of xto 7 in frame II is said to shadow the\nbinding of xto 3 in frame I. e environment is crucial to the evaluation process, because it de-\ntermines the context in which an expression should be evaluated. In-\ndeed, one could say that expressions in a programming language do\n321\nA BC DI\nII III\nz:6\nx:7m:1\ny:2x:3\ny:5Figure 3.1: A simple environment structure. not, in themselves, have any meaning. Rather, an expression acquires a\nmeaning only with respect to some environment in which it is evalu-\nated. Even the interpretation of an expression as straightforward as (+\n1 1)depends on an understanding that one is operating in a context in\nwhich +is the symbol for addition. us, in our model of evaluation we\nwillalwaysspeakofevaluatinganexpressionwithrespecttosomeenvi-\nronment.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 615, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_sicp_abelson_chunk_0616_f96910e1", "text": "us, in our model of evaluation we\nwillalwaysspeakofevaluatinganexpressionwithrespecttosomeenvi-\nronment. To describe interactions with the interpreter, we will suppose\nthatthereisa globalenvironment,consisting ofasingle frame(withno\nenclosing environment) that includes values for the symbols associated\nwith the primitive procedures. For example, the idea that +is the sym-\nbol for addition is captured by saying that the symbol +is bound in the\nglobal environment to the primitive addition procedure. 3.2.1The Rules for Evaluation\neoverallspeciﬁcationofhowtheinterpreterevaluatesacombination\nremains the same as when we ﬁrst introduced it in Section 1.1.3 :\n322\n•To evaluate a combination:\n1.Evaluate the subexpressions of the combination.12\n2.Applythevalueoftheoperatorsubexpressiontothevaluesofthe\noperand subexpressions. eenvironmentmodelofevaluationreplacesthesubstitutionmodelin\nspecifyingwhatitmeanstoapplyacompoundproceduretoarguments.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 616, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_sicp_abelson_chunk_0617_b9ea4555", "text": "eenvironmentmodelofevaluationreplacesthesubstitutionmodelin\nspecifyingwhatitmeanstoapplyacompoundproceduretoarguments. Intheenvironmentmodelofevaluation,aprocedureisalwaysapair\nconsisting of some code and a pointer to an environment. Procedures\narecreatedinonewayonly:byevaluatingaλ-expression.isproduces\na procedure whose code is obtained from the text of the λ-expression\nand whose environment is the environment in which the λ-expression\nwasevaluatedtoproducetheprocedure.Forexample,considerthepro-\ncedure deﬁnition\n(define (square x)\n(*xx))\nevaluated in the global environment. e procedure deﬁnition syntax\nis just syntactic sugar for an underlying implicit λ-expression. It would\nhave been equivalent to have used\n(define square\n(lambda (x) (* xx)))\n12Assignment introduces a subtlety into step 1 of the evaluation rule.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 617, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 828}}
{"id": "computer_science_sicp_abelson_chunk_0618_f67e1e57", "text": "It would\nhave been equivalent to have used\n(define square\n(lambda (x) (* xx)))\n12Assignment introduces a subtlety into step 1 of the evaluation rule. As shown in\nExercise3.8 ,thepresenceofassignmentallowsustowriteexpressionsthatwillproduce\ndiﬀerent values depending on the order in which the subexpressions in a combination\nare evaluated. us, to be precise, we should specify an evaluation order in step 1 (e.g.,\nle to right or right to le). However, this order should always be considered to be\nan implementation detail, and one should never write programs that depend on some\nparticular order. For instance, a sophisticated compiler might optimize a program by\nvarying the order in which subexpressions are evaluated. 323\nother variables\nsquare:global\nenv\n(define (square x)\n (* x x))\nparameters: x\nbody: (* x x)Figure3.2: Environmentstructureproducedbyevaluating\n(define (square x) (* x x)) in the global environment.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 618, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_sicp_abelson_chunk_0619_9a08b5c7", "text": "323\nother variables\nsquare:global\nenv\n(define (square x)\n (* x x))\nparameters: x\nbody: (* x x)Figure3.2: Environmentstructureproducedbyevaluating\n(define (square x) (* x x)) in the global environment. which evaluates (lambda (x) (* x x)) and binds squareto the re-\nsulting value, all in the global environment. Figure 3.2 shows the result of evaluating this define expression. e procedure object is a pair whose code speciﬁes that the procedure\nhas one formal parameter, namely x, and a procedure body (* x x) . e environment part of the procedure is a pointer to the global envi-\nronment, since that is the environment in which the λ-expression was\nevaluated to produce the procedure. A new binding, which associates\nthe procedure object with the symbol square, has been added to the\nglobal frame. In general, definecreates deﬁnitions by adding bindings\nto frames. Nowthatwehaveseenhowproceduresarecreated,wecandescribe\nhow procedures are applied.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 619, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_sicp_abelson_chunk_0620_d4541c3f", "text": "In general, definecreates deﬁnitions by adding bindings\nto frames. Nowthatwehaveseenhowproceduresarecreated,wecandescribe\nhow procedures are applied. e environment model speciﬁes: To ap-\nply a procedure to arguments, create a new environment containing a\nframethatbindstheparameterstothevaluesofthearguments.een-\nclosing environment of this frame is the environment speciﬁed by the\n324\nE1\n(* x x)\nparameters: x\nbody: (* x x)(square 5)global\nenvother variables\nsquare:\nx:5Figure3.3: Environmentcreatedbyevaluating (square 5)\nin the global environment. procedure. Now, within this new environment, evaluate the procedure\nbody. Toshowhowthisruleisfollowed, Figure3.3 illustratestheenviron-\nment structure created by evaluating the expression (square 5) in the\nglobalenvironment,where squareistheproceduregeneratedin Figure\n3.2.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 620, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 826}}
{"id": "computer_science_sicp_abelson_chunk_0621_c1929adc", "text": "Toshowhowthisruleisfollowed, Figure3.3 illustratestheenviron-\nment structure created by evaluating the expression (square 5) in the\nglobalenvironment,where squareistheproceduregeneratedin Figure\n3.2. Applying the procedure results in the creation of a new environ-\nment, labeled E1 in the ﬁgure, that begins with a frame in which x, the\nformal parameter for the procedure, is bound to the argument 5. e\npointer leading upward from this frame shows that the frame’s enclos-\ning environment is the global environment. e global environment is\nchosen here, because this is the environment that is indicated as part\nof the squareprocedure object. Within E1, we evaluate the body of the\nprocedure, (* x x) . Since the value of xin E1 is 5, the result is (* 5\n5), or 25.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 621, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 765}}
{"id": "computer_science_sicp_abelson_chunk_0622_92596540", "text": "Within E1, we evaluate the body of the\nprocedure, (* x x) . Since the value of xin E1 is 5, the result is (* 5\n5), or 25. e environment model of procedure application can be summa-\nrized by two rules:\n325\n•A procedure object is applied to a set of arguments by construct-\ningaframe,bindingtheformalparametersoftheproceduretothe\narguments of the call, and then evaluating the body of the proce-\ndureinthecontextofthenewenvironmentconstructed.enew\nframe has as its enclosing environment the environment part of\nthe procedure object being applied. •A procedure is created by evaluating a λ-expression relative to a\ngiven environment. e resulting procedure object is a pair con-\nsisting of the text of the λ-expression and a pointer to the envi-\nronment in which the procedure was created.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 622, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 788}}
{"id": "computer_science_sicp_abelson_chunk_0623_bf24f898", "text": "e resulting procedure object is a pair con-\nsisting of the text of the λ-expression and a pointer to the envi-\nronment in which the procedure was created. We also specify that deﬁning a symbol using definecreates a binding\nin the current environment frame and assigns to the symbol the indi-\ncated value.13Finally, we specify the behavior of set!, the operation\nthat forced us to introduce the environment model in the ﬁrst place. Evaluating the expression (set!⟨variable⟩⟨value⟩)in some environ-\nmentlocatesthebindingofthevariableintheenvironmentandchanges\nthat binding to indicate the new value. at is, one ﬁnds the ﬁrst frame\nin the environment that contains a binding for the variable and modi-\nﬁesthatframe.Ifthevariableisunboundintheenvironment,then set! signals an error. eseevaluationrules,thoughconsiderablymorecomplexthanthe\nsubstitution model, are still reasonably straightforward.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 623, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_sicp_abelson_chunk_0624_44ec0078", "text": "signals an error. eseevaluationrules,thoughconsiderablymorecomplexthanthe\nsubstitution model, are still reasonably straightforward. Moreover, the\nevaluation model, though abstract, provides a correct description of\n13Ifthereisalreadyabindingforthevariableinthecurrentframe,thenthebindingis\nchanged. is is convenient because it allows redeﬁnition of symbols; however, it also\nmeansthat definecanbeusedtochangevalues,andthisbringsuptheissuesofassign-\nment without explicitly using set!. Because of this, some people prefer redeﬁnitions\nof existing symbols to signal errors or warnings. 326\nhow the interpreter evaluates expressions. In Chapter 4 we shall see\nhow this model can serve as a blueprint for implementing a working\ninterpreter. e following sections elaborate the details of the model by\nanalyzing some illustrative programs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 624, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 836}}
{"id": "computer_science_sicp_abelson_chunk_0625_0fd4f70b", "text": "e following sections elaborate the details of the model by\nanalyzing some illustrative programs. 3.2.2Applying Simple Procedures\nWhenweintroducedthesubstitutionmodelin Section1.1.5 weshowed\nhow the combination (f 5)evaluates to 136, given the following pro-\ncedure deﬁnitions:\n(define (square x)\n(*xx))\n(define (sum-of-squares xy)\n(+ ( square x) (square y)))\n(define (fa)\n(sum-of-squares (+a1) (* a2)))\nWecananalyzethesameexampleusingtheenvironmentmodel. Figure\n3.4shows the three procedure objects created by evaluating the deﬁni-\ntionsof f,square,and sum-of-squares intheglobalenvironment.Each\nprocedure object consists of some code, together with a pointer to the\nglobal environment. InFigure 3.5 we see the environment structure created by evaluat-\ning the expression (f 5). e call to fcreates a new environment E1\nbeginning with a frame in which a, the formal parameter of f, is bound\nto the argument 5.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 625, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 910}}
{"id": "computer_science_sicp_abelson_chunk_0626_b568920a", "text": "e call to fcreates a new environment E1\nbeginning with a frame in which a, the formal parameter of f, is bound\nto the argument 5. In E1, we evaluate the body of f:\n(sum-of-squares (+a1) (* a2))\nTo evaluate this combination, we ﬁrst evaluate the subexpressions. e\nﬁrstsubexpression, sum-of-squares ,hasavaluethatisaprocedureob-\nject. (Notice how this value is found: We ﬁrst look in the ﬁrst frame of\n327\nsquare:sum-of-squares:\nf:global\nenv\nparameters: a\nbody: (sum-of-squares\n (+ a 1)\n (* a 2))parameters: x\nbody: (* x x)parameters: x,y\nbody: (+ (square x)\n (square y))Figure 3.4: Procedure objects in the global frame. E1, which contains no binding for sum-of-squares . en we proceed\nto the enclosing environment, i.e. the global environment, and ﬁnd the\nbinding shown in Figure 3.4 .) e other two subexpressions are evalu-\nated by applying the primitive operations +and*to evaluate the two\ncombinations (+ a 1) and(* a 2) to obtain 6 and 10, respectively.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 626, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_sicp_abelson_chunk_0627_f815dde3", "text": "Now we apply the procedure object sum-of-squares to the argu-\nments 6 and 10. is results in a new environment E2 in which the\nformal parameters xandyare bound to the arguments. Within E2 we\nevaluatethecombination (+ (square x) (square y)) .isleadsusto\nevaluate (square x) , where squareis found in the global frame and x\nis 6. Once again, we set up a new environment, E3, in which xis bound\nto 6, and within this we evaluate the body of square, which is (* x x) . Also as part of applying sum-of-squares , we must evaluate the subex-\npression (square y) , where yis 10. is second call to squarecreates\nanother environment, E4, in which x, the formal parameter of square,\nis bound to 10. And within E4 we must evaluate (* x x) . 328\n(* x x)x:10E4\n(* x x)x:6E3\n(+ (square x)\n (square y))x:6\ny:10E2\n(sum-of-squares\n (+ a 1)\n (* a 2))a:5E1(f 5)global\nenvFigure 3.5: Environments created by evaluating (f 5)us-\ning the procedures in Figure 3.4 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 627, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 943}}
{"id": "computer_science_sicp_abelson_chunk_0628_15d34ae2", "text": "e important point to observe is that each call to squarecreates a\nnew environment containing a binding for x. We can see here how the\ndiﬀerent frames serve to keep separate the diﬀerent local variables all\nnamed x. Notice that each frame created by squarepoints to the global\nenvironment,sincethisistheenvironmentindicatedbythe squarepro-\ncedure object. Aerthesubexpressionsareevaluated,theresultsarereturned.e\nvaluesgeneratedbythetwocallsto squareareaddedby sum-of-squares ,\nand this result is returned by f. Since our focus here is on the environ-\nment structures, we will not dwell on how these returned values are\npassed from call to call; however, this is also an important aspect of the\nevaluation process, and we will return to it in detail in Chapter 5 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 628, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 765}}
{"id": "computer_science_sicp_abelson_chunk_0629_575c94e5", "text": "Exercise3.9: InSection1.2.1 weusedthesubstitutionmodel\ntoanalyzetwoproceduresforcomputingfactorials,arecur-\nsive version\n329\n(define (factorial n)\n(if(=n1) 1 (* n(factorial (-n1)))))\nand an iterative version\n(define (factorial n) (fact-iter 1 1 n))\n(define (fact-iter product counter max-count )\n(if(>counter max-count )\nproduct\n(fact-iter (*counter product )\n(+counter 1)\nmax-count )))\nShow the environment structures created by evaluating\n(factorial 6) using each version of the factorial pro-\ncedure.14\n3.2.3Frames as the Repository of Local State\nWe can turn to the environment model to see how procedures and as-\nsignment can be used to represent objects with local state. As an exam-\nple, consider the “withdrawal processor” from Section 3.1.1 created by\ncalling the procedure\n(define (make-withdraw balance )\n(lambda (amount )\n(if(>= balance amount )\n(begin (set!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 629, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 870}}
{"id": "computer_science_sicp_abelson_chunk_0630_19aa024a", "text": "As an exam-\nple, consider the “withdrawal processor” from Section 3.1.1 created by\ncalling the procedure\n(define (make-withdraw balance )\n(lambda (amount )\n(if(>= balance amount )\n(begin (set! balance (-balance amount ))\nbalance )\n\"Insufficient funds \")))\n14e environment model will not clarify our claim in Section 1.2.1 that the inter-\npreter can execute a procedure such as fact-iter in a constant amount of space using\ntail recursion. We will discuss tail recursion when we deal with the control structure\nof the interpreter in Section 5.4 . 330\nparameters: balance\nbody: (lambda (amount)\n (if (>= balance amount)\n (begin (set! balance (- - balance amount))\n balance)\n \"insufficient funds\"))global\nenvmake-withdraw:Figure3.6: Result of deﬁning make-withdraw in the global\nenvironment. Let us describe the evaluation of\n(define W1(make-withdraw 100))\nfollowed by\n(W150)\n50\nFigure3.6 showstheresultofdeﬁningthe make-withdraw procedurein\nthe global environment.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 630, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_sicp_abelson_chunk_0631_ec69a1af", "text": "Let us describe the evaluation of\n(define W1(make-withdraw 100))\nfollowed by\n(W150)\n50\nFigure3.6 showstheresultofdeﬁningthe make-withdraw procedurein\nthe global environment. is produces a procedure object that contains\na pointer to the global environment. So far, this is no diﬀerent from the\nexamples we have already seen, except that the body of the procedure\nis itself a λ-expression. einterestingpartofthecomputationhappenswhenweapplythe\nprocedure make-withdraw to an argument:\n(define W1(make-withdraw 100))\n331\nE1make-withdraw:\nW1:global\nenv\nbalance: 100\nparameters: balance\nbody: ...parameters: amount\nbody: (if (>= balance amount)\n (begin (set! balance (- balance amount))\n balance)\n \"insufficient funds\")Figure 3.7: Result of evaluating (define W1 (make-withdraw 100)) . Webegin,asusual,byseingupanenvironmentE1inwhichtheformal\nparameter balance is bound to the argument 100. Within this environ-\nment,weevaluatethebodyof make-withdraw ,namelytheλ-expression.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 631, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_sicp_abelson_chunk_0632_2a37e865", "text": "Webegin,asusual,byseingupanenvironmentE1inwhichtheformal\nparameter balance is bound to the argument 100. Within this environ-\nment,weevaluatethebodyof make-withdraw ,namelytheλ-expression. is constructs a new procedure object, whose code is as speciﬁed by\nthelambda and whose environment is E1, the environment in which\nthelambdawas evaluated to produce the procedure. e resulting pro-\ncedure object is the value returned by the call to make-withdraw . is\nis bound to W1in the global environment, since the defineitself is be-\ning evaluated in the global environment. Figure 3.7 shows the resulting\nenvironment structure. Now we can analyze what happens when W1is applied to an argu-\nment:\n(W150)\n50\n332\nE1make-withdraw: ... W1:global\nenv\nbalance: 100\nparameters: amount\nbody: ...amount: 50Here is the balance\nthat will be changed\nby the set! (if (>= balance amount)\n (begin (set!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 632, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 884}}
{"id": "computer_science_sicp_abelson_chunk_0633_e4fdde99", "text": "W1:global\nenv\nbalance: 100\nparameters: amount\nbody: ...amount: 50Here is the balance\nthat will be changed\nby the set! (if (>= balance amount)\n (begin (set! balance \n (- balance amount))\n balance)\n \"insufficient funds\")Figure3.8: Environments created by applying the procedure object W1. We begin by constructing a frame in which amount, the formal pa-\nrameter of W1, is bound to the argument 50. e crucial point to ob-\nserve is that this frame has as its enclosing environment not the global\nenvironment, but rather the environment E1, because this is the envi-\nronment that is speciﬁed by the W1procedure object. Within this new\nenvironment, we evaluate the body of the procedure:\n(if(>= balance amount )\n(begin (set! balance (-balance amount ))\nbalance )\n\"Insufficient funds \")\neresultingenvironmentstructureisshownin Figure3.8 .eexpres-\nsion being evaluated references both amountandbalance .amountwill\nbe found in the ﬁrst frame in the environment, while balance will be\n333\nE1make-withdraw: ...", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 633, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_sicp_abelson_chunk_0634_5bfc1c7a", "text": "W1:global\nenv\nbalance: 50\nparameters: amount\nbody: ...Figure 3.9: Environments aer the call to W1. found by following the enclosing-environment pointer to E1. Whenthe set!isexecuted,thebindingof balance inE1ischanged. At the completion of the call to W1,balance is 50, and the frame that\ncontains balance is still pointed to by the procedure object W1. e\nframe that binds amount(in which we executed the code that changed\nbalance )isnolongerrelevant,sincetheprocedurecallthatconstructed\nit has terminated, and there are no pointers to that frame from other\nparts of the environment. e next time W1is called, this will build a\nnew frame that binds amountand whose enclosing environment is E1. We see that E1 serves as the “place” that holds the local state variable\nfor the procedure object W1.Figure 3.9 shows the situation aer the call\ntoW1.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 634, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 846}}
{"id": "computer_science_sicp_abelson_chunk_0635_8b04902c", "text": "We see that E1 serves as the “place” that holds the local state variable\nfor the procedure object W1.Figure 3.9 shows the situation aer the call\ntoW1. Observe what happens when we create a second “withdraw” object\nby making another call to make-withdraw :\n(define W2(make-withdraw 100))\n334\nE1W2:\nW1:global\nenv\nbalance: 50\nparameters: amount\nbody: ...E2balance: 100make-withdraw: ...Figure3.10: Using (define W2 (make-withdraw 100)) to\ncreate a second object. isproducestheenvironmentstructureof Figure3.10 ,whichshows\nthat W2is a procedure object, that is, a pair with some code and an en-\nvironment. e environment E2 for W2was created by the call to make-\nwithdraw . It contains a frame with its own local binding for balance . On the other hand, W1andW2have the same code: the code speciﬁed\nby the λ-expression in the body of make-withdraw .15We see here why\nW1andW2behave as independent objects.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 635, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_sicp_abelson_chunk_0636_b5a9cd7a", "text": "On the other hand, W1andW2have the same code: the code speciﬁed\nby the λ-expression in the body of make-withdraw .15We see here why\nW1andW2behave as independent objects. Calls to W1reference the state\nvariable balance storedinE1,whereascallsto W2referencethe balance\nstored in E2. us, changes to the local state of one object do not aﬀect\nthe other object. 15Whether W1andW2sharethesamephysicalcodestoredinthecomputer,orwhether\nthey each keep a copy of the code, is a detail of the implementation. For the interpreter\nwe implement in Chapter 4 , the code is in fact shared. 335\nExercise 3.10: In the make-withdraw procedure, the local\nvariable balance iscreatedasaparameterof make-withdraw . We could also create the local state variable explicitly, us-\ninglet, as follows:\n(define (make-withdraw initial-amount )\n(let ((balance initial-amount ))\n(lambda (amount )\n(if(>= balance amount )\n(begin (set!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 636, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_sicp_abelson_chunk_0637_56db2cad", "text": "balance (-balance amount ))\nbalance )\n\"Insufficient funds \"))))\nRecall from Section 1.3.2 that letis simply syntactic sugar\nfor a procedure call:\n(let ((⟨var⟩⟨exp⟩))⟨body⟩)\nis interpreted as an alternate syntax for\n((lambda (⟨var⟩)⟨body⟩)⟨exp⟩)\nUse the environment model to analyze this alternate ver-\nsionof make-withdraw ,drawingﬁguresliketheonesabove\nto illustrate the interactions\n(define W1(make-withdraw 100))\n(W150)\n(define W2(make-withdraw 100))\nShow that the two versions of make-withdraw create ob-\njectswiththesamebehavior.Howdotheenvironmentstruc-\ntures diﬀer for the two versions? 336\n3.2.4Internal Definitions\nSection 1.1.8 introduced the idea that procedures can have internal def-\ninitions, thus leading to a block structure as in the following procedure\nto compute square roots:\n(define (sqrt x)\n(define (good-enough? guess )\n(< ( abs (- ( square guess )x)) 0.001))\n(define (improve guess )\n(average guess (/xguess )))\n(define (sqrt-iter guess )\n(if(good-enough?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 637, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_sicp_abelson_chunk_0638_b65d2f7d", "text": "guess )\n(< ( abs (- ( square guess )x)) 0.001))\n(define (improve guess )\n(average guess (/xguess )))\n(define (sqrt-iter guess )\n(if(good-enough? guess )\nguess\n(sqrt-iter (improve guess ))))\n(sqrt-iter 1.0))\nNow we can use the environment model to see why these internal deﬁ-\nnitions behave as desired. Figure 3.11 shows the point in the evaluation\noftheexpression (sqrt 2) wheretheinternalprocedure good-enough? has been called for the ﬁrst time with guessequal to 1. Observe the structure of the environment. sqrtis a symbol in the\nglobal environment that is bound to a procedure object whose associ-\nated environment is the global environment. When sqrtwas called, a\nnew environment E1 was formed, subordinate to the global environ-\nment, in which the parameter xis bound to 2. e body of sqrtwas\nthen evaluated in E1. Since the ﬁrst expression in the body of sqrtis\n(define (good-enough? guess )\n(< ( abs (- ( square guess )x)) 0.001))\nevaluating this expression deﬁned the procedure good-enough?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 638, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_sicp_abelson_chunk_0639_871dffd5", "text": "Since the ﬁrst expression in the body of sqrtis\n(define (good-enough? guess )\n(< ( abs (- ( square guess )x)) 0.001))\nevaluating this expression deﬁned the procedure good-enough? in the\nenvironment E1. To be more precise, the symbol good-enough? was\nadded to the ﬁrst frame of E1, bound to a procedure object whose asso-\n337\nparameters: x\nbody: (define good-enough? ...)\n (define improve ...)\n (define sqrt-iter ...)\n (sqrt-iter 1.0)global\nenvsqrt:\nE1x:2\ngood-enough?:\nimprove: ... sqrt-iter: ... parameters: guess\nbody: (< (abs ...)\n ...)guess: 1\nguess: 1call to sqrt-iterE2\ncall to good-enough?E3Figure 3.11: sqrtprocedure with internal deﬁnitions. ciated environment is E1. Similarly, improve andsqrt-iter were de-\nﬁned as procedures in E1. For conciseness, Figure 3.11 shows only the\nprocedure object for good-enough? . Aerthelocalproceduresweredeﬁned,theexpression (sqrt-iter\n1.0)was evaluated, still in environment E1. So the procedure object\nbound to sqrt-iter in E1 was called with 1 as an argument.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 639, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1008}}
{"id": "computer_science_sicp_abelson_chunk_0640_ad34f11d", "text": ". Aerthelocalproceduresweredeﬁned,theexpression (sqrt-iter\n1.0)was evaluated, still in environment E1. So the procedure object\nbound to sqrt-iter in E1 was called with 1 as an argument. is cre-\nated an environment E2 in which guess, the parameter of sqrt-iter ,\nis bound to 1. sqrt-iter in turn called good-enough? with the value of\nguess(fromE2)astheargumentfor good-enough? .issetupanother\n338\nenvironment, E3, in which guess(the parameter of good-enough? ) is\nbound to 1. Although sqrt-iter and good-enough? both have a pa-\nrameter named guess, these are two distinct local variables located in\ndiﬀerent frames. Also, E2 and E3 both have E1 as their enclosing en-\nvironment, because the sqrt-iter andgood-enough? procedures both\nhave E1 as their environment part. One consequence of this is that the\nsymbol xthat appears in the body of good-enough? will reference the\nbinding of xthat appears in E1, namely the value of xwith which the\noriginal sqrtprocedure was called.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 640, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_sicp_abelson_chunk_0641_0da3297e", "text": "will reference the\nbinding of xthat appears in E1, namely the value of xwith which the\noriginal sqrtprocedure was called. e environment model thus explains the two key properties that\nmake local procedure deﬁnitions a useful technique for modularizing\nprograms:\n•e names of the local procedures do not interfere with names\nexternal to the enclosing procedure, because the local procedure\nnameswillbeboundintheframethattheprocedurecreateswhen\nit is run, rather than being bound in the global environment. •e local procedures can access the arguments of the enclosing\nprocedure, simply by using parameter names as free variables. is is because the body of the local procedure is evaluated in an\nenvironment that is subordinate to the evaluation environment\nfor the enclosing procedure. Exercise 3.11: InSection 3.2.3 we saw how the environ-\nmentmodeldescribedthebehaviorofprocedureswithlocal\nstate. Now we have seen how internal deﬁnitions work.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 641, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_sicp_abelson_chunk_0642_af38060a", "text": "Exercise 3.11: InSection 3.2.3 we saw how the environ-\nmentmodeldescribedthebehaviorofprocedureswithlocal\nstate. Now we have seen how internal deﬁnitions work. A\ntypical message-passing procedure contains both of these\naspects. Consider the bank account procedure of Section\n3.1.1:\n339\n(define (make-account balance )\n(define (withdraw amount )\n(if(>= balance amount )\n(begin (set! balance (-balance amount ))\nbalance )\n\"Insufficient funds \"))\n(define (deposit amount )\n(set! balance (+balance amount ))\nbalance )\n(define (dispatch m)\n(cond ((eq? m'withdraw )withdraw )\n((eq? m'deposit )deposit )\n(else\n(error \"Unknown request :MAKE-ACCOUNT \"\nm))))\ndispatch )\nShowtheenvironmentstructuregeneratedbythesequence\nof interactions\n(define acc (make-account 50))\n((acc 'deposit ) 40)\n90\n((acc 'withdraw ) 60)\n30\nWhere is the local state for acckept? Suppose we deﬁne\nanother account\n(define acc2 (make-account 100))\nHowarethelocalstatesforthetwoaccountskeptdistinct?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 642, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_sicp_abelson_chunk_0643_75c31e51", "text": "Suppose we deﬁne\nanother account\n(define acc2 (make-account 100))\nHowarethelocalstatesforthetwoaccountskeptdistinct? Which parts of the environment structure are shared be-\ntween accandacc2? 340\n3.3Modeling with Mutable Data\nChapter 2 dealt with compound data as a means for constructing com-\nputational objects that have several parts, in order to model real-world\nobjects that have several aspects. In that chapter we introduced the dis-\ncipline of data abstraction, according to which data structures are spec-\niﬁed in terms of constructors, which create data objects, and selectors,\nwhich access the parts of compound data objects. But we now know\nthat there is another aspect of data that Chapter 2 did not address. e\ndesire to model systems composed of objects that have changing state\nleadsustotheneedtomodifycompounddataobjects,aswellastocon-\nstruct and select from them.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 643, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 880}}
{"id": "computer_science_sicp_abelson_chunk_0644_065cbd9d", "text": "e\ndesire to model systems composed of objects that have changing state\nleadsustotheneedtomodifycompounddataobjects,aswellastocon-\nstruct and select from them. In order to model compound objects with\nchanging state, we will design data abstractions to include, in addition\nto selectors and constructors, operations called mutators , which mod-\nify data objects. For instance, modeling a banking system requires us to\nchange account balances. us, a data structure for representing bank\naccounts might admit an operation\n(set-balance!⟨account⟩⟨new-value⟩)\nthat changes the balance of the designated account to the designated\nnew value. Data objects for which mutators are deﬁned are known as\nmutable data objects . Chapter 2 introduced pairs as a general-purpose “glue” for synthe-\nsizingcompounddata.Webeginthissectionbydeﬁningbasicmutators\nforpairs,sothatpairscanserveasbuildingblocksforconstructingmu-\ntable data objects.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 644, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_sicp_abelson_chunk_0645_3e84bc75", "text": "ese mutators greatly enhance the representational\npower of pairs, enabling us to build data structures other than the se-\nquences and trees that we worked with in Section 2.2 . We also present\nsome examples of simulations in which complex systems are modeled\nas collections of objects with local state. 341\n3.3.1Mutable List Structure\ne basic operations on pairs— cons,car, and cdr—can be used to con-\nstruct list structure and to select parts from list structure, but they are\nincapable of modifying list structure. e same is true of the list oper-\nations we have used so far, such as appendandlist, since these can\nbe deﬁned in terms of cons,car, and cdr. To modify list structures we\nneed new operations. e primitive mutators for pairs are set-car! andset-cdr! .set-\ncar!takes two arguments, the ﬁrst of which must be a pair. It modiﬁes\nthis pair, replacing the carpointer by a pointer to the second argument\nofset-car!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 645, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_sicp_abelson_chunk_0646_a856d238", "text": "andset-cdr! .set-\ncar!takes two arguments, the ﬁrst of which must be a pair. It modiﬁes\nthis pair, replacing the carpointer by a pointer to the second argument\nofset-car! .16\nAs an example, suppose that xis bound to the list ((a b) c d) and\nytothelist (e f)asillustratedin Figure3.12 .Evaluatingtheexpression\n(set-car! x y) modiﬁesthepairtowhich xisbound,replacingits car\nby the value of y. e result of the operation is shown in Figure 3.13 . e structure xhas been modiﬁed and would now be printed as ((e f)\nc d).epairsrepresentingthelist (a b),identiﬁedbythepointerthat\nwas replaced, are now detached from the original structure.17\nCompare Figure3.13 withFigure3.14 ,whichillustratestheresultof\nexecuting (define z (cons y (cdr x))) with xandybound to the\noriginal lists of Figure 3.12 . e variable zis now bound to a new pair\ncreatedbythe consoperation;thelisttowhich xisboundisunchanged. eset-cdr! operation is similar to set-car! .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 646, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_sicp_abelson_chunk_0647_6ab8635e", "text": "e variable zis now bound to a new pair\ncreatedbythe consoperation;thelisttowhich xisboundisunchanged. eset-cdr! operation is similar to set-car! . e only diﬀerence\nisthatthe cdrpointerofthepair,ratherthanthe carpointer,isreplaced. e eﬀect of executing (set-cdr! x y) on the lists of Figure 3.12 is\n16set-car! andset-cdr! return implementation-dependent values. Like set!, they\nshould be used only for their eﬀect. 17We see from this that mutation operations on lists can create “garbage” that is\nnot part of any accessible structure. We will see in Section 5.3.2 that Lisp memory-\nmanagementsystemsincludea garbage collector ,whichidentiﬁesandrecyclesthemem-\nory space used by unneeded pairs. 342\nc d\nyx\ne fa bFigure 3.12: Lists x:((a b) c d) andy:(e f). c d\nyx\ne fa b\nFigure 3.13: Eﬀect of (set-car! x y) on the lists in Figure 3.12 . 343\nc d\nyx\ne fa b zFigure 3.14: Eﬀect of (define z (cons y (cdr x))) on\nthe lists in Figure 3.12 . c d\nyx\ne fa b\nFigure 3.15: Eﬀect of (set-cdr!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 647, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_sicp_abelson_chunk_0648_5f715e31", "text": "x y) on the lists in Figure 3.12 . 343\nc d\nyx\ne fa b zFigure 3.14: Eﬀect of (define z (cons y (cdr x))) on\nthe lists in Figure 3.12 . c d\nyx\ne fa b\nFigure 3.15: Eﬀect of (set-cdr! x y) on the lists in Figure 3.12 . 344\nshown in Figure 3.15 . Here the cdrpointer of xhas been replaced by\nthe pointer to (e f). Also, the list (c d), which used to be the cdrof\nx, is now detached from the structure. consbuildsnewliststructurebycreatingnewpairs,while set-car! andset-cdr! modify existing pairs. Indeed, we could implement cons\nin terms of the two mutators, together with a procedure get-new-pair ,\nwhich returns a new pair that is not part of any existing list structure. We obtain the new pair, set its carandcdrpointers to the designated\nobjects, and return the new pair as the result of the cons.18\n(define (cons xy)\n(let ((new (get-new-pair )))\n(set-car! new x)\n(set-cdr! new y)\nnew))\nExercise3.12: efollowingprocedureforappendinglists\nwas introduced in Section 2.2.1 :\n(define (append xy)\n(if(null?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 648, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_sicp_abelson_chunk_0649_803ea701", "text": "new x)\n(set-cdr! new y)\nnew))\nExercise3.12: efollowingprocedureforappendinglists\nwas introduced in Section 2.2.1 :\n(define (append xy)\n(if(null? x)\ny\n(cons (car x) (append (cdr x)y))))\nappend forms a new list by successively consing the el-\nements of xonto y. e procedure append! is similar to\nappend, but it is a mutator rather than a constructor. It ap-\npends the lists by splicing them together, modifying the ﬁ-\nnal pair of xso that its cdris now y. (It is an error to call\nappend! with an empty x.)\n18get-new-pair is one of the operations that must be implemented as part of the\nmemory management required by a Lisp implementation. We will discuss this in Sec-\ntion 5.3.1 . 345\n(define (append! xy)\n(set-cdr! (last-pair x)y)\nx)\nHere last-pair is a procedure that returns the last pair in\nits argument:\n(define (last-pair x)\n(if(null? (cdr x))x(last-pair (cdr x))))\nConsider the interaction\n(define x(list 'a'b))\n(define y(list 'c'd))\n(define z(append xy))\nz\n(a b c d)\n(cdr x)\n⟨response⟩\n(define w(append!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 649, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1011}}
{"id": "computer_science_sicp_abelson_chunk_0650_fc2ed027", "text": "(cdr x))x(last-pair (cdr x))))\nConsider the interaction\n(define x(list 'a'b))\n(define y(list 'c'd))\n(define z(append xy))\nz\n(a b c d)\n(cdr x)\n⟨response⟩\n(define w(append! xy))\nw\n(a b c d)\n(cdr x)\n⟨response⟩\nWhat are the missing ⟨response⟩s? Draw box-and-pointer\ndiagrams to explain your answer. Exercise 3.13: Consider the following make-cycle proce-\ndure,whichusesthe last-pair proceduredeﬁnedin Exer-\ncise 3.12 :\n(define (make-cycle x)\n(set-cdr! (last-pair x)x)\nx)\n346\nDraw a box-and-pointer diagram that shows the structure\nzcreated by\n(define z(make-cycle (list 'a'b'c)))\nWhat happens if we try to compute (last-pair z) ? Exercise 3.14: e following procedure is quite useful, al-\nthough obscure:\n(define (mystery x)\n(define (loop xy)\n(if(null? x)\ny\n(let ((temp (cdr x)))\n(set-cdr! xy)\n(loop temp x))))\n(loop x'()))\nloopuses the “temporary” variable tempto hold the old\nvalue of the cdrofx, since the set-cdr! on the next line\ndestroys the cdr. Explain what mystery does in general.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 650, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_sicp_abelson_chunk_0651_c0673458", "text": "xy)\n(loop temp x))))\n(loop x'()))\nloopuses the “temporary” variable tempto hold the old\nvalue of the cdrofx, since the set-cdr! on the next line\ndestroys the cdr. Explain what mystery does in general. Suppose vis deﬁned by (define v (list 'a 'b 'c\n'd)). Draw the box-and-pointer diagram that represents\nthe list to which vis bound. Suppose that we now evalu-\nate(define w (mystery v)) . Draw box-and-pointer dia-\ngramsthatshowthestructures vandwaerevaluatingthis\nexpression. What would be printed as the values of vand\nw? Sharing and identity\nWe mentioned in Section 3.1.3 the theoretical issues of “sameness” and\n“change” raised by the introduction of assignment. ese issues arise in\n347\npractice when individual pairs are sharedamong diﬀerent data objects. For example, consider the structure formed by\n(define x(list 'a'b))\n(define z1(cons xx))\nAs shown in Figure 3.16 ,z1is a pair whose carandcdrboth point to\nthe same pair x.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 651, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 932}}
{"id": "computer_science_sicp_abelson_chunk_0652_3268d9d3", "text": "For example, consider the structure formed by\n(define x(list 'a'b))\n(define z1(cons xx))\nAs shown in Figure 3.16 ,z1is a pair whose carandcdrboth point to\nthe same pair x. is sharing of xby the carandcdrofz1is a con-\nsequence of the straightforward way in which consis implemented. In\ngeneral, using consto construct lists will result in an interlinked struc-\nture of pairs in which many individual pairs are shared by many diﬀer-\nent structures. In contrast to Figure 3.16 ,Figure 3.17 shows the structure created\nby\n(define z2(cons (list 'a'b) (list 'a'b)))\nIn this structure, the pairs in the two (a b)lists are distinct, although\nthe actual symbols are shared.19\nWhen thought of as a list, z1andz2both represent “the same” list,\n((a b) a b) . In general, sharing is completely undetectable if we oper-\nateonlistsusingonly cons,car,and cdr.However,ifweallowmutators\non list structure, sharing becomes signiﬁcant.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 652, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_sicp_abelson_chunk_0653_1155b786", "text": "In general, sharing is completely undetectable if we oper-\nateonlistsusingonly cons,car,and cdr.However,ifweallowmutators\non list structure, sharing becomes signiﬁcant. As an example of the dif-\nferencethatsharingcanmake,considerthefollowingprocedure,which\nmodiﬁes the carof the structure to which it is applied:\n(define (set-to-wow! x) (set-car! (car x)'wow )x)\n19etwopairsaredistinctbecauseeachcallto consreturnsanewpair.esymbols\nare shared; in Scheme there is a unique symbol with any given name. Since Scheme\nprovides no way to mutate a symbol, this sharing is undetectable. Note also that the\nsharingiswhatenablesustocomparesymbolsusing eq?,whichsimplychecksequality\nof pointers. 348\nz1\nx\na bFigure 3.16: e list z1formed by (cons x x) . a bz2\nFigure 3.17: e list z2formed by (cons (list 'a 'b)\n(list 'a 'b)) . Even though z1andz2are “the same” structure, applying set-to-wow! to them yields diﬀerent results.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 653, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_sicp_abelson_chunk_0654_dc3c89b1", "text": "a bz2\nFigure 3.17: e list z2formed by (cons (list 'a 'b)\n(list 'a 'b)) . Even though z1andz2are “the same” structure, applying set-to-wow! to them yields diﬀerent results. With z1, altering the caralso changes\nthecdr, because in z1thecarand the cdrare the same pair. With z2,\nthecarandcdrare distinct, so set-to-wow! modiﬁes only the car:\nz1\n((a b) a b)\n(set-to-wow! z1)\n((wow b) wow b)\nz2\n((a b) a b)\n349\n(set-to-wow! z2)\n((wow b) a b)\nOne way to detect sharing in list structures is to use the predicate eq?,\nwhichweintroducedin Section2.3.1 asawaytotestwhethertwosym-\nbols are equal. More generally, (eq? x y) tests whether xand yare\nthe same object (that is, whether xandyare equal as pointers). us,\nwith z1andz2asdeﬁnedin Figure3.16 andFigure3.17 ,(eq? (car z1)\n(cdr z1)) is true and (eq? (car z2) (cdr z2)) is false. As will be seen in the following sections, we can exploit sharing to\ngreatly extend the repertoire of data structures that can be represented\nbypairs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 654, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_sicp_abelson_chunk_0655_cbecc0c0", "text": "(car z2) (cdr z2)) is false. As will be seen in the following sections, we can exploit sharing to\ngreatly extend the repertoire of data structures that can be represented\nbypairs. On the other hand, sharing can also be dangerous, since modi-\nﬁcationsmadetostructureswillalsoaﬀectotherstructuresthathappen\ntosharethemodiﬁedparts.emutationoperations set-car! andset-\ncdr!should be used with care; unless we have a good understanding of\nhow our data objects are shared, mutation can have unanticipated re-\nsults.20\nExercise 3.15: Draw box-and-pointer diagrams to explain\ntheeﬀectof set-to-wow! onthestructures z1andz2above.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 655, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 621}}
{"id": "computer_science_sicp_abelson_chunk_0656_d8d0b01a", "text": "onthestructures z1andz2above. Exercise 3.16: Ben Bitdiddle decides to write a procedure\ntocountthenumberofpairsinanyliststructure.“It’seasy,”\n20esubtletiesofdealingwithsharingofmutabledataobjectsreﬂecttheunderlying\nissuesof“sameness”and“change”thatwereraisedin Section3.1.3 .Wementionedthere\nthat admiing change to our language requires that a compound object must have an\n“identity” that is something diﬀerent from the pieces from which it is composed. In\nLisp,weconsiderthis“identity”tobethequalitythatistestedby eq?,i.e.,byequalityof\npointers.SinceinmostLispimplementationsapointerisessentiallyamemoryaddress,\nweare“solvingtheproblem”ofdeﬁningtheidentityofobjectsbystipulatingthatadata\nobject “itself” is the information stored in some particular set of memory locations in\nthe computer. is suﬃces for simple Lisp programs, but is hardly a general way to\nresolve the issue of “sameness” in computational models. 350\nhe reasons.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 656, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_sicp_abelson_chunk_0657_27e8e0a9", "text": "is suﬃces for simple Lisp programs, but is hardly a general way to\nresolve the issue of “sameness” in computational models. 350\nhe reasons. “e number of pairs in any structure is the\nnumber in the carplus the number in the cdrplus one\nmoretocountthecurrentpair.”SoBenwritesthefollowing\nprocedure:\n(define (count-pairs x)\n(if(not (pair? x))\n0\n(+ ( count-pairs (car x))\n(count-pairs (cdr x))\n1)))\nShow that this procedure is not correct. In particular, draw\nbox-and-pointerdiagramsrepresentingliststructuresmade\nup of exactly three pairs for which Ben’s procedure would\nreturn 3; return 4; return 7; never return at all. Exercise3.17: Deviseacorrectversionofthe count-pairs\nprocedure of Exercise 3.16 that returns the number of dis-\ntinct pairs in any structure.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 657, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 762}}
{"id": "computer_science_sicp_abelson_chunk_0658_9135e3ff", "text": "Exercise3.17: Deviseacorrectversionofthe count-pairs\nprocedure of Exercise 3.16 that returns the number of dis-\ntinct pairs in any structure. (Hint: Traverse the structure,\nmaintaininganauxiliarydatastructurethatisusedtokeep\ntrack of which pairs have already been counted.)\nExercise 3.18: Write a procedure that examines a list and\ndetermines whether it contains a cycle, that is, whether a\nprogram that tried to ﬁnd the end of the list by taking suc-\ncessive cdrs would go into an inﬁnite loop. Exercise 3.13\nconstructed such lists. Exercise 3.19: RedoExercise 3.18 using an algorithm that\ntakesonlyaconstantamountofspace.(isrequiresavery\nclever idea.)\n351\nMutation is just assignment\nWhen we introduced compound data, we observed in Section 2.1.3 that\npairs can be represented purely in terms of procedures:\n(define (cons xy)\n(define (dispatch m)\n(cond ((eq? m'car )x)\n((eq?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 658, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_sicp_abelson_chunk_0659_5da3da4c", "text": "m'car )x)\n((eq? m'cdr )y)\n(else (error \"Undefined operation :CONS \"m))))\ndispatch )\n(define (car z) (z'car ))\n(define (cdr z) (z'cdr ))\ne same observation is true for mutable data. We can implement mu-\ntable data objects as procedures using assignment and local state. For\ninstance, we can extend the above pair implementation to handle set-\ncar!andset-cdr! in a manner analogous to the way we implemented\nbank accounts using make-account inSection 3.1.1 :\n(define (cons xy)\n(define (set-x! v) (set! xv))\n(define (set-y! v) (set! yv))\n(define (dispatch m)\n(cond ((eq? m'car )x)\n((eq? m'cdr )y)\n((eq? m'set-car! )set-x! )\n((eq? m'set-cdr! )set-y! )\n(else\n(error \"Undefined operation :CONS \"m))))\ndispatch )\n(define (car z) (z'car ))\n(define (cdr z) (z'cdr ))\n(define (set-car! znew-value )\n((z'set-car! )new-value )z)\n352\n(define (set-cdr! znew-value )\n((z'set-cdr!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 659, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 865}}
{"id": "computer_science_sicp_abelson_chunk_0660_210b03aa", "text": "znew-value )\n((z'set-car! )new-value )z)\n352\n(define (set-cdr! znew-value )\n((z'set-cdr! )new-value )z)\nAssignmentisallthatisneeded,theoretically,toaccountforthebehav-\niorofmutabledata.Assoonasweadmit set!toourlanguage,weraise\nall the issues, not only of assignment, but of mutable data in general.21\nExercise 3.20: Draw environment diagrams to illustrate\nthe evaluation of the sequence of expressions\n(define x(cons 1 2))\n(define z(cons xx))\n(set-car! (cdr z) 17)\n(car x)\n17\nusing the procedural implementation of pairs given above. (Compare Exercise 3.11 .)\n3.3.2Representing eues\nemutators set-car! andset-cdr! enableustousepairstoconstruct\ndata structures that cannot be built with cons,car, and cdralone. is\nsection shows how to use pairs to represent a data structure called a\nqueue.Section 3.3.3 will show how to represent data structures called\ntables.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 660, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 863}}
{"id": "computer_science_sicp_abelson_chunk_0661_506b7f98", "text": "is\nsection shows how to use pairs to represent a data structure called a\nqueue.Section 3.3.3 will show how to represent data structures called\ntables. Aqueueis a sequence in which items are inserted at one end (called\ntherearof the queue) and deleted from the other end (the front).Fig-\nure 3.18 shows an initially empty queue in which the items aandbare\n21On the other hand, from the viewpoint of implementation, assignment requires us\nto modify the environment, which is itself a mutable data structure. us, assignment\nand mutation are equipotent: Each can be implemented in terms of the other. 353\nOperation Resulting Queue\n(define q (make-queue))\n(insert-queue! q 'a) a\n(insert-queue! q 'b) a b\n(delete-queue! q) b\n(insert-queue! q 'c) b c\n(insert-queue! q 'd) b c d\n(delete-queue! q) c dFigure 3.18: eue operations. inserted. en ais removed, canddare inserted, and bis removed. Be-\ncauseitemsarealwaysremovedintheorderinwhichtheyareinserted,\na queue is sometimes called a FIFO(ﬁrst in, ﬁrst out) buﬀer.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 661, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1011}}
{"id": "computer_science_sicp_abelson_chunk_0662_f2397fd2", "text": "inserted. en ais removed, canddare inserted, and bis removed. Be-\ncauseitemsarealwaysremovedintheorderinwhichtheyareinserted,\na queue is sometimes called a FIFO(ﬁrst in, ﬁrst out) buﬀer. In terms of data abstraction, we can regard a queue as deﬁned by\nthe following set of operations:\n•a constructor: (make-queue) returns an empty queue (a queue\ncontaining no items). •two selectors:\n(empty-queue?⟨queue⟩)tests if the queue is empty. (front-queue⟨queue⟩)returns the object at the front of the\nqueue,signalinganerrorifthequeueisempty;itdoesnotmodify\nthe queue. •two mutators:\n(insert-queue! ⟨queue⟩ ⟨item⟩)inserts the item at the rear of\nthe queue and returns the modiﬁed queue as its value. 354\n(delete-queue! ⟨queue⟩)removes the item at the front of the\nqueue and returns the modiﬁed queue as its value, signaling an\nerror if the queue is empty before the deletion.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 662, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 867}}
{"id": "computer_science_sicp_abelson_chunk_0663_dc6da0bf", "text": "354\n(delete-queue! ⟨queue⟩)removes the item at the front of the\nqueue and returns the modiﬁed queue as its value, signaling an\nerror if the queue is empty before the deletion. Because a queue is a sequence of items, we could certainly represent it\nas an ordinary list; the front of the queue would be the carof the list,\ninserting an item in the queue would amount to appending a new ele-\nment at the end of the list, and deleting an item from the queue would\njust be taking the cdrof the list. However, this representation is ineﬃ-\ncient, because in order to insert an item we must scan the list until we\nreach the end. Since the only method we have for scanning a list is by\nsuccessive cdroperations, this scanning requires Θ(n)steps for a list of\nnitems. A simple modiﬁcation to the list representation overcomes this\ndisadvantage by allowing the queue operations to be implemented so\nthat they require Θ(1) steps; that is, so that the number of steps needed\nis independent of the length of the queue.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 663, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_sicp_abelson_chunk_0664_bdabe219", "text": "e diﬃculty with the list representation arises from the need to\nscan to ﬁnd the end of the list. e reason we need to scan is that, al-\nthough the standard way of representing a list as a chain of pairs read-\nily provides us with a pointer to the beginning of the list, it gives us\nno easily accessible pointer to the end. e modiﬁcation that avoids the\ndrawback is to represent the queue as a list, together with an additional\npointer that indicates the ﬁnal pair in the list. at way, when we go to\ninsert an item, we can consult the rear pointer and so avoid scanning\nthe list. A queue is represented, then, as a pair of pointers, front-ptr and\nrear-ptr , which indicate, respectively, the ﬁrst and last pairs in an or-\ndinarylist.Sincewewouldlikethequeuetobeanidentiﬁableobject,we\ncan use consto combine the two pointers. us, the queue itself will be\ntheconsof the two pointers. Figure 3.19 illustrates this representation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 664, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 929}}
{"id": "computer_science_sicp_abelson_chunk_0665_15384081", "text": "us, the queue itself will be\ntheconsof the two pointers. Figure 3.19 illustrates this representation. 355\ncfront-ptrq\na brear-ptrFigure3.19: Implementation of a queue as a list with front\nand rear pointers. To deﬁne the queue operations we use the following procedures,\nwhich enable us to select and to modify the front and rear pointers of a\nqueue:\n(define (front-ptr queue ) (car queue ))\n(define (rear-ptr queue ) (cdr queue ))\n(define (set-front-ptr! queue item )\n(set-car! queue item ))\n(define (set-rear-ptr! queue item )\n(set-cdr! queue item ))\nNow we can implement the actual queue operations. We will consider\na queue to be empty if its front pointer is the empty list:\n(define (empty-queue? queue )\n(null? (front-ptr queue )))\nemake-queue constructor returns, as an initially empty queue, a pair\nwhose carandcdrare both the empty list:\n(define (make-queue ) (cons '()'()))\n356\nfront-ptrq\na brear-ptr\nc dFigure3.20: Resultofusing (insert-queue! q 'd) onthe\nqueue of Figure 3.19 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 665, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 990}}
{"id": "computer_science_sicp_abelson_chunk_0666_017c5bc4", "text": "q 'd) onthe\nqueue of Figure 3.19 . Toselecttheitematthefrontofthequeue,wereturnthe carofthepair\nindicated by the front pointer:\n(define (front-queue queue )\n(if(empty-queue? queue )\n(error \"FRONT called with anempty queue \"queue )\n(car (front-ptr queue ))))\nTo insert an item in a queue, we follow the method whose result is in-\ndicated in Figure 3.20 . We ﬁrst create a new pair whose caris the item\ntobe insertedandwhose cdristheempty list. Ifthe queuewasinitially\nempty, we set the front and rear pointers of the queue to this new pair. Otherwise, we modify the ﬁnal pair in the queue to point to the new\npair, and also set the rear pointer to the new pair. (define (insert-queue! queue item )\n(let ((new-pair (cons item '())))\n(cond ((empty-queue? queue )\n(set-front-ptr! queue new-pair )\n(set-rear-ptr! queue new-pair )\nqueue )\n357\nfront-ptrq\na brear-ptr\nc dFigure 3.21: Result of using (delete-queue! q) on the\nqueue of Figure 3.20 . (else\n(set-cdr! (rear-ptr queue )new-pair )\n(set-rear-ptr!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 666, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_sicp_abelson_chunk_0667_274ea4b3", "text": "queue new-pair )\nqueue )\n357\nfront-ptrq\na brear-ptr\nc dFigure 3.21: Result of using (delete-queue! q) on the\nqueue of Figure 3.20 . (else\n(set-cdr! (rear-ptr queue )new-pair )\n(set-rear-ptr! queue new-pair )\nqueue ))))\nTo delete the item at the front of the queue, we merely modify the front\npointer so that it now points at the second item in the queue, which\ncan be found by following the cdrpointer of the ﬁrst item (see Figure\n3.21):22\n(define (delete-queue! queue )\n(cond ((empty-queue? queue )\n(error \"DELETE! called with anempty queue \"queue ))\n(else (set-front-ptr! queue (cdr (front-ptr queue )))\nqueue )))\n22If the ﬁrst item is the ﬁnal item in the queue, the front pointer will be the empty\nlist aer the deletion, which will mark the queue as empty; we needn’t worry about\nupdating the rear pointer, which will still point to the deleted item, because empty-\nqueue?looks only at the front pointer. 358\nExercise 3.21: Ben Bitdiddle decides to test the queue im-\nplementation described above.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 667, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_sicp_abelson_chunk_0668_b8f4677b", "text": "358\nExercise 3.21: Ben Bitdiddle decides to test the queue im-\nplementation described above. He types in the procedures\nto the Lisp interpreter and proceeds to try them out:\n(define q1(make-queue ))\n(insert-queue! q1'a)\n((a) a)\n(insert-queue! q1'b)\n((a b) b)\n(delete-queue! q1)\n((b) b)\n(delete-queue! q1)\n(() b)\n“It’s all wrong!” he complains. “e interpreter’s response\nshows that the last item is inserted into the queue twice. And when I delete both items, the second bis still there,\nso the queue isn’t empty, even though it’s supposed to be.”\nEva Lu Ator suggests that Ben has misunderstood what is\nhappening.“It’snotthattheitemsaregoingintothequeue\ntwice,” she explains. “It’s just that the standard Lisp printer\ndoesn’t know how to make sense of the queue representa-\ntion. If you want to see the queue printed correctly, you’ll\nhave to deﬁne your own print procedure for queues.” Ex-\nplainwhatEvaLuistalkingabout.Inparticular,showwhy\nBen’s examples produce the printed results that they do.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 668, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_sicp_abelson_chunk_0669_1b9b8517", "text": "Deﬁne a procedure print-queue that takes a queue as in-\nput and prints the sequence of items in the queue. Exercise 3.22: Instead of representing a queue as a pair of\npointers, we can build a queue as a procedure with local\nstate. e local state will consist of pointers to the begin-\n359\nning and the end of an ordinary list. us, the make-queue\nprocedure will have the form\n(define (make-queue )\n(let ((front-ptr : : :)\n(rear-ptr : : :))\n⟨definitions of internal procedures ⟩\n(define (dispatch m): : :)\ndispatch ))\nComplete the deﬁnition of make-queue and provide imple-\nmentations of the queue operations using this representa-\ntion. Exercise3.23: Adeque(“double-endedqueue”)isasequence\nin which items can be inserted and deleted at either the\nfront or the rear. Operations on deques are the constructor\nmake-deque , the predicate empty-deque? , selectors front-\ndequeand rear-deque , mutators front-insert-deque! ,\nrear-insert-deque! ,front-delete-deque! ,and rear-delete-\ndeque!.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 669, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_sicp_abelson_chunk_0670_f3975f63", "text": ", selectors front-\ndequeand rear-deque , mutators front-insert-deque! ,\nrear-insert-deque! ,front-delete-deque! ,and rear-delete-\ndeque!. Show how to represent deques using pairs, and\ngive implementations of the operations.23All operations\nshould be accomplished in Θ(1) steps. 3.3.3Representing Tables\nWhen we studied various ways of representing sets in Chapter 2 , we\nmentioned in Section 2.3.3 the task of maintaining a table of records in-\ndexed by identifying keys. In the implementation of data-directed pro-\ngramming in Section 2.4.3 , we made extensive use of two-dimensional\n23Be careful not to make the interpreter try to print a structure that contains cycles. (SeeExercise 3.13 .)\n360\na b c 1 2 3*table*tableFigure 3.22: A table represented as a headed list. tables,inwhichinformationisstoredandretrievedusingtwokeys.Here\nwe see how to build tables as mutable list structures. We ﬁrst consider a one-dimensional table, in which each value is\nstored under a single key.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 670, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_sicp_abelson_chunk_0671_74401fb2", "text": "We ﬁrst consider a one-dimensional table, in which each value is\nstored under a single key. We implement the table as a list of records,\neach of which is implemented as a pair consisting of a key and the as-\nsociated value. e records are glued together to form a list by pairs\nwhose cars point to successive records. ese gluing pairs are called\nthebackbone of the table. In order to have a place that we can change\nwhenweaddanewrecordtothetable,webuildthetableasa headed list . A headed list has a special backbone pair at the beginning, which holds\na dummy “record”—in this case the arbitrarily chosen symbol *table* . Figure 3.22 shows the box-and-pointer diagram for the table\na: 1\nb: 2\nc: 3\nToextractinformationfromatableweusethe lookupprocedure,which\ntakes a key as argument and returns the associated value (or false if\n361\nthereisnovaluestoredunderthatkey). lookupisdeﬁnedintermsofthe\nassocoperation,whichexpectsakeyandalistofrecordsasarguments. Notethat assocneverseesthedummyrecord.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 671, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_sicp_abelson_chunk_0672_55b68a2d", "text": "lookupisdeﬁnedintermsofthe\nassocoperation,whichexpectsakeyandalistofrecordsasarguments. Notethat assocneverseesthedummyrecord. assocreturnstherecord\nthat has the given key as its car.24lookupthen checks to see that the\nresulting record returned by associs not false, and returns the value\n(the cdr) of the record. (define (lookup key table )\n(let ((record (assoc key (cdr table ))))\n(ifrecord\n(cdr record )\nfalse )))\n(define (assoc key records )\n(cond ((null? records )false )\n((equal? key (caar records )) ( car records ))\n(else (assoc key (cdr records )))))\nTo insert a value in a table under a speciﬁed key, we ﬁrst use assoc\nto see if there is already a record in the table with this key. If not, we\nform a new record by consing the key with the value, and insert this at\nthe head of the table’s list of records, aer the dummy record. If there\nalready is a record with this key, we set the cdrof this record to the\ndesignated new value.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 672, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 941}}
{"id": "computer_science_sicp_abelson_chunk_0673_51828c41", "text": "If there\nalready is a record with this key, we set the cdrof this record to the\ndesignated new value. e header of the table provides us with a ﬁxed\nlocation to modify in order to insert the new record.25\n(define (insert! key value table )\n(let ((record (assoc key (cdr table ))))\n24Because assocuses equal?, it can recognize keys that are symbols, numbers, or\nlist structure. 25us, the ﬁrst backbone pair is the object that represents the table “itself”; that is,\na pointer to the table is a pointer to this pair. is same backbone pair always starts\nthe table. If we did not arrange things in this way, insert! would have to return a new\nvalue for the start of the table when it added a new record. 362\n(ifrecord\n(set-cdr! record value )\n(set-cdr!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 673, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 750}}
{"id": "computer_science_sicp_abelson_chunk_0674_fdc1fef7", "text": "If we did not arrange things in this way, insert! would have to return a new\nvalue for the start of the table when it added a new record. 362\n(ifrecord\n(set-cdr! record value )\n(set-cdr! table\n(cons (cons key value )\n(cdr table )))))\n'ok)\nTo construct a new table, we simply create a list containing the symbol\n*table* :\n(define (make-table )\n(list '*table* ))\nTwo-dimensional tables\nIn a two-dimensional table, each value is indexed by two keys. We can\nconstruct such a table as a one-dimensional table in which each key\nidentiﬁes a subtable. Figure 3.23 shows the box-and-pointer diagram\nfor the table\nmath: +: 43 letters: a: 97\n-: 45 b: 98\n*: 42\nwhich has two subtables. (e subtables don’t need a special header\nsymbol, since the key that identiﬁes the subtable serves this purpose.)\nWhenwelookupanitem,weusetheﬁrstkeytoidentifythecorrect\nsubtable. en we use the second key to identify the record within the\nsubtable.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 674, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_sicp_abelson_chunk_0675_786003aa", "text": "en we use the second key to identify the record within the\nsubtable. (define (lookup key-1 key-2 table )\n(let ((subtable\n(assoc key-1 (cdr table ))))\n363\n+ - * 43 45 42*table*\na b97 98letters\nmathtableFigure 3.23: A two-dimensional table. (ifsubtable\n(let ((record\n(assoc key-2 (cdr subtable ))))\n(ifrecord\n(cdr record )\nfalse ))\nfalse )))\n364\nTo insert a new item under a pair of keys, we use assocto see if\nthere is a subtable stored under the ﬁrst key. If not, we build a new\nsubtable containing the single record ( key-2,value) and insert it into\nthe table under the ﬁrst key. If a subtable already exists for the ﬁrst key,\nwe insert the new record into this subtable, using the insertion method\nfor one-dimensional tables described above:\n(define (insert! key-1 key-2 value table )\n(let ((subtable (assoc key-1 (cdr table ))))\n(ifsubtable\n(let ((record (assoc key-2 (cdr subtable ))))\n(ifrecord\n(set-cdr! record value )\n(set-cdr! subtable\n(cons (cons key-2 value )\n(cdr subtable )))))\n(set-cdr!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 675, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1000}}
{"id": "computer_science_sicp_abelson_chunk_0676_9dc2d733", "text": "record value )\n(set-cdr! subtable\n(cons (cons key-2 value )\n(cdr subtable )))))\n(set-cdr! table\n(cons (list key-1\n(cons key-2 value ))\n(cdr table )))))\n'ok)\nCreating local tables\nelookupandinsert! operations deﬁned above take the table as an\nargument.isenablesustouseprogramsthataccessmorethanoneta-\nble.Anotherwaytodealwithmultipletablesistohaveseparate lookup\nandinsert! procedures for each table. We can do this by representing\natableprocedurally,asanobjectthatmaintainsaninternaltableaspart\nof its local state. When sent an appropriate message, this “table object”\nsuppliestheprocedurewithwhichtooperateontheinternaltable.Here\nis a generator for two-dimensional tables represented in this fashion:\n365\n(define (make-table )\n(let ((local-table (list '*table* )))\n(define (lookup key-1 key-2 )\n(let ((subtable\n(assoc key-1 (cdr local-table ))))\n(ifsubtable\n(let ((record\n(assoc key-2 (cdr subtable ))))\n(ifrecord (cdr record )false ))\nfalse )))\n(define (insert!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 676, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_sicp_abelson_chunk_0677_a435d110", "text": "key-1 key-2 value )\n(let ((subtable\n(assoc key-1 (cdr local-table ))))\n(ifsubtable\n(let ((record\n(assoc key-2 (cdr subtable ))))\n(ifrecord\n(set-cdr! record value )\n(set-cdr! subtable\n(cons (cons key-2 value )\n(cdr subtable )))))\n(set-cdr! local-table\n(cons (list key-1 (cons key-2 value ))\n(cdr local-table )))))\n'ok)\n(define (dispatch m)\n(cond ((eq? m'lookup-proc )lookup )\n((eq? m'insert-proc! )insert! )\n(else (error \"Unknown operation :TABLE \"m))))\ndispatch ))\nUsing make-table , we could implement the getand putoperations\nused inSection 2.4.3 for data-directed programming, as follows:\n366\n(define operation-table (make-table ))\n(define get (operation-table 'lookup-proc ))\n(define put (operation-table 'insert-proc! ))\ngettakes as arguments two keys, and puttakes as arguments two keys\nand a value. Both operations access the same local table, which is en-\ncapsulated within the object created by the call to make-table .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 677, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_sicp_abelson_chunk_0678_ebc8b552", "text": "Both operations access the same local table, which is en-\ncapsulated within the object created by the call to make-table . Exercise3.24: Inthetableimplementationsabove,thekeys\nare tested for equality using equal?(called by assoc). is\nis not always the appropriate test. For instance, we might\nhave a table with numeric keys in which we don’t need an\nexact match to the number we’re looking up, but only a\nnumber within some tolerance of it. Design a table con-\nstructor make-table thattakesasanargumenta same-key? procedurethatwillbeusedtotest“equality”ofkeys. make-\ntableshouldreturna dispatch procedurethatcanbeused\ntoaccessappropriate lookupandinsert! proceduresfora\nlocal table. Exercise 3.25: Generalizing one- and two-dimensional ta-\nbles, show how to implement a table in which values are\nstoredunderanarbitrarynumberofkeysanddiﬀerentval-\nues may be stored under diﬀerent numbers of keys. e\nlookupandinsert! procedures should take as input a list\nof keys used to access the table.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 678, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_sicp_abelson_chunk_0679_1d805e4f", "text": "e\nlookupandinsert! procedures should take as input a list\nof keys used to access the table. Exercise3.26: Tosearchatableasimplementedabove,one\nneeds to scan through the list of records. is is basically\nthe unordered list representation of Section 2.3.3 . For large\ntables,itmaybemoreeﬃcienttostructurethetableinadif-\nferent manner. Describe a table implementation where the\n367\n(key, value) records are organized using a binary tree, as-\nsuming that keys can be ordered in some way (e.g., numer-\nicallyoralphabetically).(Compare Exercise2.66 ofChapter\n2.)\nExercise3.27: Memoization (alsocalled tabulation )isatech-\nnique that enables a procedure to record, in a local table,\nvaluesthathavepreviouslybeencomputed.istechnique\ncanmakeavastdiﬀerenceintheperformanceofaprogram. A memoized procedure maintains a table in which values\nof previous calls are stored using as keys the arguments\nthat produced the values.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 679, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 913}}
{"id": "computer_science_sicp_abelson_chunk_0680_1f82e2e1", "text": "A memoized procedure maintains a table in which values\nof previous calls are stored using as keys the arguments\nthat produced the values. When the memoized procedure\nis asked to compute a value, it ﬁrst checks the table to see\nifthevalueisalreadythereand,ifso,justreturnsthatvalue. Otherwise, it computes the new value in the ordinary way\nand stores this in the table. As an example of memoization,\nrecall from Section 1.2.2 the exponential process for com-\nputing Fibonacci numbers:\n(define (fib n)\n(cond ((= n0) 0)\n((= n1) 1)\n(else (+ ( fib (-n1)) ( fib (-n2))))))\ne memoized version of the same procedure is\n(define memo-fib\n(memoize\n(lambda (n)\n(cond ((= n0) 0)\n((= n1) 1)\n(else (+ ( memo-fib (-n1))\n(memo-fib (-n2))))))))\n368\nwhere the memoizer is deﬁned as\n(define (memoize f)\n(let ((table (make-table )))\n(lambda (x)\n(let ((previously-computed-result\n(lookup xtable )))\n(orpreviously-computed-result\n(let ((result (fx)))\n(insert!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 680, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 937}}
{"id": "computer_science_sicp_abelson_chunk_0681_4dc06f62", "text": "xresult table )\nresult ))))))\nDraw an environment diagram to analyze the computation\nof(memo-fib 3) . Explain why memo-fib computes the nth\nFibonacci number in a number of steps proportional to n. Wouldtheschemestillworkifwehadsimplydeﬁned memo-\nfibto be (memoize fib) ? 3.3.4A Simulator for Digital Circuits\nDesigning complex digital systems, such as computers, is an important\nengineering activity. Digital systems are constructed by interconnect-\ningsimpleelements.Althoughthebehavioroftheseindividualelements\nissimple,networksofthemcanhaveverycomplexbehavior.Computer\nsimulationofproposedcircuitdesignsisanimportanttoolusedbydigi-\ntalsystemsengineers.Inthissectionwedesignasystemforperforming\ndigital logic simulations. is system typiﬁes a kind of program called\nanevent-driven simulation , in which actions (“events”) trigger further\nevents that happen at a later time, which in turn trigger more events,\nand so on.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 681, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_sicp_abelson_chunk_0682_16a0fab1", "text": "is system typiﬁes a kind of program called\nanevent-driven simulation , in which actions (“events”) trigger further\nevents that happen at a later time, which in turn trigger more events,\nand so on. Our computational model of a circuit will be composed of objects\nthat correspond to the elementary components from which the circuit\n369\nInverter And-gate Or-gateFigure 3.24: Primitive functions in the digital logic simulator. is constructed. ere are wires, which carry digital signals . A digital sig-\nnal may at any moment have only one of two possible values, 0 and\n1. ere are also various types of digital function boxes , which connect\nwires carrying input signals to other output wires. Such boxes produce\noutput signals computed from their input signals. e output signal is\ndelayed by a time that depends on the type of the function box. For\nexample, an inverter is a primitive function box that inverts its input.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 682, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_sicp_abelson_chunk_0683_7f9fce9b", "text": "e output signal is\ndelayed by a time that depends on the type of the function box. For\nexample, an inverter is a primitive function box that inverts its input. If the input signal to an inverter changes to 0, then one inverter-delay\nlatertheinverterwillchangeitsoutputsignalto1.Iftheinputsignalto\nan inverter changes to 1, then one inverter-delay later the inverter will\nchange its output signal to 0. We draw an inverter symbolically as in\nFigure 3.24 . An and-gate , also shown in Figure 3.24 , is a primitive func-\ntion box with two inputs and one output. It drives its output signal to\na value that is the logical and of the inputs. at is, if both of its input\nsignals become 1, then one and-gate-delay time later the and-gate will\nforceitsoutputsignaltobe1;otherwisetheoutputwillbe0.An or-gate\nis a similar two-input primitive function box that drives its output sig-\nnal to a value that is the logical or of the inputs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 683, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_sicp_abelson_chunk_0684_b2e8e6d2", "text": "at is, the output will\nbecome 1 if at least one of the input signals is 1; otherwise the output\nwill become 0. Wecanconnectprimitivefunctionstogethertoconstructmorecom-\nplexfunctions.Toaccomplishthiswewiretheoutputsofsomefunction\nboxes to the inputs of other function boxes. For example, the half-adder\n370\nD\nEA\nBS\nCFigure 3.25: A half-adder circuit. circuit shown in Figure 3.25 consists of an or-gate, two and-gates, and\nan inverter. It takes two input signals, A and B, and has two output sig-\nnals, S and C. S will become 1 whenever precisely one of A and B is 1,\nand C will become 1 whenever A and B are both 1. We can see from the\nﬁgure that, because of the delays involved, the outputs may be gener-\nated at diﬀerent times. Many of the diﬃculties in the design of digital\ncircuits arise from this fact. We will now build a program for modeling the digital logic circuits\nwe wish to study. e program will construct computational objects\nmodeling the wires, which will “hold” the signals.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 684, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_sicp_abelson_chunk_0685_589faa8b", "text": "We will now build a program for modeling the digital logic circuits\nwe wish to study. e program will construct computational objects\nmodeling the wires, which will “hold” the signals. Function boxes will\nbe modeled by procedures that enforce the correct relationships among\nthe signals. Onebasicelementofoursimulationwillbeaprocedure make-wire ,\nwhich constructs wires. For example, we can construct six wires as fol-\nlows:\n(define a(make-wire ))\n(define b(make-wire ))\n(define c(make-wire ))\n(define d(make-wire ))\n(define e(make-wire ))\n(define s(make-wire ))\n371\nWe aach a function box to a set of wires by calling a procedure that\nconstructsthatkindofbox.eargumentstotheconstructorprocedure\nare the wires to be aached to the box.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 685, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 737}}
{"id": "computer_science_sicp_abelson_chunk_0686_55f93686", "text": "For example, given that we can\nconstruct and-gates, or-gates, and inverters, we can wire together the\nhalf-adder shown in Figure 3.25 :\n(or-gate abd)\nok\n(and-gate abc)\nok\n(inverter ce)\nok\n(and-gate des)\nok\nBeeryet,wecanexplicitlynamethisoperationbydeﬁningaprocedure\nhalf-adder thatconstructsthiscircuit,giventhefourexternalwiresto\nbe aached to the half-adder:\n(define (half-adder absc)\n(let ((d(make-wire )) ( e(make-wire )))\n(or-gate abd)\n(and-gate abc)\n(inverter ce)\n(and-gate des)\n'ok))\ne advantage of making this deﬁnition is that we can use half-adder\nitself as a building block in creating more complex circuits. Figure 3.26 ,\nfor example, shows a full-adder composed of two half-adders and an\nor-gate.26We can construct a full-adder as follows:\n26A full-adder is a basic circuit element used in adding two binary numbers. Here\nA and B are the bits at corresponding positions in the two numbers to be added, and\n372\nhalf-\nadderhalf-\nadderA\nB\nCinSUM\nCout orFigure 3.26: A full-adder circuit.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 686, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_sicp_abelson_chunk_0687_a75371f3", "text": "Here\nA and B are the bits at corresponding positions in the two numbers to be added, and\n372\nhalf-\nadderhalf-\nadderA\nB\nCinSUM\nCout orFigure 3.26: A full-adder circuit. (define (full-adder abc-in sum c-out )\n(let ((s(make-wire )) ( c1(make-wire )) ( c2(make-wire )))\n(half-adder bc-in sc1)\n(half-adder assum c2)\n(or-gate c1c2c-out )\n'ok))\nHavingdeﬁned full-adder asaprocedure,wecannowuseitasabuild-\ning block for creating still more complex circuits. (For example, see Ex-\nercise 3.30 .)\nIn essence, our simulator provides us with the tools to construct a\nlanguage of circuits. If we adopt the general perspective on languages\nwith which we approached the study of Lisp in Section 1.1 , we can say\nthat the primitive function boxes form the primitive elements of the\nlanguage, that wiring boxes together provides a means of combination,\nand that specifying wiring paerns as procedures serves as a means of\nabstraction. Cinis the carry bit from the addition one place to the right.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 687, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_sicp_abelson_chunk_0688_b78411a9", "text": "Cinis the carry bit from the addition one place to the right. e circuit generates SUM,\nwhich is the sum bit in the corresponding position, and C out, which is the carry bit to\nbe propagated to the le. 373\nPrimitive function boxes\neprimitivefunctionboxesimplementthe“forces”bywhichachange\nin the signal on one wire inﬂuences the signals on other wires. To build\nfunction boxes, we use the following operations on wires:\n•(get-signal⟨wire⟩)\nreturns the current value of the signal on the wire. •(set-signal!⟨wire⟩ ⟨new value⟩)\nchanges the value of the signal on the wire to the new value. •(add-action!⟨wire⟩ ⟨procedure of no arguments ⟩)\nasserts that the designated procedure should be run whenever\nthe signal on the wire changes value. Such procedures are the\nvehicles by which changes in the signal value on the wire are\ncommunicated to other wires.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 688, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 853}}
{"id": "computer_science_sicp_abelson_chunk_0689_a87587f7", "text": "Such procedures are the\nvehicles by which changes in the signal value on the wire are\ncommunicated to other wires. In addition, we will make use of a procedure after-delay that takes a\ntime delay and a procedure to be run and executes the given procedure\naer the given delay. Using these procedures, we can deﬁne the primitive digital logic\nfunctions.Toconnectaninputtoanoutputthroughaninverter,weuse\nadd-action! to associate with the input wire a procedure that will be\nrun whenever the signal on the input wire changes value. e proce-\ndure computes the logical-not of the input signal, and then, aer one\ninverter-delay , sets the output signal to be this new value:\n(define (inverter input output )\n(define (invert-input )\n(let ((new-value (logical-not (get-signal input ))))\n374\n(after-delay inverter-delay\n(lambda () ( set-signal! output new-value )))))\n(add-action!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 689, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 873}}
{"id": "computer_science_sicp_abelson_chunk_0690_90283775", "text": "output new-value )))))\n(add-action! input invert-input )'ok)\n(define (logical-not s)\n(cond ((= s0) 1)\n((= s1) 0)\n(else (error \"Invalid signal \"s))))\nAn and-gate is a lile more complex. e action procedure must be run\nif either of the inputs to the gate changes. It computes the logical-\nand(using a procedure analogous to logical-not ) of the values of the\nsignals on the input wires and sets up a change to the new value to\noccur on the output wire aer one and-gate-delay . (define (and-gate a1a2output )\n(define (and-action-procedure )\n(let ((new-value\n(logical-and (get-signal a1) (get-signal a2))))\n(after-delay\nand-gate-delay\n(lambda () ( set-signal! output new-value )))))\n(add-action! a1and-action-procedure )\n(add-action! a2and-action-procedure )\n'ok)\nExercise 3.28: Deﬁne an or-gate as a primitive function\nbox. Your or-gate constructor should be similar to and-\ngate. Exercise 3.29: Another way to construct an or-gate is as\na compound digital logic device, built from and-gates and\ninverters.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 690, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_sicp_abelson_chunk_0691_66482b74", "text": "Your or-gate constructor should be similar to and-\ngate. Exercise 3.29: Another way to construct an or-gate is as\na compound digital logic device, built from and-gates and\ninverters. Deﬁne a procedure or-gate that accomplishes\n375\nA1B1C1A2B2C2A3B3C3AnBnCn = 0 \nS1C\nS2 S3 SnCn-1 FA FA FA FAFigure 3.27: A ripple-carry adder for n-bit numbers. this. What is the delay time of the or-gate in terms of and-\ngate-delay andinverter-delay ? Exercise3.30: Figure3.27 showsa ripple-carry adder formed\nbystringingtogether nfull-adders.isisthesimplestform\nof parallel adder for adding two n-bit binary numbers. e\ninputs A1,A2,A3,: : :,AnandB1,B2,B3,: : :,Bnare the\ntwo binary numbers to be added (each AkandBkis a 0 or\na 1). e circuit generates S1,S2,S3,: : :,Sn, the nbits of\nthe sum, and C, the carry from the addition. Write a proce-\ndure ripple-carry-adder that generates this circuit. e\nprocedure should take as arguments three lists of nwires\neach—the Ak, theBk, and the Sk—and also another wire C.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 691, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 997}}
{"id": "computer_science_sicp_abelson_chunk_0692_b495872a", "text": "Write a proce-\ndure ripple-carry-adder that generates this circuit. e\nprocedure should take as arguments three lists of nwires\neach—the Ak, theBk, and the Sk—and also another wire C. e major drawback of the ripple-carry adder is the need\ntowaitforthecarrysignalstopropagate.Whatisthedelay\nneeded to obtain the complete output from an n-bit ripple-\ncarry adder, expressed in terms of the delays for and-gates,\nor-gates, and inverters? 376\nRepresenting wires\nA wire in our simulation will be a computational object with two local\nstate variables: a signal-value (initially taken to be 0) and a collec-\ntion of action-procedures to be run when the signal changes value. We implement the wire, using message-passing style, as a collection of\nlocalprocedurestogetherwitha dispatch procedurethatselectstheap-\npropriate local operation, just as we did with the simple bank-account\nobject in Section 3.1.1 :\n(define (make-wire )\n(let ((signal-value 0) ( action-procedures '()))\n(define (set-my-signal!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 692, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_sicp_abelson_chunk_0693_7f2ca82c", "text": "new-value )\n(if(not (=signal-value new-value ))\n(begin (set! signal-value new-value )\n(call-each action-procedures ))\n'done ))\n(define (accept-action-procedure! proc )\n(set! action-procedures\n(cons proc action-procedures ))\n(proc ))\n(define (dispatch m)\n(cond ((eq? m'get-signal )signal-value )\n((eq? m'set-signal! )set-my-signal! )\n((eq? m'add-action! )accept-action-procedure! )\n(else (error \"Unknown operation :WIRE \"m))))\ndispatch ))\nelocalprocedure set-my-signal! testswhetherthenewsignalvalue\nchanges the signal on the wire. If so, it runs each of the action proce-\ndures,usingthefollowingprocedure call-each ,whichcallseachofthe\nitems in a list of no-argument procedures:\n(define (call-each procedures )\n377\n(if(null? procedures )\n'done\n(begin ((car procedures ))\n(call-each (cdr procedures )))))\ne local procedure accept-action-procedure! adds the given proce-\nduretothelistofprocedurestoberun,andthenrunsthenewprocedure\nonce.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 693, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_sicp_abelson_chunk_0694_a897e44b", "text": "adds the given proce-\nduretothelistofprocedurestoberun,andthenrunsthenewprocedure\nonce. (See Exercise 3.31 .)\nWith the local dispatch procedure set up as speciﬁed, we can pro-\nvide the following procedures to access the local operations on wires:27\n(define (get-signal wire ) (wire 'get-signal ))\n(define (set-signal! wire new-value )\n((wire 'set-signal! )new-value ))\n(define (add-action! wire action-procedure )\n((wire 'add-action! )action-procedure ))\nWires, which have time-varying signals and may be incrementally at-\ntachedtodevices,aretypicalofmutableobjects.Wehavemodeledthem\nasprocedureswithlocalstatevariablesthataremodiﬁedbyassignment. When a new wire is created, a new set of state variables is allocated\n(by the letexpression in make-wire ) and a new dispatch procedure\nis constructed and returned, capturing the environment with the new\nstate variables. 27ese procedures are simply syntactic sugar that allow us to use ordinary pro-\ncedural syntax to access the local procedures of objects.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 694, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_sicp_abelson_chunk_0695_5e514212", "text": "27ese procedures are simply syntactic sugar that allow us to use ordinary pro-\ncedural syntax to access the local procedures of objects. It is striking that we can in-\nterchange the role of “procedures” and “data” in such a simple way. For example, if we\nwrite (wire 'get-signal) wethinkof wireasaprocedurethatiscalledwiththemes-\nsage get-signal as input. Alternatively, writing (get-signal wire) encourages us to\nthink of wireas a data object that is the input to a procedure get-signal . e truth of\nthe maer is that, in a language in which we can deal with procedures as objects, there\nis no fundamental diﬀerence between “procedures” and “data,” and we can choose our\nsyntactic sugar to allow us to program in whatever style we choose. 378\newiresaresharedamongthevariousdevicesthathavebeencon-\nnected to them.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 695, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 816}}
{"id": "computer_science_sicp_abelson_chunk_0696_bded9cac", "text": "378\newiresaresharedamongthevariousdevicesthathavebeencon-\nnected to them. us, a change made by an interaction with one device\nwillaﬀectalltheotherdevicesaachedtothewire.ewirecommuni-\ncates the change to its neighbors by calling the action procedures pro-\nvided to it when the connections were established. The agenda\ne only thing needed to complete the simulator is after-delay . e\nidea here is that we maintain a data structure, called an agenda, that\ncontainsascheduleofthingstodo.efollowingoperationsaredeﬁned\nfor agendas:\n•(make-agenda) returns a new empty agenda. •(empty-agenda? ⟨agenda⟩)is true if the speciﬁed agenda is\nempty. •(first-agenda-item ⟨agenda⟩)returns the ﬁrst item on the\nagenda. •(remove-first-agenda-item! ⟨agenda⟩)modiﬁes the agenda\nby removing the ﬁrst item. •(add-to-agenda! ⟨time⟩ ⟨action⟩ ⟨agenda⟩)modiﬁes the\nagendabyaddingthegivenactionproceduretoberunatthespec-\niﬁed time. •(current-time⟨agenda⟩)returns the current simulation time.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 696, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_sicp_abelson_chunk_0697_51f95228", "text": "•(add-to-agenda! ⟨time⟩ ⟨action⟩ ⟨agenda⟩)modiﬁes the\nagendabyaddingthegivenactionproceduretoberunatthespec-\niﬁed time. •(current-time⟨agenda⟩)returns the current simulation time. e particular agenda that we use is denoted by the-agenda . e pro-\ncedure after-delay adds new elements to the-agenda :\n379\n(define (after-delay delay action )\n(add-to-agenda! (+delay (current-time the-agenda ))\naction\nthe-agenda ))\ne simulation is driven by the procedure propagate , which operates\nonthe-agenda ,executingeachprocedureontheagendainsequence.In\ngeneral, as the simulation runs, new items will be added to the agenda,\nandpropagate will continue the simulation as long as there are items\non the agenda:\n(define (propagate )\n(if(empty-agenda? the-agenda )\n'done\n(let ((first-item (first-agenda-item the-agenda )))\n(first-item )\n(remove-first-agenda-item! the-agenda )\n(propagate ))))\nA sample simulation\ne following procedure, which places a “probe” on a wire, shows the\nsimulator in action.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 697, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_sicp_abelson_chunk_0698_26b46951", "text": "the-agenda )\n(propagate ))))\nA sample simulation\ne following procedure, which places a “probe” on a wire, shows the\nsimulator in action. e probe tells the wire that, whenever its signal\nchanges value, it should print the new signal value, together with the\ncurrent time and a name that identiﬁes the wire:\n(define (probe name wire )\n(add-action!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 698, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 347}}
{"id": "computer_science_sicp_abelson_chunk_0699_ae52e243", "text": "wire\n(lambda ()\n(newline )\n(display name ) (display \"\")\n(display (current-time the-agenda ))\n(display \"New-value =\")\n(display (get-signal wire )))))\n380\nWe begin by initializing the agenda and specifying delays for the prim-\nitive function boxes:\n(define the-agenda (make-agenda ))\n(define inverter-delay 2)\n(define and-gate-delay 3)\n(define or-gate-delay 5)\nNow we deﬁne four wires, placing probes on two of them:\n(define input-1 (make-wire ))\n(define input-2 (make-wire ))\n(define sum (make-wire ))\n(define carry (make-wire ))\n(probe 'sum sum)\nsum 0 New-value = 0\n(probe 'carry carry )\ncarry 0 New-value = 0\nNext we connect the wires in a half-adder circuit (as in Figure 3.25 ), set\nthe signal on input-1 to 1, and run the simulation:\n(half-adder input-1 input-2 sum carry )\nok\n(set-signal! input-1 1)\ndone\n(propagate )\nsum 8 New-value = 1\ndone\nesumsignal changes to 1 at time 8. We are now eight time units from\nthe beginning of the simulation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 699, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_sicp_abelson_chunk_0700_2d640d5d", "text": "input-1 1)\ndone\n(propagate )\nsum 8 New-value = 1\ndone\nesumsignal changes to 1 at time 8. We are now eight time units from\nthe beginning of the simulation. At this point, we can set the signal on\ninput-2 to 1 and allow the values to propagate:\n381\n(set-signal! input-2 1)\ndone\n(propagate )\ncarry 11 New-value = 1\nsum 16 New-value = 0\ndone\necarrychanges to 1 at time 11 and the sumchanges to 0 at time 16. Exercise3.31: einternalprocedure accept-action-procedure! deﬁnedin make-wire speciﬁesthatwhenanewactionpro-\ncedure is added to a wire, the procedure is immediately\nrun.Explainwhythisinitializationisnecessary.Inparticu-\nlar,tracethroughthehalf-adderexampleintheparagraphs\naboveandsayhowthesystem’sresponsewoulddiﬀerifwe\nhad deﬁned accept-action-procedure! as\n(define (accept-action-procedure! proc )\n(set!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 700, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 811}}
{"id": "computer_science_sicp_abelson_chunk_0701_199d9fba", "text": "as\n(define (accept-action-procedure! proc )\n(set! action-procedures\n(cons proc action-procedures )))\nImplementing the agenda\nFinally, we give details of the agenda data structure, which holds the\nprocedures that are scheduled for future execution. e agenda is made up of time segments . Each time segment is a\npair consisting of a number (the time) and a queue (see Exercise 3.32 )\nthat holds the procedures that are scheduled to be run during that time\nsegment. (define (make-time-segment time queue )\n(cons time queue ))\n382\n(define (segment-time s) (car s))\n(define (segment-queue s) (cdr s))\nWewilloperateonthetime-segmentqueuesusingthequeueoperations\ndescribed in Section 3.3.2 . e agenda itself is a one-dimensional table of time segments. It\ndiﬀersfromthetablesdescribedin Section3.3.3 inthatthesegmentswill\nbe sorted in order of increasing time. In addition, we store the current\ntime(i.e., the time of the last action that was processed) at the head of\nthe agenda.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 701, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_sicp_abelson_chunk_0702_cdd72b97", "text": "In addition, we store the current\ntime(i.e., the time of the last action that was processed) at the head of\nthe agenda. A newly constructed agenda has no time segments and has\na current time of 0:28\n(define (make-agenda ) (list 0))\n(define (current-time agenda ) (car agenda ))\n(define (set-current-time! agenda time )\n(set-car! agenda time ))\n(define (segments agenda ) (cdr agenda ))\n(define (set-segments! agenda segments )\n(set-cdr! agenda segments ))\n(define (first-segment agenda ) (car (segments agenda )))\n(define (rest-segments agenda ) (cdr (segments agenda )))\nAn agenda is empty if it has no time segments:\n(define (empty-agenda? agenda )\n(null? (segments agenda )))\nToaddanactiontoanagenda,weﬁrstcheckiftheagendaisempty.Ifso,\nwe create a time segment for the action and install this in the agenda. Otherwise, we scan the agenda, examining the time of each segment.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 702, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_sicp_abelson_chunk_0703_df541838", "text": "Otherwise, we scan the agenda, examining the time of each segment. If we ﬁnd a segment for our appointed time, we add the action to the\n28e agenda is a headed list, like the tables in Section 3.3.3 , but since the list is\nheaded by the time, we do not need an additional dummy header (such as the *table*\nsymbol used with tables). 383\nassociated queue. If we reach a time later than the one to which we are\nappointed, we insert a new time segment into the agenda just before it. If we reach the end of the agenda, we must create a new time segment\nat the end. (define (add-to-agenda! time action agenda )\n(define (belongs-before? segments )\n(or(null? segments )\n(<time (segment-time (car segments )))))\n(define (make-new-time-segment time action )\n(let ((q(make-queue )))\n(insert-queue! qaction )\n(make-time-segment time q)))\n(define (add-to-segments! segments )\n(if(= ( segment-time (car segments ))time )\n(insert-queue!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 703, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_sicp_abelson_chunk_0704_a06ee76d", "text": "qaction )\n(make-time-segment time q)))\n(define (add-to-segments! segments )\n(if(= ( segment-time (car segments ))time )\n(insert-queue! (segment-queue (car segments ))\naction )\n(let ((rest (cdr segments )))\n(if(belongs-before? rest )\n(set-cdr! segments\n(cons (make-new-time-segment time action )\n(cdr segments )))\n(add-to-segments! rest )))))\n(let ((segments (segments agenda )))\n(if(belongs-before? segments )\n(set-segments! agenda\n(cons (make-new-time-segment time action )\nsegments ))\n(add-to-segments! segments ))))\ne procedure that removes the ﬁrst item from the agenda deletes the\nitem at the front of the queue in the ﬁrst time segment. If this deletion\n384\nmakesthetimesegmentempty,weremoveitfromthelistofsegments:29\n(define (remove-first-agenda-item! agenda )\n(let ((q(segment-queue (first-segment agenda ))))\n(delete-queue! q)\n(if(empty-queue? q)\n(set-segments! agenda (rest-segments agenda )))))\ne ﬁrst agenda item is found at the head of the queue in the ﬁrst\ntime segment.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 704, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_sicp_abelson_chunk_0705_d28465dd", "text": "q)\n(if(empty-queue? q)\n(set-segments! agenda (rest-segments agenda )))))\ne ﬁrst agenda item is found at the head of the queue in the ﬁrst\ntime segment. Whenever we extract an item, we also update the cur-\nrent time:30\n(define (first-agenda-item agenda )\n(if(empty-agenda? agenda )\n(error \"Agenda isempty :FIRST-AGENDA-ITEM \")\n(let ((first-seg (first-segment agenda )))\n(set-current-time! agenda\n(segment-time first-seg ))\n(front-queue (segment-queue first-seg )))))\nExercise 3.32: e procedures to be run during each time\nsegment of the agenda are kept in a queue. us, the pro-\ncedures for each segment are called in the order in which\nthey were added to the agenda (ﬁrst in, ﬁrst out). Explain\nwhythisordermustbeused.Inparticular,tracethebehav-\nior of an and-gate whose inputs change from 0, 1 to 1, 0\n29Observe that the ifexpression in this procedure has no ⟨alternative⟩expression. Such a “one-armed ifstatement” is used to decide whether to do something, rather\nthan to select between two expressions.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 705, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1007}}
{"id": "computer_science_sicp_abelson_chunk_0706_773614b3", "text": "Such a “one-armed ifstatement” is used to decide whether to do something, rather\nthan to select between two expressions. An ifexpression returns an unspeciﬁed value\nif the predicate is false and there is no ⟨alternative⟩. 30In this way, the current time will always be the time of the action most recently\nprocessed. Storing this time at the head of the agenda ensures that it will still be avail-\nable even if the associated time segment has been deleted. 385\nin the same segment and say how the behavior would dif-\nfer if we stored a segment’s procedures in an ordinary list,\nadding and removing procedures only at the front (last in,\nﬁrst out). 3.3.5Propagation of Constraints\nComputerprogramsaretraditionallyorganizedasone-directionalcom-\nputations, which perform operations on prespeciﬁed arguments to pro-\nduce desired outputs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 706, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 833}}
{"id": "computer_science_sicp_abelson_chunk_0707_f408d04b", "text": "3.3.5Propagation of Constraints\nComputerprogramsaretraditionallyorganizedasone-directionalcom-\nputations, which perform operations on prespeciﬁed arguments to pro-\nduce desired outputs. On the other hand, we oen model systems in\ntermsofrelationsamongquantities.Forexample,amathematicalmodel\nofamechanicalstructuremightincludetheinformationthatthedeﬂec-\ntiondof a metal rod is related to the force Fon the rod, the length L\nof the rod, the cross-sectional area A, and the elastic modulus Evia the\nequation\ndAE=F L:\nSuch an equation is not one-directional. Given any four of the quanti-\nties, we can use it to compute the ﬁh. Yet translating the equation into\na traditional computer language would force us to choose one of the\nquantities to be computed in terms of the other four.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 707, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 781}}
{"id": "computer_science_sicp_abelson_chunk_0708_9bf60cc4", "text": "Yet translating the equation into\na traditional computer language would force us to choose one of the\nquantities to be computed in terms of the other four. us, a procedure\nfor computing the area Acould not be used to compute the deﬂection\nd, even though the computations of Aanddarise from the same equa-\ntion.31\n31Constraint propagation ﬁrst appeared in the incredibly forward-looking \nsystemofIvan Sutherland(1963) .Abeautifulconstraint-propagationsystembased\non the Smalltalk language was developed by Alan Borning (1977) at Xerox Palo Alto\nResearchCenter.Sussman,Stallman,andSteeleappliedconstraintpropagationtoelec-\ntricalcircuitanalysis( SussmanandStallman1975 ;SussmanandSteele1980 ).TK!Solver\n(Konopasek and Jayaraman 1984 ) is an extensive modeling environment based on\nconstraints. 386\nIn this section, we sketch the design of a language that enables us\nto work in terms of relations themselves.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 708, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_sicp_abelson_chunk_0709_c0d1ebe6", "text": "386\nIn this section, we sketch the design of a language that enables us\nto work in terms of relations themselves. e primitive elements of the\nlanguageare primitive constraints ,whichstatethatcertainrelationshold\nbetweenquantities.Forexample, (adder a b c) speciﬁesthatthequan-\ntities a,b, and cmust be related by the equation a+b=c,(multiplier\nx y z) expresses the constraint xy=z, and (constant 3.14 x) says\nthat the value of xmust be 3.14. Our language provides a means of combining primitive constraints\nin order to express more complex relations. We combine constraints\nby constructing constraint networks , in which constraints are joined by\nconnectors . A connector is an object that “holds” a value that may par-\nticipate in one or more constraints. For example, we know that the re-\nlationship between Fahrenheit and Celsius temperatures is\n9C=5(F\u000032):\nSuchaconstraintcanbethoughtofasanetworkconsistingofprimitive\nadder, multiplier, and constant constraints ( Figure 3.28 ).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 709, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_sicp_abelson_chunk_0710_c3c6e514", "text": "In the ﬁgure,\nwe see on the le a multiplier box with three terminals, labeled m1,\nm2, and p. ese connect the multiplier to the rest of the network as\nfollows:e m1terminalis linkedtoa connector C,whichwill holdthe\nCelsius temperature. e m2 terminal is linked to a connector w, which\nis also linked to a constant box that holds 9. e pterminal, which the\nmultiplier box constrains to be the product of m1 and m2, is linked to\nthepterminal of another multiplier box, whose m2 is connected to a\nconstant 5 and whose m1 is connected to one of the terms in a sum. Computation by such a network proceeds as follows: When a con-\nnector is given a value (by the user or by a constraint box to which\nit is linked), it awakens all of its associated constraints (except for the\nconstraint that just awakened it) to inform them that it has a value. 387\nm1\nm2p* pm1\nm2*uv\n32 5 9a1\na2s+ FC\nw x yFigure 3.28: e relation 9 C=5(F\u000032)expressed as a\nconstraint network.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 710, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_sicp_abelson_chunk_0711_6d45e053", "text": "387\nm1\nm2p* pm1\nm2*uv\n32 5 9a1\na2s+ FC\nw x yFigure 3.28: e relation 9 C=5(F\u000032)expressed as a\nconstraint network. Each awakened constraint box then polls its connectors to see if there\nis enough information to determine a value for a connector. If so, the\nbox sets that connector, which then awakens all of its associated con-\nstraints, and so on. For instance, in conversion between Celsius and\nFahrenheit, w,x, andyare immediately set by the constant boxes to 9,\n5, and 32, respectively. e connectors awaken the multipliers and the\nadder, which determine that there is not enough information to pro-\nceed. If the user (or some other part of the network) sets Cto a value\n(say 25), the lemost multiplier will be awakened, and it will set uto\n25\u00019=225. en uawakens the second multiplier, which sets vto 45,\nandvawakens the adder, which sets fto 77.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 711, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 852}}
{"id": "computer_science_sicp_abelson_chunk_0712_d134527a", "text": "en uawakens the second multiplier, which sets vto 45,\nandvawakens the adder, which sets fto 77. Using the constraint system\nTo use the constraint system to carry out the temperature computation\noutlined above, we ﬁrst create two connectors, CandF, by calling the\nconstructor make-connector , and link Cand Fin an appropriate net-\nwork:\n(define C(make-connector ))\n(define F(make-connector ))\n388\n(celsius-fahrenheit-converter CF)\nok\ne procedure that creates the network is deﬁned as follows:\n(define (celsius-fahrenheit-converter cf)\n(let ((u(make-connector ))\n(v(make-connector ))\n(w(make-connector ))\n(x(make-connector ))\n(y(make-connector )))\n(multiplier cwu)\n(multiplier vxu)\n(adder vyf)\n(constant 9w)\n(constant 5x)\n(constant 32y)\n'ok))\nisprocedurecreatestheinternalconnectors u,v,w,x,and y,andlinks\nthem as shown in Figure 3.28 using the primitive constraint construc-\ntors adder,multiplier , and constant .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 712, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 915}}
{"id": "computer_science_sicp_abelson_chunk_0713_a7dfc392", "text": "Just as with the digital-circuit\nsimulator of Section 3.3.4 , expressing these combinations of primitive\nelements in terms of procedures automatically provides our language\nwith a means of abstraction for compound objects. To watch the network in action, we can place probes on the con-\nnectors CandF, using a probeprocedure similar to the one we used to\nmonitorwiresin Section3.3.4 .Placingaprobeonaconnectorwillcause\na message to be printed whenever the connector is given a value:\n(probe \"Celsius temp \"C)\n(probe \"Fahrenheit temp \"F)\nNext we set the value of Cto 25. (e third argument to set-value! tells Cthat this directive comes from the user.)\n389\n(set-value! C25'user )\nProbe: Celsius temp = 25\nProbe: Fahrenheit temp = 77\ndone\ne probe on Cawakens and reports the value. Calso propagates its\nvalue through the network as described above. is sets Fto 77, which\nis reported by the probe on F. Now we can try to set Fto a new value, say 212:\n(set-value! F212 'user )\nError!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 713, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_sicp_abelson_chunk_0714_d506c3d4", "text": "Calso propagates its\nvalue through the network as described above. is sets Fto 77, which\nis reported by the probe on F. Now we can try to set Fto a new value, say 212:\n(set-value! F212 'user )\nError! Contradiction (77 212)\ne connector complains that it has sensed a contradiction: Its value is\n77, and someone is trying to set it to 212. If we really want to reuse the\nnetwork with new values, we can tell Cto forget its old value:\n(forget-value! C'user )\nProbe: Celsius temp = ? Probe: Fahrenheit temp = ? done\nCﬁnds that the user, who set its value originally, is now retracting that\nvalue, so Cagrees to lose its value, as shown by the probe, and informs\nthe rest of the network of this fact. is information eventually prop-\nagates to F, which now ﬁnds that it has no reason for continuing to\nbelievethatitsownvalueis77.us, Falsogivesupitsvalue,asshown\nby the probe. Now that Fhas no value, we are free to set it to 212:\n(set-value!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 714, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_sicp_abelson_chunk_0715_6edb127f", "text": "Now that Fhas no value, we are free to set it to 212:\n(set-value! F212 'user )\nProbe: Fahrenheit temp = 212\nProbe: Celsius temp = 100\ndone\n390\nisnewvalue,whenpropagatedthroughthenetwork,forces Ctohave\na value of 100, and this is registered by the probe on C. Notice that the\nvery same network is being used to compute Cgiven Fand to compute\nFgiven C. is nondirectionality of computation is the distinguishing\nfeature of constraint-based systems. Implementing the constraint system\ne constraint system is implemented via procedural objects with local\nstate, in a manner very similar to the digital-circuit simulator of Sec-\ntion 3.3.4 . Although the primitive objects of the constraint system are\nsomewhat more complex, the overall system is simpler, since there is\nno concern about agendas and logic delays. e basic operations on connectors are the following:\n•(has-value?⟨connector⟩)tells whether the connector has a\nvalue. •(get-value⟨connector⟩)returnstheconnector’scurrentvalue.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 715, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_sicp_abelson_chunk_0716_f77a1e97", "text": "e basic operations on connectors are the following:\n•(has-value?⟨connector⟩)tells whether the connector has a\nvalue. •(get-value⟨connector⟩)returnstheconnector’scurrentvalue. •(set-value!⟨connector⟩⟨new-value⟩⟨informant⟩)indicates\nthat the informant is requesting the connector to set its value to\nthe new value. •(forget-value! ⟨connector⟩⟨retractor⟩)tells the connector\nthat the retractor is requesting it to forget its value. •(connect⟨connector⟩ ⟨new-constraint⟩)tells the connector\nto participate in the new constraint. e connectors communicate with the constraints bymeans of the pro-\ncedures inform-about-value , which tells the given constraint that the\n391\nconnector has a value, and inform-about-no-value , which tells the\nconstraint that the connector has lost its value.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 716, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 784}}
{"id": "computer_science_sicp_abelson_chunk_0717_2ab7bb15", "text": "adderconstructs an adder constraint among summand connectors\na1anda2anda sumconnector.Anadderisimplementedasaprocedure\nwith local state (the procedure mebelow):\n(define (adder a1a2sum)\n(define (process-new-value )\n(cond ((and (has-value? a1) (has-value? a2))\n(set-value! sum\n(+ ( get-value a1) (get-value a2))\nme))\n((and (has-value? a1) (has-value? sum))\n(set-value! a2\n(- ( get-value sum) (get-value a1))\nme))\n((and (has-value? a2) (has-value? sum))\n(set-value! a1\n(- ( get-value sum) (get-value a2))\nme))))\n(define (process-forget-value )\n(forget-value! sum me)\n(forget-value! a1me)\n(forget-value! a2me)\n(process-new-value ))\n(define (merequest )\n(cond ((eq? request 'I-have-a-value ) ( process-new-value ))\n((eq? request 'I-lost-my-value ) (process-forget-value ))\n(else (error \"Unknown request :ADDER \"request ))))\n(connect a1me)\n(connect a2me)\n(connect sum me)\nme)\n392\nadderconnectsthenewaddertothedesignatedconnectorsandreturns\nit as its value.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 717, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_sicp_abelson_chunk_0718_3e3db69b", "text": "e procedure me, which represents the adder, acts as a\ndispatch to the local procedures. e following “syntax interfaces” (see\nFootnote 27 inSection 3.3.4 ) are used in conjunction with the dispatch:\n(define (inform-about-value constraint )\n(constraint 'I-have-a-value ))\n(define (inform-about-no-value constraint )\n(constraint 'I-lost-my-value ))\neadder’slocalprocedure process-new-value iscalledwhentheadder\nisinformedthatoneofitsconnectorshasavalue.eadderﬁrstchecks\nto see if both a1anda2have values. If so, it tells sumto set its value to\nthesumofthetwoaddends.e informant argumentto set-value! is\nme,whichistheadderobjectitself.If a1anda2donotbothhavevalues,\nthen the adder checks to see if perhaps a1andsumhave values. If so, it\nsetsa2to the diﬀerence of these two. Finally, if a2andsumhave values,\nthis gives the adder enough information to set a1. If the adder is told\nthat one of its connectors has lost a value, it requests that all of its con-\nnectors now lose their values.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 718, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_sicp_abelson_chunk_0719_4cd24a6f", "text": "If the adder is told\nthat one of its connectors has lost a value, it requests that all of its con-\nnectors now lose their values. (Only those values that were set by this\nadder are actually lost.) en it runs process-new-value . e reason\nfor this last step is that one or more connectors may still have a value\n(thatis,aconnectormayhavehadavaluethatwasnotoriginallysetby\nthe adder), and these values may need to be propagated back through\nthe adder. A multiplier is very similar to an adder. It will set its product to 0 if\neither of the factors is 0, even if the other factor is not known. (define (multiplier m1m2product )\n(define (process-new-value )\n(cond ((or(and (has-value? m1) (= ( get-value m1) 0))\n(and (has-value? m2) (= ( get-value m2) 0)))\n393\n(set-value! product 0me))\n((and (has-value? m1) (has-value? m2))\n(set-value! product\n(* ( get-value m1) (get-value m2))\nme))\n((and (has-value? product ) (has-value? m1))\n(set-value! m2\n(/ ( get-value product )\n(get-value m1))\nme))\n((and (has-value?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 719, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_sicp_abelson_chunk_0720_e8b2e6ab", "text": "m1) (has-value? m2))\n(set-value! product\n(* ( get-value m1) (get-value m2))\nme))\n((and (has-value? product ) (has-value? m1))\n(set-value! m2\n(/ ( get-value product )\n(get-value m1))\nme))\n((and (has-value? product ) (has-value? m2))\n(set-value! m1\n(/ ( get-value product )\n(get-value m2))\nme))))\n(define (process-forget-value )\n(forget-value! product me)\n(forget-value! m1me)\n(forget-value! m2me)\n(process-new-value ))\n(define (merequest )\n(cond ((eq? request 'I-have-a-value ) ( process-new-value ))\n((eq? request 'I-lost-my-value ) (process-forget-value ))\n(else (error \"Unknown request :MULTIPLIER \"\nrequest ))))\n(connect m1me)\n(connect m2me)\n(connect product me)\nme)\nAconstant constructor simply sets the value of the designated con-\nnector. Any I-have-a-value orI-lost-my-value message sent to the\nconstant box will produce an error. 394\n(define (constant value connector )\n(define (merequest )\n(error \"Unknown request :CONSTANT \"request ))\n(connect connector me)\n(set-value!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 720, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_sicp_abelson_chunk_0721_f9406da5", "text": "394\n(define (constant value connector )\n(define (merequest )\n(error \"Unknown request :CONSTANT \"request ))\n(connect connector me)\n(set-value! connector value me)\nme)\nFinally, a probe prints a message about the seing or unseing of the\ndesignated connector:\n(define (probe name connector )\n(define (print-probe value )\n(newline ) (display \"Probe :\") (display name )\n(display \"=\") (display value ))\n(define (process-new-value )\n(print-probe (get-value connector )))\n(define (process-forget-value ) (print-probe \"?\"))\n(define (merequest )\n(cond ((eq? request 'I-have-a-value ) ( process-new-value ))\n((eq?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 721, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 603}}
{"id": "computer_science_sicp_abelson_chunk_0722_97814183", "text": "request 'I-have-a-value ) ( process-new-value ))\n((eq? request 'I-lost-my-value ) (process-forget-value ))\n(else (error \"Unknown request :PROBE \"request ))))\n(connect connector me)\nme)\nRepresenting connectors\nA connector is represented as a procedural object with local state vari-\nables value, the current value of the connector; informant , the object\nthatsettheconnector’svalue;and constraints ,alistoftheconstraints\nin which the connector participates. (define (make-connector )\n(let ((value false ) (informant false ) (constraints '()))\n(define (set-my-value newval setter )\n395\n(cond ((not (has-value? me))\n(set! value newval )\n(set! informant setter )\n(for-each-except setter\ninform-about-value\nconstraints ))\n((not (=value newval ))\n(error \"Contradiction \"(list value newval )))\n(else 'ignored )))\n(define (forget-my-value retractor )\n(if(eq? retractor informant )\n(begin (set!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 722, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 885}}
{"id": "computer_science_sicp_abelson_chunk_0723_71253d1d", "text": "retractor informant )\n(begin (set! informant false )\n(for-each-except retractor\ninform-about-no-value\nconstraints ))\n'ignored ))\n(define (connect new-constraint )\n(if(not (memq new-constraint constraints ))\n(set! constraints\n(cons new-constraint constraints )))\n(if(has-value? me)\n(inform-about-value new-constraint ))\n'done )\n(define (merequest )\n(cond ((eq? request 'has-value? )\n(ifinformant true false ))\n((eq? request 'value )value )\n((eq? request 'set-value! )set-my-value )\n((eq? request 'forget )forget-my-value )\n((eq? request 'connect )connect )\n(else (error \"Unknown operation :CONNECTOR \"\nrequest ))))\nme))\n396\ne connector’s local procedure set-my-value is called when there is\na request to set the connector’s value. If the connector does not cur-\nrently have a value, it will set its value and remember as informant\nthe constraint that requested the value to be set.32en the connector\nwill notify all of its participating constraints except the constraint that\nrequested the value to be set.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 723, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1007}}
{"id": "computer_science_sicp_abelson_chunk_0724_5c8116e2", "text": "is is accomplished using the follow-\ning iterator, which applies a designated procedure to all items in a list\nexcept a given one:\n(define (for-each-except exception procedure list )\n(define (loop items )\n(cond ((null? items )'done )\n((eq? (car items )exception ) (loop (cdr items )))\n(else (procedure (car items ))\n(loop (cdr items )))))\n(loop list ))\nIf a connector is asked to forget its value, it runs the local procedure\nforget-my-value , which ﬁrst checks to make sure that the request is\ncomingfromthesameobjectthatsetthevalueoriginally.Ifso,thecon-\nnector informs its associated constraints about the loss of the value. e local procedure connect adds the designated new constraint to\nthelistofconstraintsifitisnotalreadyinthatlist.en,iftheconnector\nhas a value, it informs the new constraint of this fact. e connector’s procedure meserves as a dispatch to the other in-\nternal procedures and also represents the connector as an object.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 724, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_sicp_abelson_chunk_0725_5be7d5d4", "text": "e connector’s procedure meserves as a dispatch to the other in-\nternal procedures and also represents the connector as an object. e\nfollowing procedures provide a syntax interface for the dispatch:\n(define (has-value? connector )\n(connector 'has-value? ))\n32esettermight not be a constraint. In our temperature example, we used user\nas the setter. 397\n(define (get-value connector )\n(connector 'value ))\n(define (set-value! connector new-value informant )\n((connector 'set-value! )new-value informant ))\n(define (forget-value! connector retractor )\n((connector 'forget )retractor ))\n(define (connect connector new-constraint )\n((connector 'connect )new-constraint ))\nExercise 3.33: Using primitive multiplier, adder, and con-\nstant constraints, deﬁne a procedure averager that takes\nthree connectors a,b, and cas inputs and establishes the\nconstraintthatthevalueof cistheaverageofthevaluesof\naandb.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 725, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_sicp_abelson_chunk_0726_bcde9eaa", "text": "Exercise 3.34: Louis Reasoner wants to build a squarer, a\nconstraint device with two terminals such that the value\nof connector bon the second terminal will always be the\nsquare of the value aon the ﬁrst terminal. He proposes the\nfollowing simple device made from a multiplier:\n(define (squarer ab)\n(multiplier aab))\nere is a serious ﬂaw in this idea. Explain. Exercise 3.35: Ben Bitdiddle tells Louis that one way to\navoid the trouble in Exercise 3.34 is to deﬁne a squarer\nas a new primitive constraint. Fill in the missing portions\nin Ben’s outline for a procedure to implement such a con-\nstraint:\n398\n(define (squarer ab)\n(define (process-new-value )\n(if(has-value?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 726, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 671}}
{"id": "computer_science_sicp_abelson_chunk_0727_f8171aec", "text": "Fill in the missing portions\nin Ben’s outline for a procedure to implement such a con-\nstraint:\n398\n(define (squarer ab)\n(define (process-new-value )\n(if(has-value? b)\n(if(< ( get-value b) 0)\n(error \"square less than 0:SQUARER \"\n(get-value b))\n⟨alternative1⟩)\n⟨alternative2⟩))\n(define (process-forget-value )⟨body1⟩)\n(define (merequest )⟨body2⟩)\n⟨rest of definition ⟩\nme)\nExercise3.36: Supposeweevaluatethefollowingsequence\nof expressions in the global environment:\n(define a(make-connector ))\n(define b(make-connector ))\n(set-value! a10'user )\nAtsometimeduringevaluationofthe set-value! ,thefol-\nlowing expression from the connector’s local procedure is\nevaluated:\n(for-each-except\nsetter inform-about-value constraints )\nDraw an environment diagram showing the environment\nin which the above expression is evaluated.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 727, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 818}}
{"id": "computer_science_sicp_abelson_chunk_0728_814a9956", "text": "Exercise 3.37: ecelsius-fahrenheit-converter pro-\ncedureiscumbersomewhencomparedwithamoreexpression-\noriented style of deﬁnition, such as\n399\n(define (celsius-fahrenheit-converter x)\n(c+ (c*(c/(cv9) ( cv5))\nx)\n(cv32)))\n(define C(make-connector ))\n(define F(celsius-fahrenheit-converter C))\nHere c+,c*, etc. are the “constraint” versions of the arith-\nmetic operations. For example, c+takes two connectors as\narguments and returns a connector that is related to these\nby an adder constraint:\n(define (c+xy)\n(let ((z(make-connector )))\n(adder xyz)\nz))\nDeﬁne analogous procedures c-,c*,c/, and cv(constant\nvalue) that enable us to deﬁne compound constraints as in\nthe converter example above.33\n33e expression-oriented format is convenient because it avoids the need to name\nthe intermediate expressions in a computation. Our original formulation of the con-\nstraintlanguageiscumbersomeinthesamewaythatmanylanguagesarecumbersome\nwhen dealing with operations on compound data.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 728, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_sicp_abelson_chunk_0729_0ac3b277", "text": "Our original formulation of the con-\nstraintlanguageiscumbersomeinthesamewaythatmanylanguagesarecumbersome\nwhen dealing with operations on compound data. For example, if we wanted to com-\nputetheproduct (a+b)\u0001(c+d),wherethevariablesrepresentvectors,wecouldworkin\n“imperative style,” using procedures that set the values of designated vector arguments\nbut do not themselves return vectors as values:\n(v-sum a b temp1)\n(v-sum c d temp2)\n(v-prod temp1 temp2 answer)\nAlternatively, we could deal with expressions, using procedures that return vectors as\nvalues, and thus avoid explicitly mentioning temp1andtemp2:\n(define answer (v-prod (v-sum a b) (v-sum c d)))\n400\n3.4Concurrency: Time Is of the Essence\nWe’ve seen the power of computational objects with local state as tools\nfor modeling.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 729, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 787}}
{"id": "computer_science_sicp_abelson_chunk_0730_260db405", "text": "Yet, as Section 3.1.3 warned, this power extracts a price:\nthe loss of referential transparency, giving rise to a thicket of questions\nabout sameness and change, and the need to abandon the substitution\nmodel of evaluation in favor of the more intricate environment model. ecentralissuelurkingbeneaththecomplexityofstate,sameness,\nand change is that by introducing assignment we are forced to admit\ntimeinto our computational models. Before we introduced assignment,\nall our programs were timeless, in the sense that any expression that\nhasavaluealwayshasthesamevalue.Incontrast,recalltheexampleof\nmodeling withdrawals from a bank account and returning the resulting\nbalance, introduced at the beginning of Section 3.1.1 :\n(withdraw 25)\n75\n(withdraw 25)\n50\nSince Lisp allows us to return compound objects as values of procedures, we can trans-\nform our imperative-style constraint language into an expression-oriented style as\nshown in this exercise.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 730, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_sicp_abelson_chunk_0731_e9451cc7", "text": "In languages that are impoverished in handling compound ob-\njects, such as Algol, Basic, and Pascal (unless one explicitly uses Pascal pointer vari-\nables), one is usually stuck with the imperative style when manipulating compound\nobjects. Given the advantage of the expression-oriented format, one might ask if there\nis any reason to have implemented the system in imperative style, as we did in this\nsection. One reason is that the non-expression-oriented constraint language provides\na handle on constraint objects (e.g., the value of the adderprocedure) as well as on\nconnector objects. is is useful if we wish to extend the system with new operations\nthat communicate with constraints directly rather than only indirectly via operations\non connectors. Although it is easy to implement the expression-oriented style in terms\nof the imperative implementation, it is very diﬃcult to do the converse. 401\nHere successive evaluations of the same expression yield diﬀerent val-\nues.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 731, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_sicp_abelson_chunk_0732_b6e02438", "text": "401\nHere successive evaluations of the same expression yield diﬀerent val-\nues. is behavior arises from the fact that the execution of assignment\nstatements(inthiscase,assignmentstothevariable balance )delineates\nmoments in time when values change. e result of evaluating an ex-\npression depends not only on the expression itself, but also on whether\nthe evaluation occurs before or aer these moments. Building models\nin terms of computational objects with local state forces us to confront\ntime as an essential concept in programming. Wecangofurtherinstructuringcomputationalmodelstomatchour\nperception of the physical world. Objects in the world do not change\none at a time in sequence. Rather we perceive them as acting concur-\nrently—all at once. So it is oen natural to model systems as collections\nof computational processes that execute concurrently.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 732, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 861}}
{"id": "computer_science_sicp_abelson_chunk_0733_e31f31b5", "text": "Rather we perceive them as acting concur-\nrently—all at once. So it is oen natural to model systems as collections\nof computational processes that execute concurrently. Just as we can\nmake our programs modular by organizing models in terms of objects\nwith separate local state, it is oen appropriate to divide computational\nmodels into parts that evolve separately and concurrently. Even if the\nprograms are to be executed on a sequential computer, the practice of\nwriting programs as if they were to be executed concurrently forces\nthe programmerto avoidinessential timing constraints and thus makes\nprograms more modular. In addition to making programs more modular, concurrent compu-\ntation can provide a speed advantage over sequential computation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 733, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 754}}
{"id": "computer_science_sicp_abelson_chunk_0734_28d3797a", "text": "In addition to making programs more modular, concurrent compu-\ntation can provide a speed advantage over sequential computation. Se-\nquentialcomputersexecuteonlyoneoperationatatime,sotheamount\nof time it takes to perform a task is proportional to the total number\nof operations performed.34However, if it is possible to decompose a\n34Most real processors actually execute a few operations at a time, following a strat-\negycalled pipelining .Althoughthistechniquegreatlyimprovestheeﬀectiveutilization\nof the hardware, it is used only to speed up the execution of a sequential instruction\nstream, while retaining the behavior of the sequential program. 402\nproblem into pieces that are relatively independent and need to com-\nmunicate only rarely, it may be possible to allocate pieces to separate\ncomputingprocessors,producingaspeedadvantageproportionaltothe\nnumber of processors available.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 734, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 889}}
{"id": "computer_science_sicp_abelson_chunk_0735_27c333c6", "text": "Unfortunately, the complexities introduced by assignment become\neven more problematic in the presence of concurrency. e fact of con-\ncurrent execution, either because the world operates in parallel or be-\ncause our computers do, entails additional complexity in our under-\nstanding of time. 3.4.1The Nature of Time in Concurrent Systems\nOn the surface, time seems straightforward. It is an ordering imposed\non events.35For any events AandB, either Aoccurs before B,Aand\nBare simultaneous, or Aoccurs aer B. For instance, returning to the\nbankaccountexample,supposethatPeterwithdraws$10andPaulwith-\ndraws $25 from a joint account that initially contains $100, leaving $65\nin the account. Depending on the order of the two withdrawals, the\nsequence of balances in the account is either $100 !$90!$65 or\n$100!$75!$65. In a computer implementation of the banking sys-\ntem,thischangingsequenceofbalancescouldbemodeledbysuccessive\nassignments to a variable balance .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 735, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_sicp_abelson_chunk_0736_9f7aff42", "text": "In a computer implementation of the banking sys-\ntem,thischangingsequenceofbalancescouldbemodeledbysuccessive\nassignments to a variable balance . In complex situations, however, such a view can be problematic. SupposethatPeterandPaul,andotherpeoplebesides,areaccessingthe\nsamebankaccountthroughanetworkofbankingmachinesdistributed\nall over the world. e actual sequence of balances in the account will\ndepend critically on the detailed timing of the accesses and the details\nof the communication among the machines.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 736, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 515}}
{"id": "computer_science_sicp_abelson_chunk_0737_62c632bd", "text": "e actual sequence of balances in the account will\ndepend critically on the detailed timing of the accesses and the details\nof the communication among the machines. 35To quote some graﬃti seen on a Cambridge building wall: “Time is a device that\nwas invented to keep everything from happening at once.”\n403\nis indeterminacy in the order of events can pose serious prob-\nlemsinthedesignofconcurrentsystems.Forinstance,supposethatthe\nwithdrawals made by Peter and Paul are implemented as two separate\nprocesses sharing a common variable balance , each process speciﬁed\nby the procedure given in Section 3.1.1 :\n(define (withdraw amount )\n(if(>= balance amount )\n(begin\n(set! balance (-balance amount ))\nbalance )\n\"Insufficient funds \"))\nIf the two processes operate independently, then Peter might test the\nbalance and aempt to withdraw a legitimate amount.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 737, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 857}}
{"id": "computer_science_sicp_abelson_chunk_0738_97e7cdaf", "text": "balance (-balance amount ))\nbalance )\n\"Insufficient funds \"))\nIf the two processes operate independently, then Peter might test the\nbalance and aempt to withdraw a legitimate amount. However, Paul\nmight withdraw some funds in between the time that Peter checks the\nbalance and the time Peter completes the withdrawal, thus invalidating\nPeter’s test. ings can be worse still. Consider the expression\n(set! balance (-balance amount ))\nexecutedaspartofeachwithdrawalprocess.isconsistsofthreesteps:\n(1) accessing the value of the balance variable; (2) computing the new\nbalance; (3) seing balance to this new value. If Peter and Paul’s with-\ndrawals execute this statement concurrently, then the two withdrawals\nmight interleave the order in which they access balance and set it to\nthe new value.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 738, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 796}}
{"id": "computer_science_sicp_abelson_chunk_0739_641c2e67", "text": "If Peter and Paul’s with-\ndrawals execute this statement concurrently, then the two withdrawals\nmight interleave the order in which they access balance and set it to\nthe new value. e timing diagram in Figure 3.29 depicts an order of events where\nbalance starts at 100, Peter withdraws 10, Paul withdraws 25, and yet\ntheﬁnalvalueof balance is75.Asshowninthediagram,thereasonfor\nthis anomaly is that Paul’s assignment of 75 to balance is made under\ntheassumptionthatthevalueof balance tobedecrementedis100.at\n404\nPeter\nAccess balance: $100\nnew value: 100 –10 = 90\nset! balance to $90\ntimeBank Paul\n$100\n$90\n$75Access balance: $100\nnew value: 100 – 25 =75\nset! balance to $75Figure 3.29: Timing diagram showing how interleaving\nthe order of events in two banking withdrawals can lead\nto an incorrect ﬁnal balance. 405\nassumption, however, became invalid when Peter changed balance to\n90.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 739, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_sicp_abelson_chunk_0740_d7a6cae0", "text": "405\nassumption, however, became invalid when Peter changed balance to\n90. is is a catastrophic failure for the banking system, because the\ntotalamountofmoneyinthesystemisnotconserved.Beforethetrans-\nactions,thetotalamountofmoneywas$100.Aerwards,Peterhas$10,\nPaul has $25, and the bank has $75.36\ne general phenomenon illustrated here is that several processes\nmayshareacommonstatevariable.Whatmakesthiscomplicatedisthat\nmore than one process may be trying to manipulate the shared state at\nthe same time. For the bank account example, during each transaction,\neach customer should be able to act as if the other customers did not\nexist. When a customer changes the balance in a way that depends on\nthe balance, he must be able to assume that, just before the moment of\nchange, the balance is still what he thought it was. Correct behavior of concurrent programs\ne above example typiﬁes the subtle bugs that can creep into concur-\nrent programs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 740, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_sicp_abelson_chunk_0741_49ebdcb4", "text": "Correct behavior of concurrent programs\ne above example typiﬁes the subtle bugs that can creep into concur-\nrent programs. e root of this complexity lies in the assignments to\nvariables that are shared among the diﬀerent processes. We already\nknow that we must be careful in writing programs that use set!, be-\ncause the results of a computation depend on the order in which the\n36An even worse failure for this system could occur if the two set!operations at-\ntempt to change the balance simultaneously, in which case the actual data appearing\nin memory might end up being a random combination of the information being writ-\nten by the two processes. Most computers have interlocks on the primitive memory-\nwrite operations, which protect against such simultaneous access.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 741, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 775}}
{"id": "computer_science_sicp_abelson_chunk_0742_896d53f9", "text": "Most computers have interlocks on the primitive memory-\nwrite operations, which protect against such simultaneous access. Even this seemingly\nsimple kind of protection, however, raises implementation challenges in the design of\nmultiprocessing computers, where elaborate cache-coherence protocols are required to\nensurethatthevariousprocessorswillmaintainaconsistentviewofmemorycontents,\ndespite the fact that data may be replicated (“cached”) among the diﬀerent processors\nto increase the speed of memory access. 406\nassignments occur.37With concurrent processes we must be especially\ncareful about assignments, because we may not be able to control the\norderoftheassignmentsmadebythediﬀerentprocesses.Ifseveralsuch\nchanges might be made concurrently (as with two depositors accessing\na joint account) we need some way to ensure that our system behaves\ncorrectly. For example, in the case of withdrawals from a joint bank ac-\ncount, we must ensure that money is conserved.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 742, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_sicp_abelson_chunk_0743_43850b21", "text": "For example, in the case of withdrawals from a joint bank ac-\ncount, we must ensure that money is conserved. To make concurrent\nprograms behave correctly, we may have to place some restrictions on\nconcurrent execution. Onepossiblerestrictiononconcurrencywouldstipulatethatnotwo\noperationsthatchangeanysharedstatevariablescanoccuratthesame\ntime. is is an extremely stringent requirement. For distributed bank-\ning, it would require the system designer to ensure that only one trans-\nactioncouldproceedatatime.iswouldbebothineﬃcientandoverly\nconservative. Figure 3.30 shows Peter and Paul sharing a bank account,\nwhere Paul has a private account as well.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 743, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 654}}
{"id": "computer_science_sicp_abelson_chunk_0744_c4955928", "text": "Figure 3.30 shows Peter and Paul sharing a bank account,\nwhere Paul has a private account as well. e diagram illustrates two\nwithdrawals from the shared account (one by Peter and one by Paul)\nand a deposit to Paul’s private account.38e two withdrawals from\nthe shared account must not be concurrent (since both access and up-\ndate the same account), and Paul’s deposit and withdrawal must not be\nconcurrent (since both access and update the amount in Paul’s wallet). But there should be no problem permiing Paul’s deposit to his pri-\nvate account to proceed concurrently with Peter’s withdrawal from the\nshared account. Alessstringentrestrictiononconcurrencywouldensurethatacon-\n37efactorialprogramin Section3.1.3 illustratesthisforasinglesequentialprocess. 38e columns show the contents of Peter’s wallet, the joint account (in Bank1),\nPaul’s wallet, and Paul’s private account (in Bank2), before and aer each withdrawal\n(W) and deposit (D).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 744, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_sicp_abelson_chunk_0745_45747855", "text": "38e columns show the contents of Peter’s wallet, the joint account (in Bank1),\nPaul’s wallet, and Paul’s private account (in Bank2), before and aer each withdrawal\n(W) and deposit (D). Peter withdraws $10 from Bank1; Paul deposits $5 in Bank2, then\nwithdraws $25 from Bank1. 407\n$100 $7 $5 $300\n$0 $305\n$305 $25 $65 $17$17 $90W\nWD\ntimePeter Bank1 Paul Bank2Figure 3.30: Concurrent deposits and withdrawals from a\njoint account in Bank1 and a private account in Bank2. current system produces the same result as if the processes had run\nsequentially in some order. ere are two important aspects to this re-\nquirement. First, it does not require the processes to actually run se-\nquentially, but only to produce results that are the same as ifthey had\nrun sequentially.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 745, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 770}}
{"id": "computer_science_sicp_abelson_chunk_0746_50e4aa84", "text": "First, it does not require the processes to actually run se-\nquentially, but only to produce results that are the same as ifthey had\nrun sequentially. For the example in Figure 3.30 , the designer of the\nbank account system can safely allow Paul’s deposit and Peter’s with-\ndrawal to happen concurrently, because the net result will be the same\nas if the two operations had happened sequentially. Second, there may\nbe more than one possible “correct” result produced by a concurrent\nprogram, because we require only that the result be the same as for\n408\nsomesequential order. For example, suppose that Peter and Paul’s joint\naccount starts out with $100, and Peter deposits $40 while Paul concur-\nrently withdraws half the money in the account. en sequential exe-\ncution could result in the account balance being either $70 or $90 (see\nExercise 3.38 ).39\nere are still weaker requirements for correct execution of con-\ncurrent programs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 746, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_sicp_abelson_chunk_0747_bb7404e9", "text": "en sequential exe-\ncution could result in the account balance being either $70 or $90 (see\nExercise 3.38 ).39\nere are still weaker requirements for correct execution of con-\ncurrent programs. A program for simulating diﬀusion (say, the ﬂow of\nheat in an object) might consist of a large number of processes, each\none representing a small volume of space, that update their values con-\ncurrently. Each process repeatedly changes its value to the average of\nitsownvalueanditsneighbors’values.isalgorithmconvergestothe\nrightanswerindependentoftheorderinwhichtheoperationsaredone;\nthereisnoneedforanyrestrictionsonconcurrentuseofthesharedval-\nues. Exercise 3.38: Suppose that Peter, Paul, and Mary share\na joint bank account that initially contains $100. Concur-\nrently, Peter deposits $10, Paul withdraws $20, and Mary\nwithdraws half the money in the account, by executing the\nfollowing commands:\nPeter : (set! balance (+balance 10))\nPaul : ( set! balance (-balance 20))\nMary : ( set!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 747, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_sicp_abelson_chunk_0748_6dae47ea", "text": "balance (+balance 10))\nPaul : ( set! balance (-balance 20))\nMary : ( set! balance (-balance (/balance 2)))\na.List all the diﬀerent possible values for balance aer\nthesethreetransactionshavebeencompleted,assum-\n39A more formal way to express this idea is to say that concurrent programs are\ninherently nondeterministic . at is, they are described not by single-valued functions,\nbut by functions whose results are sets of possible values. In Section 4.3 we will study\na language for expressing nondeterministic computations. 409\ningthatthebankingsystemforcesthethreeprocesses\nto run sequentially in some order. b.What are some other values that could be produced\nif the system allows the processes to be interleaved? Draw timing diagrams like the one in Figure 3.29 to\nexplain how these values can occur.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 748, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 805}}
{"id": "computer_science_sicp_abelson_chunk_0749_d4f484a1", "text": "b.What are some other values that could be produced\nif the system allows the processes to be interleaved? Draw timing diagrams like the one in Figure 3.29 to\nexplain how these values can occur. 3.4.2Mechanisms for Controlling Concurrency\nWe’ve seen that the diﬃculty in dealing with concurrent processes is\nrooted in the need to consider the interleaving of the order of events in\nthe diﬀerent processes. For example, suppose we have two processes,\nonewiththreeorderedevents (a;b;c)andonewiththreeorderedevents\n(x;y;z).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 749, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 519}}
{"id": "computer_science_sicp_abelson_chunk_0750_de9f5f51", "text": "For example, suppose we have two processes,\nonewiththreeorderedevents (a;b;c)andonewiththreeorderedevents\n(x;y;z). If the two processes run concurrently, with no constraints on\nhow their execution is interleaved, then there are 20 diﬀerent possible\norderings for the events that are consistent with the individual order-\nings for the two processes:\n(a,b,c,x,y,z) (a,x,b,y,c,z) (x,a,b,c,y,z) (x,a,y,z,b,c)\n(a,b,x,c,y,z) (a,x,b,y,z,c) (x,a,b,y,c,z) (x,y,a,b,c,z)\n(a,b,x,y,c,z) (a,x,y,b,c,z) (x,a,b,y,z,c) (x,y,a,b,z,c)\n(a,b,x,y,z,c) (a,x,y,b,z,c) (x,a,y,b,c,z) (x,y,a,z,b,c)\n(a,x,b,c,y,z) (a,x,y,z,b,c) (x,a,y,b,z,c) (x,y,z,a,b,c)\nAs programmers designing this system, we would have to consider the\neﬀects of each of these 20 orderings and check that each behavior is\nacceptable.Suchanapproachrapidlybecomesunwieldyasthenumbers\nof processes and events increase.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 750, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 859}}
{"id": "computer_science_sicp_abelson_chunk_0751_f4ebe5e2", "text": "Amorepractical approach to the design of concurrentsystems is to\ndevisegeneralmechanismsthatallowustoconstraintheinterleavingof\nconcurrent processes so that we can be sure that the program behavior\n410\nis correct. Many mechanisms have been developed for this purpose. In\nthis section, we describe one of them, the serializer . Serializing access to shared state\nSerializationimplementsthefollowingidea:Processeswillexecutecon-\ncurrently,buttherewillbecertaincollectionsofproceduresthatcannot\nbe executed concurrently. More precisely, serialization creates distin-\nguished sets of procedures such that only one execution of a procedure\nineachserializedsetispermiedtohappenatatime.Ifsomeprocedure\nin the set is being executed, then a process that aempts to execute any\nprocedure in the set will be forced to wait until the ﬁrst execution has\nﬁnished. We can use serialization to control access to shared variables.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 751, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_sicp_abelson_chunk_0752_192ceb1e", "text": "We can use serialization to control access to shared variables. For\nexample, if we want to update a shared variable based on the previ-\nous value of that variable, we put the access to the previous value of\nthe variable and the assignment of the new value to the variable in the\nsame procedure. We then ensure that no other procedure that assigns\nto the variable can run concurrently with this procedure by serializing\nall of these procedures with the same serializer. is guarantees that\nthe value of the variable cannot be changed between an access and the\ncorresponding assignment. Serializers in Scheme\nTo make the above mechanism more concrete, suppose that we have\nextended Scheme to include a procedure called parallel-execute :\n(parallel-execute ⟨p1⟩⟨p2⟩: : :⟨pk⟩)\nEach⟨p⟩must be a procedure of no arguments. parallel-execute cre-\natesaseparateprocessforeach ⟨p⟩,whichapplies⟨p⟩(tonoarguments).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 752, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_sicp_abelson_chunk_0753_dc846dd0", "text": "parallel-execute cre-\natesaseparateprocessforeach ⟨p⟩,whichapplies⟨p⟩(tonoarguments). 411\nese processes all run concurrently.40\nAs an example of how this is used, consider\n(define x10)\n(parallel-execute\n(lambda () ( set! x(*xx)))\n(lambda () ( set! x(+x1))))\nis creates two concurrent processes— P1, which sets xtoxtimes x,\nandP2, which increments x. Aer execution is complete, xwill be le\nwith one of ﬁve possible values, depending on the interleaving of the\nevents of P1andP2:\n101: P1setsxto 100 and then P2increments xto 101. 121: P2increments xto 11 and then P1setsxtox * x. 110: P2changes xfrom 10 to 11 between the two times that\nP1accesses the value of xduring the evaluation of (* x x) . 11:P2accesses x, then P1setsxto 100, then P2setsx. 100: P1accesses x(twice), then P2setsxto 11, then P1setsx. Wecanconstraintheconcurrencybyusingserializedprocedures,which\narecreatedby serializers .Serializersareconstructedby make-serializer ,\nwhose implementation is given below.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 753, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_sicp_abelson_chunk_0754_266812d0", "text": "Wecanconstraintheconcurrencybyusingserializedprocedures,which\narecreatedby serializers .Serializersareconstructedby make-serializer ,\nwhose implementation is given below. A serializer takes a procedure as\nargumentandreturnsaserializedprocedurethatbehavesliketheorigi-\nnalprocedure.Allcallstoagivenserializerreturnserializedprocedures\nin the same set. us, in contrast to the example above, executing\n(define x10)\n40parallel-execute is not part of standard Scheme, but it can be implemented in\nScheme. In our implementation, the new concurrent processes also run concur-\nrently with the original Scheme process. Also, in our implementation, the value re-\nturned by parallel-execute is a special control object that can be used to halt the\nnewly created processes. 412\n(define s(make-serializer ))\n(parallel-execute\n(s(lambda () ( set! x(*xx))))\n(s(lambda () ( set! x(+x1)))))\ncan produce only two possible values for x, 101 or 121.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 754, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_sicp_abelson_chunk_0755_623fe770", "text": "412\n(define s(make-serializer ))\n(parallel-execute\n(s(lambda () ( set! x(*xx))))\n(s(lambda () ( set! x(+x1)))))\ncan produce only two possible values for x, 101 or 121. e other pos-\nsibilities are eliminated, because the execution of P1andP2cannot be\ninterleaved. Hereisaversionofthe make-account procedurefrom Section3.1.1 ,\nwhere the deposits and withdrawals have been serialized:\n(define (make-account balance )\n(define (withdraw amount )\n(if(>= balance amount )\n(begin (set! balance (-balance amount ))\nbalance )\n\"Insufficient funds \"))\n(define (deposit amount )\n(set! balance (+balance amount ))\nbalance )\n(let ((protected (make-serializer )))\n(define (dispatch m)\n(cond ((eq? m'withdraw ) (protected withdraw ))\n((eq? m'deposit ) (protected deposit ))\n((eq? m'balance )balance )\n(else (error \"Unknown request :MAKE-ACCOUNT \"\nm))))\ndispatch ))\nWith this implementation, two processes cannot be withdrawing from\nor depositing into a single account concurrently.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 755, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_sicp_abelson_chunk_0756_06f0d347", "text": "is eliminates the\nsource of the error illustrated in Figure 3.29 , where Peter changes the\naccount balance between the times when Paul accesses the balance to\ncompute the new value and when Paul actually performs the assign-\n413\nment. On the other hand, each account has its own serializer, so that\ndeposits and withdrawals for diﬀerent accounts can proceed concur-\nrently. Exercise 3.39: Which of the ﬁve possibilities in the par-\nallel execution shown above remain if we instead serialize\nexecution as follows:\n(define x10)\n(define s(make-serializer ))\n(parallel-execute\n(lambda () ( set! x((s(lambda () (* xx))))))\n(s(lambda () ( set! x(+x1)))))\nExercise 3.40: Give all possible values of xthat can result\nfrom executing\n(define x10)\n(parallel-execute (lambda () ( set! x(*xx)))\n(lambda () ( set! x(*xxx))))\nWhich of these possibilities remain if we instead use seri-\nalized procedures:\n(define x10)\n(define s(make-serializer ))\n(parallel-execute (s(lambda () ( set! x(*xx))))\n(s(lambda () ( set!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 756, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1000}}
{"id": "computer_science_sicp_abelson_chunk_0757_5a96fb1e", "text": "x(*xxx))))\nWhich of these possibilities remain if we instead use seri-\nalized procedures:\n(define x10)\n(define s(make-serializer ))\n(parallel-execute (s(lambda () ( set! x(*xx))))\n(s(lambda () ( set! x(*xxx)))))\nExercise 3.41: Ben Bitdiddle worries that it would be bet-\nter to implement the bank account as follows (where the\ncommented line has been changed):\n414\n(define (make-account balance )\n(define (withdraw amount )\n(if(>= balance amount )\n(begin (set! balance\n(-balance amount ))\nbalance )\n\"Insufficient funds \"))\n(define (deposit amount )\n(set! balance (+balance amount ))\nbalance )\n(let ((protected (make-serializer )))\n(define (dispatch m)\n(cond ((eq? m'withdraw ) (protected withdraw ))\n((eq? m'deposit ) (protected deposit ))\n((eq? m'balance )\n((protected\n(lambda ()balance )))); serialized\n(else\n(error \"Unknown request :MAKE-ACCOUNT \"\nm))))\ndispatch ))\nbecause allowing unserialized access to the bank balance\ncan result in anomalous behavior. Do you agree?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 757, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_sicp_abelson_chunk_0758_3708c6c8", "text": "Do you agree? Is there\nany scenario that demonstrates Ben’s concern? Exercise 3.42: Ben Bitdiddle suggests that it’s a waste of\ntime to create a new serialized procedure in response to\nevery withdraw anddeposit message. He says that make-\naccount could be changed so that the calls to protected\nare done outside the dispatch procedure. at is, an ac-\ncount would return the same serialized procedure (which\n415\nwas created at the same time as the account) each time it is\nasked for a withdrawal procedure. (define (make-account balance )\n(define (withdraw amount )\n(if(>= balance amount )\n(begin (set! balance (-balance amount ))\nbalance )\n\"Insufficient funds \"))\n(define (deposit amount )\n(set! balance (+balance amount ))\nbalance )\n(let ((protected (make-serializer )))\n(let ((protected-withdraw (protected withdraw ))\n(protected-deposit (protected deposit )))\n(define (dispatch m)\n(cond ((eq? m'withdraw )protected-withdraw )\n((eq? m'deposit )protected-deposit )\n((eq?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 758, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_sicp_abelson_chunk_0759_9fa95a7d", "text": "m'withdraw )protected-withdraw )\n((eq? m'deposit )protected-deposit )\n((eq? m'balance )balance )\n(else\n(error \"Unknown request :MAKE-ACCOUNT \"\nm))))\ndispatch )))\nIsthisasafechangetomake?Inparticular,isthereanydif-\nference in what concurrency is allowed by these two ver-\nsions of make-account ? Complexity of using multiple shared resources\nSerializers provide a powerful abstraction that helps isolate the com-\nplexitiesofconcurrentprogramssothattheycanbedealtwithcarefully\nand (hopefully) correctly. However, while using serializers is relatively\n416\nstraightforward when there is only a single shared resource (such as\na single bank account), concurrent programming can be treacherously\ndiﬃcult when there are multiple shared resources. Toillustrateoneofthediﬃcultiesthatcanarise,supposewewishto\nswapthebalancesintwobankaccounts.Weaccesseachaccounttoﬁnd\nthe balance, compute the diﬀerence between the balances, withdraw\nthis diﬀerence from one account, and deposit it in the other account.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 759, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_sicp_abelson_chunk_0760_4a35363d", "text": "We could implement this as follows:41\n(define (exchange account1 account2 )\n(let ((difference (- ( account1 'balance )\n(account2 'balance ))))\n((account1 'withdraw )difference )\n((account2 'deposit )difference )))\nis procedure works well when only a single process is trying to do\nthe exchange. Suppose, however, that Peter and Paul both have access\nto accounts a1,a2, and a3, and that Peter exchanges a1 and a2 while\nPaulconcurrentlyexchanges a1and a3.Evenwithaccountdepositsand\nwithdrawals serialized for individual accounts (as in the make-account\nprocedure shown above in this section), exchange can still produce in-\ncorrect results. For example, Peter might compute the diﬀerence in the\nbalances for a1 and a2, but then Paul might change the balance in a1\nbefore Peter is able to complete the exchange.42For correct behavior,\nwemustarrangeforthe exchange proceduretolockoutanyothercon-\ncurrentaccessestotheaccountsduringtheentiretimeoftheexchange.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 760, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_sicp_abelson_chunk_0761_74b50928", "text": "41We have simpliﬁed exchange by exploiting the fact that our deposit message ac-\ncepts negative amounts. (is is a serious bug in our banking system!)\n42If the account balances start out as $10, $20, and $30, then aer any number of\nconcurrent exchanges, the balances should still be $10, $20, and $30 in some order. Serializing the deposits to individual accounts is not suﬃcient to guarantee this. See\nExercise 3.43 . 417\nOne way we can accomplish this is by using both accounts’ seri-\nalizers to serialize the entire exchange procedure. To do this, we will\narrange for access to an account’s serializer. Note that we are deliber-\nately breaking the modularity of the bank-account object by exposing\nthe serializer.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 761, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 717}}
{"id": "computer_science_sicp_abelson_chunk_0762_28cfd1b6", "text": "To do this, we will\narrange for access to an account’s serializer. Note that we are deliber-\nately breaking the modularity of the bank-account object by exposing\nthe serializer. e following version of make-account is identical to the\noriginal version given in Section 3.1.1 , except that a serializer is pro-\nvided to protect the balance variable, and the serializer is exported via\nmessage passing:\n(define (make-account-and-serializer balance )\n(define (withdraw amount )\n(if(>= balance amount )\n(begin (set! balance (-balance amount ))\nbalance )\n\"Insufficient funds \"))\n(define (deposit amount )\n(set! balance (+balance amount ))\nbalance )\n(let ((balance-serializer (make-serializer )))\n(define (dispatch m)\n(cond ((eq? m'withdraw )withdraw )\n((eq? m'deposit )deposit )\n((eq? m'balance )balance )\n((eq? m'serializer )balance-serializer )\n(else (error \"Unknown request :MAKE-ACCOUNT \"m))))\ndispatch ))\nWe can use this to do serialized deposits and withdrawals.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 762, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_sicp_abelson_chunk_0763_1ae3e21c", "text": "m'balance )balance )\n((eq? m'serializer )balance-serializer )\n(else (error \"Unknown request :MAKE-ACCOUNT \"m))))\ndispatch ))\nWe can use this to do serialized deposits and withdrawals. However,\nunlikeourearlierserializedaccount,itisnowtheresponsibilityofeach\nuser of bank-account objects to explicitly manage the serialization, for\nexample as follows:43\n43Exercise 3.45 investigates why deposits and withdrawals are no longer automati-\ncally serialized by the account. 418\n(define (deposit account amount )\n(let ((s(account 'serializer ))\n(d(account 'deposit )))\n((sd)amount )))\nExportingtheserializerinthiswaygivesusenoughﬂexibilitytoimple-\nment a serialized exchange program.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 763, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 676}}
{"id": "computer_science_sicp_abelson_chunk_0764_4d29dea0", "text": "We simply serialize the original\nexchange procedure with the serializers for both accounts:\n(define (serialized-exchange account1 account2 )\n(let ((serializer1 (account1 'serializer ))\n(serializer2 (account2 'serializer )))\n((serializer1 (serializer2 exchange ))\naccount1\naccount2 )))\nExercise3.43: Suppose that the balances in three accounts\nstart out as $10, $20, and $30, and that multiple processes\nrun, exchanging the balances in the accounts. Argue that if\ntheprocessesarerunsequentially,aeranynumberofcon-\ncurrentexchanges,theaccountbalancesshouldbe$10,$20,\nand $30 in some order. Draw a timing diagram like the one\ninFigure 3.29 to show how this condition can be violated\nif the exchanges are implemented using the ﬁrst version of\ntheaccount-exchangeprograminthissection.Ontheother\nhand,arguethatevenwiththis exchange program,thesum\nof the balances in the accounts will be preserved.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 764, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_sicp_abelson_chunk_0765_df6e6df0", "text": "Draw a\ntiming diagram to show how even this condition would be\nviolated if we did not serialize the transactions on individ-\nual accounts. Exercise3.44: Considertheproblemoftransferringanamount\nfrom one account to another. Ben Bitdiddle claims that this\n419\ncan be accomplished with the following procedure, even if\nthere are multiple people concurrently transferring money\namong multiple accounts, using any account mechanism\nthat serializes deposit and withdrawal transactions, for ex-\nample, the version of make-account in the text above. (define (transfer from-account to-account amount )\n((from-account 'withdraw )amount )\n((to-account 'deposit )amount ))\nLouis Reasoner claims that there is a problem here, and\nthat we need to use a more sophisticated method, such as\nthe one required for dealing with the exchange problem. Is\nLouis right?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 765, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 845}}
{"id": "computer_science_sicp_abelson_chunk_0766_eea7c05a", "text": "Is\nLouis right? If not, what is the essential diﬀerence between\nthetransferproblemandtheexchangeproblem?(Youshould\nassumethatthebalancein from-account isatleast amount.)\nExercise3.45: LouisReasonerthinksourbank-accountsys-\ntemisunnecessarilycomplexanderror-pronenowthatde-\nposits and withdrawals aren’t automatically serialized. He\nsuggests that make-account-and-serializer should have\nexportedtheserializer(forusebysuchproceduresas serialized-\nexchange ) in addition to (rather than instead o) using it\nto serialize accounts and deposits as make-account did. He\nproposes to redeﬁne accounts as follows:\n(define (make-account-and-serializer balance )\n(define (withdraw amount )\n(if(>= balance amount )\n(begin (set! balance (-balance amount ))balance )\n\"Insufficient funds \"))\n(define (deposit amount )\n(set! balance (+balance amount ))balance )\n420\n(let ((balance-serializer (make-serializer )))\n(define (dispatch m)\n(cond ((eq? m'withdraw ) (balance-serializer withdraw ))\n((eq?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 766, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_sicp_abelson_chunk_0767_b6a63448", "text": "balance (+balance amount ))balance )\n420\n(let ((balance-serializer (make-serializer )))\n(define (dispatch m)\n(cond ((eq? m'withdraw ) (balance-serializer withdraw ))\n((eq? m'deposit ) (balance-serializer deposit ))\n((eq? m'balance )balance )\n((eq? m'serializer )balance-serializer )\n(else (error \"Unknown request :MAKE-ACCOUNT \"m))))\ndispatch ))\nendepositsarehandledaswiththeoriginal make-account :\n(define (deposit account amount )\n((account 'deposit )amount ))\nExplain what is wrong with Louis’s reasoning. In particu-\nlar, consider what happens when serialized-exchange is\ncalled. Implementing serializers\nWe implement serializers in terms of a more primitive synchroniza-\ntion mechanism called a mutex. A mutex is an object that supports two\noperations—the mutex can be acquired , and the mutex can be released.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 767, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 816}}
{"id": "computer_science_sicp_abelson_chunk_0768_81362b93", "text": "A mutex is an object that supports two\noperations—the mutex can be acquired , and the mutex can be released. Once a mutex has been acquired, no other acquire operations on that\nmutex may proceed until the mutex is released.44In our implementa-\n44e term “mutex” is an abbreviation for mutual exclusion . e general problem of\narranging a mechanism that permits concurrent processes to safely share resources is\ncalled the mutual exclusion problem. Our mutex is a simple variant of the semaphore\nmechanism (see Exercise3.47 ), which was introduced in the “THE” Multiprogramming\nSystem developed at the Technological University of Eindhoven and named for the\nuniversity’s initials in Dutch ( Dijkstra 1968a ). e acquire and release operations were\noriginally called P and V, from the Dutch words passeren (to pass) and vrijgeven (to\nrelease), in reference to the semaphores used on railroad systems.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 768, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 898}}
{"id": "computer_science_sicp_abelson_chunk_0769_91b31e1b", "text": "e acquire and release operations were\noriginally called P and V, from the Dutch words passeren (to pass) and vrijgeven (to\nrelease), in reference to the semaphores used on railroad systems. Dijkstra’s classic\nexposition ( Dijkstra 1968b ) was one of the ﬁrst to clearly present the issues of concur-\n421\ntion, each serializer has an associated mutex. Given a procedure p, the\nserializer returns a procedure that acquires the mutex, runs p, and then\nreleases the mutex. is ensures that only one of the procedures pro-\nduced by the serializer can be running at once, which is precisely the\nserialization property that we need to guarantee. (define (make-serializer )\n(let ((mutex (make-mutex )))\n(lambda (p)\n(define (serialized-p .args )\n(mutex 'acquire )\n(let ((val (apply pargs )))\n(mutex 'release )\nval))\nserialized-p )))\ne mutex is a mutable object (here we’ll use a one-element list, which\nwe’ll refer to as a cell) that can hold the value true or false.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 769, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_sicp_abelson_chunk_0770_101cec6b", "text": "When the\nvalue is false, the mutex is available to be acquired. When the value is\ntrue, the mutex is unavailable, and any process that aempts to acquire\nthe mutex must wait. Our mutex constructor make-mutex begins by initializing the cell\ncontents to false. To acquire the mutex, we test the cell. If the mutex\nis available, we set the cell contents to true and proceed. Otherwise,\nwe wait in a loop, aempting to acquire over and over again, until we\nﬁnd that the mutex is available.45To release the mutex, we set the cell\nrency control, and showed how to use semaphores to handle a variety of concurrency\nproblems. 45In most time-shared operating systems, processes that are blocked by a mutex do\nnot waste time “busy-waiting” as above. Instead, the system schedules another process\nto run while the ﬁrst is waiting, and the blocked process is awakened when the mutex\nbecomes available. 422\ncontents to false. (define (make-mutex )\n(let ((cell (list false )))\n(define (the-mutex m)\n(cond ((eq?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 770, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_sicp_abelson_chunk_0771_be668e29", "text": "422\ncontents to false. (define (make-mutex )\n(let ((cell (list false )))\n(define (the-mutex m)\n(cond ((eq? m'acquire )\n(if(test-and-set! cell )\n(the-mutex 'acquire ))); retry\n((eq? m'release ) (clear! cell ))))\nthe-mutex ))\n(define (clear! cell ) (set-car! cell false ))\ntest-and-set! tests the cell and returns the result of the test. In addi-\ntion, if the test was false, test-and-set! sets the cell contents to true\nbefore returning false. We can express this behavior as the following\nprocedure:\n(define (test-and-set! cell )\n(if(car cell )true (begin (set-car! cell true )false )))\nHowever, this implementation of test-and-set! does not suﬃce as\nit stands. ere is a crucial subtlety here, which is the essential place\nwhere concurrency control enters the system: e test-and-set! op-\neration must be performed atomically . at is, we must guarantee that,\nonce a process has tested the cell and found it to be false, the cell con-\ntents will actually be set to true before any other process can test the\ncell.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 771, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1014}}
{"id": "computer_science_sicp_abelson_chunk_0772_455358c8", "text": "at is, we must guarantee that,\nonce a process has tested the cell and found it to be false, the cell con-\ntents will actually be set to true before any other process can test the\ncell. If we do not make this guarantee, then the mutex can fail in a way\nsimilar to the bank-account failure in Figure 3.29 . (SeeExercise 3.46 .)\ne actual implementation of test-and-set! depends on the de-\ntails of how our system runs concurrent processes. For example, we\nmight be executing concurrent processes on a sequential processor us-\ningatime-slicingmechanismthatcyclesthroughtheprocesses,permit-\ntingeachprocesstorunforashorttimebeforeinterruptingitandmov-\n423\ningontothenextprocess.Inthatcase, test-and-set! canworkbydis-\nabling time slicing during the testing and seing.46Alternatively, mul-\ntiprocessing computers provide instructions that support atomic oper-\nations directly in hardware.47\nExercise3.46: Supposethatweimplement test-and-set!", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 772, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_sicp_abelson_chunk_0773_85eb8df0", "text": "using an ordinary procedure as shown in the text, without\naempting to make the operation atomic. Draw a timing\n46InScheme for a single processor, which uses a time-slicing model, test-and-\nset!can be implemented as follows:\n(define (test-and-set! cell )\n(without-interrupts\n(lambda ()\n(if(car cell )\ntrue\n(begin (set-car! cell true )\nfalse )))))\nwithout-interrupts disables time-slicing interrupts while its procedure argument is\nbeing executed. 47ere are many variants of such instructions—including test-and-set, test-and-\nclear,swap,compare-and-exchange,load-reserve,andstore-conditional—whosedesign\nmustbecarefullymatchedtothemachine’sprocessor-memoryinterface.Oneissuethat\narises here is to determine what happens if two processes aempt to acquire the same\nresource at exactly the same time by using such an instruction. is requires some\nmechanismformakingadecisionaboutwhichprocessgetscontrol.Suchamechanism\nis called an arbiter. Arbiters usually boil down to some sort of hardware device.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 773, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_sicp_abelson_chunk_0774_9c7030d4", "text": "is requires some\nmechanismformakingadecisionaboutwhichprocessgetscontrol.Suchamechanism\nis called an arbiter. Arbiters usually boil down to some sort of hardware device. Un-\nfortunately, it is possible to prove that one cannot physically construct a fair arbiter\nthat works 100% of the time unless one allows the arbiter an arbitrarily long time to\nmake its decision. e fundamental phenomenon here was originally observed by the\nfourteenth-century French philosopher Jean Buridan in his commentary on Aristotle’s\nDe caelo . Buridan argued that a perfectly rational dog placed between two equally at-\ntractive sources of food will starve to death, because it is incapable of deciding which\nto go to ﬁrst. 424\ndiagram like the one in Figure 3.29 to demonstrate how the\nmutex implementation can fail by allowing two processes\nto acquire the mutex at the same time. Exercise3.47: Asemaphore(ofsize n)isageneralizationof\na mutex.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 774, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_sicp_abelson_chunk_0775_121101b3", "text": "Exercise3.47: Asemaphore(ofsize n)isageneralizationof\na mutex. Like a mutex, a semaphore supports acquire and\nrelease operations, but it is more general in that up to n\nprocesses can acquire it concurrently. Additional processes\nthataempttoacquirethesemaphoremustwaitforrelease\noperations. Give implementations of semaphores\na.in terms of mutexes\nb.in terms of atomic test-and-set! operations. Deadlock\nNow that we have seen how to implement serializers, we can see that\naccount exchanging still has a problem, even with the serialized-\nexchange procedure above. Imagine that Peter aempts to exchange\na1 with a2 while Paul concurrently aempts to exchange a2 with a1. Suppose that Peter’s process reaches the point where it has entered a\nserializedprocedureprotecting a1and,justaerthat,Paul’sprocessen-\nters a serialized procedure protecting a2.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 775, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 848}}
{"id": "computer_science_sicp_abelson_chunk_0776_7005f6ff", "text": "Suppose that Peter’s process reaches the point where it has entered a\nserializedprocedureprotecting a1and,justaerthat,Paul’sprocessen-\nters a serialized procedure protecting a2. Now Peter cannot proceed (to\nenteraserializedprocedureprotecting a2)untilPaulexitstheserialized\nprocedureprotecting a2.Similarly,PaulcannotproceeduntilPeterexits\nthe serialized procedure protecting a1. Each process is stalled forever,\nwaiting for the other. is situation is called a deadlock . Deadlock is al-\nways a danger in systems that provide concurrent access to multiple\nshared resources. One way to avoid the deadlock in this situation is to give each ac-\ncountauniqueidentiﬁcationnumberandrewrite serialized-exchange\n425\nsothataprocesswillalwaysaempttoenteraprocedureprotectingthe\nlowest-numbered account ﬁrst. Although this method works well for\nthe exchange problem, there are other situations that require more so-\nphisticated deadlock-avoidance techniques, or where deadlock cannot\nbe avoided at all.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 776, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_sicp_abelson_chunk_0777_5482f7d7", "text": "Although this method works well for\nthe exchange problem, there are other situations that require more so-\nphisticated deadlock-avoidance techniques, or where deadlock cannot\nbe avoided at all. (See Exercise 3.48 andExercise 3.49 .)48\nExercise3.48: Explainindetailwhythedeadlock-avoidance\nmethod described above, (i.e., the accounts are numbered,\nandeachprocessaemptstoacquirethesmaller-numbered\naccountﬁrst)avoidsdeadlockintheexchangeproblem.Re-\nwrite serialized-exchange to incorporate this idea. (You\nwillalsoneedtomodify make-account sothateachaccount\niscreatedwithanumber,whichcanbeaccessedbysending\nan appropriate message.)\nExercise 3.49: Give a scenario where the deadlock-avoid-\nance mechanism described above does not work. (Hint: In\ntheexchangeproblem,eachprocessknowsinadvancewhich\naccounts it will need to get access to.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 777, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 833}}
{"id": "computer_science_sicp_abelson_chunk_0778_0e7afea7", "text": "(Hint: In\ntheexchangeproblem,eachprocessknowsinadvancewhich\naccounts it will need to get access to. Consider a situation\nwhere a process must get access to some shared resources\nbeforeitcanknowwhichadditionalsharedresourcesitwill\nrequire.)\n48e general technique for avoiding deadlock by numbering the shared resources\nand acquiring them in order is due to Havender (1968) . Situations where deadlock can-\nnotbeavoidedrequire deadlock-recovery methods,whichentailhavingprocesses“back\nout” of the deadlocked state and try again. Deadlock-recovery mechanisms are widely\nused in database management systems, a topic that is treated in detail in Gray and\nReuter 1993 . 426\nConcurrency, time, and communication\nWe’ve seen how programming concurrent systems requires controlling\ntheorderingofeventswhendiﬀerentprocessesaccesssharedstate,and\nwe’ve seen how to achieve this control through judicious use of serial-\nizers.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 778, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 913}}
{"id": "computer_science_sicp_abelson_chunk_0779_8f4dc264", "text": "But the problems of concurrency lie deeper than this, because,\nfrom a fundamental point of view, it’s not always clear what is meant\nby “shared state.”\nMechanismssuchas test-and-set! requireprocessestoexaminea\nglobal shared ﬂag at arbitrary times. is is problematic and ineﬃcient\ntoimplementinmodernhigh-speedprocessors,whereduetooptimiza-\ntion techniques such as pipelining and cached memory, the contents\nof memory may not be in a consistent state at every instant. In con-\ntemporary multiprocessing systems, therefore, the serializer paradigm\nis being supplanted by new approaches to concurrency control.49\neproblematicaspectsofsharedstatealsoariseinlarge,distributed\nsystems.Forinstance,imagineadistributedbankingsystemwhereindi-\nvidualbranchbanksmaintainlocalvaluesforbankbalancesandperiod-\nicallycomparethesewithvaluesmaintainedbyotherbranches.Insuch\na system the value of “the account balance” would be undetermined,\nexcept right aer synchronization.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 779, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_sicp_abelson_chunk_0780_e4a5ae64", "text": "If Peter deposits money in an ac-\ncount he holds jointly with Paul, when should we say that the account\nbalance has changed—when the balance in the local branch changes, or\nnot until aer the synchronization? And if Paul accesses the account\n49Onesuchalternativetoserializationiscalled barrier synchronization .eprogram-\nmer permits concurrent processes to execute as they please, but establishes certain\nsynchronization points (“barriers”) through which no process can proceed until all the\nprocesses have reached the barrier. Modern processors provide machine instructions\nthat permit programmers to establish synchronization points at places where consis-\ntencyisrequired.ePowerPC,forexample,includesforthispurposetwoinstructions\ncalledand(Enforced In-order Execution of Input/Output). 427\nfromadiﬀerentbranch,whatarethereasonableconstraintstoplaceon\nthe banking system such that the behavior is “correct”?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 780, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 920}}
{"id": "computer_science_sicp_abelson_chunk_0781_9427e0ca", "text": "427\nfromadiﬀerentbranch,whatarethereasonableconstraintstoplaceon\nthe banking system such that the behavior is “correct”? e only thing\nthat might maer for correctness is the behavior observed by Peter and\nPaul individually and the “state” of the account immediately aer syn-\nchronization.estionsaboutthe“real”accountbalanceortheorderof\nevents between synchronizations may be irrelevant or meaningless.50\ne basic phenomenon here is that synchronizing diﬀerent pro-\ncesses, establishing shared state, or imposing an order on events re-\nquires communication among the processes. In essence, any notion of\ntime in concurrency control must be intimately tied to communica-\ntion.51It is intriguing that a similar connection between time and com-\nmunication also arises in the eory of Relativity, where the speed of\nlight (the fastest signal that can be used to synchronize events) is a\nfundamental constant relating time and space.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 781, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_sicp_abelson_chunk_0782_fca584c3", "text": "e complexities we en-\ncounterindealingwithtimeandstateinourcomputationalmodelsmay\nin fact mirror a fundamental complexity of the physical universe. 3.5Streams\nWe’vegainedagoodunderstandingofassignmentasatoolinmodeling,\nas well as an appreciation of the complex problems that assignment\nraises. It is time to ask whether we could have gone about things in a\ndiﬀerent way, so as to avoid some of these problems. In this section,\n50is may seem like a strange point of view, but there are systems that work this\nway. International charges to credit-card accounts, for example, are normally cleared\non a per-country basis, and the charges made in diﬀerent countries are periodically\nreconciled. us the account balance may be diﬀerent in diﬀerent countries. 51For distributed systems, this perspective was pursued by Lamport (1978) , who\nshowed how to use communication to establish “global clocks” that can be used to\nestablish orderings on events in distributed systems.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 782, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_sicp_abelson_chunk_0783_cce26c7e", "text": "428\nwe explore an alternative approach to modeling state, based on data\nstructures called streams. As we shall see, streams can mitigate some of\nthe complexity of modeling state. Let’s step back and review where this complexity comes from. In\nan aempt to model real-world phenomena, we made some apparently\nreasonabledecisions:Wemodeledreal-worldobjectswithlocalstateby\ncomputationalobjectswithlocalvariables.Weidentiﬁedtimevariation\nin the real world with time variation in the computer. We implemented\nthe time variation of the states of the model objects in the computer\nwith assignments to the local variables of the model objects. Is there another approach? Can we avoid identifying time in the\ncomputer with time in the modeled world? Must we make the model\nchange with time in order to model phenomena in a changing world? ink about the issue in terms of mathematical functions.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 783, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 887}}
{"id": "computer_science_sicp_abelson_chunk_0784_a8cc7864", "text": "Must we make the model\nchange with time in order to model phenomena in a changing world? ink about the issue in terms of mathematical functions. We can de-\nscribe the time-varying behavior of a quantity xas a function of time\nx(t).Ifweconcentrateon xinstantbyinstant,wethinkofitasachang-\ning quantity. Yet if we concentrate on the entire time history of values,\nwe do not emphasize change—the function itself does not change.52\nIftimeismeasuredindiscretesteps,thenwecanmodelatimefunc-\ntion as a (possibly inﬁnite) sequence. In this section, we will see how to\nmodel change in terms of sequences that represent the time histories\nof the systems being modeled. To accomplish this, we introduce new\ndata structures called streams. From an abstract point of view, a stream\nis simply a sequence.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 784, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 791}}
{"id": "computer_science_sicp_abelson_chunk_0785_e3551150", "text": "To accomplish this, we introduce new\ndata structures called streams. From an abstract point of view, a stream\nis simply a sequence. However, we will ﬁnd that the straightforward\nimplementation of streams as lists (as in Section 2.2.1 ) doesn’t fully re-\n52Physicists sometimes adopt this view by introducing the “world lines” of particles\nas a device for reasoning about motion. We’ve also already mentioned ( Section 2.2.3 )\nthat this is the natural way to think about signal-processing systems. We will explore\napplications of streams to signal processing in Section 3.5.3 . 429\nveal the power of stream processing. As an alternative, we introduce\nthe technique of delayed evaluation , which enables us to represent very\nlarge (even inﬁnite) sequences as streams.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 785, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 765}}
{"id": "computer_science_sicp_abelson_chunk_0786_ab5c554a", "text": "429\nveal the power of stream processing. As an alternative, we introduce\nthe technique of delayed evaluation , which enables us to represent very\nlarge (even inﬁnite) sequences as streams. Stream processing lets us model systems that have state without\neverusingassignmentormutabledata.ishasimportantimplications,\nboth theoretical and practical, because we can build models that avoid\nthe drawbacks inherent in introducing assignment. On the other hand,\nthe stream framework raises diﬃculties of its own, and the question\nof which modeling technique leads to more modular and more easily\nmaintained systems remains open. 3.5.1Streams Are Delayed Lists\nAs we saw in Section 2.2.3 , sequences can serve as standard interfaces\nfor combining program modules. We formulated powerful abstractions\nfor manipulating sequences, such as map,filter, and accumulate , that\ncapture a wide variety of operations in a manner that is both succinct\nand elegant.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 786, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_sicp_abelson_chunk_0787_a87598a0", "text": "We formulated powerful abstractions\nfor manipulating sequences, such as map,filter, and accumulate , that\ncapture a wide variety of operations in a manner that is both succinct\nand elegant. Unfortunately, if we represent sequences as lists, this elegance is\nbought at the price of severe ineﬃciency with respect to both the time\nand space required by our computations. When we represent manip-\nulations on sequences as transformations of lists, our programs must\nconstruct and copy data structures (which may be huge) at every step\nof a process. Toseewhythisistrue,letuscomparetwoprogramsforcomputing\nthe sum of all the prime numbers in an interval. e ﬁrst program is\nwrien in standard iterative style:53\n53Assume that we have a predicate prime? (e.g., as in Section 1.2.6 ) that tests for\nprimality. 430\n(define (sum-primes ab)\n(define (iter count accum )\n(cond ((> count b)accum )\n((prime?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 787, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 893}}
{"id": "computer_science_sicp_abelson_chunk_0788_51a0acbb", "text": "(e.g., as in Section 1.2.6 ) that tests for\nprimality. 430\n(define (sum-primes ab)\n(define (iter count accum )\n(cond ((> count b)accum )\n((prime? count )\n(iter (+count 1) (+ count accum )))\n(else (iter (+count 1)accum ))))\n(iter a0))\nesecondprogramperformsthesamecomputationusingthesequence\noperations of Section 2.2.3 :\n(define (sum-primes ab)\n(accumulate +\n0\n(filter prime? (enumerate-interval ab))))\nIn carrying out the computation, the ﬁrst program needs to store only\nthe sum being accumulated. In contrast, the ﬁlter in the second pro-\ngram cannot do any testing until enumerate-interval has constructed\na complete list of the numbers in the interval. e ﬁlter generates an-\nother list, which in turn is passed to accumulate before being collapsed\ntoformasum.Suchlargeintermediatestorageisnotneededbytheﬁrst\nprogram, which we can think of as enumerating the interval incremen-\ntally, adding each prime to the sum as it is generated.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 788, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_sicp_abelson_chunk_0789_9421c5d6", "text": "e ineﬃciency in using lists becomes painfully apparent if we use\nthe sequence paradigm to compute the second prime in the interval\nfrom 10,000 to 1,000,000 by evaluating the expression\n(car (cdr (filter prime? (enumerate-interval 10000 1000000))))\nisexpressiondoesﬁndthesecondprime,butthecomputationalover-\nheadisoutrageous.Weconstructalistofalmostamillionintegers,ﬁlter\n431\nthis list by testing each element for primality, and then ignore almost\nall of the result. In a more traditional programming style, we would in-\nterleave the enumeration and the ﬁltering, and stop when we reached\nthe second prime. Streams are a clever idea that allows one to use sequence manipu-\nlations without incurring the costs of manipulating sequences as lists. With streams we can achieve the best of both worlds: We can formu-\nlate programs elegantly as sequence manipulations, while aaining the\neﬃciency of incremental computation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 789, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 919}}
{"id": "computer_science_sicp_abelson_chunk_0790_9ddbede2", "text": "With streams we can achieve the best of both worlds: We can formu-\nlate programs elegantly as sequence manipulations, while aaining the\neﬃciency of incremental computation. e basic idea is to arrange to\nconstruct a stream only partially, and to pass the partial construction\nto the program that consumes the stream. If the consumer aempts to\naccessapartofthestreamthathasnotyetbeenconstructed,thestream\nwill automatically construct just enough more of itself to produce the\nrequired part, thus preserving the illusion that the entire stream exists. In other words, although we will write programs as if we were process-\ning complete sequences, we design our stream implementation to au-\ntomatically and transparently interleave the construction of the stream\nwith its use. On the surface, streams are just lists with diﬀerent names for the\nprocedures that manipulate them.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 790, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 875}}
{"id": "computer_science_sicp_abelson_chunk_0791_42b0d7e9", "text": "On the surface, streams are just lists with diﬀerent names for the\nprocedures that manipulate them. ere is a constructor, cons-stream ,\nand two selectors, stream-car andstream-cdr , which satisfy the con-\nstraints\n(stream-car (cons-stream xy)) = x\n(stream-cdr (cons-stream xy)) = y\nere is a distinguishable object, the-empty-stream , which cannot be\nthe result of any cons-stream operation, and which can be identiﬁed\nwiththepredicate stream-null? .54uswecanmakeandusestreams,\n54In theimplementation, the-empty-stream is the same as the empty list '(),\nandstream-null? is the same as null?. 432\ninjustthesamewayaswecanmakeanduselists,torepresentaggregate\ndata arranged in a sequence. In particular, we can build stream analogs\nof the list operations from Chapter 2 , such as list-ref ,map, and for-\neach:55\n(define (stream-ref sn)\n(if(=n0)\n(stream-car s)\n(stream-ref (stream-cdr s) (- n1))))\n(define (stream-map proc s)\n(if(stream-null?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 791, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_sicp_abelson_chunk_0792_e30efd68", "text": "s)\nthe-empty-stream\n(cons-stream (proc (stream-car s))\n(stream-map proc (stream-cdr s)))))\n(define (stream-for-each proc s)\n(if(stream-null? s)\n'done\n(begin (proc (stream-car s))\n(stream-for-each proc (stream-cdr s)))))\nstream-for-each is useful for viewing streams:\n(define (display-stream s)\n(stream-for-each display-line s))\n(define (display-line x) (newline ) (display x))\nTo make the stream implementation automatically and transparently\ninterleave the construction of a stream with its use, we will arrange for\n55is should bother you. e fact that we are deﬁning such similar procedures for\nstreams and lists indicates that we are missing some underlying abstraction. Unfor-\ntunately, in order to exploit this abstraction, we will need to exert ﬁner control over\nthe process of evaluation than we can at present. We will discuss this point further at\nthe end of Section 3.5.4 . InSection 4.2 , we’ll develop a framework that uniﬁes lists and\nstreams.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 792, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 957}}
{"id": "computer_science_sicp_abelson_chunk_0793_59b3cf86", "text": "We will discuss this point further at\nthe end of Section 3.5.4 . InSection 4.2 , we’ll develop a framework that uniﬁes lists and\nstreams. 433\nthecdrof a stream to be evaluated when it is accessed by the stream-\ncdrprocedure rather than when the stream is constructed by cons-\nstream. is implementation choice is reminiscent of our discussion of\nrational numbers in Section 2.1.2 , where we saw that we can choose\nto implement rational numbers so that the reduction of numerator and\ndenominator to lowest terms is performed either at construction time\noratselectiontime.etworational-numberimplementationsproduce\nthe same data abstraction, but the choice has an eﬀect on eﬃciency. ere is a similar relationship between streams and ordinary lists. As a\ndataabstraction,streamsarethesameaslists.ediﬀerenceisthetime\nat which the elements are evaluated. With ordinary lists, both the car\nand the cdrare evaluated at construction time. With streams, the cdr\nis evaluated at selection time.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 793, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_sicp_abelson_chunk_0794_18502140", "text": "With ordinary lists, both the car\nand the cdrare evaluated at construction time. With streams, the cdr\nis evaluated at selection time. Ourimplementationofstreamswillbebasedonaspecialformcalled\ndelay.Evaluating (delay⟨exp⟩)doesnotevaluatetheexpression ⟨exp⟩,\nbut rather returns a so-called delayed object , which we can think of as\na “promise” to evaluate ⟨exp⟩at some future time. As a companion to\ndelay, there is a procedure called forcethat takes a delayed object as\nargument and performs the evaluation—in eﬀect, forcing the delayto\nfulﬁll its promise. We will see below how delayandforcecan be im-\nplemented, but ﬁrst let us use these to construct streams. cons-stream is a special form deﬁned so that\n(cons-stream⟨a⟩⟨b⟩)\nis equivalent to\n(cons⟨a⟩(delay⟨b⟩))\nWhat this means is that we will construct streams using pairs. How-\never, rather than placing the value of the rest of the stream into the cdr\nof the pair we will put there a promise to compute the rest if it is ever\n434\nrequested.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 794, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_sicp_abelson_chunk_0795_dec9a050", "text": "How-\never, rather than placing the value of the rest of the stream into the cdr\nof the pair we will put there a promise to compute the rest if it is ever\n434\nrequested. stream-car andstream-cdr can now be deﬁned as proce-\ndures:\n(define (stream-car stream ) (car stream ))\n(define (stream-cdr stream ) (force (cdr stream )))\nstream-car selects the carof the pair; stream-cdr selects the cdrof\nthe pair and evaluates the delayed expression found there to obtain the\nrest of the stream.56\nThe stream implementation in action\nTo see how this implementation behaves, let us analyze the “outra-\ngeous”primecomputationwesawabove,reformulatedintermsofstreams:\n(stream-car\n(stream-cdr\n(stream-filter prime? (stream-enumerate-interval\n10000 1000000))))\nWe will see that it does indeed work eﬃciently. We begin by calling stream-enumerate-interval with the argu-\nments10,000and1,000,000.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 795, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_sicp_abelson_chunk_0796_586268ed", "text": "(stream-enumerate-interval\n10000 1000000))))\nWe will see that it does indeed work eﬃciently. We begin by calling stream-enumerate-interval with the argu-\nments10,000and1,000,000. stream-enumerate-interval isthestream\nanalog of enumerate-interval (Section 2.2.3 ):\n(define (stream-enumerate-interval low high )\n(if(>low high )\nthe-empty-stream\n(cons-stream\n56Although stream-car andstream-cdr canbedeﬁnedasprocedures, cons-stream\nmustbeaspecialform.If cons-stream wereaprocedure,then,accordingtoourmodel\nof evaluation, evaluating (cons-stream⟨a⟩ ⟨b⟩)would automatically cause ⟨b⟩to be\nevaluated, which is precisely what we do not want to happen. For the same reason,\ndelaymust be a special form, though forcecan be an ordinary procedure.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 796, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 736}}
{"id": "computer_science_sicp_abelson_chunk_0797_c607541e", "text": "For the same reason,\ndelaymust be a special form, though forcecan be an ordinary procedure. 435\nlow\n(stream-enumerate-interval (+low 1)high ))))\nand thus the result returned by stream-enumerate-interval , formed\nby the cons-stream , is57\n(cons 10000\n(delay (stream-enumerate-interval 10001 1000000)))\natis, stream-enumerate-interval returnsastreamrepresentedasa\npairwhose caris10,000andwhose cdrisapromisetoenumeratemore\nof the interval if so requested. is stream is now ﬁltered for primes,\nusing the stream analog of the filterprocedure ( Section 2.2.3 ):\n(define (stream-filter pred stream )\n(cond ((stream-null? stream )the-empty-stream )\n((pred (stream-car stream ))\n(cons-stream (stream-car stream )\n(stream-filter\npred\n(stream-cdr stream ))))\n(else (stream-filter pred (stream-cdr stream )))))\nstream-filter tests the stream-car of the stream (the carof the pair,\nwhich is 10,000).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 797, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 889}}
{"id": "computer_science_sicp_abelson_chunk_0798_9cd207be", "text": "Since this is not prime, stream-filter examines the\nstream-cdr ofitsinputstream.ecallto stream-cdr forcesevaluation\nof the delayed stream-enumerate-interval , which now returns\n(cons 10001\n(delay (stream-enumerate-interval 10002 1000000)))\n57e numbers shown here do not really appear in the delayed expression. What\nactually appears is the original expression, in an environment in which the variables\nare bound to the appropriate numbers. For example, (+ low 1) with lowbound to\n10,000 actually appears where 10001is shown. 436\nstream-filter now looks at the stream-car of this stream, 10,001,\nsees that this is not prime either, forces another stream-cdr , and so on,\nuntil stream-enumerate-interval yieldstheprime10,007,whereupon\nstream-filter , according to its deﬁnition, returns\n(cons-stream (stream-car stream )\n(stream-filter pred (stream-cdr stream )))\nwhich in this case is\n(cons 10007\n(delay (stream-filter\nprime?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 798, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_sicp_abelson_chunk_0799_43c65cd6", "text": "(cons 10008\n(delay (stream-enumerate-interval\n10009\n1000000))))))\nisresultisnowpassedto stream-cdr inouroriginalexpression.is\nforces the delayed stream-filter , which in turn keeps forcing the de-\nlayed stream-enumerate-interval untilitﬁndsthenextprime,which\nis 10,009. Finally, the result passed to stream-car in our original ex-\npression is\n(cons 10009\n(delay (stream-filter\nprime? (cons 10010\n(delay (stream-enumerate-interval\n10011\n1000000))))))\nstream-car returns 10,009, and the computation is complete. Only as\nmany integers were tested for primality as were necessary to ﬁnd the\n437\nsecond prime, and the interval was enumerated only as far as was nec-\nessary to feed the prime ﬁlter.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 799, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 694}}
{"id": "computer_science_sicp_abelson_chunk_0800_df9a99b1", "text": "Only as\nmany integers were tested for primality as were necessary to ﬁnd the\n437\nsecond prime, and the interval was enumerated only as far as was nec-\nessary to feed the prime ﬁlter. In general, we can think of delayed evaluation as “demand-driven”\nprogramming, whereby each stage in the stream process is activated\nonlyenoughtosatisfythenextstage.Whatwehavedoneistodecouple\nthe actual order of events in the computation from the apparent struc-\ntureofourprocedures.Wewriteproceduresasifthestreamsexisted“all\nat once” when, in reality, the computation is performed incrementally,\nas in traditional programming styles. Implementing delayand force\nAlthough delayandforcemay seem like mysterious operations, their\nimplementation is really quite straightforward. delaymust package an\nexpression so that it can be evaluated later on demand, and we can ac-\ncomplish this simply by treating the expression as the body of a proce-\ndure.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 800, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_sicp_abelson_chunk_0801_d1a1f786", "text": "delaymust package an\nexpression so that it can be evaluated later on demand, and we can ac-\ncomplish this simply by treating the expression as the body of a proce-\ndure. delaycan be a special form such that\n(delay⟨exp⟩)\nis syntactic sugar for\n(lambda ()⟨exp⟩)\nforcesimplycallstheprocedure(ofnoarguments)producedby delay,\nso we can implement forceas a procedure:\n(define (force delayed-object ) (delayed-object ))\nisimplementationsuﬃcesfor delayandforcetoworkasadvertised,\nbutthereisanimportantoptimizationthatwecaninclude.Inmanyap-\nplications, we end up forcing the same delayed object many times. is\ncanleadtoseriousineﬃciencyinrecursiveprogramsinvolvingstreams. (SeeExercise 3.57 .) e solution is to build delayed objects so that the\n438\nﬁrst time they are forced, they store the value that is computed. Subse-\nquentforcingswillsimplyreturnthestoredvaluewithoutrepeatingthe\ncomputation.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 801, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 891}}
{"id": "computer_science_sicp_abelson_chunk_0802_17426893", "text": "Subse-\nquentforcingswillsimplyreturnthestoredvaluewithoutrepeatingthe\ncomputation. In other words,weimplement delayasa special-purpose\nmemoized procedure similar to the one described in Exercise 3.27 . One\nwaytoaccomplishthisistousethefollowingprocedure,whichtakesas\nargument a procedure (of no arguments) and returns a memoized ver-\nsion of the procedure. e ﬁrst time the memoized procedure is run, it\nsavesthecomputedresult.Onsubsequentevaluations,itsimplyreturns\nthe result. (define (memo-proc proc )\n(let ((already-run? false ) (result false ))\n(lambda ()\n(if(not already-run? )\n(begin (set! result (proc ))\n(set! already-run? true )\nresult )\nresult ))))\ndelayis then deﬁned so that (delay⟨exp⟩)is equivalent to\n(memo-proc (lambda ()⟨exp⟩))\nandforceis as deﬁned previously.58\n58ere are many possible implementations of streams other than the one described\nin this section. Delayed evaluation, which is the key to making streams practical, was\ninherent in Algol 60’s call-by-name parameter-passing method.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 802, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1010}}
{"id": "computer_science_sicp_abelson_chunk_0803_3e3df045", "text": "Delayed evaluation, which is the key to making streams practical, was\ninherent in Algol 60’s call-by-name parameter-passing method. e use of this mech-\nanism to implement streams was ﬁrst described by Landin (1965) . Delayed evaluation\nfor streams was introduced into Lisp by Friedman and Wise (1976) . In their implemen-\ntation, consalways delays evaluating its arguments, so that lists automatically behave\nas streams. e memoizing optimization is also known as call-by-need . e Algol com-\nmunity would refer to our original delayed objects as call-by-name thunks and to the\noptimized versions as call-by-need thunks . 439\nExercise 3.50: Complete the following deﬁnition, which\ngeneralizes stream-map to allow procedures that take mul-\ntiplearguments,analogousto mapinSection2.2.1 ,Footnote\n12.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 803, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 798}}
{"id": "computer_science_sicp_abelson_chunk_0804_4f60040a", "text": "439\nExercise 3.50: Complete the following deﬁnition, which\ngeneralizes stream-map to allow procedures that take mul-\ntiplearguments,analogousto mapinSection2.2.1 ,Footnote\n12. (define (stream-map proc .argstreams )\n(if(⟨??⟩(car argstreams ))\nthe-empty-stream\n(⟨??⟩\n(apply proc (map⟨??⟩argstreams ))\n(apply stream-map\n(cons proc (map⟨??⟩argstreams ))))))\nExercise3.51: Inordertotakeacloserlookatdelayedeval-\nuation, we will use the following procedure, which simply\nreturns its argument aer printing it:\n(define (show x)\n(display-line x)\nx)\nWhat does the interpreter print in response to evaluating\neach expression in the following sequence?59\n(define x\n59Exercises such as Exercise 3.51 andExercise 3.52 are valuable for testing our un-\nderstanding of how delayworks.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 804, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 768}}
{"id": "computer_science_sicp_abelson_chunk_0805_4bb31c95", "text": "On the other hand, intermixing delayed evaluation\nwithprinting—and,evenworse,withassignment—isextremelyconfusing,andinstruc-\ntorsofcoursesoncomputerlanguageshavetraditionallytormentedtheirstudentswith\nexamination questions such as the ones in this section. Needless to say, writing pro-\ngrams that depend on such subtleties is odious programming style. Part of the power\nof stream processing is that it lets us ignore the order in which events actually happen\nin our programs. Unfortunately, this is precisely what we cannot aﬀord to do in the\npresence of assignment, which forces us to be concerned with time and change. 440\n(stream-map show\n(stream-enumerate-interval 0 10)))\n(stream-ref x5)\n(stream-ref x7)\nExercise 3.52: Consider the sequence of expressions\n(define sum 0)\n(define (accum x) (set! sum (+xsum))sum)\n(define seq\n(stream-map accum\n(stream-enumerate-interval 1 20)))\n(define y(stream-filter even?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 805, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 912}}
{"id": "computer_science_sicp_abelson_chunk_0806_e8cf8d50", "text": "sum (+xsum))sum)\n(define seq\n(stream-map accum\n(stream-enumerate-interval 1 20)))\n(define y(stream-filter even? seq))\n(define z\n(stream-filter (lambda (x) (= ( remainder x5) 0))\nseq))\n(stream-ref y7)\n(display-stream z)\nWhatisthevalueof sumaereachoftheaboveexpressions\nis evaluated? What is the printed response to evaluating\nthestream-ref anddisplay-stream expressions? Would\ntheseresponsesdiﬀerifwehadimplemented (delay⟨exp⟩)\nsimply as (lambda ()⟨exp⟩)without using the optimiza-\ntion provided by memo-proc ? Explain. 3.5.2Infinite Streams\nWe have seen how to support the illusion of manipulating streams as\ncomplete entities even though, in actuality, we compute only as much\nofthestreamasweneedtoaccess.Wecanexploitthistechniquetorep-\nresent sequences eﬃciently as streams, even if the sequences are very\n441\nlong. What is more striking, we can use streams to represent sequences\nthat are inﬁnitely long.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 806, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 908}}
{"id": "computer_science_sicp_abelson_chunk_0807_6447da6d", "text": "What is more striking, we can use streams to represent sequences\nthat are inﬁnitely long. For instance, consider the following deﬁnition\nof the stream of positive integers:\n(define (integers-starting-from n)\n(cons-stream n(integers-starting-from (+n1))))\n(define integers (integers-starting-from 1))\nis makes sense because integers will be a pair whose caris 1 and\nwhose cdris a promise to produce the integers beginning with 2. is\nis an inﬁnitely long stream, but in any given time we can examine only\naﬁniteportionofit.us,ourprogramswillneverknowthattheentire\ninﬁnite stream is not there. Using integers we can deﬁne other inﬁnite streams, such as the\nstream of integers that are not divisible by 7:\n(define (divisible? xy) (= ( remainder xy) 0))\n(define no-sevens\n(stream-filter (lambda (x) (not (divisible?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 807, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 813}}
{"id": "computer_science_sicp_abelson_chunk_0808_c3e0e7e4", "text": "xy) (= ( remainder xy) 0))\n(define no-sevens\n(stream-filter (lambda (x) (not (divisible? x7)))\nintegers ))\nen we can ﬁnd integers not divisible by 7 simply by accessing ele-\nments of this stream:\n(stream-ref no-sevens 100)\n117\nInanalogywith integers ,wecandeﬁnetheinﬁnitestreamofFibonacci\nnumbers:\n(define (fibgen ab) (cons-stream a(fibgen b(+ab))))\n(define fibs (fibgen 0 1))\nfibsis a pair whose caris 0 and whose cdris a promise to evaluate\n(fibgen 1 1) . When we evaluate this delayed (fibgen 1 1) , it will\n442\nproduce a pair whose caris 1 and whose cdris a promise to evaluate\n(fibgen 1 2) , and so on. For a look at a more exciting inﬁnite stream, we can generalize the\nno-sevens example to construct the inﬁnite stream of prime numbers,\nusing a method known as the sieve of Eratosthenes .60We start with the\nintegers beginning with 2, which is the ﬁrst prime.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 808, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 867}}
{"id": "computer_science_sicp_abelson_chunk_0809_3f41e42f", "text": "To get the rest of\nthe primes, we start by ﬁltering the multiples of 2 from the rest of the\nintegers.isleavesastreambeginningwith3,whichisthenextprime. Now we ﬁlter the multiples of 3 from the rest of this stream. is leaves\na stream beginning with 5, which is the next prime, and so on. In other\nwords, we construct the primes by a sieving process, described as fol-\nlows: To sieve a stream S, form a stream whose ﬁrst element is the ﬁrst\nelement of Sand the rest of which is obtained by ﬁltering all multiples\nof the ﬁrst element of Sout of the rest of Sand sieving the result. is\nprocess is readily described in terms of stream operations:\n(define (sieve stream )\n(cons-stream\n(stream-car stream )\n(sieve (stream-filter\n(lambda (x)\n(not (divisible?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 809, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 753}}
{"id": "computer_science_sicp_abelson_chunk_0810_f981d96b", "text": "is\nprocess is readily described in terms of stream operations:\n(define (sieve stream )\n(cons-stream\n(stream-car stream )\n(sieve (stream-filter\n(lambda (x)\n(not (divisible? x(stream-car stream ))))\n(stream-cdr stream )))))\n(define primes (sieve (integers-starting-from 2)))\n60Eratosthenes, a third-century ..Alexandrian Greek philosopher, is famous for\ngivingtheﬁrstaccurateestimateofthecircumferenceoftheEarth,whichhecomputed\nby observing shadows cast at noon on the day of the summer solstice. Eratosthenes’s\nsieve method, although ancient, has formed the basis for special-purpose hardware\n“sieves”that,untilrecently,werethemostpowerfultoolsinexistenceforlocatinglarge\nprimes. Since the 70s, however, these methods have been superseded by outgrowths of\nthe probabilistic techniques discussed in Section 1.2.6 . 443\nfilter:\nnot\ndivisible?sievesieve\ncar\ncdrconsFigure3.31: eprimesieveviewedasasignal-processing\nsystem.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 810, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_sicp_abelson_chunk_0811_9617846a", "text": "443\nfilter:\nnot\ndivisible?sievesieve\ncar\ncdrconsFigure3.31: eprimesieveviewedasasignal-processing\nsystem. Now to ﬁnd a particular prime we need only ask for it:\n(stream-ref primes 50)\n233\nIt is interesting to contemplate the signal-processing system set up by\nsieve, shown in the “Henderson diagram” in Figure 3.31 .61e input\nstream feeds into an “un conser” that separates the ﬁrst element of the\nstreamfromtherestofthestream.eﬁrstelementisusedtoconstruct\na divisibility ﬁlter, through which the rest is passed, and the output of\nthe ﬁlter is fed to another sieve box. en the original ﬁrst element is\nconsed onto the output of the internal sieve to form the output stream. us, not only is the stream inﬁnite, but the signal processor is also\ninﬁnite, because the sieve contains a sieve within it. 61We have named these ﬁgures aer Peter Henderson, who was the ﬁrst person to\nshow us diagrams of this sort as a way of thinking about stream processing.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 811, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_sicp_abelson_chunk_0812_8c46be04", "text": "61We have named these ﬁgures aer Peter Henderson, who was the ﬁrst person to\nshow us diagrams of this sort as a way of thinking about stream processing. Each solid\nline represents a stream of values being transmied. e dashed line from the carto\ntheconsand the filterindicates that this is a single value rather than a stream. 444\nDefining streams implicitly\neintegers andfibsstreamsaboveweredeﬁnedbyspecifying“gen-\nerating”proceduresthatexplicitlycomputethestreamelementsoneby\none. An alternative way to specify streams is to take advantage of de-\nlayedevaluationtodeﬁnestreamsimplicitly.Forexample,thefollowing\nexpression deﬁnes the stream onesto be an inﬁnite stream of ones:\n(define ones (cons-stream 1ones ))\nis works much like the deﬁnition of a recursive procedure: onesis\na pair whose caris 1 and whose cdris a promise to evaluate ones. Evaluating the cdrgives us again a 1 and a promise to evaluate ones,\nand so on.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 812, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_sicp_abelson_chunk_0813_55a863b7", "text": "Evaluating the cdrgives us again a 1 and a promise to evaluate ones,\nand so on. We can do more interesting things by manipulating streams with\noperations such as add-streams , which produces the elementwise sum\nof two given streams:62\n(define (add-streams s1s2) (stream-map +s1s2))\nNow we can deﬁne the integers as follows:\n(define integers\n(cons-stream 1 (add-streams ones integers )))\nisdeﬁnes integers tobeastreamwhoseﬁrstelementis1andtherest\nof which is the sum of onesandintegers . us, the second element of\nintegers is1plustheﬁrstelementof integers ,or2;thethirdelement\nofintegers is 1 plus the second element of integers , or 3; and so on. is deﬁnition works because, at any point, enough of the integers\nstreamhasbeengeneratedsothatwecanfeeditbackintothedeﬁnition\nto produce the next integer. We can deﬁne the Fibonacci numbers in the same style:\n62is uses the generalized version of stream-map fromExercise 3.50 .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 813, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_sicp_abelson_chunk_0814_802839dd", "text": "We can deﬁne the Fibonacci numbers in the same style:\n62is uses the generalized version of stream-map fromExercise 3.50 . 445\n(define fibs\n(cons-stream\n0\n(cons-stream 1 (add-streams (stream-cdr fibs )fibs ))))\nis deﬁnition says that fibsis a stream beginning with 0 and 1, such\nthat the rest of the stream can be generated by adding fibsto itself\nshied by one place:\n1 1 2 3 5 8 13 21 : : : = (stream-cdr fibs)\n0 1 1 2 3 5 8 13 : : : = fibs\n0 1 1 2 3 5 8 13 21 34 : : : = fibs\nscale-stream is another useful procedure in formulating such stream\ndeﬁnitions. is multiplies each item in a stream by a given constant:\n(define (scale-stream stream factor )\n(stream-map (lambda (x) (* xfactor ))\nstream ))\nFor example,\n(define double (cons-stream 1 (scale-stream double 2)))\nproduces the stream of powers of 2: 1, 2, 4, 8, 16, 32, : : :.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 814, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 835}}
{"id": "computer_science_sicp_abelson_chunk_0815_50c5f68d", "text": "Analternatedeﬁnitionofthestreamofprimescanbegivenbystart-\ningwiththeintegersandﬁlteringthembytestingforprimality.Wewill\nneed the ﬁrst prime, 2, to get started:\n(define primes\n(cons-stream\n2\n(stream-filter prime? (integers-starting-from 3))))\nis deﬁnition is not so straightforward as it appears, because we will\ntest whether a number nis prime by checking whether nis divisible by\na prime (not by just any integer) less than or equal topn:\n446\n(define (prime? n)\n(define (iter ps)\n(cond ((> ( square (stream-car ps))n)true )\n((divisible? n(stream-car ps))false )\n(else (iter (stream-cdr ps)))))\n(iter primes ))\nis is a recursive deﬁnition, since primes is deﬁned in terms of the\nprime?predicate, which itself uses the primesstream. e reason this\nprocedure works is that, at any point, enough of the primesstream has\nbeen generated to test the primality of the numbers we need to check\nnext.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 815, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 893}}
{"id": "computer_science_sicp_abelson_chunk_0816_93c6549c", "text": "e reason this\nprocedure works is that, at any point, enough of the primesstream has\nbeen generated to test the primality of the numbers we need to check\nnext. at is, for every nwe test for primality, either nis not prime (in\nwhich case there is a prime already generated that divides it) or nis\nprime (in which case there is a prime already generated—i.e., a prime\nless than n—that is greater thanpn).63\nExercise 3.53: Without running the program, describe the\nelements of the stream deﬁned by\n(define s(cons-stream 1 (add-streams ss)))\nExercise3.54: Deﬁneaprocedure mul-streams ,analogous\ntoadd-streams , that produces the elementwise product of\nits two input streams. Use this together with the stream of\nintegers tocompletethefollowingdeﬁnitionofthestream\nwhose nthelement (counting from 0) is n+ 1 factorial:\n63islastpointisverysubtleandreliesonthefactthat pn+1\u0014p2n.(Here, pkdenotes\nthekthprime.) Estimates such as these are very diﬃcult to establish.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 816, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 958}}
{"id": "computer_science_sicp_abelson_chunk_0817_91015db0", "text": "e ancient proof\nbyEuclidthatthereareaninﬁnitenumberofprimesshowsthat pn+1\u0014p1p2\u0001\u0001\u0001pn+1,\nand no substantially beer result was proved until 1851, when the Russian mathemati-\ncian P. L. Chebyshev established that pn+1\u00142pnfor all n. is result, originally con-\njecturedin1845,isknownas Bertrand’s hypothesis .Aproofcanbefoundinsection22.3\nofHardy and Wright 1960 . 447\n(define factorials\n(cons-stream 1 (mul-streams⟨??⟩⟨??⟩)))\nExercise3.55: Deﬁneaprocedure partial-sums thattakes\nas argument a stream Sand returns the stream whose ele-\nmentsare S0,S0+S1,S0+S1+S2; : : :.Forexample, (partial-\nsums integers) should be the stream 1, 3, 6, 10, 15, : : :. Exercise 3.56: A famous problem, ﬁrst raised by R. Ham-\nming, is to enumerate, in ascending order with no repeti-\ntions, all positive integers with no prime factors other than\n2, 3, or 5. One obvious way to do this is to simply test each\ninteger in turn to see whether it has any factors other than\n2, 3, and 5.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 817, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_sicp_abelson_chunk_0818_4f6d3e21", "text": "One obvious way to do this is to simply test each\ninteger in turn to see whether it has any factors other than\n2, 3, and 5. But this is very ineﬃcient, since, as the integers\nget larger, fewer and fewer of them ﬁt the requirement. As\nan alternative, let us call the required stream of numbers S\nand notice the following facts about it. •Sbegins with 1. •e elements of (scale-stream S 2) are also ele-\nments of S. •esameistruefor (scale-stream S 3) and(scale-\nstream 5 S) . •ese are all the elements of S. Nowallwehavetodoiscombineelementsfromthesesources. Forthiswedeﬁneaprocedure mergethatcombinestwoor-\ndered streams into one ordered result stream, eliminating\nrepetitions:\n448\n(define (merge s1s2)\n(cond ((stream-null? s1)s2)\n((stream-null?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 818, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 746}}
{"id": "computer_science_sicp_abelson_chunk_0819_e55ee8c0", "text": "Forthiswedeﬁneaprocedure mergethatcombinestwoor-\ndered streams into one ordered result stream, eliminating\nrepetitions:\n448\n(define (merge s1s2)\n(cond ((stream-null? s1)s2)\n((stream-null? s2)s1)\n(else\n(let ((s1car (stream-car s1))\n(s2car (stream-car s2)))\n(cond ((< s1car s2car )\n(cons-stream\ns1car\n(merge (stream-cdr s1)s2)))\n((> s1car s2car )\n(cons-stream\ns2car\n(merge s1(stream-cdr s2))))\n(else\n(cons-stream\ns1car\n(merge (stream-cdr s1)\n(stream-cdr s2)))))))))\nen the required stream may be constructed with merge,\nas follows:\n(define S(cons-stream 1 (merge⟨??⟩⟨??⟩)))\nFill in the missing expressions in the places marked ⟨⁇⟩\nabove. Exercise 3.57: How many additions are performed when\nwe compute the nthFibonacci number using the deﬁnition\noffibsbased on the add-streams procedure?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 819, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 786}}
{"id": "computer_science_sicp_abelson_chunk_0820_2ca3d19a", "text": "Exercise 3.57: How many additions are performed when\nwe compute the nthFibonacci number using the deﬁnition\noffibsbased on the add-streams procedure? Show that\nthe number of additions would be exponentially greater\nif we had implemented (delay⟨exp⟩)simply as (lambda\n449\n()⟨exp⟩), without using the optimization provided by the\nmemo-proc procedure described in Section 3.5.1 .64\nExercise 3.58: Give an interpretation of the stream com-\nputed by the following procedure:\n(define (expand num den radix )\n(cons-stream\n(quotient (*num radix )den)\n(expand (remainder (*num radix )den)den radix )))\n(quotient isaprimitivethatreturnstheintegerquotientof\ntwo integers.) What are the successive elements produced\nby(expand 1 7 10) ? What is produced by (expand 3 8\n10)? Exercise 3.59: InSection 2.5.3 we saw how to implement\na polynomial arithmetic system representing polynomials\nas lists of terms.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 820, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 890}}
{"id": "computer_science_sicp_abelson_chunk_0821_43fcc6f1", "text": "What is produced by (expand 3 8\n10)? Exercise 3.59: InSection 2.5.3 we saw how to implement\na polynomial arithmetic system representing polynomials\nas lists of terms. In a similar way, we can work with power\nseries, such as\nex=1 +x+x2\n2+x3\n3\u00012+x4\n4\u00013\u00012+: : : ;\ncosx=1\u0000x2\n2+x4\n4\u00013\u00012\u0000: : : ;\nsinx=x\u0000x3\n3\u00012+x5\n5\u00014\u00013\u00012\u0000: : :\n64isexerciseshowshowcall-by-neediscloselyrelatedtoordinarymemoizationas\ndescribed in Exercise 3.27 . In that exercise, we used assignment to explicitly construct\na local table. Our call-by-need stream optimization eﬀectively constructs such a table\nautomatically, storing values in the previously forced parts of the stream. 450\nrepresentedasinﬁnitestreams.Wewillrepresenttheseries\na0+a1x+a2x2+a3x3+: : :as the stream whose elements\nare the coeﬃcients a0,a1,a2,a3,: : :.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 821, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 792}}
{"id": "computer_science_sicp_abelson_chunk_0822_48f4694d", "text": "450\nrepresentedasinﬁnitestreams.Wewillrepresenttheseries\na0+a1x+a2x2+a3x3+: : :as the stream whose elements\nare the coeﬃcients a0,a1,a2,a3,: : :. a.e integral of the series a0+a1x+a2x2+a3x3+: : :\nis the series\nc+a0x+1\n2a1x2+1\n3a2x3+1\n4a3x4+: : : ;\nwhere cisanyconstant.Deﬁneaprocedure integrate-\nseriesthat takes as input a stream a0,a1,a2,: : :rep-\nresenting a power series and returns the stream a0,\n1\n2a1,1\n3a2,: : :of coeﬃcients of the non-constant terms\nof the integral of the series. (Since the result has no\nconstantterm,itdoesn’trepresentapowerseries;when\nwe use integrate-series , we will conson the ap-\npropriate constant.)\nb.e function x7!exis its own derivative. is im-\nplies that exand the integral of exare the same se-\nries, except for the constant term, which is e0=1.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 822, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 787}}
{"id": "computer_science_sicp_abelson_chunk_0823_f7b93228", "text": "is im-\nplies that exand the integral of exare the same se-\nries, except for the constant term, which is e0=1. Accordingly, we can generate the series for exas\n(define exp-series\n(cons-stream 1 (integrate-series exp-series )))\nShow how to generate the series for sine and cosine,\nstarting from the facts that the derivative of sine is\ncosine and the derivative of cosine is the negative of\nsine:\n(define cosine-series (cons-stream 1⟨??⟩))\n(define sine-series (cons-stream 0⟨??⟩))\n451\nExercise 3.60: With power series represented as streams\nof coeﬃcients as in Exercise 3.59 , adding series is imple-\nmentedby add-streams .Completethedeﬁnitionofthefol-\nlowing procedure for multiplying series:\n(define (mul-series s1s2)\n(cons-stream⟨??⟩(add-streams⟨??⟩⟨??⟩)))\nYoucantestyourprocedurebyverifyingthatsin2x+ cos2x=1,\nusing the series from Exercise 3.59 . Exercise3.61: LetSbeapowerseries( Exercise3.59 )whose\nconstant term is 1.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 823, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_sicp_abelson_chunk_0824_90b84f50", "text": "Exercise3.61: LetSbeapowerseries( Exercise3.59 )whose\nconstant term is 1. Suppose we want to ﬁnd the power se-\nries 1 =S, that is, the series Xsuch that SX=1. Write\nS=1 +SRwhere SRis the part of Saer the constant\nterm. en we can solve for Xas follows:\nS\u0001X=1;\n(1 +SR)\u0001X=1;\nX+SR\u0001X=1;\nX=1\u0000SR\u0001X:\nIn other words, Xis the power series whose constant term\nis1andwhosehigher-ordertermsaregivenbythenegative\nofSRtimes X. Use this idea to write a procedure invert-\nunit-series that computes 1 =Sfor a power series Swith\nconstant term 1. You will need to use mul-series fromEx-\nercise 3.60 . Exercise 3.62: Use the results of Exercise 3.60 andExer-\ncise3.61 todeﬁneaprocedure div-series thatdividestwo\npower series. div-series should work for any two series,\n452\nprovidedthatthedenominatorseriesbeginswithanonzero\nconstantterm.(Ifthedenominatorhasazeroconstantterm,\nthen div-series should signal an error.) Show how to use\ndiv-series togetherwiththeresultof Exercise3.59 togen-\nerate the power series for tangent.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 824, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_sicp_abelson_chunk_0825_8de93754", "text": "3.5.3Exploiting the Stream Paradigm\nStreams with delayed evaluation can be a powerful modeling tool, pro-\nviding many of the beneﬁts of local state and assignment. Moreover,\nthey avoid some of the theoretical tangles that accompany the intro-\nduction of assignment into a programming language. e stream approach can be illuminating because it allows us to\nbuildsystemswithdiﬀerentmoduleboundariesthansystemsorganized\naround assignment to state variables. For example, we can think of an\nentiretimeseries(orsignal)asafocusofinterest,ratherthanthevalues\nof the state variables at individual moments. is makes it convenient\nto combine and compare components of state from diﬀerent moments. Formulating iterations as stream processes\nInSection 1.2.1 , we introduced iterative processes, which proceed by\nupdating state variables. We know now that we can represent state as\na “timeless” stream of values rather than as a set of variables to be up-\ndated.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 825, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_sicp_abelson_chunk_0826_379b8909", "text": "We know now that we can represent state as\na “timeless” stream of values rather than as a set of variables to be up-\ndated. Let’s adopt this perspective in revisiting the square-root proce-\ndure from Section 1.1.7 . Recall that the idea is to generate a sequence of\nbeer and beer guesses for the square root of xby applying over and\nover again the procedure that improves guesses:\n(define (sqrt-improve guess x)\n(average guess (/xguess )))\n453\nInouroriginal sqrtprocedure,wemadetheseguessesbethesuccessive\nvalues of a state variable. Instead we can generate the inﬁnite stream of\nguesses, starting with an initial guess of 1:65\n(define (sqrt-stream x)\n(define guesses\n(cons-stream\n1.0\n(stream-map (lambda (guess ) (sqrt-improve guess x))\nguesses )))\nguesses )\n(display-stream (sqrt-stream 2))\n1.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 826, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 797}}
{"id": "computer_science_sicp_abelson_chunk_0827_c1fe872a", "text": "1.5\n1.4166666666666665\n1.4142156862745097\n1.4142135623746899\n: : :\nWe can generate more and more terms of the stream to get beer and\nbeerguesses.Ifwelike,wecanwriteaprocedurethatkeepsgenerating\nterms until the answer is good enough. (See Exercise 3.64 .)\nAnother iteration that we can treat in the same way is to generate\nan approximation to π, based upon the alternating series that we saw\ninSection 1.3.1 :π\n4=1\u00001\n3+1\n5\u00001\n7+: : : :\nWe ﬁrst generate the stream of summands of the series (the reciprocals\nof the odd integers, with alternating signs). en we take the stream of\n65We can’t use letto bind the local variable guesses , because the value of guesses\ndepends on guesses itself.Exercise 3.63 addresses why we want a local variable here.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 827, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 747}}
{"id": "computer_science_sicp_abelson_chunk_0828_574a51a9", "text": "en we take the stream of\n65We can’t use letto bind the local variable guesses , because the value of guesses\ndepends on guesses itself.Exercise 3.63 addresses why we want a local variable here. 454\nsums of more and more terms (using the partial-sums procedure of\nExercise 3.55 ) and scale the result by 4:\n(define (pi-summands n)\n(cons-stream (/ 1.0 n)\n(stream-map - (pi-summands (+n2)))))\n(define pi-stream\n(scale-stream (partial-sums (pi-summands 1)) 4))\n(display-stream pi-stream )\n4. 2.666666666666667\n3.466666666666667\n2.8952380952380956\n3.3396825396825403\n2.9760461760461765\n3.2837384837384844\n3.017071817071818\n: : :\nisgivesusastreamofbeerandbeerapproximationsto π,although\ntheapproximationsconvergeratherslowly.Eighttermsofthesequence\nbound the value of πbetween 3.284 and 3.017. Sofar,ouruseofthestreamofstatesapproachisnotmuchdiﬀerent\nfrom updating state variables. But streams give us an opportunity to do\nsome interesting tricks.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 828, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_sicp_abelson_chunk_0829_1eb83e62", "text": "Sofar,ouruseofthestreamofstatesapproachisnotmuchdiﬀerent\nfrom updating state variables. But streams give us an opportunity to do\nsome interesting tricks. For example, we can transform a stream with\nasequence accelerator that converts a sequence of approximations to a\nnew sequence that converges to the same value as the original, only\nfaster.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 829, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 343}}
{"id": "computer_science_sicp_abelson_chunk_0830_fca990eb", "text": "For example, we can transform a stream with\nasequence accelerator that converts a sequence of approximations to a\nnew sequence that converges to the same value as the original, only\nfaster. One such accelerator, due to the eighteenth-century Swiss math-\nematician Leonhard Euler, works well with sequences that are partial\nsumsofalternatingseries(seriesoftermswithalternatingsigns).InEu-\nler’s technique, if Snis the nthterm of the original sum sequence, then\n455\nthe accelerated sequence has terms\nSn+1\u0000(Sn+1\u0000Sn)2\nSn\u00001\u00002Sn+Sn+1:\nus, if the original sequence is represented as a stream of values, the\ntransformed sequence is given by\n(define (euler-transform s)\n(let ((s0(stream-ref s0)) ;Sn\u00001\n(s1(stream-ref s1)) ;Sn\n(s2(stream-ref s2))) ;Sn+1\n(cons-stream (-s2(/ ( square (-s2s1))\n(+s0(* -2 s1)s2)))\n(euler-transform (stream-cdr s)))))\nWe can demonstrate Euler acceleration with our sequence of approxi-\nmations to π:\n(display-stream (euler-transform pi-stream ))\n3.166666666666667\n3.1333333333333337\n3.1452380952380956\n3.13968253968254\n3.1427128427128435\n3.1408813408813416\n3.142071817071818\n3.1412548236077655\n: : :\nEvenbeer,wecanacceleratetheacceleratedsequence,andrecursively\naccelerate that, and so on.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 830, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 1211}}
{"id": "computer_science_sicp_abelson_chunk_0831_2e177150", "text": "Namely, we create a stream of streams (a\nstructure we’ll call a tableau) in which each stream is the transform of\nthe preceding one:\n456\n(define (make-tableau transform s)\n(cons-stream s(make-tableau transform (transform s))))\ne tableau has the form\ns00s01s02s03s04: : :\ns10s11s12s13: : :\ns20s21s22: : :\n: : :\nFinally, we form a sequence by taking the ﬁrst term in each row of the\ntableau:\n(define (accelerated-sequence transform s)\n(stream-map stream-car (make-tableau transform s)))\nWecandemonstratethiskindof“super-acceleration”ofthe πsequence:\n(display-stream\n(accelerated-sequence euler-transform pi-stream ))\n4. 3.166666666666667\n3.142105263157895\n3.141599357319005\n3.1415927140337785\n3.1415926539752927\n3.1415926535911765\n3.141592653589778\n: : :\ne result is impressive. Taking eight terms of the sequence yields the\ncorrect value of πto 14 decimal places.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 831, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 864}}
{"id": "computer_science_sicp_abelson_chunk_0832_a5fcc3f6", "text": "Taking eight terms of the sequence yields the\ncorrect value of πto 14 decimal places. If we had used only the original\nπsequence, we would need to compute on the order of 1013terms (i.e.,\nexpanding the series far enough so that the individual terms are less\nthan 10\u000013) to get that much accuracy! 457\nWe could have implemented these acceleration techniques without\nusing streams. But the stream formulation is particularly elegant and\nconvenient because the entire sequence of states is available to us as a\ndatastructurethatcanbemanipulatedwithauniformsetofoperations. Exercise 3.63: Louis Reasoner asks why the sqrt-stream\nprocedure was not wrien in the following more straight-\nforward way, without the local variable guesses :\n(define (sqrt-stream x)\n(cons-stream 1.0 ( stream-map\n(lambda (guess )\n(sqrt-improve guess x))\n(sqrt-stream x))))\nAlyssa P. Hacker replies that this version of the procedure\nisconsiderablylesseﬃcientbecauseitperformsredundant\ncomputation. Explain Alyssa’s answer.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 832, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_sicp_abelson_chunk_0833_1931accf", "text": "Hacker replies that this version of the procedure\nisconsiderablylesseﬃcientbecauseitperformsredundant\ncomputation. Explain Alyssa’s answer. Would the two ver-\nsionsstilldiﬀerineﬃciencyifourimplementationof delay\nused only (lambda ()⟨exp⟩)without using the optimiza-\ntion provided by memo-proc (Section 3.5.1 )? Exercise3.64: Write a procedure stream-limit that takes\nasargumentsastreamandanumber(thetolerance).Itshould\nexamine the stream until it ﬁnds two successive elements\nthat diﬀer in absolute value by less than the tolerance, and\nreturnthesecondofthetwoelements.Usingthis,wecould\ncompute square roots up to a given tolerance by\n(define (sqrt xtolerance )\n(stream-limit (sqrt-stream x)tolerance ))\n458\nExercise 3.65: Use the series\nln2=1\u00001\n2+1\n3\u00001\n4+: : :\nto compute three sequences of approximations to the nat-\nural logarithm of 2, in the same way we did above for π. How rapidly do these sequences converge?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 833, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_sicp_abelson_chunk_0834_50c0caa6", "text": "How rapidly do these sequences converge? Infinite streams of pairs\nInSection2.2.3 ,wesawhowthesequenceparadigmhandlestraditional\nnestedloopsasprocessesdeﬁnedonsequencesofpairs.Ifwegeneralize\nthis technique to inﬁnite streams, then we can write programs that are\nnot easily represented as loops, because the “looping” must range over\nan inﬁnite set. For example, suppose we want to generalize the prime-sum-pairs\nprocedure of Section 2.2.3 to produce the stream of pairs of allintegers\n(i;j)with i\u0014jsuch that i+jis prime. If int-pairs is the sequence of\nallpairsofintegers (i;j)with i\u0014j,thenourrequiredstreamissimply66\n(stream-filter\n(lambda (pair ) (prime?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 834, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 656}}
{"id": "computer_science_sicp_abelson_chunk_0835_64f39154", "text": "If int-pairs is the sequence of\nallpairsofintegers (i;j)with i\u0014j,thenourrequiredstreamissimply66\n(stream-filter\n(lambda (pair ) (prime? (+ ( car pair ) (cadr pair ))))\nint-pairs )\nOurproblem,then,istoproducethestream int-pairs .Moregenerally,\nsuppose we have two streams S=(Si)andT=(Tj), and imagine the\ninﬁnite rectangular array\n(S0;T0) (S0;T1) (S0;T2): : :\n(S1;T0) (S1;T1) (S1;T2): : :\n(S2;T0) (S2;T1) (S2;T2): : :\n: : :\n66As inSection 2.2.3 , we represent a pair of integers as a list rather than a Lisp pair.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 835, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 512}}
{"id": "computer_science_sicp_abelson_chunk_0836_baf37fa0", "text": "459\nWe wish to generate a stream that contains all the pairs in the array\nthat lie on or above the diagonal, i.e., the pairs\n(S0;T0) (S0;T1) (S0;T2): : :\n(S1;T1) (S1;T2): : :\n(S2;T2): : :\n: : :\n(If we take both SandTto be the stream of integers, then this will be\nour desired stream int-pairs .)\nCall the general stream of pairs (pairs S T) , and consider it to be\ncomposedofthreeparts:thepair (S0;T0),therestofthepairsintheﬁrst\nrow, and the remaining pairs:67\n(S0;T0)(S0;T1) (S0;T2): : :\n(S1;T1) (S1;T2): : :\n(S2;T2): : :\n: : :\nObserve that the third piece in this decomposition (pairs that are not\nin the ﬁrst row) is (recursively) the pairs formed from (stream-cdr S)\nand(stream-cdr T) .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 836, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 690}}
{"id": "computer_science_sicp_abelson_chunk_0837_085164e6", "text": "Also note that the second piece (the rest of the\nﬁrst row) is\n(stream-map (lambda (x) (list (stream-car s)x))\n(stream-cdr t))\nus we can form our stream of pairs as follows:\n(define (pairs st)\n(cons-stream\n(list (stream-car s) (stream-car t))\n67SeeExercise 3.68 for some insight into why we chose this decomposition. 460\n(⟨combine-in-some-way ⟩\n(stream-map (lambda (x) (list (stream-car s)x))\n(stream-cdr t))\n(pairs (stream-cdr s) (stream-cdr t)))))\nIn order to complete the procedure, we must choose some way to com-\nbine the two inner streams. One idea is to use the stream analog of the\nappendprocedure from Section 2.2.1 :\n(define (stream-append s1s2)\n(if(stream-null? s1)\ns2\n(cons-stream (stream-car s1)\n(stream-append (stream-cdr s1)s2))))\nis is unsuitable for inﬁnite streams, however, because it takes all the\nelements from the ﬁrst stream before incorporating the second stream.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 837, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_sicp_abelson_chunk_0838_4c19f85f", "text": "In particular, if we try to generate all pairs of positive integers using\n(pairs integers integers )\nour stream of results will ﬁrst try to run through all pairs with the ﬁrst\ninteger equal to 1, and hence will never produce pairs with any other\nvalue of the ﬁrst integer. To handle inﬁnite streams, we need to devise an order of combina-\ntion that ensures that every element will eventually be reached if we\nlet our program run long enough. An elegant way to accomplish this is\nwith the following interleave procedure:68\n68e precise statement of the required property on the order of combination is as\nfollows: ere should be a function fof two arguments such that the pair correspond-\ning to element iof the ﬁrst stream and element jof the second stream will appear as\nelement number f(i;j)of the output stream. e trick of using interleave to accom-\nplish this was shown to us by David Turner, who employed it in the language KRC\n(Turner 1981 ). 461\n(define (interleave s1s2)\n(if(stream-null?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 838, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_sicp_abelson_chunk_0839_ebfd216d", "text": "e trick of using interleave to accom-\nplish this was shown to us by David Turner, who employed it in the language KRC\n(Turner 1981 ). 461\n(define (interleave s1s2)\n(if(stream-null? s1)\ns2\n(cons-stream (stream-car s1)\n(interleave s2(stream-cdr s1)))))\nSince interleave takes elements alternately from the two streams, ev-\nery element of the second stream will eventually ﬁnd its way into the\ninterleaved stream, even if the ﬁrst stream is inﬁnite. We can thus generate the required stream of pairs as\n(define (pairs st)\n(cons-stream\n(list (stream-car s) (stream-car t))\n(interleave\n(stream-map (lambda (x) (list (stream-car s)x))\n(stream-cdr t))\n(pairs (stream-cdr s) (stream-cdr t)))))\nExercise3.66: Examinethestream (pairs integers integers) . Can you make any general comments about the order in\nwhich the pairs are placed into the stream? For example,\napproximately how many pairs precede the pair (1, 100)? the pair (99, 100)? the pair (100, 100)?", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 839, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_sicp_abelson_chunk_0840_5132bd01", "text": "For example,\napproximately how many pairs precede the pair (1, 100)? the pair (99, 100)? the pair (100, 100)? (If you can make pre-\ncise mathematical statements here, all the beer. But feel\nfree to give more qualitative answers if you ﬁnd yourself\ngeing bogged down.)\nExercise3.67: Modify the pairsprocedure so that (pairs\nintegers integers) willproducethestreamof allpairsof\nintegers (i;j)(without the condition i\u0014j). Hint: You will\nneed to mix in an additional stream. 462\nExercise3.68: LouisReasonerthinksthatbuildingastream\nof pairs from three parts is unnecessarily complicated. In-\nsteadofseparatingthepair (S0;T0)fromtherestofthepairs\nin the ﬁrst row, he proposes to work with the whole ﬁrst\nrow, as follows:\n(define (pairs st)\n(interleave\n(stream-map (lambda (x) (list (stream-car s)x))\nt)\n(pairs (stream-cdr s) (stream-cdr t))))\nDoesthiswork?Considerwhathappensifweevaluate (pairs\nintegers integers) using Louis’s deﬁnition of pairs.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 840, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_sicp_abelson_chunk_0841_74d175db", "text": "Exercise 3.69: Write a procedure triples that takes three\ninﬁnite streams, S,T, and U, and produces the stream of\ntriples (Si;Tj;Uk)such that i\u0014j\u0014k. Use triples to gen-\nerate the stream of all Pythagorean triples of positive inte-\ngers, i.e., the triples (i;j;k)such that i\u0014jandi2+j2=k2. Exercise3.70: Itwouldbenicetobeabletogeneratestreams\nin which the pairs appear in some useful order, rather than\nin the order that results from an ad hocinterleaving pro-\ncess.Wecanuseatechniquesimilartothe mergeprocedure\nofExercise 3.56 , if we deﬁne a way to say that one pair of\nintegers is “less than” another. One way to do this is to de-\nﬁne a “weighting function” W(i;j)and stipulate that (i1;j1)\nis less than (i2;j2)ifW(i1;j1)<W(i2;j2).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 841, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 732}}
{"id": "computer_science_sicp_abelson_chunk_0842_3ee7e32e", "text": "One way to do this is to de-\nﬁne a “weighting function” W(i;j)and stipulate that (i1;j1)\nis less than (i2;j2)ifW(i1;j1)<W(i2;j2). Write a proce-\ndure merge-weighted thatislike merge,exceptthat merge-\nweighted takes an additional argument weight, which is a\nprocedure that computes the weight of a pair, and is used\n463\nto determine the order in which elements should appear in\ntheresultingmergedstream.69Usingthis,generalize pairs\nto a procedure weighted-pairs that takes two streams, to-\ngether with a procedure that computes a weighting func-\ntion, and generates the stream of pairs, ordered according\nto weight. Use your procedure to generate\na.the stream of all pairs of positive integers (i;j)with\ni\u0014jordered according to the sum i+j,\nb.the stream of all pairs of positive integers (i;j)with\ni\u0014j,whereneither inorjisdivisibleby2,3,or5,and\nthe pairs are ordered according to the sum 2 i+3j+5ij.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 842, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 898}}
{"id": "computer_science_sicp_abelson_chunk_0843_fe68c88a", "text": "Exercise3.71: Numbersthatcanbeexpressedasthesumof\ntwo cubes in more than one way are sometimes called Ra-\nmanujan numbers , in honor of the mathematician Srinivasa\nRamanujan.70Ordered streams of pairs provide an elegant\nsolution to the problem of computing these numbers. To\nﬁnd a number that can be wrien as the sum of two cubes\nin two diﬀerent ways, we need only generate the stream of\npairs of integers (i;j)weighted according to the sum i3+j3\n69We will require that the weighting function be such that the weight of a pair in-\ncreases as we move out along a row or down along a column of the array of pairs. 70To quote from G. H. Hardy’s obituary of Ramanujan ( Hardy 1921 ): “It was Mr. Lilewood(Ibelieve)whoremarkedthat‘everypositiveintegerwasoneofhisfriends.’\nI remember once going to see him when he was lying ill at Putney. I had ridden in taxi-\ncab No.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 843, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 864}}
{"id": "computer_science_sicp_abelson_chunk_0844_ee0ddf44", "text": "Lilewood(Ibelieve)whoremarkedthat‘everypositiveintegerwasoneofhisfriends.’\nI remember once going to see him when he was lying ill at Putney. I had ridden in taxi-\ncab No. 1729, and remarked that the number seemed to me a rather dull one, and that I\nhopeditwasnotanunfavorableomen.‘No,’hereplied,‘itisaveryinterestingnumber;\nit is the smallest number expressible as the sum of two cubes in two diﬀerent ways.’ ”\ne trick of using weighted pairs to generate the Ramanujan numbers was shown to\nus by Charles Leiserson. 464\n(seeExercise3.70 ),thensearchthestreamfortwoconsecu-\ntivepairswiththesameweight.Writeaproceduretogener-\natetheRamanujannumbers.eﬁrstsuchnumberis1,729. What are the next ﬁve? Exercise 3.72: In a similar way to Exercise 3.71 generate a\nstreamofallnumbersthatcanbewrienasthesumoftwo\nsquares in three diﬀerent ways (showing how they can be\nso wrien).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 844, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 870}}
{"id": "computer_science_sicp_abelson_chunk_0845_5e45c596", "text": "What are the next ﬁve? Exercise 3.72: In a similar way to Exercise 3.71 generate a\nstreamofallnumbersthatcanbewrienasthesumoftwo\nsquares in three diﬀerent ways (showing how they can be\nso wrien). Streams as signals\nWe began our discussion of streams by describing them as computa-\ntional analogs of the “signals” in signal-processing systems. In fact, we\ncan use streams to model signal-processing systems in a very direct\nway, representing the values of a signal at successive time intervals as\nconsecutive elements of a stream. For instance, we can implement an\nintegrator orsummer that, for an input stream x=(xi), an initial value\nC, and a small increment dt, accumulates the sum\nSi=C+i∑\nj=1xjdt\nand returns the stream of values S=(Si).", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 845, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 742}}
{"id": "computer_science_sicp_abelson_chunk_0846_0f100162", "text": "e following integral pro-\ncedure is reminiscent of the “implicit style” deﬁnition of the stream of\nintegers ( Section 3.5.2 ):\n(define (integral integrand initial-value dt)\n(define int\n(cons-stream initial-value\n(add-streams (scale-stream integrand dt)\nint)))\nint)\n465\naddconsinitial-value\nintegral input\nscale: dtFigure 3.32: eintegral procedure viewed as a signal-\nprocessing system. Figure 3.32 is a picture of a signal-processing system that corresponds\nto the integral procedure. e input stream is scaled by dtand passed\nthroughanadder,whoseoutputispassedbackthroughthesameadder. e self-reference in the deﬁnition of intis reﬂected in the ﬁgure by\nthe feedback loop that connects the output of the adder to one of the\ninputs. Exercise3.73: Wecanmodelelectricalcircuitsusingstreams\ntorepresentthevaluesofcurrentsorvoltagesatasequence\nof times. For instance, suppose we have an RC circuit con-\nsistingofaresistorofresistance Randacapacitorofcapac-\nitance Cin series.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 846, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_sicp_abelson_chunk_0847_5aa8c59c", "text": "For instance, suppose we have an RC circuit con-\nsistingofaresistorofresistance Randacapacitorofcapac-\nitance Cin series. e voltage response vof the circuit to\nan injected current iis determined by the formula in Fig-\nure 3.33 , whose structure is shown by the accompanying\nsignal-ﬂow diagram. Write a procedure RCthat models this circuit. RCshould\ntake as inputs the values of R,C, and dtand should return\na procedure that takes as inputs a stream representing the\ncurrent iand an initial value for the capacitor voltage v0\n466\nv\nv0iRCi+ -- v\nscale: R\nintegraladd\nscale: 1\nC\nv = v0 + 1 i dt + Ri\n0t\nCZFigure 3.33: An RC circuit and the associated signal-ﬂow diagram. and produces as output the stream of voltages v. For ex-\nample, you should be able to use RCto model an RC circuit\nwith R= 5 ohms, C= 1 farad, and a 0.5-second time step by\nevaluating (define RC1 (RC 5 1 0.5)) .", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 847, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 880}}
{"id": "computer_science_sicp_abelson_chunk_0848_3d9c22da", "text": "For ex-\nample, you should be able to use RCto model an RC circuit\nwith R= 5 ohms, C= 1 farad, and a 0.5-second time step by\nevaluating (define RC1 (RC 5 1 0.5)) . is deﬁnes RC1\nas a procedure that takes a stream representing the time\nsequence of currents and an initial capacitor voltage and\nproduces the output stream of voltages. Exercise 3.74: Alyssa P. Hacker is designing a system to\nprocess signals coming from physical sensors. One impor-\ntantfeatureshewishestoproduceisasignalthatdescribes\nthezero crossings of the input signal. at is, the resulting\nsignalshouldbe+1whenevertheinputsignalchangesfrom\nnegative to positive, \u00001 whenever the input signal changes\nfrom positive to negative, and 0 otherwise.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 848, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 712}}
{"id": "computer_science_sicp_abelson_chunk_0849_6b70771c", "text": "at is, the resulting\nsignalshouldbe+1whenevertheinputsignalchangesfrom\nnegative to positive, \u00001 whenever the input signal changes\nfrom positive to negative, and 0 otherwise. (Assume that\nthe sign of a 0 input is positive.) For example, a typical in-\n467\nputsignalwithitsassociatedzero-crossingsignalwouldbe\n: : :1 2 1.5 1 0.5 -0.1 -2 -3 -2 -0.5 0.2 3 4 : : :\n: : :0 0 0 0 0 -1 0 0 0 0 1 0 0 : : :\nInAlyssa’ssystem,thesignalfromthesensorisrepresented\nas a stream sense-data and the stream zero-crossings\nis the corresponding stream of zero crossings. Alyssa ﬁrst\nwrites a procedure sign-change-detector that takes two\nvalues as arguments and compares the signs of the values\nto produce an appropriate 0, 1, or - 1.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 849, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 714}}
{"id": "computer_science_sicp_abelson_chunk_0850_a018d2b7", "text": "Alyssa ﬁrst\nwrites a procedure sign-change-detector that takes two\nvalues as arguments and compares the signs of the values\nto produce an appropriate 0, 1, or - 1. She then constructs\nher zero-crossing stream as follows:\n(define (make-zero-crossings input-stream last-value )\n(cons-stream\n(sign-change-detector\n(stream-car input-stream )\nlast-value )\n(make-zero-crossings\n(stream-cdr input-stream )\n(stream-car input-stream ))))\n(define zero-crossings\n(make-zero-crossings sense-data 0))\nAlyssa’s boss, Eva Lu Ator, walks by and suggests that this\nprogram is approximately equivalent to the following one,\nwhichusesthegeneralizedversionof stream-map fromEx-\nercise 3.50 :\n(define zero-crossings\n(stream-map sign-change-detector\nsense-data\n⟨expression⟩))\n468\nCompletetheprogrambysupplyingtheindicated ⟨expression⟩. Exercise 3.75: Unfortunately, Alyssa’s zero-crossing de-\ntectorin Exercise3.74 provestobeinsuﬃcient,becausethe\nnoisy signal from the sensor leads to spurious zero cross-\nings. Lem E.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 850, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_sicp_abelson_chunk_0851_b01b2e49", "text": "Exercise 3.75: Unfortunately, Alyssa’s zero-crossing de-\ntectorin Exercise3.74 provestobeinsuﬃcient,becausethe\nnoisy signal from the sensor leads to spurious zero cross-\nings. Lem E. Tweakit, a hardware specialist, suggests that\nAlyssa smooth the signal to ﬁlter out the noise before ex-\ntracting the zero crossings. Alyssa takes his advice and de-\ncidestoextractthezerocrossingsfromthesignalconstructed\nbyaveragingeachvalueofthesensedatawiththeprevious\nvalue.Sheexplainstheproblemtoherassistant,LouisRea-\nsoner,whoaemptstoimplementtheidea,alteringAlyssa’s\nprogram as follows:\n(define (make-zero-crossings input-stream last-value )\n(let ((avpt (/ (+ ( stream-car input-stream )\nlast-value )\n2)))\n(cons-stream\n(sign-change-detector avpt last-value )\n(make-zero-crossings\n(stream-cdr input-stream )avpt ))))\nis does not correctly implement Alyssa’s plan. Find the\nbug that Louishas installed and ﬁx it without changingthe\nstructure of the program.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 851, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_sicp_abelson_chunk_0852_e9472416", "text": "Find the\nbug that Louishas installed and ﬁx it without changingthe\nstructure of the program. (Hint: You will need to increase\nthe number of arguments to make-zero-crossings .)\nExercise 3.76: Eva Lu Ator has a criticism of Louis’s ap-\nproach in Exercise 3.75 . e program he wrote is not mod-\nular,becauseitintermixestheoperationofsmoothingwith\nthezero-crossingextraction.Forexample,theextractorshould\n469\nnot have to be changed if Alyssa ﬁnds a beer way to con-\ndition her input signal. Help Louis by writing a procedure\nsmooththat takes a stream as input and produces a stream\nin which each element is the average of two successive in-\nput stream elements. en use smoothas a component to\nimplement the zero-crossing detector in a more modular\nstyle. 3.5.4Streams and Delayed Evaluation\neintegral procedureattheendoftheprecedingsectionshowshow\nwe can use streams to model signal-processing systems that contain\nfeedback loops.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 852, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 929}}
{"id": "computer_science_sicp_abelson_chunk_0853_83cc89f0", "text": "3.5.4Streams and Delayed Evaluation\neintegral procedureattheendoftheprecedingsectionshowshow\nwe can use streams to model signal-processing systems that contain\nfeedback loops. e feedback loop for the adder shown in Figure 3.32\nis modeled by the fact that integral ’s internal stream intis deﬁned in\nterms of itself:\n(define int\n(cons-stream\ninitial-value\n(add-streams (scale-stream integrand dt)\nint)))\neinterpreter’sabilitytodealwithsuchanimplicitdeﬁnitiondepends\nonthe delaythatisincorporatedinto cons-stream .Withoutthis delay,\nthe interpreter could not construct intbefore evaluating both argu-\nmentsto cons-stream ,whichwouldrequirethat intalreadybedeﬁned. Ingeneral, delayiscrucialforusingstreamstomodelsignal-processing\nsystems that contain loops. Without delay, our models would have to\nbe formulated so that the inputs to any signal-processing component\nwould be fully evaluated before the output could be produced. is\nwould outlaw loops.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 853, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_sicp_abelson_chunk_0854_c398a01c", "text": "Without delay, our models would have to\nbe formulated so that the inputs to any signal-processing component\nwould be fully evaluated before the output could be produced. is\nwould outlaw loops. 470\ny0\ndy y\nintegral map: fFigure 3.34: An “analog computer circuit” that solves the\nequation dy=dt=f(y). Unfortunately, stream models of systems with loops may require\nusesof delaybeyondthe“hidden” delaysuppliedby cons-stream .For\ninstance, Figure 3.34 shows a signal-processing system for solving the\ndiﬀerential equation dy=dt=f(y)where fis a given function. e ﬁg-\nure shows a mapping component, which applies fto its input signal,\nlinked in a feedback loop to an integrator in a manner very similar to\nthat of the analog computer circuits that are actually used to solve such\nequations.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 854, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 785}}
{"id": "computer_science_sicp_abelson_chunk_0855_1a3c0619", "text": "Assuming we are given an initial value y0fory, we could try to\nmodel this system using the procedure\n(define (solve fy0dt)\n(define y(integral dyy0dt))\n(define dy(stream-map fy))\ny)\nis procedure does not work, because in the ﬁrst line of solvethe\ncall to integral requires that the input dybe deﬁned, which does not\nhappen until the second line of solve. On the other hand, the intent of our deﬁnition does make sense,\nbecause we can, in principle, begin to generate the ystream without\n471\nknowing dy. Indeed, integral and many other stream operations have\nproperties similar to those of cons-stream , in that we can generate\npart of the answer given only partial information about the arguments. Forintegral , the ﬁrst element of the output stream is the speciﬁed\ninitial-value . us, we can generate the ﬁrst element of the output\nstream without evaluating the integrand dy.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 855, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_sicp_abelson_chunk_0856_97840900", "text": "Forintegral , the ﬁrst element of the output stream is the speciﬁed\ninitial-value . us, we can generate the ﬁrst element of the output\nstream without evaluating the integrand dy. Once we know the ﬁrst\nelement of y, the stream-map in the second line of solvecan begin\nworking to generate the ﬁrst element of dy, which will produce the\nnext element of y, and so on.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 856, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 364}}
{"id": "computer_science_sicp_abelson_chunk_0857_0f0f9d3e", "text": "Once we know the ﬁrst\nelement of y, the stream-map in the second line of solvecan begin\nworking to generate the ﬁrst element of dy, which will produce the\nnext element of y, and so on. To take advantage of this idea, we will redeﬁne integral to expect\nthe integrand stream to be a delayed argument .integral willforcethe\nintegrandtobeevaluatedonlywhenitisrequiredtogeneratemorethan\nthe ﬁrst element of the output stream:\n(define (integral delayed-integrand initial-value dt)\n(define int\n(cons-stream\ninitial-value\n(let ((integrand (force delayed-integrand )))\n(add-streams (scale-stream integrand dt)int))))\nint)\nNowwecanimplementour solveprocedurebydelayingtheevaluation\nofdyin the deﬁnition of y:71\n(define (solve fy0dt)\n(define y(integral (delay dy)y0dt))\n(define dy(stream-map fy))\ny)\n71isprocedureisnotguaranteedtoworkinallSchemeimplementations,although\nfor any implementation there is a simple variation that will work.", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 857, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_sicp_abelson_chunk_0858_88f38d7f", "text": "e problem has to\ndo with subtle diﬀerences in the ways that Scheme implementations handle internal\ndeﬁnitions. (See Section 4.1.6 .)\n472", "metadata": {"book_id": "computer_science_sicp_abelson", "book_title": "SICP_Abelson", "category": "computer_science", "chunk_index": 858, "total_chunks": 859, "source_file": "SICP_Abelson.pdf", "file_type": "pdf", "char_count": 137}}
