{"id": "computer_science_design_patterns_gof_chunk_0000_a586faab", "text": "ptg\n\nptgC r e a t i o n a l P a t t e r n s\nA b s t r a c t F a c t o r y ( 8 7) P r o v i d e an interfac e f or c r e a t i n g familie s of r e l a t e d or d e p e n d e n t\no b j e c t s withou t s p e c i f y i n g t h e ir c o n c r e t e c l a s s e s . Builde r ( 9 7) S e p a r a t e t he c o n s t r u c t i o n of a c o m p l e x o b j e c t from i ts r e p r e s e n t a t i o n so\nthat t he s a me c o n s t r u c t i o n p r o c e s s c an c r e a t e differen t r e p r e s e n t a t i o n s . F a c t o r y M e t h o d ( 1 0 7) D e f i n e an interfac e f or c r e a t i n g an o b j e c t , b ut l et s u b c l a s s e s d e -\nc i de w h i c h c l a ss to i n s t a n t i a t e . F a c t o r y M e t h o d l e ts a c l a ss defer instantiatio n to\ns u b c l a s s e s . P r o t o t y p e ( 1 1 7) S p e c i f y t he k i n ds of o b j e c t s to c r e a te u s i ng a prototypica l i n s t a n c e , a nd\nc r e a t e n ew o b j e c t s by c o p y i n g t h is p r o t o t y p e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 0, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_design_patterns_gof_chunk_0001_703ff692", "text": "S i n g l e t o n ( 1 2 7) Ensur e a c l a ss o n ly h as o ne i n s t a n c e , a nd p r o v i d e a g l o b a l p o i nt of\na c c e s s to it. S t r u c t u r a l P a t t e r n s\nAdapte r ( 1 3 9) C o n v e r t t he interfac e of a c l a ss i n to anothe r i n t e r f a c e c l i e n t s e x p e c t . Adapte r l e ts c l a s s e s work t o g e t h e r that c o u l d n ' t o t h e r w i s e b e c a u s e of i n c o m p a t -\ni b le i n t e r f a c e s . B r i d g e ( 1 5 1) D e c o u p l e an a b s t r a c t i o n from i ts implementatio n so that t he t wo c an vary\ni n d e p e n d e n t l y . C o m p o s i t e ( 1 6 3) C o m p o s e o b j e c t s into t r ee structure s to r e p r e s e n t p a r t - w h o l e hierar-\nc h i e s . C o m p o s i t e l e ts c l i e n t s treat individua l o b j e c t s a nd c o m p o s i t i o n s of o b j e c t s\nuniformly. D e c o r a t o r ( 1 7 5) Attac h a d d i t i o n a l r e s p o n s i b i l i t i e s to an o b j e c t d y n a m i c a l l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_design_patterns_gof_chunk_0002_3db59d5c", "text": "D e c o r a t o r ( 1 7 5) Attac h a d d i t i o n a l r e s p o n s i b i l i t i e s to an o b j e c t d y n a m i c a l l y . D e c o r a t o r s\nprovid e a f l e x i b l e alternativ e to s u b c l a s s i n g for extendin g functionality. F a c a d e ( 1 8 5) P r o v i d e a unifie d interfac e to a s et of interface s in a s u b s y s t e m . F a c a d e\ndefine s a h i g h e r - l e v e l interfac e that make s t he s u b s y s t e m e a s i e r to u s e . F l y w e i g h t ( 1 9 5) U se s h a r i n g to s u p p o r t l a r ge number s of f i n e - g r a i n e d o b j e c t s e f f i -\nc i e n t l y . P r o xy ( 2 0 7) P r o v i d e a s u r r o g a t e or p l a c e h o l d e r f or a n o t h e r o b j e c t to c o n t r o l a c c e s s to\ni t . ptgB e h a v i o r a l P a t t e r n s\nChai n of Responsibilit y ( 2 2 3) Avoi d couplin g the s e n d e r of a reques t to its r e c e i v e r by\ng i v i n g more than o ne o b j e c t a c h a n c e to handl e t he r e q u e s t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 2, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_design_patterns_gof_chunk_0003_596f6506", "text": "C h a in t he r e c e i v i n g\no b j e c t s and p a ss the reques t along the chain until an o b j e c t handle s it. C o m m a n d ( 2 3 3) E n c a p s u l a t e a r e q u e s t as an o b j e c t , t h e r e b y l e t t i n g y ou parameter-\nize c l i e n t s with d i f f e r e n t r e q u e s t s , queu e or log r e q u e s t s , and suppor t undoabl e \noperations. Interprete r ( 2 4 3) Give n a language , defin e a representio n for its gramma r along with\nan interprete r that u s es the representatio n to interpre t s e n t e n c e s in the language. Iterato r ( 2 5 7) Provid e a way to a c c e s s the element s of an aggregat e o b j e c t sequentiall y\nwithou t e x p o s i n g i ts u n d e r l y i n g r e p r e s e n t a t i o n . Mediato r ( 2 7 3) Defi n e an o b j e c t that encapsulate s h ow a s et of o b j e c t s interact .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 3, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 850}}
{"id": "computer_science_design_patterns_gof_chunk_0004_d2024821", "text": "Mediato r ( 2 7 3) Defi n e an o b j e c t that encapsulate s h ow a s et of o b j e c t s interact . M e -\nd i a t o r p r o m o t e s l o o se c o u p l i n g by k e e p i n g o b j e c t s from r e f e r r i n g to e a ch o t h er\nexplicitly , and it l e ts you vary their interactio n independently. Mement o ( 2 8 3) Withou t violatin g encapsulation , captur e and externaliz e an o b j e c t ' s\ninterna l state so that the o b j e c t can be restore d to this state later. Observe r ( 2 9 3) Defin e a one-to-man y dependenc y betwee n o b j e c t s so that when one\no b j e c t c h a n g e s state, all its dependent s are notifie d and update d automatically. S t a te ( 3 0 5) Allow an objec t to alter its behavio r when its interna l state c h a n g e s . The\no b j e c t w i ll appea r to c h a n g e i ts c l a s s . Strateg y ( 3 1 5) Defin e a f a m i l y of algorithms , encapsulat e e a ch o n e, and make them\ni n t e r c h a n g e a b l e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 4, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_design_patterns_gof_chunk_0005_330f991a", "text": "The\no b j e c t w i ll appea r to c h a n g e i ts c l a s s . Strateg y ( 3 1 5) Defin e a f a m i l y of algorithms , encapsulat e e a ch o n e, and make them\ni n t e r c h a n g e a b l e . S t r a t e g y l e ts t he algorith m vary i n d e p e n d e n t l y from c l i e n t s that\nuse it. Templat e Metho d ( 3 2 5) D e f i n e t he s k e l e t o n of an a l g o r i t h m in an o p e r a t i o n , deferrin g\ns o me steps to s u b c l a s s e s . Templat e Metho d l e ts s u b c l a s s e s redefin e certai n steps\nof an algorith m w i t h o u t changin g the algorithm' s structure. Visito r ( 3 3 1) Represen t an operatio n to be performe d on the element s of an objec t\nstructure . V i s i t o r l e ts you defin e a new operatio n withou t c h a n g i n g the c l a s s e s of\nt h e elements on which it operates. ptg\nThis page intentionally left blank \n\nptgD e s i g n Patterns\n\nptgA d d i s o n - W e s l e y P r o f e s s i o n a l C o m p u t i n g S e r i e s\nBrian W.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 5, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_design_patterns_gof_chunk_0006_7c1f4a66", "text": "ptg\nThis page intentionally left blank \n\nptgD e s i g n Patterns\n\nptgA d d i s o n - W e s l e y P r o f e s s i o n a l C o m p u t i n g S e r i e s\nBrian W. Kernighan , C o n s u l t i n g Editor\nMatthe w H. Austern , Generic Programming and the STL: Using and Extending the C++ Standard Template Library\nD a v i d R. Butenhof , Programming with POSIX® Threads \nB r e n t C a l l a g h a n , N FS Illustrated \nTom C a r g i l l , C++ Programming Style \nW i l l i a m R. C h es wick /Steve n M. Bellovin/Avie l D. Rubin , Firewalls and Internet Security, Second Edition: Repelling\nthe Wily Hacker\nD a v i d A. Curry , UNIX® System Security: A Guide for Users and System Administrators \nS t e p h e n C.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 6, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 704}}
{"id": "computer_science_design_patterns_gof_chunk_0007_c87ce09a", "text": "Rubin , Firewalls and Internet Security, Second Edition: Repelling\nthe Wily Hacker\nD a v i d A. Curry , UNIX® System Security: A Guide for Users and System Administrators \nS t e p h e n C. Dewhurst , C++ Gotchas: Avoiding Common Problems in Coding and Design \nDan Farmer/Wiets e V e n e m a , Forensic Discovery \nE r i ch Gamma/Richard Helm/Ralp h Johnson/Joh n V l i s s i d e s , Design Patterns: Elements of Reusable Object-\nOriented Software\nErich Gamma/Richar d Helm/Ralp h Johnson/Joh n V l i s s i d e s , Design Patterns CD: Elements of Reusable Object-\nOriented Software\nP e t er H a g g a r , Practical Java\"\" Programming Language Guide \nD a v i d R. H a n s o n , C Interfaces and Implementations: Techniques for Creating Reusable Software \nMark Harrison/Michae l M c L e n n a n , Effective Tcl/Tk Programming: Writing Better Programs with Tcl and Tk \nM i c h i Henning/Stev e V i n o s k i , Advanced CORBA® Programming with C++ \nB r i an W.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 7, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_design_patterns_gof_chunk_0008_4985b1cc", "text": "Kernighan/Ro b P i k e, The Practice of Programming \nS. K e s h a v , An Engineering Approach to Computer Networking: ATM Networks, the Internet, and the Telephone Network \nJ o hn L a k o s , Large-Scale C++ Software Design \nS c o tt M e y e r s , Effective C++ CD: 85 Specific Ways to Improve Your Programs and Designs \nS c o tt M e y e r s , Effective C++, Third Edition: 55 Specific Ways to Improve Your Programs and Designs \nS c o tt M e y e r s , More Effective C++ : 35 New Ways to Improve Your Programs and Designs \nS c o tt M e y e r s , Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library \nRober t B. Murray , C++ Strategies and Tactics \nD a v i d R. M u s s e r / G i l l m e r J. D e r g e / A t u l S a i n i , S TL Tutorial a nd Reference Guide, Second Edition:\nC++ Programming with the Standard Template Library\nJohn K.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 8, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 866}}
{"id": "computer_science_design_patterns_gof_chunk_0009_eb00ca2a", "text": "M u s s e r / G i l l m e r J. D e r g e / A t u l S a i n i , S TL Tutorial a nd Reference Guide, Second Edition:\nC++ Programming with the Standard Template Library\nJohn K. Ousterhout , Tel and the Tk Toolkit \nC r a ig Partridge , Gigabit Networking \nR a d i a P e r l m a n , Interconnections, Second Edition: Bridges, Routers, Switches, and Internetworking Protocols \nS t e p h e n A. R a g o , UNIX® System V Network Programming \nEric S. Raymond , The Art of UNIX Programming \nM a rc J. R o c h k i n d , Advanced UNIX Programming, Second Edition \nC u rt S c h i m m e l , UNIX® Systems for Modern Architectures: Symmetric Multiprocessing and Caching for Kernel Programmers\nW. Richar d S t e v e n s , TCP/IP Illustrated, Volume 1: The Protocols \nW. Richar d S t e v e n s , TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP, and the UNIX®\nDomain Protocols\nW. Richar d S t e v e n s / B i l l Fenner/Andre w M.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 9, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_design_patterns_gof_chunk_0010_c385c279", "text": "Richar d S t e v e n s , TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP, and the UNIX®\nDomain Protocols\nW. Richar d S t e v e n s / B i l l Fenner/Andre w M. Rudoff , UNIX Network Programming Volume 1, Third Edition: The \nSockets Networking API\nW. Richar d S t e v e n s / S t e p h e n A. Rago , Advanced Programming in the UNIX® Environment, Second Edition\nW. R i c h a r d S t e v e n s / G a r y R. W r i g h t , TCP/IP Illustrated Volumes 1-3 Boxed Set \nJ o hn Viega/Gar y M c G r a w , Building Secure Software: How to Avoid Security Problems the Right Way \nGary R. Wright/W . Richar d S t e v e n s , TCP/IP Illustrated, Volume 2: The Implementation \nRuixi Yuan/W. Timothy Strayer, Virtual Private Networks: T e c h n o l o g i e s and S o l u t i o n s\nV i s i t www.awprofessional.com/series/professionalcomputing for more information about t h e s e titles.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 10, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 883}}
{"id": "computer_science_design_patterns_gof_chunk_0011_d2c8c0ae", "text": "Timothy Strayer, Virtual Private Networks: T e c h n o l o g i e s and S o l u t i o n s\nV i s i t www.awprofessional.com/series/professionalcomputing for more information about t h e s e titles. ptgD e s i g n Patterns\nE l e m e n t s of Reusable Object-Oriented Software\nE r i ch G a m m a\nR i c h a r d H e l m\nR a l p h J o h n s o n\nJ o h n V l i s s i d e s\nB o s t o n • San F r a n c i s c o • New Y o rk • T o r o n t o • M o n t r e a l\nL o n d o n • Munic h • P a r is • M a d r i d \nCapetown • S i d n e y • T o k y o • S i n g a p o r e • M e x i c o C i t y\n\nptgM a t e r i a l f r om A Pattern Language: Towns/Buildings/Construction by C h r i s t o p h e r A l e x a n d e r ,\nc o p y r i g h t © 1 9 77 by C h r i s t o p h e r A l e x a n d e r is r e p r i n t e d by p e r m i s s i o n of O x f o r d U n i v e r s i t y\nP r e s s , I n c .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 11, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 861}}
{"id": "computer_science_design_patterns_gof_chunk_0012_fc18f7b2", "text": "Many of t he d e s i g n a t i o n s used by manufacturer s a nd s e l l e r s to d i s t i n g u i s h t h e ir product s a re c l a i m e d as\ntrademarks . W h e r e t h o se d e s i g n a t i o n s a p p e a r in t h is b o o k , a nd we were awar e of a trademar k claim , t he\nd e s i g n a t i o n s have b e en p r i n t e d in i n i t i a l c a p i t a l l e t t e r s or in a ll capitals. T he a u t h o r a nd p u b l i s h e r h a ve t a k en c a re in t he p r e p a r a t i o n of t h is b o o k , b ut m a ke no e x p r e s s e d or\ni m p l i e d warrant y of a ny k i nd a nd a s s u m e no r e s p o n s i b i l i t y f or error s or o m i s s i o n s . No l i a b i l i t y is\na s s u m e d f or i n c i d e n t a l or c o n s e q u e n t i a l d a m a g e s in c o n n e c t i o n with or a r i s i n g o ut of t he u se of t he\ninformatio n or program s c o n t a i n e d herein.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 12, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 898}}
{"id": "computer_science_design_patterns_gof_chunk_0013_f19c8a00", "text": "T he p u b l i s h e r offers d i s c o u n t s on t h is b o ok w h en o r d e r e d in quantit y f or s p e c i a l s a l e s. F or m o re i n f o r m a -\nt i o n, p l e a s e c o n t a c t :\nP e a r s o n Educatio n C o r p o r a t e S a l es Divisio n\n2 01 W. 1 0 3 rd S t r e e t \nI n d i a n a p o l i s , IN 4 6 2 90 \n( 8 0 0) 4 2 8 - 5 3 3 1\nc o r p s a l e s @ p e a r s o n e d . c o m\nV i s it AW on t he W e b: w w w . a w p r o f e s s i o n a l . c o m\nLibrary of Congress Cataloging-in-Publication Data\nD e s i g n Pattern s : e l e m e n t s of r e u s a b l e o b j e c t - o r i e n t e d softwar e / E r i ch Gamm a ... [et a l . ]. p. cm.—(Addison-Wesle y professiona l computin g s e r i e s )\nI n c l u d e s b i b l i o g r a p h i c a l r e f e r e n c e s a nd i n d e x . I S BN 0 - 2 0 1 - 6 3 3 6 1 - 2\n1. O b j e c t - o r i e n t e d programmin g ( C o m p u t e r s c i e n c e ) 2. C o m p u t e r software—Reusability. I. Gamma , Erich . II. S e r i e s . Q A 7 6 . 6 4 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 13, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_design_patterns_gof_chunk_0014_0dc59bcb", "text": "I S BN 0 - 2 0 1 - 6 3 3 6 1 - 2\n1. O b j e c t - o r i e n t e d programmin g ( C o m p u t e r s c i e n c e ) 2. C o m p u t e r software—Reusability. I. Gamma , Erich . II. S e r i e s . Q A 7 6 . 6 4 . D 4 7 1 9 9 4\n0 0 5 . 1 ' 2 - d c 2 0 9 4 - 3 4 2 6 4\nC I P\nC o p y r i g h t © 1 9 95 by A d d i s o n - W e s l e y\nA ll r i g h ts r e s e r v e d . No part of this publicatio n m ay be r e p r o d u c e d , s t o r ed in a r e t r i e v a l s y s t e m , or\nt r a n s m i t t e d , in a ny form , or by a ny m e a n s , e l e c t r o n i c , m e c h a n i c a l , p h o t o c o p y i n g , r e c o r d i n g , or o t h e r -\nwise, w i t h o u t t he p r i or c o n s e n t of t he p u b l i s h e r . P r i n t e d in t he U n i t e d S t a t es of A m e r i c a . P u b l i s h e d\ns i m u l t a n e o u s l y in Canada. C o v e r art © M.C. Escher/Cordon Art - Baarn - Holland. All rights reserved.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 14, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_design_patterns_gof_chunk_0015_4131c1c9", "text": "P r i n t e d in t he U n i t e d S t a t es of A m e r i c a . P u b l i s h e d\ns i m u l t a n e o u s l y in Canada. C o v e r art © M.C. Escher/Cordon Art - Baarn - Holland. All rights reserved. I S B N 0 - 2 0 1 - 6 3 3 6 1 - 2\nT e x t printed in the United States on recycled paper at Courier Westford in Westford, Massachusetts. 3 7 t h P r i n t i n g M a r c h 2 0 0 9\n\nptgTo Karin\n—E.G. To S y l v i e\n—R.H. To Faith\n-R.J. To D r u A n n a n d M a t t h e w\nJoshua 2 4 : 1 5 b\n—J.v. ptgP r a i s e for Design Patterns: Elements of Reusable\nObject-Oriented Software\n\" T h is is o ne of t he b e st writte n a nd wonderfull y insightfu l b o o k s that I have r e ad in a g r e at l o ng w h i l e . . . t h i s\nb o ok e s t a b l i s h e s t he l e g i t i m a c y of pattern s in t he b e st way: n ot by argumen t b ut by e x a m p l e . \"\n— S t an L i p p m a n , C ++ Report\n\" . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 15, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 896}}
{"id": "computer_science_design_patterns_gof_chunk_0016_add95123", "text": ". . t h i s\nb o ok e s t a b l i s h e s t he l e g i t i m a c y of pattern s in t he b e st way: n ot by argumen t b ut by e x a m p l e . \"\n— S t an L i p p m a n , C ++ Report\n\" . . . t h i s n ew b o ok by G a m m a , Helm , Johnson , a nd V l i s s i d e s p r o m i s e s to have an i m p o r t a n t a nd l a s t i n g\ni m p a c t on t he d i s c i p l i n e of softwar e d e s i g n . B e c a u s e Design Patterns b i l ls i t s e lf as b e i ng c o n c e r n e d with\no b j e c t - o r i e n t e d softwar e a l o n e , I fear that softwar e d e v e l o p e r s o u t s i d e the o b j e c t communit y may i g n o r e it. T h is woul d be a s h a m e . T h is b o ok h as s o m e t h i n g f or e v e r y o n e w ho d e s i g n s software . A ll softwar e design-\ne rs u se p a t t e r n s ; understandin g b e t t e r t he r e u s a b l e a b s t r a c t i o n s of o ur work c an only m a ke us b e t t er at i t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 16, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_design_patterns_gof_chunk_0017_ad1ada6f", "text": "A ll softwar e design-\ne rs u se p a t t e r n s ; understandin g b e t t e r t he r e u s a b l e a b s t r a c t i o n s of o ur work c an only m a ke us b e t t er at i t . \"\n— T om D e M a r c o , IEEE Software\n\" O v e r a l l , I think this b o ok r e p r e s e n t s an e x t r e m e l y v a l u a b l e a nd uniqu e contributio n to t he field b e c a u s e\nit c a p t u r e s a wealt h of o b j e c t - o r i e n t e d d e s i g n e x p e r i e n c e in a c o m p a c t a nd r e u s a b l e form . T h is b o ok is\nc e r t a i n l y o ne that I s h a ll turn to often in s e a r c h of powerfu l o b j e c t - o r i e n t e d d e s i g n i d e a s ; after a l l, that's\nwhat r e u se is a ll about , isn't i t ? \"\n— S a n j i v G o s s a i n , Journal of Object-Oriented Programming\n\" T h is m u c h - a n t i c i p a t e d b o ok l i v es up to i ts f u ll year of a d v a n c e buzz .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 17, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 894}}
{"id": "computer_science_design_patterns_gof_chunk_0018_26485f55", "text": "\"\n— S a n j i v G o s s a i n , Journal of Object-Oriented Programming\n\" T h is m u c h - a n t i c i p a t e d b o ok l i v es up to i ts f u ll year of a d v a n c e buzz . T he m e t a p h o r is of an architect' s\np a t t e r n b o ok f i l l ed with t i m e - t e s t e d , u s a b l e d e s i g n s . T he author s have c h o s e n 23 pattern s from d e c a d e s of\no b j e c t - o r i e n t e d e x p e r i e n c e . T he b r i l l i a n c e of t he b o ok l i es in t he d i s c i p l i n e r e p r e s e n t e d by that number . G i ve a c o py of Design Patterns to e v e ry g o od p r o g r a m m e r y ou know w ho want s to be b e t t e r . \"\n— L a r r y O ' B r i e n , Software Development\n\" T he s i m p l e fact of t he m a t t e r is that p a t t e r n s have t he p o t e n t i a l to p e r m a n e n t l y a l t er t he softwar e\ne n g i n e e r i n g field, catapultin g it into t he r e a lm of true e l e g a n t d e s i g n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 18, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_design_patterns_gof_chunk_0019_356a816f", "text": "Of t he b o o k s to d a te on t h is s u b j e c t ,\nDesign Patterns is f ar a nd away t he b e s t. It is a b o ok to be r e a d, s t u d i e d , i n t e r n a l i z e d , a nd l o v e d . T he b o ok\nwill foreve r c h a n g e the way you v i ew software.\"\n— S t e ve B i l o w , Journal of Object-Oriented Programming\n\"Design Patterns is a powerfu l b o o k . After a m o d e s t investmen t of t i me with it, m o st C++ p r o g r a m m e r s\nw i ll be a b le to s t a rt a p p l y i n g i ts \" p a t t e r n s \" to p r o d u c e b e t t e r software . T h is b o ok d e l i v e r s i n t e l l e c t u a l\nl e v e r a g e : c o n c r e t e t o o ls that h e lp us think a nd e x p r e s s o u r s e l v e s m o re effectively . It m ay fundamentall y\nc h a n g e the way you think about programming. — Tom Cargill, C + + Report\n\nptgC o n t e n t s\nP r e f a c e xi\nF o r e w o r d xiii\nGuide to Readers xv\n1 Introduction 1\n1 . 1 What Is a Design Pattern? 2\n1 . 2 Design Patterns in Smalltalk MVC 4\n1 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 19, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_design_patterns_gof_chunk_0020_b8c49397", "text": "— Tom Cargill, C + + Report\n\nptgC o n t e n t s\nP r e f a c e xi\nF o r e w o r d xiii\nGuide to Readers xv\n1 Introduction 1\n1 . 1 What Is a Design Pattern? 2\n1 . 2 Design Patterns in Smalltalk MVC 4\n1 . 3 Describing Design Patterns 6\n1 . 4 The Catalog of Design Patterns 8\n1 . 5 Organizing the Catalog 9\n1 . 6 How Design Patterns Solve Design Problems 11\n1 . 7 H o w t o Select a Design Pattern 28\n1 . 8 H o w t o U s e a Design Pattern 29\n2 A Case Study: Designing a D o c u m e n t Editor 33\n2 . 1 Design Problems 33\n2 . 2 Document Structure 35\n2 . 3 Formatting 40\n2 . 4 Embellishing the User Interface . 4 3\n2 . 5 Supporting Multiple Look-and-Feel Standards 47\n2 . 6 Supporting Multiple Window Systems 51\n2 . 7 User Operations i 58\n2 . 8 Spelling Checking and Hyphenation 64\nv i i\n\nptgv i i i CONTENTS\n2 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 20, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 807}}
{"id": "computer_science_design_patterns_gof_chunk_0021_322526e5", "text": "4 3\n2 . 5 Supporting Multiple Look-and-Feel Standards 47\n2 . 6 Supporting Multiple Window Systems 51\n2 . 7 User Operations i 58\n2 . 8 Spelling Checking and Hyphenation 64\nv i i\n\nptgv i i i CONTENTS\n2 . 9 Summary 76\nD e s i g n P a t t e r n C a t a l o g 7 9\n3 C r e a t i o n a l P a t t e r n s 81\nA b s t r a c t F a c t o r y 87\nB u i l d e r 97\nF a c t o r y M e t h o d 1 07\nP r o t o t y p e 1 17 \nS i n g l e t o n 1 2 7\nD i s c u s s i o n of C r e a t i o n a l P a t t e r n s 1 3 5\n4 S t r u c t u r a l P a t t e r n s 1 37\nA d a p t e r 1 39\nB r i d g e 1 51\nC o m p o s i t e 1 63\nD e c o r a t o r 1 75\nF a c a d e 1 85\nF l y w e i g h t 1 95 \nP r o xy 2 0 7\nD i s c u s s i o n of S t r u c t u r a l P a t t e r n s 2 1 9\n5 B e h a v i o r a l P a t t e r n s 2 21\nC h a in of R e s p o n s i b i l i t y 2 23\nC o m m a n d 2 33\nI n t e r p r e t e r 2 43\nI t e r a t o r 2 57\nM e d i a t o r 2 73\nM e m e n t o 2 83 \nO b s e r v e r 2 93\nS t a te 3 05\nS t r a t e g y 315\n\nptgCONTENTS ix\nT e m p l a t e Method 325\nV i s i t o r 331\nD i s c u s s i o n of Behavioral Patterns 345\n6 Conclusion 351\n6 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 21, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1119}}
{"id": "computer_science_design_patterns_gof_chunk_0022_34346a83", "text": "1 What t o Expect from Design Patterns 351\n6 . 2 A Brief H i s t o r y 355\n6 . 3 The Pattern Community 356\n6 . 4 An Invitation 358\n6 . 5 A Parting Thought 358\nA G l o s s a r y 359\nB Guide to Notation 363\nB . I Class Diagram 363\nB . 2 Object Diagram 364\nB . 3 Interaction Diagram 366\nC F o u n d a t i o n Classes 369\nC . 1 List 369\nC . 2 Iterator 372\nC . 3 L i s t l t e r a t o r 372\nC . 4 Point 373\nC . 5 Rect 374\nB i b l i o g r a p h y 375\nI n d e x 383\n\nptg\nThis page intentionally left blank \n\nptgP r e f a c e\nT h is b ook i s n 't an introductio n to o b j e c t - o r i e n t e d t e c h n o l o g y or d e s i g n . Many b o o k s\nalread y do a g o od j ob of that. T h is b o ok a s s u m e s y ou a re r e a s o n a b l y proficien t in at l e a st\no ne o b j e c t - o r i e n t e d programmin g l a n g u a g e , a nd y ou s h o u l d h a ve s o me e x p e r i e n c e in\no b j e c t - o r i e n t e d d e s i g n as w e l l.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 22, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_design_patterns_gof_chunk_0023_15275d9e", "text": "Y ou d e f i n i t e l y s h o u l d n ' t h a ve to rush to t he n e a r e s t\nd i c t i o n a r y t he momen t we m enti o n \" t y p e s \" a nd \" p o l y m o r p h i s m , \" or \" i n t e r f a c e \" as\no p p o s e d to \" i m p l e m e n t a t i o n \" i n h e r i t a n c e . On t he o t h er hand , t h is i s n 't an a d v a n c e d t e c h n i c a l t r e a t i s e e i t h e r . I t 's a b o ok of d e s i g n\npattern s that d e s c r i b e s s i m p l e a nd e l e g a n t s o l u t i o n s to s p e c i f i c p r o b l e m s in o b j e c t -\no r i e n t e d softwar e d e s i g n . D e s i g n pattern s captur e s o l u t i o n s that have d e v e l o p e d a nd\ne v o l v e d o v er time. H e n c e t h ey aren' t t he d e s i g n s p e o p l e t e nd to g e n e r a t e i n i t i a l l y . T h ey\nreflec t untol d r e d e s i g n a nd r e c e d i n g as d e v e l o p e r s have s t r u g g l e d f or g r e a t e r r e u se \na nd f l e x i b i l i t y in their software .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 23, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_design_patterns_gof_chunk_0024_88416dca", "text": "T h ey\nreflec t untol d r e d e s i g n a nd r e c e d i n g as d e v e l o p e r s have s t r u g g l e d f or g r e a t e r r e u se \na nd f l e x i b i l i t y in their software . D e s i g n pattern s captur e t h e se s o l u t i o n s in a s u c c i n c t\na nd e a s i ly a p p l i e d f o r m . The d e s i g n pattern s requir e n e i t h e r unusua l l a n g u a g e feature s nor amazin g program-\nming t r i c ks with w h i c h to astoun d your friend s and m a n a g e r s . All can be i m p l e m e n t e d \nin standar d o b j e c t - o r i e n t e d l a n g u a g e s , thoug h they migh t take a l i t t le m o re work than\nad hoc s o l u t i o n s . But the extra e f f o r t invariabl y pays d i v i d e n d s in i n c r e a s e d flexibilit y\nand r e u s a b i l i t y . O n ce you understan d the d e s i g n pattern s and have had an \" A h a ! \" (and not just a\n\" H u h ?", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 24, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 891}}
{"id": "computer_science_design_patterns_gof_chunk_0025_2df20341", "text": "O n ce you understan d the d e s i g n pattern s and have had an \" A h a ! \" (and not just a\n\" H u h ? \" ) e x p e r i e n c e with t h e m , y ou won' t e v er t h i nk abou t o b j e c t - o r i e n t e d d e s i g n in\nt he s a me w a y. Y o u ' l l have i n s i g h t s that c an make your o wn d e s i g n s more f l e x i b l e ,\nmodular , r e u s a b l e , a nd understandable—whic h is w hy you'r e i n t e r e s t e d in o b j e c t -\no r i e n t e d t e c h n o l o g y in t he first p l a c e , ri g ht? A word of warnin g and e n c o u r a g e m e n t : D o n ' t worr y if you don't understan d t h is\nbo ok c o m p l e t e l y on t he first r e a d i n g . We didn' t understan d it a ll on t he f i r st w r i t i n g ! Remembe r that t h is i s n 't a book to read o n ce and put on a s h e l f . We h o pe y o u ' l l find\ny o u r s e l f referrin g to it a g a in and a g a in for d e s i g n i n s i g h t s and for inspiration. T h is book h as h ad a l o ng g e s t a t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 25, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_design_patterns_gof_chunk_0026_abdb4e84", "text": "We h o pe y o u ' l l find\ny o u r s e l f referrin g to it a g a in and a g a in for d e s i g n i n s i g h t s and for inspiration. T h is book h as h ad a l o ng g e s t a t i o n . It h as s e en f o ur c o u n t r i e s , t h r ee of i ts authors '\nmarriages , and the birth of two (unrelated ) offspring . Many p e o p l e have had a part\nin i ts development . S p e c i a l thank s a re d ue Bruce A n d e r s o n , K e nt B e c k , a nd Andr e\nW e i n a n d f o r their inspiration a n d a d v i c e . We also thank those w h o r e v i e w e d d r a f t s\nXI\n\nptgx ii PREFACE\nof t he m a n u s c r i p t : R o g e r B i e l e f e l d , Grad y B o o c h , T om C a r g i l l , M a r s h a l l C l i n e , Ralp h\nH y r e , B r i an K e r n i g h a n , T h o m a s L a l i b e r t y , Mark L o r e n z , Arthu r R i e l, D o ug S c h m i d t ,\nC l o v i s T o n d o , S t e ve V i n o s k i , a nd R e b e c c a W i r f s - B r o c k .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 26, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 941}}
{"id": "computer_science_design_patterns_gof_chunk_0027_979ab95c", "text": "We a re a l so gratefu l to t he\nteam at A d d i s o n - W e s l e y f or t h e ir h e lp a nd p a t i e n c e : Kate H a b i b , Tiffan y M o o r e , L i sa\nRaffaele , P r a d e e p a S i v a, a nd John Wait . S p e c i a l t h a n k s to C a rl K e s s l e r , D a n n y S a b b a h ,\na nd Mark W e g m a n at I BM R e s e a r c h f or t h e ir unflaggin g suppor t of t h is work. L a st b ut c e r t a i n l y n ot l e a s t, we thank e v e r y o n e on t he I n t e r n e t a nd p o i n t s b e y o n d w ho\nc o m m e n t e d on v e r s i o n s of t he patterns , offere d e n c o u r a g i n g w o r d s , a nd t o ld us that\nwhat we w e re d o i ng w as w o r t h w h i l e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 27, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 682}}
{"id": "computer_science_design_patterns_gof_chunk_0028_c4e6c908", "text": "T h e se p e o p l e i n c l u d e b ut a re n ot l i m i t e d to \nJ on A v o t i n s , S t e ve B e r c z u k , J u l i a n B e r d y c h , Matthia s B o h l e n , J o hn B r a n t , A l l an C l a r k e ,\nPaul C h i s h o l m , J e ns C o l d e w e y , D a ve C o l l i n s , J im C o p l i e n , D on D w i g g i n s , G a b r i e l e E l i a,\nD o ug F e l t, B r i an F o o t e , D e n is F o r t i n , W a rd H a r o l d , H e r m a n n H u e n i , N a y e e m I s l a m ,\nBikramji t K a l r a , P a ul K e e f e r , T h o m a s Kofler , D o ug L e a, D an L a L i b e r t e , J a m e s L o n g ,\nA nn L o u i s e L u u, P u n d i M a d h a v a n , B r i an M a r i c k , R o b e r t M a r t i n , D a ve M c C o m b , Carl\nM c C o n n e l l , C h r i s t i n e M i n g i n s , H a n s p e t e r M o s s e n b o c k , E r ic N e w t o n , M a r i a n n e O z k a n ,\nR o x s a n P a y e t t e , Larry P o d m o l i k , G e o r g e R a d i n , S i ta R a m a k r i s h n a n , R u ss R a m i r e z ,\nA l e x a n d e r R a n, D i rk R i e h l e , B r y a n R o s e n b u r g , Aamo d S a n e, D u ri S c h m i d t , R o b e r t\nS e i d l , X in S h u, a nd B i ll W a l k e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 28, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1181}}
{"id": "computer_science_design_patterns_gof_chunk_0029_a7a249da", "text": "We d o n 't c o n s i d e r t h is c o l l e c t i o n of d e s i g n pattern s c o m p l e t e a nd s t a t i c ; i t 's m o re a\nr e c o r d i n g of o ur c u r r e n t t h o u g h t s on d e s i g n . We w e l c o m e c o m m e n t s on i t, w h e t h e r\nc r i t i c i s m s of o ur e x a m p l e s , r e f e r e n c e s a nd know n u s es w e ' ve m i s s e d , or d e s i g n pat-\nt e r ns we s h o u l d have i n c l u d e d . Y ou c an write us c a re of A d d i s o n - W e s l e y , or s e nd\ne l e c t r o n i c m a il to d e s i g n - p a t t e r n s @ c s . u i u c . edu. Y ou c an a l so o b t a i n softcop y \nf or t he c o de in t he S a m p l e C o de s e c t i o n s by s e n d i n g t he m e s s a g e \" s e nd d e s i g n patter n\ns o u r c e \" to d e s i g n - p a t t e r n s - s o u r c e i c s . u i u c . e d u. And now t h e r e ' s a Web p a ge\nat h t t p : / / s t - w w w . c s . u i u c . e d u / u s e r s / p a t t e r n s / D P B o o k / D P B o o k .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 29, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_design_patterns_gof_chunk_0030_1072e062", "text": "u i u c . e d u. And now t h e r e ' s a Web p a ge\nat h t t p : / / s t - w w w . c s . u i u c . e d u / u s e r s / p a t t e r n s / D P B o o k / D P B o o k . h t m l f or\nl a t e - b r e a k i n g i n f o r m a t i o n and u p d a t e s . Mountain V i e w , California E.G. Montreal, Q u e b e c R.H. Urbana, Illinois R.J. Hawthorne, New Y o r k J.V. August 1 9 9 4\n\nptgF o r e w o r d\nA ll w e l l - s t r u c t u r e d o b j e c t - o r i e n t e d a r c h i t e c t u r e s a re full of patterns . I n d e e d , o ne of t he\nways that I measur e the qualit y of an o b j e c t - o r i e n t e d s y s t e m is to judge whethe r or\nnot its d e v e l o p e r s have p a id carefu l attentio n to the c o m m o n c o l l a b o r a t i o n s amon g its\no b j e c t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 30, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 774}}
{"id": "computer_science_design_patterns_gof_chunk_0031_36f6e8a8", "text": "F o c u s i n g on s u ch m e c h a n i s m s durin g a s y s t e m ' s d e v e l o p m e n t c an y i e ld an\narchitectur e that is s m a l l e r , s i m p l e r , and far m o re understandabl e than if t h e se pattern s\na re i g n o r e d . T he importanc e of pattern s in craftin g c o m p l e x s y s t e m s h as b e en l o ng r e c o g n i z e d in\no t h er d i s c i p l i n e s . In p a r t i c u l a r , C h r i s t o p h e r A l e x a n d e r a nd h is c o l l e a g u e s w e re p e r h a p s\nthe first to p r o p o s e the i d ea of u s i ng a patter n languag e to a r c h i t e c t b u i l d i n g s and c i t i e s . H is i d e as a nd t he c o n t r i b u t i o n s of o t h e r s have n ow taken r o ot in t he o b j e c t - o r i e n t e d\nsoftwar e c o m m u n i t y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 31, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 789}}
{"id": "computer_science_design_patterns_gof_chunk_0032_b7e0bf0a", "text": "H is i d e as a nd t he c o n t r i b u t i o n s of o t h e r s have n ow taken r o ot in t he o b j e c t - o r i e n t e d\nsoftwar e c o m m u n i t y . In s h o r t , t he c o n c e p t of t he d e s i g n patter n in softwar e p r o v i d e s a\nk ey to helpin g d e v e l o p e r s l e v e r a g e t he e x p e r t i s e of o t h er s k i l l e d a r c h i t e c t s . In this b o o k , E r i ch Gamma , R i c h a r d H e l m , Ralp h J o h n s o n , a nd J o hn V l i s s i d e s introduc e\nt he p r i n c i p l e s of d e s i g n pattern s a nd then o f f er a c a t a l o g of s u ch patterns . T h u s , t h is\nb o ok m a k e s t wo i m p o r t a n t c o n t r i b u t i o n s . F i r s t, it s h o w s t he r o le that p a t t e r n s c an p l ay\nin architectin g c o m p l e x s y s t e m s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 32, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 803}}
{"id": "computer_science_design_patterns_gof_chunk_0033_7fc3062e", "text": "T h u s , t h is\nb o ok m a k e s t wo i m p o r t a n t c o n t r i b u t i o n s . F i r s t, it s h o w s t he r o le that p a t t e r n s c an p l ay\nin architectin g c o m p l e x s y s t e m s . S e c o n d , it p r o v i d e s a very pragmati c referenc e to a s et\nof w e l l - e n g i n e e r e d pattern s that the p r a c t i c i n g d e v e l o p e r can apply to craftin g his or\nher own s p e c i f i c a p p l i c a t i o n s . I'm h o n o r e d to have had the opportunit y to work d i r e c t l y with s o me of the author s of\nt h is b ook in architectura l d e s i g n efforts . I have l e a r n e d much from them , and I s u s p e c t\nthat in reading this book, you will also. Grady Booch\nC h i e f Scientist, Rational S o f t w a r e Corporation\nxm\n\nptg\nThis page intentionally left blank \n\nptgG u i d e to Readers\nT h is b ook has two main parts .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 33, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 870}}
{"id": "computer_science_design_patterns_gof_chunk_0034_a5122cf6", "text": "Grady Booch\nC h i e f Scientist, Rational S o f t w a r e Corporation\nxm\n\nptg\nThis page intentionally left blank \n\nptgG u i d e to Readers\nT h is b ook has two main parts . The first part (Chapter s 1 and 2) d e s c r i b e s what d e s i g n\npattern s a re a nd h ow they h e lp y ou d e s i g n o b j e c t - o r i e n t e d software . It i n c l u d e s a d e s i g n\nc a se study that demonstrate s h ow d e s i g n pattern s apply in p r a c t i c e . T he s e c o n d part\nof t he bo ok (Chapter s 3,4, a nd 5) is a c a t a l o g of t he actua l d e s i g n patterns. The catalo g make s up the majorit y of the b o o k . Its chapter s d i v i d e the d e s i g n pattern s\ninto three t y p e s : c r e a t i o n a l , structural , a nd b e h a v i o r a l . Y ou c an u se t he c a t a l o g hi s e v e r a l\nways . You can r e ad the c a t a l o g from start to finish , or you can just b r o w s e from patter n \nto pattern . Anothe r approac h is to study o ne of t he chapters .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 34, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_design_patterns_gof_chunk_0035_4db1f402", "text": "You can r e ad the c a t a l o g from start to finish , or you can just b r o w s e from patter n \nto pattern . Anothe r approac h is to study o ne of t he chapters . T h at w i ll help y ou s ee\nh ow c l o s e l y r e l a t e d pattern s d i s t i n g u i s h t h e m s e l v e s . You can use the r e f e r e n c e s betwee n the pattern s as a l o g i c a l route throug h the c a t a l o g . T h is approac h w i ll g i ve y ou i n s i g h t into h ow pattern s relate to e a ch o t h e r , h ow they c an\nbe c o m b i n e d with o t h er patterns , a nd w h i c h pattern s work w e ll t o g e t h e r . F i g u r e 1 .1\n( p a ge 1 2) d e p i c t s t h e se r e f e r e n c e s g r a p h i c a l l y . Y et anothe r w ay to r e ad t he c a t a l o g is to u se a more p r o b l e m - d i r e c t e d a p p r o a c h .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 35, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 822}}
{"id": "computer_science_design_patterns_gof_chunk_0036_41edc65a", "text": "Y et anothe r w ay to r e ad t he c a t a l o g is to u se a more p r o b l e m - d i r e c t e d a p p r o a c h . S k ip\nto S e c t i o n 1 .6 ( p a ge 2 4) to r e ad abou t s o me c o m m o n p r o b l e m s hi d e s i g n i n g r e u s a b l e\no b j e c t - o r i e n t e d software ; then r e ad the pattern s that a d d r e s s t h e se p r o b l e m s . S o me\np e o p l e r e ad the c a t a l o g throug h first and then use a p r o b l e m - d i r e c t e d approac h to\napply the pattern s to their p r o j e c t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 36, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 526}}
{"id": "computer_science_design_patterns_gof_chunk_0037_631034fc", "text": "S o me\np e o p l e r e ad the c a t a l o g throug h first and then use a p r o b l e m - d i r e c t e d approac h to\napply the pattern s to their p r o j e c t s . If you aren' t an e x p e r i e n c e d o b j e c t - o r i e n t e d d e s i g n e r , then start with the s i m p l e s t and\nm o st c o m m o n patterns:\n• Abstrac t Factor y ( p a ge 8 7) • Factor y M e t h o d ( 1 0 7 )\n• Adapte r ( 1 3 9) • O b s e r v e r ( 2 9 3 )\n• C o m p o s i t e ( 1 6 3) • S t r a t e g y ( 3 1 5 )\n• Decorato r ( 1 7 5) • T e m p l a t e Metho d ( 3 2 5 )\nI t 's hard to f i nd an o b j e c t - o r i e n t e d s y s t e m that d o e s n ' t u se at l e a st a c o u p l e of t h e se\npatterns , a nd l a r ge s y s t e m s u se nearl y a ll of them . T h is s u b s e t w i ll h e lp y ou understan d\nd e s i g n p a t t e r n s in particular and good object-oriented design in general.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 37, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 885}}
{"id": "computer_science_design_patterns_gof_chunk_0038_000decc2", "text": "T h is s u b s e t w i ll h e lp y ou understan d\nd e s i g n p a t t e r n s in particular and good object-oriented design in general. xv\n\nptg\nThis page intentionally left blank \n\nptgC h a p t e r 1\nI n t r o d u c t i o n\nD e s i g n i n g o b j e c t - o r i e n t e d softwar e is hard, a nd d e s i g n i n g reusable o b j e c t - o r i e n t e d soft-\nware is e v en h a r d e r . Y ou must f i nd p e r t i n e n t o b j e c t s , facto r them into c l a s s e s at t he\nr i g ht granularity , defin e c l a ss interface s a nd i n h e r i t a n c e h i e r a r c h i e s , a nd e s t a b l i s h k ey\nr e l a t i o n s h i p s amon g t h e m . Your d e s i g n s h o u l d be s p e c i f i c to t he p r o b l e m at hand b ut\na l so g e n e r a l e n o u g h to a d d r e s s futur e p r o b l e m s a nd r e q u i r e m e n t s . Y ou a l so want to\na v o id r e d e s i g n , or at l e a st m i n i m i z e i t.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 38, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_design_patterns_gof_chunk_0039_4eb108ad", "text": "Y ou a l so want to\na v o id r e d e s i g n , or at l e a st m i n i m i z e i t. E x p e r i e n c e d o b j e c t - o r i e n t e d d e s i g n e r s w i ll t e ll\ny ou that a r e u s a b l e a nd f l e x i b l e d e s i g n is difficul t if n ot i m p o s s i b l e to g et \" r i g h t \" t he f i r st\nt i m e. B e f o r e a d e s i g n is f i n i s h e d , they u s u a l l y t ry to r e u se it s e v e r a l t i m e s , modifyin g it\ne a ch t i m e . Y et e x p e r i e n c e d o b j e c t - o r i e n t e d d e s i g n e r s do make g o od d e s i g n s . M e a n w h i l e n ew\nd e s i g n e r s a re o v e r w h e l m e d by t he o p t i o n s a v a i l a b l e a nd tend to fall back on n o n -\no b j e c t - o r i e n t e d t e c h n i q u e s they'v e u s ed before . It takes a l o ng t i me f or n o v i c e s to l e a rn\nwhat g o od o b j e c t - o r i e n t e d d e s i g n is a ll a b o u t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 39, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 910}}
{"id": "computer_science_design_patterns_gof_chunk_0040_2b6e5aa9", "text": "It takes a l o ng t i me f or n o v i c e s to l e a rn\nwhat g o od o b j e c t - o r i e n t e d d e s i g n is a ll a b o u t . E x p e r i e n c e d d e s i g n e r s e v i d e n t l y know\ns o m e t h i n g i n e x p e r i e n c e d o n es don't . Wha t is i t ? O ne t h i ng e x p e r t d e s i g n e r s know n ot to do is s o l ve e v e ry p r o b l e m from f i r st p r i n c i p l e s . R a t h e r , they r e u se s o l u t i o n s that have worke d for them in the past. Whe n they find a\ng o od s o l u t i o n , they u se it a g a in a nd a g a i n . S u ch e x p e r i e n c e is part of what make s them \ne x p e r t s . C o n s e q u e n t l y , y o u ' l l f i nd r e c u r r i n g pattern s of c l a s s e s a nd communicatin g\no b j e c t s in many o b j e c t - o r i e n t e d s y s t e m s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 40, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 815}}
{"id": "computer_science_design_patterns_gof_chunk_0041_e9deedb1", "text": "C o n s e q u e n t l y , y o u ' l l f i nd r e c u r r i n g pattern s of c l a s s e s a nd communicatin g\no b j e c t s in many o b j e c t - o r i e n t e d s y s t e m s . T h e se p a t t e r n s s o l ve s p e c i f i c d e s i g n p r o b l e m s\na nd make o b j e c t - o r i e n t e d d e s i g n s m o re f l e x i b l e , e l e g a n t , a nd ultimatel y r e u s a b l e . T h ey\nh e lp d e s i g n e r s r e u se s u c c e s s f u l d e s i g n s by b a s i n g n ew d e s i g n s on p r i or e x p e r i e n c e . A d e s i g n e r w ho is familia r with s u ch pattern s c an apply them i m m e d i a t e l y to d e s i g n\np r o b l e m s withou t h a v i n g to r e d i s c o v e r them. An a n a l o g y w i ll h e lp i l l u s t r a t e t he p o i n t . N o v e l i s t s a nd playwright s rarely d e s i g n\nt h e ir p l o ts from s c r a t c h .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 41, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 867}}
{"id": "computer_science_design_patterns_gof_chunk_0042_eb367193", "text": "An a n a l o g y w i ll h e lp i l l u s t r a t e t he p o i n t . N o v e l i s t s a nd playwright s rarely d e s i g n\nt h e ir p l o ts from s c r a t c h . I n s t e a d , they follow pattern s l i ke \" T r a g i c a l l y F l a w e d H e r o \"\n( M a c b e t h , H a m l e t , e t c .) or \" T he Romanti c N o v e l \" ( c o u n t l e s s romanc e n o v e l s ) . In t he\ns a m e w a y , o b j e c t - o r i e n t e d d e s i g n e r s follow patterns like \"represent states with objects\"\n1\n\nptg2 INTRODUCTION CHAPTER 1\na nd \"de cor at e o b j e c t s so y ou c an e a s i ly add/remov e features. \" O n ce y ou k n ow t he\npattern , a l ot of d e s i g n d e c i s i o n s follow automatically. We a ll know t he v a l ue of d e s i g n e x p e r i e n c e . How many t i m es have y ou h ad d e s i g n deja-\nvu—that f e e l i n g that y o u ' v e s o l v e d a p r o b l e m b ef or e b ut n ot k n o w i n g e x a c t l y w h e r e or\nhow?", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 42, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_design_patterns_gof_chunk_0043_cc3f6772", "text": "How many t i m es have y ou h ad d e s i g n deja-\nvu—that f e e l i n g that y o u ' v e s o l v e d a p r o b l e m b ef or e b ut n ot k n o w i n g e x a c t l y w h e r e or\nhow? If y ou c o u ld r e m e m b e r t he d e t a i l s of t he p r e v i o u s p r o b l e m a nd h ow y ou s o l v e d\ni t, then y ou c o u ld r e u se t he e x p e r i e n c e i n s t e a d of r e d i s c o v e r i n g i t. H o w e v e r , we don't\ndo a g o od j ob of r e c o r d i n g e x p e r i e n c e in softwar e d e s i g n f or o t h e r s to u s e . T he purpos e of t h is b o ok is to r e c o r d e x p e r i e n c e in d e s i g n i n g o b j e c t - o r i e n t e d softwar e as\nd e s i g n p a t t e r n s . E a ch d e s i g n patter n s y s t e m a t i c a l l y n a m e s , e x p l a i n s , a nd e v a l u a t e s an\nimportan t a nd recurrin g d e s i g n in o b j e c t - o r i e n t e d s y s t e m s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 43, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 905}}
{"id": "computer_science_design_patterns_gof_chunk_0044_5828dbfc", "text": "E a ch d e s i g n patter n s y s t e m a t i c a l l y n a m e s , e x p l a i n s , a nd e v a l u a t e s an\nimportan t a nd recurrin g d e s i g n in o b j e c t - o r i e n t e d s y s t e m s . O ur g o al is to captur e d e s i g n\ne x p e r i e n c e in a form that p e o p l e c an u se e f f e c t i v e l y . To t h is e nd we have d o c u m e n t e d\ns o me of t he most importan t d e s i g n pattern s a nd p r e s e n t them as a c a t a l o g . D e s i g n pattern s make it e a s i e r to r e u se s u c c e s s f u l d e s i g n s a nd a r c h i t e c t u r e s . E x p r e s s i n g\np r o v e n t e c h n i q u e s as d e s i g n p a t t e r n s m a k e s t h em m o re a c c e s s i b l e to d e v e l o p e r s of\nn ew s y s t e m s . D e s i g n pattern s h e lp y ou c h o o s e d e s i g n alternative s that make a s y s t e m\nreusabl e a nd a v o id alternative s that c o m p r o m i s e r e u s a b i l i t y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 44, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_design_patterns_gof_chunk_0045_84407a33", "text": "D e s i g n pattern s h e lp y ou c h o o s e d e s i g n alternative s that make a s y s t e m\nreusabl e a nd a v o id alternative s that c o m p r o m i s e r e u s a b i l i t y . D e s i g n pattern s c an e v en\ni m p r o v e t he documentatio n a nd maintenanc e of e x i s t i n g s y s t e m s by furnishin g an\ne x p l i c i t s p e c i f i c a t i o n of c l a ss a nd o b j e c t interaction s a nd t h e ir underlyin g i n t e n t . P ut\ns i m p l y , d e s i g n pattern s help a d e s i g n e r g et a d e s i g n \" r i g h t \" faster. None of t he d e s i g n pattern s in t h is b o ok d e s c r i b e s n ew or unprove n d e s i g n s . We have\ni n c l u d e d o n ly d e s i g n s that have b e en a p p l i e d m o re than o n ce in differen t s y s t e m s . M o st\nof t h e se d e s i g n s hav e n e v er b e en d o c u m e n t e d before .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 45, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 862}}
{"id": "computer_science_design_patterns_gof_chunk_0046_f1684f96", "text": "M o st\nof t h e se d e s i g n s hav e n e v er b e en d o c u m e n t e d before . T h ey a re e i t h er part of t he f o l k l o r e\nof t he o b j e c t - o r i e n t e d communit y or a re e l e m e n t s of s o me s u c c e s s f u l o b j e c t - o r i e n t e d\nsystems—neithe r of whic h is e a sy f or n o v i c e d e s i g n e r s to learn from . So althoug h t h e se\nd e s i g n s aren' t n e w, we captur e them in a n ew a nd a c c e s s i b l e way: as a c a t a l o g of d e s i g n\npattern s havin g a c o n s i s t e n t format. D e s p i t e t he b o o k ' s s i z e, t he d e s i g n p a t t e r n s in it c a p t u r e o n ly a f r a c t i o n of what an e x p e r t\nmigh t k n o w . It d o e s n ' t have a ny pattern s d e a l i n g with c o n c u r r e n c y or d i s t r i b u t e d p r o -\ngrammin g or r e a l - t i m e programming . It d o e s n ' t have any a p p l i c a t i o n d o m a i n - s p e c i f i c\npatterns .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 46, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_design_patterns_gof_chunk_0047_e36cbd15", "text": "It d o e s n ' t have any a p p l i c a t i o n d o m a i n - s p e c i f i c\npatterns . It d o e s n ' t t e ll you how to b u i ld user i n t e r f a c e s , how to write d e v i c e d r i v e r s ,\nor how to use an o b j e c t - o r i e n t e d database . E a ch of t h e se a r e as has its own p a t t e r n s , and\nit would be worthwhile for someone to catalog those too. 1 . 1 What Is a D e s i g n P a t t e r n ? C h r i s t o p h e r A l e x a n d e r s a y s, \" E a ch patter n d e s c r i b e s a p r o b l e m w h i c h o c c u r s o v er a nd\no v er again in o ur e n v i r o n m e n t , a nd then d e s c r i b e s t he c o re of t he s o l u t i o n to that\np r o b l e m , in s u ch a w ay that y ou c an u se this s o l u t i o n a m i l l i o n t i m es o v e r, withou t e v er\nd o i ng it t he s a me w ay t w i c e \" [ A I S + 7 7 , p a ge x }.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 47, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 866}}
{"id": "computer_science_design_patterns_gof_chunk_0048_d87e756d", "text": "E v en t h o u g h A l e x a n d e r w as t a l k i n g\nabou t pattern s in b u i l d i n g s a nd t o w n s , what he s a ys is true abou t o b j e c t - o r i e n t e d d e s i g n\npatterns. Our solutions are expressed in terms of objects a n d interfaces instead of walls\n\nptgSECTION 1.1 WHAT IS A DESIGN PATTERN? 3\nand d o o r s , but at the c o re of both kinds of pattern s is a s o l u t i o n to a p r o b l e m in a\ncontext. In g e n e r a l , a patter n has f o ur e s s e n t i a l e l e m e n t s :\n1. T he p a t t e r n n a me is a handl e we c an u se to d e s c r i b e a d e s i g n p r o b l e m , i ts s o -\nl u t i o n s , and c o n s e q u e n c e s in a w o rd or two. Namin g a patter n immediatel y\ni n c r e a s e s o ur d e s i g n v o c a b u l a r y . It l e ts us d e s i g n at a highe r l e v el of abstraction . Havin g a v o c a b u l a r y for pattern s l e ts us talk abou t them with our c o l l e a g u e s ,\nin our documentation , and e v en to o u r s e l v e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 48, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_design_patterns_gof_chunk_0049_b9141af4", "text": "Havin g a v o c a b u l a r y for pattern s l e ts us talk abou t them with our c o l l e a g u e s ,\nin our documentation , and e v en to o u r s e l v e s . It make s it e a s i e r to think abou t\nd e s i g n s and to communicat e them and their trade-off s to others . Findin g g o od \nname s has b e en one of the hardes t parts of d e v e l o p i n g our catalog. 2. The p r o b l e m d e s c r i b e s when to apply the pattern . It explain s the p r o b l e m and its\nc o n t e x t . It migh t d e s c r i b e s p e c i f i c d e s i g n p r o b l e m s such as h ow to r e p r e s e n t a l g o -\nrithm s as o b j e c t s . It migh t d e s c r i b e c l a ss or o b j e c t structure s that are symptomati c\nof an inflexibl e d e s i g n . S o m e t i m e s t he p r o b l e m w i ll includ e a l i st of condition s\nthat must be met befor e it make s s e n se to apply the pattern. 3.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 49, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 894}}
{"id": "computer_science_design_patterns_gof_chunk_0050_0ff16cb2", "text": "S o m e t i m e s t he p r o b l e m w i ll includ e a l i st of condition s\nthat must be met befor e it make s s e n se to apply the pattern. 3. The s o l u t i o n d e s c r i b e s the e l e m e n t s that make up the d e s i g n , their r e l a t i o n s h i p s ,\nr e s p o n s i b i l i t i e s , and c o l l a b o r a t i o n s . The solutio n doesn' t d e s c r i b e a particula r\nc o n c r e t e d e s i g n or implementation , becaus e a patter n is l i ke a templat e that can\nbe applie d in many differen t situations . Instead , the patter n provide s an abstrac t\nd e s c r i p t i o n of a d e s i g n p r o b l e m and how a genera l arrangemen t of element s\n( c l a s s e s a nd o b j e c t s in o ur c a s e) s o l v e s i t . 4. The c o n s e q u e n c e s are the result s and trade-off s of applyin g the pattern .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 50, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 837}}
{"id": "computer_science_design_patterns_gof_chunk_0051_a224499e", "text": "4. The c o n s e q u e n c e s are the result s and trade-off s of applyin g the pattern . Thoug h\nc o n s e q u e n c e s are often u n v o i c e d when we d e s c r i b e d e s i g n d e c i s i o n s , they are\nc r i t i c a l for evaluatin g d e s i g n alternative s and for understandin g the c o s ts and\nbenefit s of applyin g the pattern. The c o n s e q u e n c e s for softwar e o f t en c o n c e r n s p a ce and time trade-offs . T h ey\nmay a d d r e s s languag e and implementatio n i s s u e s as w e l l. S i n ce reuse is o f t en a\nfacto r in o b j e c t - o r i e n t e d d e s i g n , the c o n s e q u e n c e s of a patter n includ e its impac t\non a s y s t e m ' s flexibility , e x t e n s i b i l i t y , or portability . Listin g these c o n s e q u e n c e s\ne x p l i c i t l y h e l ps you understan d and evaluat e them. P o i nt of v i ew a f f e c t s one's interpretatio n of what is and isn't a pattern .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 51, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 941}}
{"id": "computer_science_design_patterns_gof_chunk_0052_f7dee209", "text": "Listin g these c o n s e q u e n c e s\ne x p l i c i t l y h e l ps you understan d and evaluat e them. P o i nt of v i ew a f f e c t s one's interpretatio n of what is and isn't a pattern . One person' s\npatter n can be anothe r person' s primitiv e buildin g b l o c k . For this book we have c o n c e n -\ntrated on pattern s at a certai n l e v el of abstraction . Design patterns are not abou t d e s i g n s\ns u ch as l i n k e d l i s ts a nd hash table s that c an be e n c o d e d in c l a s s e s a nd r e u s e d as i s. N or\nare they c o m p l e x , d o m a i n - s p e c i f i c d e s i g n s for an entire applicatio n or subsystem . The\nd e s i g n pattern s in this b o ok are descriptions of communicating objects and classes that are\ncustomized to solve a general design problem in a particular context.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 52, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 822}}
{"id": "computer_science_design_patterns_gof_chunk_0053_1a0a7fcb", "text": "The\nd e s i g n pattern s in this b o ok are descriptions of communicating objects and classes that are\ncustomized to solve a general design problem in a particular context. A d e s i g n patter n n a m e s , abstracts , and identifie s the key aspect s of a commo n d e s i g n\nstructur e that make it usefu l for creatin g a reusabl e object-oriente d d e s i g n . The d e s i g n\npattern identifies the participating classes and instances, their roles and collaborations,\n\nptg4 INTRODUCTION CHAPTER 1\nand the distributio n of r e s p o n s i b i l i t i e s . Each d e s i g n patter n focuse s on a particula r\nobject-oriente d d e s i g n proble m or i s s u e . It d e s c r i b e s when it a p p l i e s , whethe r it can be\napplie d in v i ew of other d e s i g n constraints , and the c o n s e q u e n c e s and trade-off s of its\nu s e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 53, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 848}}
{"id": "computer_science_design_patterns_gof_chunk_0054_dcd73c18", "text": "It d e s c r i b e s when it a p p l i e s , whethe r it can be\napplie d in v i ew of other d e s i g n constraints , and the c o n s e q u e n c e s and trade-off s of its\nu s e. S i n ce we must eventuall y implemen t our d e s i g n s , a d e s i g n patter n a l so p r o v i d e s\nsampl e C++ and (sometimes ) Smalltal k c o de to illustrat e an implementation. A l t h o u g h d e s i g n pattern s d e s c r i b e o b j e c t - o r i e n t e d d e s i g n s , t h ey a re b a s ed on p r a c t i c a l\ns o l u t i o n s t h at have been implemente d in mainstrea m object-oriente d programmin g\nlanguage s l i ke Smalltal k and C++ rathe r than procedura l language s ( P a s c a l , C, Ada) or\nm o re dynami c object-oriente d language s ( C L O S , D y la n , S e l f ). We c h o se Smalltal k a nd\nC++ for pragmati c r e a s o n s : Our day-to-da y e x p e r i e n c e has been in t h e se l a n g u a g e s ,\nand they are i n c r e a s i n g l y popular.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 54, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_design_patterns_gof_chunk_0055_1f74776e", "text": "We c h o se Smalltal k a nd\nC++ for pragmati c r e a s o n s : Our day-to-da y e x p e r i e n c e has been in t h e se l a n g u a g e s ,\nand they are i n c r e a s i n g l y popular. T he c h o i c e of programmin g languag e is importan t becaus e it influence s o n e 's point\nof v i e w. Our pattern s assum e Smalltalk/C++-leve l languag e features , and that c h o i c e \ndetermine s w h at can and canno t be implemente d e a s i l y . If we assume d procedura l\nl a n g u a g e s , we migh t have include d d e s i g n pattern s c a l l ed \" I n h e r i t a n c e , \" \"Encapsu-\nl a t i o n , \" and \" P o l y m o r p h i s m . \" S i m i l a r l y , some of our pattern s are supporte d d i r e c t l y\nby the l e ss commo n object-oriente d languages . C L OS has multi-methods , for e x a m p l e ,\nw h i c h l e s s en the n e ed for a patter n s u ch as Visito r (page 3 3 1 ).", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 55, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 889}}
{"id": "computer_science_design_patterns_gof_chunk_0056_67f45458", "text": "C L OS has multi-methods , for e x a m p l e ,\nw h i c h l e s s en the n e ed for a patter n s u ch as Visito r (page 3 3 1 ). In fact, t h e re are enoug h\ndifference s betwee n Smalltal k and C++ to mean that s o me pattern s can be e x p r e s s e d\nmore easily in one language than the other. (See Iterator (257) f o r a n example.)\n1 . 2 Design Patterns i n Smalltalk MVC\nT he Model/View/Controlle r (MVC ) triad of c l a s s e s [ K P 8 8 ] is u s ed to b u i ld u s er inter-\nfaces in S m a l l t a l k - 8 0 . Lookin g at the d e s i g n pattern s i n s i d e MVC shoul d help you see\nwhat we mean by the term \"pattern.\"\nM VC c o n s i s t s of three kinds of objects . T he M o d e l is t he applicatio n o b j e c t , t he V i ew is\nits s c r e e n presentation , and the C o n t r o l l e r define s the way the user interfac e r e a c t s to\nu s er input . Befor e M V C , user interfac e d e s i g n s tende d to lump these o b j e c t s together .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 56, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_design_patterns_gof_chunk_0057_c848754a", "text": "Befor e M V C , user interfac e d e s i g n s tende d to lump these o b j e c t s together . MVC d e c o u p l e s them to i n c r e a s e flexibilit y and r e u s e . MVC d e c o u p l e s v i e w s and model s by establishin g a subscribe/notif y protoco l betwee n\nthem . A v i ew must ensur e that its appearanc e reflect s the state of the m o d e l . Wheneve r\nthe model' s data c h a n g e s , the mode l notifie s v i e w s that depen d on it. In r e s p o n s e , e a ch\nv i ew g e ts an opportunit y to updat e itself . T h is approac h l e ts you attac h multipl e v i e w s\nto a mode l to provid e differen t presentations . You can a l so creat e new v i e w s for a m o d e l\nwithou t rewritin g it. The followin g diagra m show s a mode l and three v i e w s . ( W e ' v e left out the c o n t r o l l e r s\nfor s i m p l i c i t y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 57, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 848}}
{"id": "computer_science_design_patterns_gof_chunk_0058_06472fff", "text": "The followin g diagra m show s a mode l and three v i e w s . ( W e ' v e left out the c o n t r o l l e r s\nfor s i m p l i c i t y . ) The mode l contain s some data v a l u e s , and the v i e w s definin g a s p r e a d -\ns h e e t , h i s t o g r a m , a nd p ie c h a rt d i s p l a y t h e se data in v a r i o u s w a y s . T he m o d e l c o m m u -\nnicate s with its v i e w s when its value s c h a n g e , and the v i e w s communicat e with the\nmodel to access these values. ptgSECTION 1 . 2 DESIGN P A T T E R N S I N S M A L L T A L K M V C 5\nm o d e l\nT a k e n at face v a l u e , this exampl e reflect s a d e s i g n that d e c o u p l e s v i e w s from m o d e l s . But\nt he d e s i g n is a p p l i c a b l e to a more g e n e r a l p r o b l e m : d e c o u p l i n g o b j e c t s so that c h a n g e s\nto one can a f f e c t any numbe r of o t h e r s withou t r equi ri n g the change d o b j e c t to know \nd e t a i l s of t he o t h e r s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 58, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_design_patterns_gof_chunk_0059_868b355e", "text": "T h is m o re g e n e r a l d e s i g n is d e s c r i b e d by t he O b s e r v e r ( p a ge 2 9 3)\nd e s i g n pattern. Anothe r featur e of M VC is that v i e w s c an be n e s t e d . F or e x a m p l e , a c o n t r o l panel of\nbutton s migh t be implemente d as a c o m p l e x v i ew containin g n e s t e d butto n v i e w s . The\nu s er interfac e for an o b j e c t i n s p e c t o r can c o n s i s t of n e s t e d v i e w s that may be r e u s e d in\na d e b u g g e r . M VC support s n e s t e d v i e w s with t he C o m p o s i t e V i e w c l a s s, a s u b c l a s s of\nV i e w . C o m p o s i t e V i e w o b j e c t s a ct just l i ke V i ew o b j e c t s ; a c o m p o s i t e v i ew c an be u s ed\nw h e r e v e r a v i ew can be u s e d, but it a l so contain s and manage s n e s t e d v i e w s . A g a i n , we c o u ld think of t h is as a d e s i g n that l e ts us treat a c o m p o s i t e v i ew just l i ke\nwe treat o ne of i ts components .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 59, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_design_patterns_gof_chunk_0060_a680d2cd", "text": "A g a i n , we c o u ld think of t h is as a d e s i g n that l e ts us treat a c o m p o s i t e v i ew just l i ke\nwe treat o ne of i ts components . B ut t he d e s i g n is a p p l i c a b l e to a more g e n e r a l p r o b l e m ,\nw h i c h o c c u r s wheneve r we want to group o b j e c t s and treat the group l i ke an individua l\no b j e c t . T h is m o re genera l d e s i g n is d e s c r i b e d by t he C o m p o s i t e ( 1 6 3) d e s i g n pattern . It\nl e ts y ou c r e a t e a c l a ss hierarch y in w h i c h s o me s u b c l a s s e s defin e primitiv e o b j e c t s ( e . g .,\nButton ) and other c l a s s e s defin e c o m p o s i t e object s ( C o m p o s i t e V i e w ) that a s s e m b l e the\np r i m i t i v e s into m o re c o m p l e x o b j e c t s . MVC a l so l e ts you chang e the way a v i ew r e s p o n d s to u s er input withou t changin g its\nvisua l presentation .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 60, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_design_patterns_gof_chunk_0061_14fb911b", "text": "MVC a l so l e ts you chang e the way a v i ew r e s p o n d s to u s er input withou t changin g its\nvisua l presentation . You migh t want to c h a n g e the way it r e s p o n d s to the k e y b o a r d , for\ne x a m p l e , or have it u se a pop-u p menu instea d of comman d k e y s. M VC encapsulate s\nt he r e s p o n s e m e c h a n i s m in a C o n t r o l l e r o b j e c t . T h e re is a c l a ss h i e r a r c h y of c o n t r o l l e r s ,\nmaking it easy to create a new controller as a variation on an existing one. ptg6 INTRODUCTION CHAPTER 1\nA v i ew u s es an instanc e of a C o n t r o l l e r s u b c l a s s to i m p l e m e n t a particula r r e s p o n s e\nstrategy ; to implemen t a differen t strategy , s i m p l y r e p l a c e the instanc e with a differen t\nk i nd of c o n t r o l l e r . It's e v en p o s s i b l e to c h a n g e a v i e w ' s c o n t r o l l e r at run-tim e to l et t he\nv i ew chang e t he w ay it r e s p o n d s to u s er input .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 61, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_design_patterns_gof_chunk_0062_5418c24e", "text": "It's e v en p o s s i b l e to c h a n g e a v i e w ' s c o n t r o l l e r at run-tim e to l et t he\nv i ew chang e t he w ay it r e s p o n d s to u s er input . F or e x a m p l e , a v i ew c an be d i s a b l e d so\nthat it d o e s n ' t a c c e p t input s i m p l y by g i v i n g it a c o n t r o l l e r that i g n o r e s input e v e n t s . T he V i e w - C o n t r o l l e r relationshi p is an exampl e of t he S t r a t e g y ( 3 1 5) d e s i g n pattern . A Strateg y is an o b j e c t that r e p r e s e n t s an algorithm . It's usefu l when you want to\nr e p l a c e the algorith m eithe r staticall y or d y n a m i c a l l y , whe n you have a lot of variant s\nof the algorithm , or when the algorith m has c o m p l e x data structure s that you want to\nencapsulate. M VC u s es other d e s i g n patterns , such as F a c t o r y Metho d ( 1 0 7) to s p e c i f y t he defaul t\nc o n t r o l l e r c l a ss for a v i ew and Decorato r ( 1 7 5) to add s c r o l l i n g to a v i e w.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 62, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_design_patterns_gof_chunk_0063_5eea823b", "text": "But the\nmain r e l a t i o n s h i p s in M VC a re g i v en by t he O b s e r v e r , C o m p o s i t e , a nd Strateg y d e s i g n\npatterns. 1 . 3 Describing Design P a t t e r n s\nHow do we d e s c r i b e d e s i g n patterns ? Graphica l notations , w h i le importan t and useful ,\naren' t sufficient . T h ey s i m p l y captur e t he e nd produc t of t he d e s i g n p r o c e s s as r e l a -\nt i o n s h i p s betwee n c l a s s e s a nd o b j e c t s . To r e u se t he d e s i g n , we must a l so r e c o r d t he\nd e c i s i o n s , alternatives , and trade-off s that led to it. C o n c r e t e e x a m p l e s are importan t \nt o o, b e c a u s e they help y ou s ee t he d e s i g n in a c t i o n . We d e s c r i b e d e s i g n pattern s using a c o n s i s t e n t format . E a ch pattern is d i v i d e d into\ns e c t i o n s a c c o r d i n g to the followin g template .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 63, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 896}}
{"id": "computer_science_design_patterns_gof_chunk_0064_e73d9428", "text": "We d e s c r i b e d e s i g n pattern s using a c o n s i s t e n t format . E a ch pattern is d i v i d e d into\ns e c t i o n s a c c o r d i n g to the followin g template . The templat e l e n d s a unifor m structur e\nto the information , makin g d e s i g n pattern s e a s i e r to l e a r n , c o m p a r e , and u s e . P a t t e r n N a m e a nd Classification\nThe pattern' s name c o n v e y s the e s s e n c e of the patter n s u c c i n c t l y . A g o od name\nis v i t a l, b e c a u s e it w i ll b e c o m e part of your d e s i g n v o c a b u l a r y . T he pattern' s\nclassificatio n reflect s t he s c h e m e we introduc e in S e c t i o n 1 . 5 . I n t e n t\nA s h o rt statemen t that a n s w e r s the followin g q u e s t i o n s : Wha t d o es the d e s i g n\npatter n do? Wha t is its rational e and intent ? Wha t particula r d e s i g n i s s ue or\np r o b l e m does it address? Also Known As\nO t h e r w e l l - k n o w n n a m e s for the pattern, if a n y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 64, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_design_patterns_gof_chunk_0065_e208070b", "text": "Wha t is its rational e and intent ? Wha t particula r d e s i g n i s s ue or\np r o b l e m does it address? Also Known As\nO t h e r w e l l - k n o w n n a m e s for the pattern, if a n y . Motivation\nA scenario that illustrates a d e s i g n p r o b l e m and how the c l a s s and object structures\n\nptgSECTION 1.3 DESCRIBING DESIGN PATTERNS 7\nin t he patter n s o l ve t he p r o b l e m . T he s c e n a r i o w i ll h e lp y ou understan d t he more\nabstrac t d e s c r i p t i o n of the patter n that follows. Applicability\nWha t are the s i t u a t i o n s in whic h the d e s i g n patter n can be applied ? Wha t are\ne x a m p l e s of p o or d e s i g n s that t he patter n c an a d d r e s s ? H ow c an y ou r e c o g n i z e\nt h e se situations? S t r u c t u r e\nA g r a p h i c a l r e p r e s e n t a t i o n of the c l a s s e s in the patter n using a notatio n b a s ed\non t he O b j e c t M o d e l i n g T e c h n i q u e ( O M T ) [ R B P + 9 1 ] .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 65, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_design_patterns_gof_chunk_0066_97c4289c", "text": "We a l so u se interactio n d i -\na g r a m s [ J C J O 9 2 , B o o 9 4 ] to i l l u s t r a t e s e q u e n c e s of r e q u e s t s a nd c o l l a b o r a t i o n s\nb e t w e e n o b j e c t s . Appendi x B d e s c r i b e s t h e se notation s in detail. P a r t i c i p a n t s\nT he c l a s s e s a n d / o r o b j e c t s participatin g in t he d e s i g n patter n a nd their r e s p o n s i -\nb i l i t i e s . C o l l a b o r a t i o n s\nH ow t he participant s c o l l a b o r a t e to c a r ry o ut t h e ir r e s p o n s i b i l i t i e s . C o n s e q u e n c e s\nHow d o es the patter n suppor t its o b j e c t i v e s ? Wha t are the trade-off s and r e s u l t s\nof u s i ng t he pattern? Wha t a s p e c t of s y s t e m structur e d o es it l et y ou vary i n d e -\np e n d e n t l y ? Implementation\nWha t p i t f a l l s , h i n t s , or t e c h n i q u e s s h o u l d y ou be awar e of when i m p l e m e n t i n g\nthe pattern ? Are there l a n g u a g e - s p e c i f i c i s s u e s ?", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 66, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1008}}
{"id": "computer_science_design_patterns_gof_chunk_0067_f194773d", "text": "Are there l a n g u a g e - s p e c i f i c i s s u e s ? S a m p l e C o d e\nC o de fragment s that illustrat e how you migh t implemen t the patter n in C++ or\nS m a l l t a l k . K n o w n U s e s\nE x a m p l e s of t he patter n foun d in r e al s y s t e m s . We i n c l u d e at l e a st t wo e x a m p l e s\nfrom differen t d o m a i n s . R e l a t e d P a t t e r n s\nWha t d e s i g n pattern s are c l o s e l y r e l a t e d to t h is o n e? Wha t are the importan t\nd i f f e r e n c e s ? With which other patterns should this one be used? The a p p e n d i c e s p r o v i d e b a c k g r o u n d i n f o r m a t i o n that will help y o u u n d e r s t a n d the pat-\nt e r n s and the discussions surrounding them. Appendix A is a glossary of terminology\n\nptg8 INTRODUCTION CHAPTER 1\nwe u s e. W e ' v e alread y m e n t i o n e d Appendi x B, w h i c h p r e s e n t s t he v a r i o u s n o t a t i o n s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 67, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_design_patterns_gof_chunk_0068_2e4ba152", "text": "Appendix A is a glossary of terminology\n\nptg8 INTRODUCTION CHAPTER 1\nwe u s e. W e ' v e alread y m e n t i o n e d Appendi x B, w h i c h p r e s e n t s t he v a r i o u s n o t a t i o n s . W e ' ll a l so d e s c r i b e a s p e c t s of t he notation s as we i n t r o d u c e them in t he u p c o m i n g\nd i s c u s s i o n s . F i n a l l y , Appendi x C c o n t a i n s s o u r c e c o de f or t he foundatio n c l a s s e s we\nu s e i n code samples. 1 . 4 The Catalog o f Design Patterns\nT he c a t a l o g b e g i n n i n g on page 79 c o n t a i n s 23 d e s i g n patterns . T h e ir n a m e s a nd i n t e n t s\na re l i s t ed next to g i ve y ou an o v e r v i e w . T he numbe r in p a r e n t h e s e s after e a ch patter n\nname g i v es the p a ge numbe r for the pattern (a c o n v e n t i o n we f o l l ow throughou t the\nbook).", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 68, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 853}}
{"id": "computer_science_design_patterns_gof_chunk_0069_3aca1a7e", "text": "T he numbe r in p a r e n t h e s e s after e a ch patter n\nname g i v es the p a ge numbe r for the pattern (a c o n v e n t i o n we f o l l ow throughou t the\nbook). Abstrac t Factor y ( 8 7) P r o v i d e an interfac e f or c r e a t i n g f a m i l i e s of r e l a t e d or d e p e n d e n t\no b j e c t s withou t s p e c i f y i n g t h e ir c o n c r e t e c l a s s e s . Adapte r ( 1 3 9) C o n v e r t t he interfac e of a c l a ss into anothe r interfac e c l i e n t s e x p e c t . Adapte r l e ts c l a s s e s work t o g e t h e r that c o u l d n ' t o t h e r w i s e b e c a u s e of i n c o m p a t -\ni b le interfaces. Bridg e ( 1 5 1) D e c o u p l e an abstractio n from i ts i m p l e m e n t a t i o n so that t he t wo c an vary\ni n d e p e n d e n t l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 69, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 783}}
{"id": "computer_science_design_patterns_gof_chunk_0070_5996ac85", "text": "Bridg e ( 1 5 1) D e c o u p l e an abstractio n from i ts i m p l e m e n t a t i o n so that t he t wo c an vary\ni n d e p e n d e n t l y . Builde r ( 9 7) Separat e t he c o n s t r u c t i o n of a c o m p l e x o b j e c t from i ts r e p r e s e n t a t i o n so\nthat the s a me c o n s t r u c t i o n p r o c e s s can c r e a t e differen t r e p r e s e n t a t i o n s . Chai n of R e s p o n s i b i l i t y ( 2 2 3) A v o i d c o u p l i n g t he s e n d e r of a r e q u e s t to i ts r e c e i v e r by\ng i v i n g m o re than o ne o b j e c t a c h a n c e to h a n d l e t he r e q u e s t . C h a in t he r e c e i v i n g\no b j e c t s a nd pass t he r e q u e s t a l o ng t he c h a in until an o b j e c t h a n d l e s i t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 70, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 748}}
{"id": "computer_science_design_patterns_gof_chunk_0071_dcbc6eb1", "text": "C h a in t he r e c e i v i n g\no b j e c t s a nd pass t he r e q u e s t a l o ng t he c h a in until an o b j e c t h a n d l e s i t . Comman d ( 2 3 3) Encapsulat e a r e q u e s t as an o b j e c t , t h e r e b y l e t t i n g y ou p a r a m e t e r -\ni ze c l i e n t s with differen t r e q u e s t s , q u e u e or l og r e q u e s t s , a nd s u p p o r t u n d o a b l e\no p e r a t i o n s . C o m p o s i t e ( 1 6 3) C o m p o s e o b j e c t s i n to t r ee s t r u c t u r e s to r e p r e s e n t p a r t - w h o l e h i e r a r -\nc h i e s . C o m p o s i t e l e ts c l i e n t s treat i n d i v i d u a l o b j e c t s a nd c o m p o s i t i o n s of o b j e c t s\nuniformly. Decorato r ( 1 7 5) Attac h additiona l r e s p o n s i b i l i t i e s to an o b j e c t d y n a m i c a l l y . D e c o r a t o r s\np r o v i d e a f l e x i b l e alternativ e to s u b c l a s s i n g for e x t e n d i n g f u n c t i o n a l i t y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 71, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_design_patterns_gof_chunk_0072_8802bcbe", "text": "D e c o r a t o r s\np r o v i d e a f l e x i b l e alternativ e to s u b c l a s s i n g for e x t e n d i n g f u n c t i o n a l i t y . Facad e ( 1 8 5) P r o v i d e a u n i f i e d interfac e to a s et of interface s in a s u b s y s t e m . F a c a d e\ndefine s a h i g h e r - l e v e l interfac e that m a k e s t he s u b s y s t e m e a s i er to u s e . Factor y Metho d ( 1 0 7) Defin e an interfac e f or c r e a t i n g an o b j e c t , b ut l et s u b c l a s s e s d e -\nc i de w h i c h c l a ss to i n s t a n t i a t e . F a c t o r y M e t h o d l e ts a c l a ss defer i n s t a n t i a t i o n to\ns u b c l a s s e s . ptgSECTION 1.5 ORGANIZING THE CATALOG 9\nF l y w e i g h t ( 1 9 5) U se s h a r i n g to suppor t l a r ge number s of fine-graine d o b j e c t s effi-\nc i e n t l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 72, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 810}}
{"id": "computer_science_design_patterns_gof_chunk_0073_52c4f292", "text": "ptgSECTION 1.5 ORGANIZING THE CATALOG 9\nF l y w e i g h t ( 1 9 5) U se s h a r i n g to suppor t l a r ge number s of fine-graine d o b j e c t s effi-\nc i e n t l y . Interprete r ( 2 4 3) G i v e n a l a n g u a g e , defin e a r e p r e s e n t i o n for its gramma r a l o ng with\nan i n t e r p r e t e r that u s es t he r e p r e s e n t a t i o n to i n t e r p r e t s e n t e n c e s in t he l a n g u a g e . I t e r a t o r ( 2 5 7) P r o v i d e a w ay to a c c e s s t he e l e m e n t s of an a g g r e g a t e o b j e c t s e q u e n t i a l l y\nw i t h o u t e x p o s i n g i ts u n d e r l y i n g r e p r e s e n t a t i o n . Mediato r ( 2 7 3) Defin e an o b j e c t that e n c a p s u l a t e s h ow a s et of o b j e c t s interact . M e -\ndiato r p r o m o t e s l o o se c o u p l i n g by k e e p i n g o b j e c t s from referrin g to e a ch other\ne x p l i c i t l y , a nd it l e ts y ou vary t h e ir i n t e r a c t i o n i n d e p e n d e n t l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 73, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_design_patterns_gof_chunk_0074_c394d45f", "text": "Mement o ( 2 8 3) Withou t v i o l a t i n g e n c a p s u l a t i o n , captur e a nd externaliz e an o b j e c t ' s\ni n t e r n a l s t a te so that t he o b j e c t c an be r e s t o r e d to t h is s t a te l a t e r . O b s e r v e r ( 2 9 3) D e f i n e a o n e - t o - m a n y d e p e n d e n c y bet w ee n o b j e c t s so that when o ne\no b j e c t c h a n g e s s t a t e, a ll i ts d e p e n d e n t s a re notifie d a nd update d automatically. P r o t o t y p e ( 1 1 7) S p e c i f y t he k i n ds of o b j e c t s to c r e a t e u s i ng a prototypica l i n s t a n c e , a nd\nc r e a t e n ew o b j e c t s by c o p y i n g t h is prototype. P r o xy ( 2 0 7) P r o v i d e a s u r r o g a t e or p l a c e h o l d e r f or anothe r o b j e c t to c o n t r o l a c c e s s to\ni t . S i n g l e t o n ( 1 2 7) E n s u r e a c l a ss o n ly h as o ne i n s t a n c e , a nd p r o v i d e a g l o b a l point of\na c c e s s to i t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 74, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_design_patterns_gof_chunk_0075_88b53de0", "text": "S i n g l e t o n ( 1 2 7) E n s u r e a c l a ss o n ly h as o ne i n s t a n c e , a nd p r o v i d e a g l o b a l point of\na c c e s s to i t . S t a te ( 3 0 5) A l l ow an o b j e c t to a l t er i ts b e h a v i o r w h en i ts interna l s t a te c h a n g e s . T he\no b j e c t w i ll appea r to c h a n g e i ts c l a s s . S t r a t e g y ( 3 1 5) D e f i n e a famil y of a l g o r i t h m s , e n c a p s u l a t e e a ch o n e, a nd make t h em\ni n t e r c h a n g e a b l e . S t r a t e g y l e ts the a l g o r i t h m vary independentl y from c l i e n t s that\nu se i t . T e m p l a t e Metho d ( 3 2 5) Defin e t he s k e l e t o n of an algorith m in an o p e r a t i o n , deferrin g\ns o me s t e ps to s u b c l a s s e s . T e m p l a t e M e t h o d l e ts s u b c l a s s e s redefin e certai n s t e ps\nof an a l g o r i t h m withou t changin g the algorithm' s structure.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 75, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_design_patterns_gof_chunk_0076_f47a604b", "text": "T e m p l a t e M e t h o d l e ts s u b c l a s s e s redefin e certai n s t e ps\nof an a l g o r i t h m withou t changin g the algorithm' s structure. V i s i t o r ( 3 3 1) R e p r e s e n t an o p e r a t i o n to be performe d on t he e l e m e n t s of an o b j e c t\nstructure . V i s i t o r l e ts y ou defin e a n ew o p e r a t i o n withou t c h a n g i n g t he c l a s s e s of \nt h e elements on which it operates. 1 . 5 Organizing the C a t a l o g\nD e s i g n pattern s vary in t h e ir granularit y a nd l e v el of abstraction . B e c a u s e th ere a re\nmany d e s i g n p a t t e r n s , we n e ed a w ay to o r g a n i z e them . T h is s e c t i o n c l a s s i f i e s d e s i g n\npatterns so that we can refer to families o f r e l a t e d p a t t e r n s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 76, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 783}}
{"id": "computer_science_design_patterns_gof_chunk_0077_ed79fddc", "text": "T h is s e c t i o n c l a s s i f i e s d e s i g n\npatterns so that we can refer to families o f r e l a t e d p a t t e r n s . The classification helps you\n\nptg1 0 INTRODUCTION CHAPTER 1\nS c o p e C l a s s\nObjectPurpose\nCreational\nFactor y M e t h o d ( 1 0 7 )\nAbstrac t Factor y ( 8 7)\nB u i l d e r ( 9 7)\nPrototyp e ( 1 1 7)\nS i n g l e t o n (127)Structura l\nAdapte r ( c l a s s ) ( 1 3 9 )\nAdapte r ( o b j e c t ) ( 1 3 9)\nB r i d g e ( 1 5 1)\nC o m p o s i t e ( 1 6 3)\nD e c o r a t o r ( 1 7 5)\nF a c a d e ( 1 8 5)\nF l y w e i g h t ( 1 9 5)\nP r o x y ( 2 0 7 )Behaviora l\nInterprete r ( 2 4 3 )\nTemplat e M e t h o d ( 3 2 5)\nChain of R e s p o n s i b i l i t y ( 2 2 3)\nCommand (233)\nIterator (257)\nMediator (273)\nM e m e n t o ( 2 8 3 )\nO b s e r v e r (293)\nS t a t e ( 3 0 5 )\nStrategy (315)\nV i s i t o r ( 3 3 1 )\nT a b le 1 . 1: D e s i g n pattern s p a c e\nlearn the pattern s in the c a t a l o g faster , and it can d i r e c t effort s to find new pattern s as\nw e l l .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 77, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_design_patterns_gof_chunk_0078_0aeb4ff6", "text": "1: D e s i g n pattern s p a c e\nlearn the pattern s in the c a t a l o g faster , and it can d i r e c t effort s to find new pattern s as\nw e l l . We classif y d e s i g n pattern s by two c r i t e r i a ( T a b l e 1 . 1 ). T he f i r st c r i t e r i o n , c a l l ed p u r p o s e ,\nreflect s what a patter n d o e s. Pattern s c an have e i t h e r c r e a t i o n a l , s t r u c t u r a l , or b e h a v -\ni o r al p u r p o s e . Creationa l pattern s c o n c e r n t he p r o c e s s of o b j e c t c r e a t i o n . Structura l\npattern s deal with t he c o m p o s i t i o n of c l a s s e s or o b j e c t s . B e h a v i o r a l pattern s c h a r a c t e r -\ni ze t he ways in whic h c l a s s e s or o b j e c t s interac t a nd d i s t r i b u t e r e s p o n s i b i l i t y . T he s e c o n d c r i t e r i o n , c a l l ed s c o p e , s p e c i f i e s whethe r t he patter n a p p l i e s p r i m a r i l y to\nc l a s s e s or to o b j e c t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 78, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_design_patterns_gof_chunk_0079_4ecf91b2", "text": "T he s e c o n d c r i t e r i o n , c a l l ed s c o p e , s p e c i f i e s whethe r t he patter n a p p l i e s p r i m a r i l y to\nc l a s s e s or to o b j e c t s . C l a ss pattern s d e al with r e l a t i o n s h i p s betwee n c l a s s e s a nd t h e ir\ns u b c l a s s e s . T h e se r e l a t i o n s h i p s a re e s t a b l i s h e d throug h i n h e r i t a n c e , so they a re s t a t i c —\nf i x ed at c o m p i l e - t i m e . O b j e c t pattern s d e al with o b j e c t r e l a t i o n s h i p s , w h i c h c an be\nc h a n g e d at run-tim e and are m o re d y n a m i c . A l m o s t all pattern s use i n h e r i t a n c e to\ns o me extent . So t he o n ly pattern s l a b e l e d \" c l a ss p a t t e r n s \" a re t h o se that focus on c l a ss\nr e l a t i o n s h i p s . Note that m o st pattern s a re in t he O b j e c t s c o p e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 79, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 865}}
{"id": "computer_science_design_patterns_gof_chunk_0080_7843b70f", "text": "So t he o n ly pattern s l a b e l e d \" c l a ss p a t t e r n s \" a re t h o se that focus on c l a ss\nr e l a t i o n s h i p s . Note that m o st pattern s a re in t he O b j e c t s c o p e . C r e a t i o n a l c l a ss pattern s defer s o me part of o b j e c t c r e a t i o n to s u b c l a s s e s , w h i le C r e -\nationa l o b j e c t pattern s defer it to anothe r o b j e c t . T he Structura l c l a ss pattern s u se\ni n h e r i t a n c e to c o m p o s e c l a s s e s , w h i le t he S t r u c t u r a l o b j e c t pattern s d e s c r i b e ways to\na s s e m b l e o b j e c t s . T he B e h a v i o r a l c l a ss pattern s u se i n h e r i t a n c e to d e s c r i b e a l g o r i t h m s\na nd f l ow of c o n t r o l , w h e r e a s t he B e h a v i o r a l o b j e c t pattern s d e s c r i b e h ow a group of\no b j e c t s c o o p e r a t e to perfor m a task that no s i n g le o b j e c t can c a r ry out a l o n e . T h e re a re other ways to o r g a n i z e t he patterns .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 80, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_design_patterns_gof_chunk_0081_b09fcf42", "text": "T h e re a re other ways to o r g a n i z e t he patterns . S o me p a t t e r n s a re often u s ed t o g e t h e r . F or \ne x a m p l e , C o m p o s i t e is often u s ed with Iterato r or V i s i t o r . S o me pattern s a re a l t e r n a t i v e s :\nPrototyp e is often an alternativ e to Abstrac t F a c t o r y . S o me pattern s r e s u lt in s i m i l a r\nd e s i g n s e v en thoug h the pattern s have differen t i n t e n t s . For e x a m p l e , the structur e\nd i a g r a m s of Composite and Decorator are similar. ptgSECTION 1 .6 H OW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 1 1\nYet anothe r way to organiz e d e s i g n pattern s is a c c o r d i n g to how they referenc e e a ch\nother in their \" R e l a t e d Patterns \" s e c t i o n s . F i g u r e 1 .1 depict s these relationship s graph-\ni c a l l y . C l e a r l y there are many ways to o r g a n i z e d e s i g n patterns .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 81, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_design_patterns_gof_chunk_0082_3c060e1d", "text": "F i g u r e 1 .1 depict s these relationship s graph-\ni c a l l y . C l e a r l y there are many ways to o r g a n i z e d e s i g n patterns . Havin g multipl e ways of\nthinkin g abou t pattern s w i ll d e e p e n your i n s i g h t into w h at they d o, how they c o m p a r e ,\nand when to apply them. 1 . 6 How Design Patterns Solve Design Problems\nD e s i g n pattern s s o l ve many of the day-to-da y p r o b l e m s object-oriente d d e s i g n e r s face,\nand in many differen t ways . H e re are s e v e r a l of t h e se p r o b l e m s and how d e s i g n pattern s \ns o l ve them. F i n d i n g A p p r o p r i a t e Objects\nO b j e c t - o r i e n t e d program s are made up of o b j e c t s . An objec t p a c k a g e s both data and\nthe p r o c e d u r e s that operat e on that data. The p r o c e d u r e s are t y p i c a l l y c a l l ed method s\nor operations . An o b j e c t perform s an operatio n when it r e c e i v e s a reques t (or m e s s a g e )\nfrom a client.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 82, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_design_patterns_gof_chunk_0083_0d46ab3a", "text": "The p r o c e d u r e s are t y p i c a l l y c a l l ed method s\nor operations . An o b j e c t perform s an operatio n when it r e c e i v e s a reques t (or m e s s a g e )\nfrom a client. Request s are the only way to get an o b j e c t to execut e an operation . O p e r a t i o n s are\nthe only way to c h a n g e an o b j e c t ' s interna l data. B e c a u s e of these r e s t r i c t i o n s , the\nobject' s interna l state is s a id to be encapsulated ; it canno t be a c c e s s e d d i r e c t l y , a nd i ts\nrepresentatio n is i n v i s i b l e from outsid e t he object. T he hard part abou t o b j e c t - o r i e n t e d d e s i g n is d e c o m p o s i n g a s y s t e m into o b j e c t s . T he\ntask is difficul t b e c a u s e many factor s c o me into play: encapsulation , granularity , depen-\nd e n c y , f l e x i b i l i t y , performance , e v o l u t i o n , r e u s a b i l i t y , a nd on a nd o n.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 83, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_design_patterns_gof_chunk_0084_8e9fa203", "text": "T h ey a ll influenc e\nt he d e c o m p o s i t i o n , often in c o n f l i c t i n g ways. O b j e c t - o r i e n t e d d e s i g n m e t h o d o l o g i e s favor many differen t approaches . You can write\na p r o b l e m statement , s i n g le out the noun s and v e r b s , and creat e correspondin g c l a s s e s\nand o p e r a t i o n s . Or you can focus on the c o l l a b o r a t i o n s and r e s p o n s i b i l i t i e s in your\nsystem . Or you can m o d e l the r e al world and translat e the o b j e c t s found durin g analysi s\ninto d e s i g n . T h e re w i ll alway s be disagreemen t on whic h approac h is best. Many o b j e c t s in a d e s i g n c o me from the analysi s model . But object-oriente d d e s i g n s\noften end up with c l a s s e s that have no counterpart s in the r e al world . S o me of these are\nl o w - l e v e l c l a s s e s l i ke arrays . Other s a re much h i g h e r - l e v e l .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 84, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_design_patterns_gof_chunk_0085_ef338736", "text": "S o me of these are\nl o w - l e v e l c l a s s e s l i ke arrays . Other s a re much h i g h e r - l e v e l . F or e x a m p l e , t he C o m p o s -\nite ( 1 6 3) patter n i n t r o d u c e s an abstractio n for treatin g o b j e c t s uniforml y that d o e s n ' t\nhave a physica l counterpart . S t r i ct m o d e l i n g of the r e al world l e a ds to a s y s t e m that\nreflect s today' s r e a l i t i e s but not n e c e s s a r i l y tomorrow's . The abstraction s that e m e r g e \nduring design are key to making a design f l e x i b l e . ptg1 2 INTRODUCTION CHAPTER 1\nF i g u r e 1.1: Design pattern relationships\n\nptgSECTION 1.6 HOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 13\nD e s i g n pattern s h e lp you identif y l e s s - o b v i o u s abstraction s and the o b j e c t s t h at can\ncaptur e them . For example , object s t h at represen t a p r o c e s s or algorith m don't occur\nin nature , yet they are a crucia l part of flexibl e d e s i g n s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 85, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_design_patterns_gof_chunk_0086_91462d93", "text": "For example , object s t h at represen t a p r o c e s s or algorith m don't occur\nin nature , yet they are a crucia l part of flexibl e d e s i g n s . The Strateg y ( 3 1 5) patter n\nd e s c r i b e s how to implemen t interchangeabl e familie s of algorithms . The State ( 3 0 5)\npatter n represent s each state of an entity as an object . T h e se object s are seldo m f o u n d\ndurin g analysi s or e v en the early stage s of d e s i g n ; they'r e d i s c o v e r e d later in the cours e\nof makin g a d e s i g n more flexibl e and reusable. D e t e r m i n i n g Objec t G r a n u l a r i t y\nO b j e c t s can vary tremendousl y in s i ze and number . T h ey can represen t everythin g\ndown to the hardwar e or all the way up to entire applications . How do we d e c i d e w h at\nshoul d be an object? D e s i g n pattern s addres s this i s s ue as w e l l.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 86, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 868}}
{"id": "computer_science_design_patterns_gof_chunk_0087_a97d9951", "text": "How do we d e c i d e w h at\nshoul d be an object? D e s i g n pattern s addres s this i s s ue as w e l l. The F a c a d e ( 1 8 5) patter n d e s c r i b e s how to\nrepresen t complet e subsystem s as objects , and the F l y w e i g h t ( 1 9 5) p a t t e r n d e s c r i b e s\nhow to suppor t huge number s of o b j e c t s at the fines t granularities . Othe r d e s i g n pat-\nterns d e s c r i b e specifi c ways of decomposin g an objec t into smalle r objects . Abstrac t\nFactor y ( 8 7) and Builde r ( 9 7) y i e ld object s whos e only r e s p o n s i b i l i t i e s are creatin g other\nob j ects . Visito r ( 3 3 1) a nd Comman d ( 2 3 3) y i e ld object s whos e only r e s p o n s i b i l i t i e s a re\nto implemen t a r e q u e s t on anothe r objec t or group of objects. Specifyin g Objec t Interfaces\nEvery operatio n d e c l a r e d by an objec t specifie s the operation' s name , the object s it\ntakes as parameters , and the operation' s retur n value .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 87, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_design_patterns_gof_chunk_0088_94cc8f6b", "text": "Specifyin g Objec t Interfaces\nEvery operatio n d e c l a r e d by an objec t specifie s the operation' s name , the object s it\ntakes as parameters , and the operation' s retur n value . T h is is know n as the operation' s\ns i g n a t u r e . T he s et of a ll signature s define d by an object' s operation s is c a l l ed t he\ninterfac e to the object . An object' s interfac e characterize s the complet e set of request s\nt h at can be sent to the object . Any r e q u e s t t h at matche s a signatur e in the object' s\ninterfac e may be s e nt to the object. A type is a name used to denot e a particula r interface . We speak of an o b j e c t as havin g\nthe type \" W i n d o w \" if it accept s all request s for the operation s define d in the interfac e\nname d \" W i n d o w . \" An o b j e c t may have many types , and widel y differen t object s can\nshare a type. Part of an object' s interfac e may be characterize d by one type, and other\nparts by other t y p e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 88, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_design_patterns_gof_chunk_0089_fa8e1973", "text": "\" An o b j e c t may have many types , and widel y differen t object s can\nshare a type. Part of an object' s interfac e may be characterize d by one type, and other\nparts by other t y p e s . Two object s of the same type need o n ly share parts of their\ninterfaces . Interface s can contai n other interface s as s u b s e t s . We say t h at a type is a \ns u b t y p e of anothe r if i ts interfac e contain s t he interfac e of i ts s u p e r t y p e . Often we\nspeak of a subtyp e inheriting the interfac e of its supertype. Interface s are f u n d a m e n t a l in object-oriente d systems . O b j e c t s are know n only throug h\ntheir interfaces . T h e re is no way to know anythin g abou t an objec t or to ask it to do\nanythin g withou t g o i ng throug h its interface . An object' s interfac e says nothin g abou t \nits implementation—different o b j e c t s are f r e e t o implement requests d i f f e r e n t l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 89, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_design_patterns_gof_chunk_0090_b42daa76", "text": "An object' s interfac e says nothin g abou t \nits implementation—different o b j e c t s are f r e e t o implement requests d i f f e r e n t l y . T h a t\n\nptg14 INTRODUCTION CHAPTER 1\nmean s two o b j e c t s havin g c o m p l e t e l y differen t implementation s can h a ve i d e n t i c a l\ninterfaces. Whe n a r e q u e s t is s e nt to an o b j e c t , the particula r operatio n that's performe d d e p e n d s on\nboth the r e q u e s t and the r e c e i v i n g o b j e c t . Differen t o b j e c t s that s u p p o r t i d e n t i c a l r e q u e s t s\nmay have differen t implementation s of the o p e r a t i o n s that fulfil l t h e se r e q u e s t s . The\nrun-tim e a s s o c i a t i o n of a reques t to an o b j e c t a nd o ne of i ts o p e r a t i o n s is know n as\nd y n a m i c b i n d i n g . Dynami c bindin g mean s that i s s u i n g a r e q u e s t d o e s n ' t c o m m i t you to a particula r\nimplementatio n until run-time .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 90, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_design_patterns_gof_chunk_0091_7b170be9", "text": "Dynami c bindin g mean s that i s s u i n g a r e q u e s t d o e s n ' t c o m m i t you to a particula r\nimplementatio n until run-time . C o n s e q u e n t l y , you can write program s that e x p e c t an\nobjec t with a particula r interface , knowin g that any o b j e c t that has the c o r r e c t interfac e\nw i ll a c c e p t the r e q u e s t . M o r e o v e r , dynami c bindin g l e ts you substitut e o b j e c t s that\nhave identica l interface s for e a ch other at run-time . T h is substitutabilit y is know n as\np o l y m o r p h i s m , a nd it's a k ey c o n c e p t in o b j e c t - o r i e n t e d s y s t e m s . It l e ts a c l i e nt o b j e c t\nmake few assumption s abou t other object s b e y o n d supportin g a particula r interface . Polymorphis m s i m p l i f i e s t he definition s of c l i e n t s , d e c o u p l e s o b j e c t s from e a ch o t h e r ,\nand l e ts them vary their relationship s to each other at run-time.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 91, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_design_patterns_gof_chunk_0092_de5f6cb6", "text": "Polymorphis m s i m p l i f i e s t he definition s of c l i e n t s , d e c o u p l e s o b j e c t s from e a ch o t h e r ,\nand l e ts them vary their relationship s to each other at run-time. D e s i g n pattern s help you defin e interface s by identifyin g t h e ir key e l e m e n t s and the\nkinds of data t h at get s e nt a c r o s s an interface . A d e s i g n patter n migh t a l so t e ll you what\nnot to put in the interface . The Mement o ( 2 8 3) patter n is a g o od e x a m p l e . It d e s c r i b e s\nhow to encapsulat e and s a ve the interna l state of an o b j e c t so that the o b j e c t can be\nrestore d to that state later. The patter n stipulate s that Mement o o b j e c t s must defin e two\ninterfaces : a r e s t r i c t e d o ne that l e ts c l i e n t s h o ld a nd c o py m e m e n t o s , a nd a p r i v i l e g e d \none that only the origina l o b j e c t can use to store and retriev e state in the memento.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 92, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_design_patterns_gof_chunk_0093_92c313bd", "text": "D e s i g n pattern s a l so specif y relationship s betwee n interfaces . In particular , they often\nrequir e some c l a s s e s to have s i m i l a r interfaces , or they p l a ce constraint s on the interface s\nof s o me c l a s s e s . F or e x a m p l e , both Decorato r ( 1 7 5) a nd P r o xy ( 2 0 7) r e q u i r e t he interface s\nof Decorato r and P r o xy object s to be identica l to the decorate d and p r o x i e d o b j e c t s . In\nVisito r ( 3 3 1 ) , t he V i s i t o r interfac e must reflec t a ll c l a s s e s of o b j e c t s that v i s i t o r s c an v i s i t . Specifyin g Objec t Implementations\nSo far we've s a id little abou t how we actuall y defin e an object . An o b j e c t ' s i m p l e -\nmentatio n is define d by i ts c l a s s . T he c l a ss s p e c i f i e s t he o b j e c t ' s interna l data and\nrepresentatio n and define s the operation s the o b j e c t can perform.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 93, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 913}}
{"id": "computer_science_design_patterns_gof_chunk_0094_d6855158", "text": "T he c l a ss s p e c i f i e s t he o b j e c t ' s interna l data and\nrepresentatio n and define s the operation s the o b j e c t can perform. O ur O M T - b a s e d notatio n (summarize d in A p p e n d i x B) d e p i c t s a c l a ss as a r e c t a n g l e\nwith the c l a ss name in bold. Operation s appea r in norma l type b e l ow the c l a ss name . Any data that the c l a ss define s c o m e s a f t er the operations . L i n es s e p a r a t e the c l a ss name\nfrom the operations and the operations f r o m the data:\n\nptgSECTION 1 . 6 HOW D E S I G N P A T T E R N S S O L V E D E S I G N P R O B L E M S 1 5\nRetur n t y p es a nd i n s t a n c e v a r i a b l e t y p es a re o p t i o n a l , s i n ce we d o n 't a s s u m e a s t a t i c a l l y\nt y p ed implementatio n language. O b j e c t s a re c r e a t e d by i n s t a n t i a t i n g a c l a s s. T he o b j e c t is s a id to be an i n s t a n c e of t he\nc l a s s.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 94, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_design_patterns_gof_chunk_0095_158a9d40", "text": "O b j e c t s a re c r e a t e d by i n s t a n t i a t i n g a c l a s s. T he o b j e c t is s a id to be an i n s t a n c e of t he\nc l a s s. T he p r o c e s s of instantiatin g a c l a ss a l l o c a t e s s t o r a g e f or t he o b j e c t ' s interna l data\n(mad e up of instanc e variables ) and a s s o c i a t e s the o p e r a t i o n s with t h e se data. Man y\ns i m i l a r i n s t a n c e s of an o b j e c t c an be c r e a t e d by instantiatin g a c l a s s . A d a s h e d arrowhea d l i ne i n d i c a t e s a c l a ss that instantiate s o b j e c t s of anothe r c l a s s. T he\na r r o w points to the class of the instantiated objects. N ew c l a s s e s c an be define d in terms of e x i s t i n g c l a s s e s using c l a ss inheritance . Whe n\na s u b c l a s s inherit s from a paren t c l a s s, it include s the definition s of all the data and\no p e r a t i o n s that the paren t c l a ss defines .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 95, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_design_patterns_gof_chunk_0096_a63c5ecc", "text": "Whe n\na s u b c l a s s inherit s from a paren t c l a s s, it include s the definition s of all the data and\no p e r a t i o n s that the paren t c l a ss defines . O b j e c t s that are i n s t a n c e s of the s u b c l a s s w i ll\ncontai n all data define d by the s u b c l a s s and its paren t c l a s s e s , and they'l l be a b le to\nperfor m a ll o p e r a t i o n s d e f i n e d by t h is s u b c l a s s a nd i ts p a r e n t s . We i n d i c a t e t he s u b c l a s s\nr e l a t i o n s h i p w i t h a vertical line and a triangle:\nAn a b s t r a c t c l a ss is o ne w h o s e m a in p u r p o s e is to d e f i n e a c o m m o n i n t e r f a c e f or i ts\ns u b c l a s s e s . An a b s t r a c t c l a ss w i ll defer s o me or a ll of i ts implementatio n to operation s\ndefine d in s u b c l a s s e s ; h e n ce an abstrac t c l a ss canno t be instantiated .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 96, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 883}}
{"id": "computer_science_design_patterns_gof_chunk_0097_f891c6f3", "text": "An a b s t r a c t c l a ss w i ll defer s o me or a ll of i ts implementatio n to operation s\ndefine d in s u b c l a s s e s ; h e n ce an abstrac t c l a ss canno t be instantiated . T he operation s\nthat an abstrac t c l a ss d e c l a r e s b ut d o e s n ' t implemen t a re c a l l ed abstrac t operations . C l a s s e s t h a t a r e n ' t a b s t r a c t are called concrete classes. ptg1 6 INTRODUCTION CHAFTER 1\nS u b c l a s s e s c an refine a nd redefin e b e h a v i o r s of their paren t c l a s s e s . M o re s p e c i f i c a l l y , a\nc l a ss m ay overrid e an o p e r a t i o n d e f i n e d by i ts paren t c l a s s. O v e r r i d i n g g i v es s u b c l a s s e s\na c h a n c e to handl e r e q u e s t s i n s t e a d of t h e ir paren t c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 97, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 782}}
{"id": "computer_science_design_patterns_gof_chunk_0098_6c0d5c3c", "text": "O v e r r i d i n g g i v es s u b c l a s s e s\na c h a n c e to handl e r e q u e s t s i n s t e a d of t h e ir paren t c l a s s e s . C l a ss i n h e r i t a n c e l e ts y ou\ndefin e c l a s s e s s i m p l y by e x t e n d i n g o t h er c l a s s e s , makin g it e a sy to defin e f a m i l i e s of\no b j e c t s h a v i n g r e l a t e d f u n c t i o n a l i t y . T he n a m e s of a b s t r a c t c l a s s e s appea r in s l a n t e d type to d i s t i n g u i s h them from c o n c r e t e\nc l a s s e s . S l a n t e d type is a l so u s ed to d e n o t e a b s t r a c t o p e r a t i o n s . A d i a g r a m m ay i n c l u d e\np s e u d o c o d e f o r a n operation's implementation; if so, the c o d e w i l l a p p e a r in a dog-\ne a r e d box connected by a dashed line to the operation it implements. A mixin c l a ss is a c l a ss that's i n t e n d e d to p r o v i d e an o p t i o n a l i n t e r f a c e or functionalit y\nto other c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 98, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_design_patterns_gof_chunk_0099_76a2fd48", "text": "A mixin c l a ss is a c l a ss that's i n t e n d e d to p r o v i d e an o p t i o n a l i n t e r f a c e or functionalit y\nto other c l a s s e s . I t 's s i m i l a r to an a b s t r a c t c l a ss in that i t 's n ot i n t e n d e d to be i n s t a n t i a t e d . M i x i n classes require multiple inheritance:\nC l a ss v e r s u s I n t e r f a c e I n h e r i t a n c e\nIt's importan t to understan d the differenc e b e t w e e n an o b j e c t ' s class and its type. An o b j e c t ' s c l a ss d e f i n e s h ow t he o b j e c t is i m p l e m e n t e d . T he c l a ss d e f i n e s t he o b j e c t ' s\ninterna l state a nd t he implementatio n of i ts o p e r a t i o n s . In c o n t r a s t , an o b j e c t ' s t y pe\no n ly refers to i ts interface—th e s et of r e q u e s t s to w h i c h it c an r e s p o n d . An o b j e c t c an\nhave many types, and objects of different c l a s s e s can have the same type.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 99, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_design_patterns_gof_chunk_0100_96593d52", "text": "An o b j e c t c an\nhave many types, and objects of different c l a s s e s can have the same type. ptgSECTION 1.6 HOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 17\nOf c o u r s e , t h e r e ' s a c l o se r e l a t i o n s h i p b e t w e e n c l a ss a nd t y p e. B e c a u s e a c l a ss d e f i n e s\nthe operation s an o b j e c t can perform , it a l so define s the o b j e c t ' s type. Whe n we say\nthat an objec t is an instanc e of a c l a s s , we imply that the o b j e c t support s the interfac e\nd e f i n e d by t he c l a s s . L a n g u a g e s l i ke C ++ a nd Eiffe l u se c l a s s e s to s p e c i f y both an o b j e c t ' s t y pe a nd i ts i m p l e -\nmentation . S m a l l t a l k program s do n ot d e c l a r e t he t y p es of v a r i a b l e s ; c o n s e q u e n t l y , t he\nc o m p i l e r d o es n ot c h e ck that t he t y p es of o b j e c t s a s s i g n e d to a v a r i a b l e a re subtype s of\nt he v a r i a b l e ' s t y p e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 100, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_design_patterns_gof_chunk_0101_aeeb0443", "text": "S e n d i n g a m e s s a g e r e q u i r e s c h e c k i n g that t he c l a ss of t he r e c e i v e r\nimplement s the m e s s a g e , but it doesn' t r e q u i r e c h e c k i n g that the r e c e i v e r is an instanc e\nof a particula r c l a s s . It's a l so importan t to understan d the differenc e betwee n c l a ss i n h e r i t a n c e and interfac e\ninheritanc e ( or subtyping) . C l a ss i n h e r i t a n c e define s an o b j e c t ' s i m p l e m e n t a t i o n in\nterms of a n o t h e r o b j e c t ' s i m p l e m e n t a t i o n . In s h o r t , i t 's a m e c h a n i s m f or c o de a nd\nrepresentatio n sharing . In contrast , interfac e inheritanc e (or s u b t y p i n g ) d e s c r i b e s when\nan o b j e c t c an be u s ed in p l a ce of another. I t 's e a sy to confus e t h e se two c o n c e p t s , b e c a u s e many l a n g u a g e s don't make the d i s -\nt i n c t i o n e x p l i c i t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 101, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_design_patterns_gof_chunk_0102_2ff3dccb", "text": "I t 's e a sy to confus e t h e se two c o n c e p t s , b e c a u s e many l a n g u a g e s don't make the d i s -\nt i n c t i o n e x p l i c i t . In l a n g u a g e s l i ke C ++ a nd Eiffel , i n h e r i t a n c e m e a n s both i n t e r f a c e\nand implementatio n inheritance . The standar d way to i n h e r i t an interfac e in C++ is \nto i n h e r i t publicl y f r om a c l a ss that has (pure ) virtua l membe r functions . P u re inter-\nface i n h e r i t a n c e c an be a p p r o x i m a t e d in C ++ by i n h e r i t i n g p u b l i c l y from pure a b s t r a c t\nc l a s s e s . Pure implementatio n or c l a ss inheritanc e c an be a p p r o x i m a t e d with privat e\ninheritance . In S m a l l t a l k , inheritanc e mean s just implementatio n i n h e r i t a n c e . You can\na s s i g n i n s t a n c e s of a ny c l a ss to a v a r i a b l e as l o ng as t h o se i n s t a n c e s suppor t t he o p e r a -\nt i on performe d on the value of the v a r i a b l e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 102, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_design_patterns_gof_chunk_0103_7c1d860f", "text": "You can\na s s i g n i n s t a n c e s of a ny c l a ss to a v a r i a b l e as l o ng as t h o se i n s t a n c e s suppor t t he o p e r a -\nt i on performe d on the value of the v a r i a b l e . Althoug h most programmin g l a n g u a g e s don't suppor t the d i s t i n c t i o n betwee n i n t e r -\nface and implementatio n i n h e r i t a n c e , p e o p l e make the distinctio n in p r a c t i c e . S m a l l t a l k\nprogrammer s usuall y a ct as if s u b c l a s s e s w e re subtype s (thoug h there a re s o me w e l l -\nknow n e x c e p t i o n s [ C o o 9 2 ] ) ; C ++ p r o g r a m m e r s m a n i p u l a t e o b j e c t s t h r o u g h t y p es d e -\nfined by abstrac t c l a s s e s . Many of the d e s i g n pattern s d e p e n d on this distinction . For e x a m p l e , o b j e c t s in a Chai n\nof R e s p o n s i b i l i t y ( 2 2 3) must have a commo n t y p e, b ut usuall y they don't s h a re a c o m -\nm on i m p l e m e n t a t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 103, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_design_patterns_gof_chunk_0104_ee3b8f8a", "text": "For e x a m p l e , o b j e c t s in a Chai n\nof R e s p o n s i b i l i t y ( 2 2 3) must have a commo n t y p e, b ut usuall y they don't s h a re a c o m -\nm on i m p l e m e n t a t i o n . In t he C o m p o s i t e ( 1 6 3) p a t t e r n , C o m p o n e n t d e f i n e s a c o m m o n\ninterface , but Composit e often define s a commo n implementation . Comman d ( 2 3 3 ) ,\nO b s e r v e r ( 2 9 3 ) , State ( 3 0 5 ) , a nd Strateg y ( 3 1 5) a re often implemente d with abstrac t\nc l a s s e s that a re p u re i n t e r f a c e s . P r o g r a m m i n g to an I n t e r f a c e , n ot an I m p l e m e n t a t i o n\nC l a ss inheritanc e is b a s i c a l l y just a mechanis m for extendin g an application' s function-\na l i ty by r e u s i n g f u n c t i o n a l i t y in paren t c l a s s e s . It l e ts y ou d e f i n e a n ew k i nd of o b j e c t\nrapidl y in term s of an old o n e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 104, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_design_patterns_gof_chunk_0105_6e47db44", "text": "It l e ts y ou d e f i n e a n ew k i nd of o b j e c t\nrapidl y in term s of an old o n e. It l e ts you get new implementation s a l m o s t for f r e e,\ninheriting most of what you need from existing classes. ptg18 INTRODUCTION CHAPTER 1\nH o w e v e r , i m p l e m e n t a t i o n r e u se is o n ly h a lf t he s t o r y . I n h e r i t a n c e ' s a b i l i t y to d e f i n e\nfamilie s of o b j e c t s with identical interface s ( u s u a l l y by i n h e r i t i n g from an abstrac t c l a s s)\nis a l so i m p o r t a n t . W h y ? B e c a u s e p o l y m o r p h i s m d e p e n d s on i t . W h en i n h e r i t a n c e is u s ed c a r e f u l l y ( s o m e w i ll s ay properly), a ll c l a s s e s d e r i v e d from\nan abstrac t c l a ss w i l l s h a re i ts interface . T h is i m p l i e s that a s u b c l a s s m e r e l y a d ds or\no v e r r i d e s o p e r a t i o n s a nd d o es n ot h i de o p e r a t i o n s of t he paren t c l a s s.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 105, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_design_patterns_gof_chunk_0106_e18a7d19", "text": "T h is i m p l i e s that a s u b c l a s s m e r e l y a d ds or\no v e r r i d e s o p e r a t i o n s a nd d o es n ot h i de o p e r a t i o n s of t he paren t c l a s s. A ll s u b c l a s s e s\nc an t h en r e s p o n d to t he r e q u e s t s in t he interfac e of t h is abstrac t c l a s s, m a k i n g them a ll\ns u b t y p e s of t he abstrac t c l a s s . T h e re a re t wo benefit s to manipulatin g o b j e c t s s o l e ly in terms of t he interfac e d e f i n e d\nby abstrac t c l a s s e s :\n1. C l i e n t s r e m a i n unawar e of t he s p e c i f i c t y p es of o b j e c t s t h ey u s e, as l o ng as t he\no b j e c t s a d h e r e to the interfac e that c l i e n t s e x p e c t . 2. C l i e n t s r e m a i n unawar e of t he c l a s s e s that i m p l e m e n t t h e s e o b j e c t s . C l i e n t s o n ly\nk n ow abou t t he a b s t r a c t c l a s s ( e s ) definin g t he interface.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 106, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 915}}
{"id": "computer_science_design_patterns_gof_chunk_0107_32ccee54", "text": "C l i e n t s o n ly\nk n ow abou t t he a b s t r a c t c l a s s ( e s ) definin g t he interface. T h is so greatl y r e d u c e s implementatio n d e p e n d e n c i e s betwee n su bsy s tem s that it l e a ds\nto t he f o l l o w i n g p r i n c i p l e of r e u s a b l e o b j e c t - o r i e n t e d d e s i g n :\nProgram to an interface, not an implementation. D o n ' t d e c l a r e v a r i a b l e s to be i n s t a n c e s of particula r c o n c r e t e c l a s s e s . I n s t e a d , c o m m i t\no n ly to an i n t e r f a c e d e f i n e d by an a b s t r a c t c l a s s. Y ou w i ll f i nd t h is to be a c o m m o n\nthem e of t he d e s i g n pattern s in t h is book.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 107, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 686}}
{"id": "computer_science_design_patterns_gof_chunk_0108_a94dbade", "text": "Y ou w i ll f i nd t h is to be a c o m m o n\nthem e of t he d e s i g n pattern s in t h is book. Y ou h a ve to instantiat e c o n c r e t e c l a s s e s (that i s, specif y a particula r i m p l e m e n t a t i o n )\ns o m e w h e r e in your s y s t e m , of c o u r s e , a nd t he c r e a t i o n a l p a t t e r n s ( A b s t r a c t F a c t o r y ( 8 7 ),\nB u i l d e r ( 9 7 ), Factor y M e t h o d ( 1 0 7 ) , Prototyp e ( 1 1 7 ) , a nd S i n g l e t o n ( 1 2 7 ) ) l et y ou do just\nth a t. By a b s t r a c t i n g t he p r o c e s s of o b j e c t c r e a t i o n , t h e se p a t t e r n s g i ve y ou differen t\nways to a s s o c i a t e an interfac e with its implementatio n transparentl y at i n s t a n t i a t i o n . C r e a t i o n a l pattern s e n s u r e that your s y s t e m is writte n in terms of i n t e r f a c e s , n ot i m p l e -\nm e n t a t i o n s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 108, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 889}}
{"id": "computer_science_design_patterns_gof_chunk_0109_7d69d99d", "text": "C r e a t i o n a l pattern s e n s u r e that your s y s t e m is writte n in terms of i n t e r f a c e s , n ot i m p l e -\nm e n t a t i o n s . P u t t i n g R e u s e M e c h a n i s m s to W o r k\nM o st p e o p l e c an understan d c o n c e p t s l i ke o b j e c t s , interfaces , c l a s s e s , a nd i n h e r i t a n c e . T he c h a l l e n g e l i es in applyin g them to b u i ld f l e x i b l e , r e u s a b l e software , a nd d e s i g n\npattern s c an s h ow y ou h o w . I n h e r i t a n c e v e r s u s C o m p o s i t i o n\nT he t wo m o st c o m m o n t e c h n i q u e s f or r e u s i n g functionalit y in o b j e c t - o r i e n t e d s y s t e m s\na r e class inheritance and object composition. A s w e ' v e e x p l a i n e d , c l a s s i n h e r i t a n c e l e t s\n\nptgSECTION 1.6 HOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 19\ny ou defin e t he implementatio n of o ne c l a ss in terms of another's .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 109, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 937}}
{"id": "computer_science_design_patterns_gof_chunk_0110_49354896", "text": "Reus e by s u b c l a s s i n g\nis often referre d to as white-bo x reuse . The term \" w h i t e - b o x \" refers to v i s i b i l i t y : With\ni n h e r i t a n c e , t he i n t e r n a l s of paren t c l a s s e s a re often v i s i b l e to s u b c l a s s e s . O b j e c t c o m p o s i t i o n is an a l t e r n a t i v e to c l a ss i n h e r i t a n c e . H e r e, n ew f u n c t i o n a l i t y is\nobtaine d by a s s e m b l i n g or composing o b j e c t s to get more c o m p l e x functionality . O b j e c t\nc o m p o s i t i o n r e q u i r e s that t he o b j e c t s b e i ng c o m p o s e d h a ve w e l l - d e f i n e d i n t e r f a c e s . T h is s t y le of r e u se is c a l l ed black-bo x reuse , b e c a u s e no interna l d e t a i l s of o b j e c t s a re\nv i s i b l e . O b j e c t s appea r o n ly as \" b l a c k b o x e s . \"\nInheritanc e a nd c o m p o s i t i o n e a ch have their advantage s a nd disadvantages .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 110, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_design_patterns_gof_chunk_0111_1327fb06", "text": "O b j e c t s appea r o n ly as \" b l a c k b o x e s . \"\nInheritanc e a nd c o m p o s i t i o n e a ch have their advantage s a nd disadvantages . C l a ss\ninheritanc e is define d staticall y at c o m p i l e - t i m e a nd is straightforwar d to u s e, s i n ce\ni t 's supporte d d i r e c t l y by the programmin g language . C l a ss inheritanc e a l so make s it\ne a s i er to modif y t he i m p l e m e n t a t i o n b e i ng r e u s e d . W h en a s u b c l a s s o v e r r i d e s s o me\nbut not all operations , it can a f f e c t the operation s it inherit s as w e l l, assumin g they c a ll\nthe overridde n o p e r a t i o n s . B ut c l a ss i n h e r i t a n c e h as s o me d i s a d v a n t a g e s , t o o. F i r s t, y ou c a n 't c h a n g e t he i m p l e -\nmentation s i n h e r i t e d from paren t c l a s s e s at run-time , becaus e inheritanc e is define d\nat c o m p i l e - t i m e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 111, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 913}}
{"id": "computer_science_design_patterns_gof_chunk_0112_66acd0f6", "text": "F i r s t, y ou c a n 't c h a n g e t he i m p l e -\nmentation s i n h e r i t e d from paren t c l a s s e s at run-time , becaus e inheritanc e is define d\nat c o m p i l e - t i m e . S e c o n d , a nd g e n e r a l l y w o r s e , paren t c l a s s e s often defin e at l e a st part\nof t h e ir s u b c l a s s e s ' p h y s i c a l representation . B e c a u s e inheritanc e e x p o s e s a s u b c l a s s to\nd e t a i l s of its parent' s implementation , i t 's often s a id that \" i n h e r i t a n c e break s e n c a p -\ns u l a t i o n \" [ S n y 8 6 ] . T he i m p l e m e n t a t i o n of a s u b c l a s s b e c o m e s so b o u n d up w i th t he\nimplementatio n of its paren t c l a ss that any c h a n g e in the parent' s implementatio n w i ll\nforce the s u b c l a s s to c h a n g e . I m p l e m e n t a t i o n d e p e n d e n c i e s c an c a u se p r o b l e m s w h en y o u ' r e trying to r e u se a s u b -\nc l a s s.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 112, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_design_patterns_gof_chunk_0113_f6b62f53", "text": "I m p l e m e n t a t i o n d e p e n d e n c i e s c an c a u se p r o b l e m s w h en y o u ' r e trying to r e u se a s u b -\nc l a s s. S h o u l d any a s p e c t of the inherite d implementatio n not be appropriat e for new\np r o b l e m domains , the paren t c l a ss must be rewritte n or r e p l a c e d by somethin g m o re \nappropriate . T h is dependenc y limits f l e x i b i l i t y a nd ultimatel y r e u s a b i l i t y . O ne c u re\nfor this is to inheri t o n ly from abstrac t c l a s s e s , s i n ce they usuall y provid e little or no\ni m p l e m e n t a t i o n . O b j e c t compositio n is define d dynamicall y at run-tim e throug h o b j e c t s a c q u i r i n g refer-\ne n c es to other ob j ect s . C o m p o s i t i o n r e q u i r e s object s to r e s p e c t e a ch others ' interfaces ,\nw h i c h in turn r e q u i r e s c a r e f u l l y d e s i g n e d i n t e r f a c e s that don't s t op y ou from u s i ng\none o b j e c t with many others .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 113, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_design_patterns_gof_chunk_0114_9ab2e459", "text": "But there is a p a y o f f . B e c a u s e o b j e c t s are a c c e s s e d s o l e ly\nthroug h their interfaces , we don't break encapsulation . Any o b j e c t can be r e p l a c e d at\nrun-tim e by anothe r as l o ng as it has the same type. M o r e o v e r , becaus e an o b j e c t ' s im-\nplementatio n w i ll be writte n in terms of o b j e c t interfaces , there are substantiall y fewe r\ni m p l e m e n t a t i o n d e p e n d e n c i e s . O b j e c t c o m p o s i t i o n h as anothe r effec t on s y s t e m d e s i g n . F a v o r i n g o b j e c t c o m p o s i t i o n\no v er c l a ss inheritanc e h e l ps you keep e a ch c l a ss encapsulate d and focuse d on one task. Y o ur c l a s s e s a nd c l a ss h i e r a r c h i e s w i ll r e m a i n s m a ll a nd w i ll be l e ss l i k e ly to g r ow i n to\nunmanageabl e monsters .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 114, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 849}}
{"id": "computer_science_design_patterns_gof_chunk_0115_cf1b9ef2", "text": "Y o ur c l a s s e s a nd c l a ss h i e r a r c h i e s w i ll r e m a i n s m a ll a nd w i ll be l e ss l i k e ly to g r ow i n to\nunmanageabl e monsters . On the other hand , a d e s i g n b a s ed on o b j e c t c o m p o s i t i o n w i ll\nhave more o b j e c t s (if fewe r c l a s s e s ) , and the system' s behavio r w i ll depen d on their\ninterrelationships instead of being defined i n o n e class. ptg2 0 INTRODUCTION CHAPTER 1\nThat l e a ds us to o ur s e c o n d p r i n c i p l e of object-oriente d d e s i g n :\nFavor object composition over class inheritance. I d e a l l y , you shouldn' t have to c r e a t e new component s to a c h i e v e r e u s e . You s h o u l d\nbe a b le to get all the functionalit y you n e ed just by a s s e m b l i n g e x i s t i n g component s\nthroug h o b j e c t c o m p o s i t i o n . B ut t h is is r a r e ly t he c a s e, b e c a u s e t he s et of a v a i l a b l e\ncomponent s is n e v er q u i te rich enoug h in p r a c t i c e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 115, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_design_patterns_gof_chunk_0116_c662163a", "text": "B ut t h is is r a r e ly t he c a s e, b e c a u s e t he s et of a v a i l a b l e\ncomponent s is n e v er q u i te rich enoug h in p r a c t i c e . R e u s e by inheritanc e make s it e a s i e r\nto m a ke n ew c o m p o n e n t s that c an be c o m p o s e d with o ld o n e s. I n h e r i t a n c e a nd o b j e c t\nc o m p o s i t i o n thus work together. N e v e r t h e l e s s , our e x p e r i e n c e is that d e s i g n e r s o v e r u s e inheritanc e as a r e u se t e c h n i q u e ,\nand d e s i g n s are o f t en made m o re r e u s a b l e (and s i m p l e r ) by d e p e n d i n g m o re on ob-\nject c o m p o s i t i o n . Y o u ' l l s ee o b j e c t c o m p o s i t i o n a p p l i e d again a nd again in t he d e s i g n\npatterns. Delegation\nDelegatio n is a way of makin g c o m p o s i t i o n as powerfu l for r e u se as i n h e r i -\nt a n ce [ L i e 8 6 , J Z 9 1 1 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 116, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_design_patterns_gof_chunk_0117_cd2c7ba1", "text": "Delegation\nDelegatio n is a way of makin g c o m p o s i t i o n as powerfu l for r e u se as i n h e r i -\nt a n ce [ L i e 8 6 , J Z 9 1 1 . In d e l e g a t i o n , t wo o b j e c t s a re i n v o l v e d in handlin g a r e q u e s t : a\nr e c e i v i n g o b j e c t delegate s o p e r a t i o n s to i ts delegate . T h is is analogou s to s u b c l a s s e s\nd e f e r r i n g r e q u e s t s to p a r e n t c l a s s e s . B ut with i n h e r i t a n c e , an i n h e r i t e d o p e r a t i o n c an\nalway s refer to the r e c e i v i n g objec t throug h the t h is m e m b e r variabl e in C++ and \nsel f in S m a l l t a l k . To a c h i e v e t he s a me effect with d e l e g a t i o n , t he r e c e i v e r p a s s e s i t s e lf\nto the d e l e g a t e to let the delegate d operatio n refer to the r e c e i v e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 117, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 831}}
{"id": "computer_science_design_patterns_gof_chunk_0118_24bb539e", "text": "To a c h i e v e t he s a me effect with d e l e g a t i o n , t he r e c e i v e r p a s s e s i t s e lf\nto the d e l e g a t e to let the delegate d operatio n refer to the r e c e i v e r . F or e x a m p l e , instea d of makin g c l a ss Windo w a s u b c l a s s of Rectangl e ( b e c a u s e win-\nd o ws h a p p e n to be rectangular) , the Windo w c l a ss migh t r e u se the behavio r of Rectan-\ngle by k eep i n g a R e c t a n g l e i n s t a n c e v a r i a b l e and delegating R e c t a n g l e - s p e c i f i c behavio r\nto it. In other w o r d s , i n s t e a d of a W i n d o w being a R e c t a n g l e , it woul d have a Rectangle . W i n d o w must now forwar d r e q u e s t s to its Rectangl e instanc e e x p l i c i t l y , w h e r e a s befor e\nit w o u l d h a ve i n h e r i t e d t h o se o p e r a t i o n s . The followin g diagra m d e p i c t s the W i n d o w c l a ss delegatin g its A r ea operatio n to a\nR e c t a n g l e instance.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 118, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_design_patterns_gof_chunk_0119_50690081", "text": "The followin g diagra m d e p i c t s the W i n d o w c l a ss delegatin g its A r ea operatio n to a\nR e c t a n g l e instance. ptgSECTION 1.6 HOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 21\nA p l a in a r r o w h e a d l i ne i n d i c a t e s that a c l a ss k e e ps a r e f e r e n c e to an i n s t a n c e of anothe r\nc l a s s. The referenc e has an optiona l name , \" r e c t a n g l e \" in this c a s e . The main advantag e of delegatio n is that it make s it e a sy to c o m p o s e b e h a v i o r s at\nrun-tim e and to chang e the way they'r e c o m p o s e d . Our windo w can b e c o m e c i r c u l a r\nat run-tim e s i m p l y by r e p l a c i n g its Rectangl e instanc e with a C i r c le instance , assumin g\nRectangl e and C i r c l e have the same type.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 119, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 774}}
{"id": "computer_science_design_patterns_gof_chunk_0120_aec7a9e8", "text": "Our windo w can b e c o m e c i r c u l a r\nat run-tim e s i m p l y by r e p l a c i n g its Rectangl e instanc e with a C i r c le instance , assumin g\nRectangl e and C i r c l e have the same type. Delegatio n has a disadvantag e it s h a r e s with other technique s that make softwar e m o re\nf l e x i b l e throug h o b j e c t c o m p o s i t i o n : D y n a m i c , h i g h l y p a r a m e t e r i z e d softwar e is harde r \nto understan d than m o re static software . T h e re are a l so run-time i n e f f i c i e n c i e s , but the\nh u m a n inefficiencie s are more importan t in the l o ng run. D e l e g a t i o n is a g o od d e s i g n\nc h o i c e o n ly when it s i m p l i f i e s more than it c o m p l i c a t e s . It i s n 't e a sy to g i ve r u l es that\nt e ll you exactl y when to use d e l e g a t i o n , b e c a u s e how effectiv e it w i ll be d e p e n d s on the\ncontex t and on how much e x p e r i e n c e you have with it.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 120, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_design_patterns_gof_chunk_0121_c423f78c", "text": "D e l e g a t i o n work s b e st when \nit's u s ed in highl y s t y l i z e d ways—tha t is, in standar d patterns. S e v e r a l desig n pattern s u se delegation . T he State ( 3 0 5 ) , Strateg y ( 3 1 5 ) , a nd Visito r ( 3 3 1)\npattern s depen d on it. In the State pattern , an objec t d e l e g a t e s r e q u e s t s to a State o b j e c t\nthat r e p r e s e n t s i ts c u r r e n t s t a t e. In t he S t r a t e g y pattern , an o b j e c t d e l e g a t e s a s p e c i f i c\nr e q u e s t to an objec t that represent s a strategy for carryin g out the request . An o b j e c t w i ll\no n ly have one s t a t e, but it can have many s t r a t e g i e s for differen t r e q u e s t s . The purpos e\nof both pattern s is to c h a n g e the behavio r of an o b j e c t by changin g the o b j e c t s to w h i c h\nit delegate s r e q u e s t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 121, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 858}}
{"id": "computer_science_design_patterns_gof_chunk_0122_ca52aa6b", "text": "The purpos e\nof both pattern s is to c h a n g e the behavio r of an o b j e c t by changin g the o b j e c t s to w h i c h\nit delegate s r e q u e s t s . In V i s i t o r , the operatio n that g e ts performe d on e a ch elemen t of\nan o b j e c t structur e is a l w a y s d e l e g a t e d to t he V i s i t o r o b j e c t . O t h e r pattern s u se d e l e g a t i o n l e ss h e a v i l y . M e d i a t o r ( 2 7 3) i n t r o d u c e s an o b j e c t to m e d i -\nate communicatio n betwee n other objects . S o m e t i m e s the Mediato r o b j e c t implement s\noperation s s i m p l y by forwardin g them to the other o b j e c t s ; other times it p a s s e s along\na referenc e to i t s e lf a nd thus u s es true d e l e g a t i o n . C h a in of R e s p o n s i b i l i t y ( 2 2 3) h a n d l e s\nrequest s by forwardin g them from one o b j e c t to anothe r a l o ng a chain of objects .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 122, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 904}}
{"id": "computer_science_design_patterns_gof_chunk_0123_3d507a7b", "text": "C h a in of R e s p o n s i b i l i t y ( 2 2 3) h a n d l e s\nrequest s by forwardin g them from one o b j e c t to anothe r a l o ng a chain of objects . S o m e -\nt i m es t h is r e q u e s t c a r r i e s with it a r e f e r e n c e to t he o r i g i n a l o b j e c t r e c e i v i n g t he r e q u e s t ,\nin whic h c a se t he patter n is using delegation . B r i d g e ( 1 5 1) d e c o u p l e s an abstractio n\nfrom its implementation . If the abstractio n and a particula r implementatio n are c l o s e l y\nm a t c h e d , then t he a b s t r a c t i o n m ay s i m p l y d e l e g a t e o p e r a t i o n s to that i m p l e m e n t a t i o n . D e l e g a t i o n is an extrem e ex amp l e of o b j e c t c o m p o s i t i o n . It s h o w s that y ou c an a l w a y s\nr e p l a c e inheritanc e with objec t c o m p o s i t i o n as a mechanis m for c o de r e u s e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 123, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 883}}
{"id": "computer_science_design_patterns_gof_chunk_0124_f8ed4ac4", "text": "It s h o w s that y ou c an a l w a y s\nr e p l a c e inheritanc e with objec t c o m p o s i t i o n as a mechanis m for c o de r e u s e . Inheritanc e versu s Parameterize d T y p e s\nAnothe r (not s t r i c t l y object-oriented ) techniqu e for r e u s i n g functionalit y is throug h\np a r a m e t e r i z e d t y p e s , a l so know n as g e n e r i c s ( A d a , Eiffel ) a nd t e m p l a t e s (C++) . T h is\ntechniqu e l e ts you defin e a type withou t s p e c i f y i n g all the other t y p es it u s e s. The\nunspecifie d types are s u p p l i e d as parameters at the point of u s e. For e x a m p l e , a L i st\nc l a ss c an be p a r a m e t e r i z e d by t he t y pe of e l e m e n t s it c o n t a i n s . To d e c l a r e a l i st of\ni n t e g e r s , you supply the type \"integer\" as a parameter to the List parameterized type. ptg22 INTRODUCTION CHAPTER I\nTo d e c l a r e a l i st of S t r i n g o b j e c t s , y ou s u p p l y t he \" S t r i n g \" type as a parameter .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 124, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_design_patterns_gof_chunk_0125_d23e002e", "text": "ptg22 INTRODUCTION CHAPTER I\nTo d e c l a r e a l i st of S t r i n g o b j e c t s , y ou s u p p l y t he \" S t r i n g \" type as a parameter . T he\nl a n g u a g e i m p l e m e n t a t i o n w i ll c r e a t e a c u s t o m i z e d v e r s i o n of t he L i st c l a ss templat e f or\ne a ch type of e l e m e n t . Parameterize d t y p es g i ve us a th ird way (in additio n to c l a ss inheritanc e and o b j e c t\nc o m p o s i t i o n ) to c o m p o s e b e h a v i o r in o b j e c t - o r i e n t e d s y s t e m s . M a ny d e s i g n s c an be\ni m p l e m e n t e d u s i ng a ny of t h e se three t e c h n i q u e s . To parameteriz e a s o r t i n g routin e by\nt he o p e r a t i o n it u s es to c o m p a r e e l e m e n t s , we c o u ld m a ke t he c o m p a r i s o n\n1. an o p e r a t i o n i m p l e m e n t e d by s u b c l a s s e s ( an a p p l i c a t i o n of T e m p l a t e\nM e t h o d ( 3 2 5 ) ) ,\n2.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 125, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_design_patterns_gof_chunk_0126_c51ed152", "text": "an o p e r a t i o n i m p l e m e n t e d by s u b c l a s s e s ( an a p p l i c a t i o n of T e m p l a t e\nM e t h o d ( 3 2 5 ) ) ,\n2. t he r e s p o n s i b i l i t y of an o b j e c t that's p a s s e d to t he s o r t i n g routin e ( S t r a t e g y ( 3 1 5 ) ) ,\no r\n3. an a r g u m e n t of a C ++ t e m p l a t e or A da g e n e r i c that s p e c i f i e s t he n a me of t he\nfunctio n to c a ll to c o m p a r e the e l e m e n t s . T h e re a re importan t difference s bet w ee n t h e se t e c h n i q u e s . O b j e c t c o m p o s i t i o n l e ts y ou\nc h a n g e t he b e h a v i o r b e i ng c o m p o s e d at r u n - t i m e , b ut it a l so r e q u i r e s i n d i r e c t i o n a nd c an\nbe l e ss efficient . I n h e r i t a n c e l e ts you p r o v i d e defaul t implementation s for operation s\na nd l e ts s u b c l a s s e s o v e r r i d e them . Parameterize d t y p es l et y ou c h a n g e t he t y p es that a\nc l a ss c an u s e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 126, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_design_patterns_gof_chunk_0127_5b41a12a", "text": "Parameterize d t y p es l et y ou c h a n g e t he t y p es that a\nc l a ss c an u s e. B ut neithe r i n h e r i t a n c e n or parameterize d t y p es c an c h a n g e at run-time . W h i c h a p p r o a c h is b e st d e p e n d s on your d e s i g n a nd implementatio n constraints. N o ne of t he pattern s in t h is b o ok c o n c e r n s p a r a m e t e r i z e d t y p e s , t h o u g h we u se t h em\non o c c a s i o n to c u s t o m i z e a pattern' s C++ implementation . Parameterize d t y p es aren' t\nn e e d e d at a ll in a l a n g u a g e l i ke S m a l l t a l k that d o e s n ' t h a ve c o m p i l e - t i m e t y pe c h e c k i n g . R e l a t i n g R u n - T i m e a nd C o m p i l e - T i m e S t r u c t u r e s\nAn o b j e c t - o r i e n t e d program' s run-tim e structur e often bears little r e s e m b l a n c e to its\nc o de s t r u c t u r e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 127, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 878}}
{"id": "computer_science_design_patterns_gof_chunk_0128_61915c3c", "text": "T he c o de structur e is froze n at c o m p i l e - t i m e ; it c o n s i s t s of c l a s s e s in\nf i x ed inheritanc e r e l a t i o n s h i p s . A program' s run-tim e structur e c o n s i s t s of rapidl y\nc h a n g i n g network s of communicatin g o b j e c t s . In fact, the two structure s are l a r g e l y\nindependent . T r y i n g to understan d one from the other is l i ke tryin g to understan d the\nd y n a m i s m of l i v i ng e c o s y s t e m s from t he static taxonom y of plant s a nd a n i m a l s , a nd\nv i ce versa. C o n s i d e r t he d i s t i n c t i o n betwee n o b j e c t a g g r e g a t i o n a nd a c q u a i n t a n c e a nd h ow dif-\nferentl y t h ey manifes t t h e m s e l v e s at c o m p i l e - a nd r u n - t i m e s . A g g r e g a t i o n i m p l i e s that \no ne o b j e c t owns or is r e s p o n s i b l e f or anothe r o b j e c t . G e n e r a l l y we s p e ak of an o b j e c t\nhaving or b e i ng part of anothe r o b j e c t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 128, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_design_patterns_gof_chunk_0129_9d4ce9b1", "text": "G e n e r a l l y we s p e ak of an o b j e c t\nhaving or b e i ng part of anothe r o b j e c t . A g g r e g a t i o n i m p l i e s that an a g g r e g a t e o b j e c t a nd\ni t s owner have identical lifetimes. A c q u a i n t a n c e i m p l i e s t h a t a n o b j e c t m e r e l y k n o w s o f another o b j e c t . S o m e t i m e s ac-\nq u a i n t a n c e is called \"association\" o r t h e \"using\" relationship. Acquainted objects m a y\n\nptgSECTION 1.6 HOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 23\nr e q u e s t o p e r a t i o n s of e a ch o t h e r , b ut they aren' t r e s p o n s i b l e f or e a ch o t h e r . A c q u a i n -\ntance is a weaker relationshi p t h an aggregatio n and suggest s much l o o s e r couplin g\nbetwee n objects. In our diagrams , a p l a in arrowhea d l i ne denote s acquaintance .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 129, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 826}}
{"id": "computer_science_design_patterns_gof_chunk_0130_d58f9007", "text": "A c q u a i n -\ntance is a weaker relationshi p t h an aggregatio n and suggest s much l o o s e r couplin g\nbetwee n objects. In our diagrams , a p l a in arrowhea d l i ne denote s acquaintance . An arrowhea d l i ne w i th\na diamond at its base denotes aggregation:\nIt's easy to confus e aggregatio n and acquaintance , becaus e they are o f t en implemente d\nin t he s a me w a y. In S m a l l t a l k , a ll v a r i a b l e s a re r e f e r e n c e s to o t h er o b j e c t s . T h e r e ' s\nno distinctio n in the programmin g languag e betwee n aggregatio n and acquaintance . In C++, a g g r e g a t i o n can be i m p l e m e n t e d by definin g membe r v a r i a b l e s that are r e al\ni n s t a n c e s , but i t 's more commo n to defin e them as pointer s or reference s to instances . Acquaintanc e is implemente d with pointer s and reference s as w e l l . U l t i m a t e l y , acquaintanc e and aggregatio n are determine d more by inten t than by ex-\np l i c it languag e mechanisms .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 130, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_design_patterns_gof_chunk_0131_804084d3", "text": "U l t i m a t e l y , acquaintanc e and aggregatio n are determine d more by inten t than by ex-\np l i c it languag e mechanisms . The distinctio n may be hard to see in the compile-tim e\nstructure , but it's significant . Aggregatio n relationship s tend to be fewe r and more\npermanen t than a c q u a i n t a n c e . A c q u a i n t a n c e s , in c o n t r a s t , a re made a nd remad e m o re\nfrequently , s o m e t i m e s existin g o n ly f or the duratio n of an operation . Acquaintance s are\nmore dynami c as w e l l, makin g them m o re difficul t to d i s c e r n in the s o u r c e c o d e . With s u ch d i s p a r i t y b e t w e e n a p r o g r a m ' s run-tim e a nd c o m p i l e - t i m e s t r u c t u r e s , i t 's\nc l e ar that c o de won' t r e v e a l everythin g abou t how a syste m w i ll work . The s y s t e m ' s\nrun-tim e structur e must be i m p o s e d more by the d e s i g n e r than the language .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 131, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_design_patterns_gof_chunk_0132_2a5c63e8", "text": "The s y s t e m ' s\nrun-tim e structur e must be i m p o s e d more by the d e s i g n e r than the language . The \nr e l a t i o n s h i p s betwee n o b j e c t s and their types must be d e s i g n e d with great c a r e, becaus e\nthey determin e how g o od or bad the run-tim e structur e is. Many d e s i g n pattern s (in particula r t h o se that have o b j e c t s c o p e ) captur e the distinctio n\nbetwee n c o m p i l e - t i m e a nd run-tim e structure s e x p l i c i t l y . C o m p o s i t e ( 1 6 3) a nd D e c o r a -\ntor ( 1 7 5) are e s p e c i a l l y usefu l for buildin g comple x run-tim e structures . O b s e r v e r ( 2 9 3)\ni n v o l v e s r u n - t i m e s t r u c t u r e s that a re often hard to understan d u n l e s s y ou k n ow t he\npattern . Chai n of Responsibilit y ( 2 2 3) a l so result s in communicatio n pattern s that in-\nheritanc e d o e s n ' t r e v e a l .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 132, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 906}}
{"id": "computer_science_design_patterns_gof_chunk_0133_201ad3d5", "text": "Chai n of Responsibilit y ( 2 2 3) a l so result s in communicatio n pattern s that in-\nheritanc e d o e s n ' t r e v e a l . In g e n e r a l , the run-tim e structure s aren' t c l e ar f r om the c o de\nuntil you understan d the patterns. Designin g f or C h a n g e\nThe key to maximizin g r e u se l i es in anticipatin g new requirement s and change s to ex-\ni s t i ng r e q u i r e m e n t s , and in d e s i g n i n g your system s so t h at they can e v o l v e a c c o r d i n g l y . To d e s i g n t he s y s t e m so that i t 's robus t to s u ch c h a n g e s , y ou must c o n s i d e r h ow t he\ns y s t e m migh t n e ed to chang e o v er its lifetime . A d e s i g n that doesn' t take chang e\ninto account risks m a j o r r e d e s i g n i n t h e f u t u r e . T h o s e c h a n g e s m i g h t i n v o l v e c l a s s\n\nptg24 INTRODUCTION CHAPTER 1\nredefinitio n a nd reimplementation , c l i e nt m o d i f i c a t i o n , a nd r e t e s t i n g .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 133, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_design_patterns_gof_chunk_0134_960a3539", "text": "T h o s e c h a n g e s m i g h t i n v o l v e c l a s s\n\nptg24 INTRODUCTION CHAPTER 1\nredefinitio n a nd reimplementation , c l i e nt m o d i f i c a t i o n , a nd r e t e s t i n g . R e d e s i g n affect s\nmany parts of the softwar e s y s t e m , and unanticipate d c h a n g e s are i n v a r i a b l y e x p e n s i v e . D e s i g n pattern s h e lp y ou a v o id t h is by e n s u r i n g that a s y s t e m c an c h a n g e in s p e c i f i c\nways . E a ch d e s i g n patter n l e ts s o me a s p e c t of s y s t e m structur e vary i n d e p e n d e n t l y of\no t h er a s p e c t s , thereb y makin g a s y s t e m m o re r o b u s t to a particula r k i nd of c h a n g e . H e re a re s o me c o m m o n c a u s e s of r e d e s i g n a l o ng with t he d e s i g n pattern(s ) that a d d r e s s\nthem:\n1. Creating an object by specifying a class explicitly.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 134, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 878}}
{"id": "computer_science_design_patterns_gof_chunk_0135_42c93de5", "text": "H e re a re s o me c o m m o n c a u s e s of r e d e s i g n a l o ng with t he d e s i g n pattern(s ) that a d d r e s s\nthem:\n1. Creating an object by specifying a class explicitly. S p e c i f y i n g a c l a ss name when\nyou c r e a t e an o b j e c t commit s you to a particula r i m p l e m e n t a t i o n i n s t e a d of a\nparticula r interface . T h is commitmen t c an c o m p l i c a t e f u t u r e c h a n g e s . To a v o id i t,\nc r e a t e o b j e c t s i n d i r e c t l y . D e s i g n patterns : Abstrac t Factor y ( 8 7 ), F a c t o r y M e t h o d ( 1 0 7 ) , Prototyp e ( 1 1 7 ) . 2. Dependence on specific operations. W h e n you s p e c i f y a p a r t i c u l a r o p e r a t i o n , you\nc o m m i t to o ne w ay of satisfyin g a r e q u e s t . By a v o i d i n g h a r d - c o d e d r e q u e s t s , y ou\nm a ke it e a s i e r to c h a n g e t he w ay a r e q u e s t g e ts s a t i s f i e d b o th at c o m p i l e - t i m e a nd\nat run-time.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 135, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_design_patterns_gof_chunk_0136_3bd8656d", "text": "D e s i g n p a t t e r n s : C h a in of R e s p o n s i b i l i t y ( 2 2 3 ) , C o m m a n d ( 2 3 3 ) . 3. Dependence on hardware a nd software platform. E x t e r n a l o p e r a t i n g s y s t e m i n t e r f a c e s\nand applicatio n programmin g interface s ( A P I s ) are differen t on differen t hard-\nware and softwar e platforms . Softwar e that d e p e n d s on a particula r platfor m w i ll\nbe harde r to port to other platforms . It may e v en be difficul t to k e ep it up to date\non its nativ e platform . It's importan t therefor e to d e s i g n your s y s t e m to l i m it its\nplatfor m d e p e n d e n c i e s . D e s i g n patterns : Abstrac t Factor y ( 8 7 ), B r i d g e ( 1 5 1 ) . 4. Dependence on object representations or implementations. C l i e n t s that know how an\no b j e c t is r e p r e s e n t e d , s t o r e d , l o c a t e d , or i m p l e m e n t e d m i g h t n e ed to be c h a n g e d\nwhen t he o b j e c t c h a n g e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 136, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_design_patterns_gof_chunk_0137_c299848a", "text": "C l i e n t s that know how an\no b j e c t is r e p r e s e n t e d , s t o r e d , l o c a t e d , or i m p l e m e n t e d m i g h t n e ed to be c h a n g e d\nwhen t he o b j e c t c h a n g e s . H i d i n g t h is informatio n from c l i e n t s k e e ps c h a n g e s\nfrom c a s c a d i n g . D e s i g n patterns : Abstrac t Factor y ( 8 7 ), B r i d g e ( 1 5 1 ) , Mement o ( 2 8 3 ) , P r o xy ( 2 0 7 ) . 5. Algorithmic dependencies. Algorithm s a re often e x t e n d e d , o p t i m i z e d , a nd r e p l a c e d\ndurin g d e v e l o p m e n t a nd r e u s e . O b j e c t s that d e p e n d on an a l g o r i t h m w i ll have\nto chang e when the algorith m c h a n g e s . Therefor e a l g o r i t h m s that are l i k e ly to\nchang e s h o u l d be i s o l a t e d . D e s i g n patterns : B u i l d e r ( 9 7 ), Iterato r ( 2 5 7 ) , S t r a t e g y ( 3 1 5 ) , T e m p l a t e\nMetho d ( 3 2 5 ) , V i s i t o r ( 3 3 1 ) . 6. Tight coupling.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 137, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_design_patterns_gof_chunk_0138_2605acd5", "text": "D e s i g n patterns : B u i l d e r ( 9 7 ), Iterato r ( 2 5 7 ) , S t r a t e g y ( 3 1 5 ) , T e m p l a t e\nMetho d ( 3 2 5 ) , V i s i t o r ( 3 3 1 ) . 6. Tight coupling. C l a s s e s that a re tightl y c o u p l e d a re hard to r e u se in i s o l a t i o n , s i n ce\nt h ey d e p e n d on e a ch o t h e r . T i g ht c o u p l i n g l e a ds to m o n o l i t h i c s y s t e m s , w h e r e\ny o u can't change or remove a class without understanding a n d changing many\n\nptgSECTION 1.6 HOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 25\nother c l a s s e s . T he s y s t e m b e c o m e s a d e n se m a ss that's hard to l e a r n , port, a nd\nm a i n t a i n . L o o s e c o u p l i n g i n c r e a s e s t he p r o b a b i l i t y that a c l a ss c an be r e u s e d by i t s e lf a nd\nthat a s y s t e m c an be l e a r n e d , p o r t e d , m o d i f i e d , a nd e x t e n d e d more e a s i l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 138, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_design_patterns_gof_chunk_0139_6d83440d", "text": "D e s i g n\npattern s use t e c h n i q u e s s u ch as abstrac t c o u p l i n g and layerin g to promot e l o o s e l y\nc o u p l e d s y s t e m s . D e s i g n patterns : Abstrac t F a c t o r y ( 8 7 ), B r i d g e ( 1 5 1 ) , C h a in of R e s p o n s i b i l i t y ( 2 2 3 ) ,\nComman d ( 2 3 3 ) , F a c a d e ( 1 8 5 ) , Mediato r ( 2 7 3 ) , O b s e r v e r ( 2 9 3 ) . 7. Extending functionality by subclassing. C u s t o m i z i n g an o b j e c t by s u b c l a s s i n g often\ni s n 't e a s y. Every n ew c l a ss h as a f i x ed implementatio n overhea d (initialization ,\nf i n a l i z a t i o n , e t c . ). D e f i n i n g a s u b c l a s s a l so r e q u i r e s an i n - d e p t h understandin g of\nt he paren t c l a s s. F or e x a m p l e , o v e r r i d i n g o ne operatio n migh t requir e o v e r r i d i n g\na n o t h e r . An o v e r r i d d e n o p e r a t i o n m i g h t be r e q u i r e d to c a ll an i n h e r i t e d o p e r a t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 139, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_design_patterns_gof_chunk_0140_ce772b62", "text": "An o v e r r i d d e n o p e r a t i o n m i g h t be r e q u i r e d to c a ll an i n h e r i t e d o p e r a t i o n . A nd s u b c l a s s i n g c an l e ad to an e x p l o s i o n of c l a s s e s , becaus e y ou migh t have to\nintroduc e many new s u b c l a s s e s for e v en a s i m p l e e x t e n s i o n . O b j e c t c o m p o s i t i o n in g e n e r a l a nd d e l e g a t i o n in particula r p r o v i d e f l e x i b l e a l t e r -\nn a t i v e s to i n h e r i t a n c e for c o m b i n i n g b e h a v i o r . New functionalit y can be adde d to\nan a p p l i c a t i o n by c o m p o s i n g e x i s t i n g o b j e c t s in new ways rathe r than by definin g\nn ew s u b c l a s s e s of e x i s t i n g c l a s s e s . On t he other hand , heav y u se of o b j e c t c o m -\np o s i t i o n can make d e s i g n s harde r to understand .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 140, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 857}}
{"id": "computer_science_design_patterns_gof_chunk_0141_277bb2a1", "text": "On t he other hand , heav y u se of o b j e c t c o m -\np o s i t i o n can make d e s i g n s harde r to understand . Many d e s i g n pattern s p r o d u c e\nd e s i g n s in w h i c h you can introduc e c u s t o m i z e d functionalit y just by definin g one\ns u b c l a s s a nd c o m p o s i n g i ts i n s t a n c e s with e x i s t i n g o n e s . D e s i g n patterns : B r i d g e ( 1 5 1 ) , C h a in of R e s p o n s i b i l i t y ( 2 2 3 ) , Composit e ( 1 6 3 ) ,\nD e c o r a t o r ( 1 7 5 ) , O b s e r v e r ( 2 9 3 ) , S t r a t e g y ( 3 1 5 ) . 8. Inability to alter classes conveniently. S o m e t i m e s you have to modif y a c l a ss that\ncan't be modifie d c o n v e n i e n t l y . P e r h a p s you n e ed the s o u r c e c o de and don't have\nit (as may be t he c a se with a c o m m e r c i a l c l a ss library) . Or mayb e any c h a n g e\nwoul d r e q u i r e modifyin g l o ts of e x i s t i n g s u b c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 141, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_design_patterns_gof_chunk_0142_09261465", "text": "Or mayb e any c h a n g e\nwoul d r e q u i r e modifyin g l o ts of e x i s t i n g s u b c l a s s e s . D e s i g n pattern s o f f er ways\nto modif y c l a s s e s in such c i r c u m s t a n c e s . D e s i g n patterns : Adapte r ( 1 3 9 ) , Decorato r ( 1 7 5 ) , V i s i t o r ( 3 3 1 ) . T h e se e x a m p l e s r e f l e c t the flexibilit y that d e s i g n pattern s can help you b u i ld into\ny o ur s o f t w a r e . H ow c r u c i a l s u ch f l e x i b i l i t y is d e p e n d s on t he k i nd of s o f t w a r e y o u ' r e\nb u i l d i n g . L e t 's l o ok at t he r o le d e s i g n pattern s play in t he d e v e l o p m e n t of t hr ee broad\nc l a s s e s of s o f t w a r e : a p p l i c a t i o n p r o g r a m s , t o o l k i t s , a nd f r a m e w o r k s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 142, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 784}}
{"id": "computer_science_design_patterns_gof_chunk_0143_527a8c1a", "text": "Applicatio n P r o g r a m s\nIf you'r e b u i l d i n g an a p p l i c a t i o n progra m s u ch as a documen t e d i t o r or s p r e a d s h e e t ,\nthen internal r e u s e , maintainability , a nd e x t e n s i o n a re h i gh p r i o r i t i e s . Interna l r e u se\ne n s u r e s t h a t y o u d o n ' t d e s i g n a n d i m p l e m e n t a n y m o r e t h a n y o u h a v e t o . D e s i g n\n\nptg26 INTRODUCTION CHAPTER 1\npattern s t h at r e d u c e d e p e n d e n c i e s can i n c r e a s e interna l r e u s e . L o o s e r c o u p l i n g b o o s t s\nthe l i k e l i h o o d that one c l a ss of objec t can cooperat e with s e v e r a l o t h e r s . For e x a m p l e ,\nwhen you eliminat e dependencie s on s p e c i f i c operation s by i s o l a t i n g and encapsulatin g\ne a ch operation , you make it e a s i e r to r e u se an operatio n in differen t contexts . The same\nthing can happe n when you remov e algorithmi c and representationa l d e p e n d e n c i e s\ntoo.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 143, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_design_patterns_gof_chunk_0144_fe28ba53", "text": "The same\nthing can happe n when you remov e algorithmi c and representationa l d e p e n d e n c i e s\ntoo. D e s i g n pattern s a l so make an applicatio n m o re maintainabl e when they'r e u s ed to l i m it\nplatfor m d e p e n d e n c i e s and to layer a system . T h ey enhanc e e x t e n s i b i l i t y by s h owin g\nyou how to exten d c l a ss hierarchie s and how to e x p l o i t o b j e c t c o m p o s i t i o n . Reduce d\ncouplin g a l so enhance s e x t e n s i b i l i t y . Extendin g a c l a ss in i s o l a t i o n is e a s i e r if t he c l a ss \ndoesn' t depen d on l o ts of other c l a s s e s . T o o l k i t s\nOften an applicatio n w i ll incorporat e c l a s s e s f r om one or more l i b r a r i e s of predefine d\nc l a s s e s c a l l ed toolkits . A toolki t is a s et of relate d a nd r e u s a b l e c l a s s e s d e s i g n e d to p r o -\nvide useful , general-purpos e functionality .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 144, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_design_patterns_gof_chunk_0145_b216e6e9", "text": "A toolki t is a s et of relate d a nd r e u s a b l e c l a s s e s d e s i g n e d to p r o -\nvide useful , general-purpos e functionality . An exampl e of a t o o l k i t is a s et of c o l l e c t i o n\nc l a s s e s for l i s t s, a s s o c i a t i v e t a b l e s , s t a c k s , and the l i k e. The C++ I/O strea m librar y is\nanothe r e x a m p l e . T o o l k i t s don't i m p o s e a particula r d e s i g n on your application ; they\njust provid e functionalit y that can help your applicatio n do its job. T h ey let you as\nan implemente r a v o id r e c e d i n g commo n functionality . T o o l k i t s emphasiz e code reuse. T h ey are the object-oriente d equivalen t of subroutin e l i b r a r i e s . T o o l k i t d e s i g n is arguabl y harde r than applicatio n d e s i g n , b e c a u s e toolkit s have to\nwork in many application s to be useful .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 145, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 872}}
{"id": "computer_science_design_patterns_gof_chunk_0146_3fddf6db", "text": "T o o l k i t d e s i g n is arguabl y harde r than applicatio n d e s i g n , b e c a u s e toolkit s have to\nwork in many application s to be useful . M o r e o v e r , the toolki t write r i s n 't in a p o s i t i o n\nto know what t h o se application s will be or their s p e c i a l n e e d s . T h at make s it all the\nmore importan t to a v o id assumption s and dependencie s that can l i m it the toolkit' s\nflexibilit y and consequentl y its applicabilit y and effectiveness. Frameworks\nA framewor k is a set of cooperatin g c l a s s e s that make up a r e u s a b l e d e s i g n f or a s p e c i f i c\nc l a ss of softwar e [ D e u 8 9 , J F 8 8 ] . F or e x a m p l e , a f r a m e w o r k c an be g e a r e d towar d b u i l d -\ning graphica l e d i t o r s for differen t domain s l i ke artisti c drawing , musi c c o m p o s i t i o n ,\nand m e c h a n i c a l CAD [ V L 9 0 , J o h 9 2 ] .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 146, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_design_patterns_gof_chunk_0147_0575ee20", "text": "Anothe r framewor k can help you b u i ld c o m p i l e r s\nfor differen t programmin g language s and targe t machine s [ J M L 9 2 ] . Yet anothe r migh t\nhelp you build financia l modelin g application s [ B E 9 3 ] . You customiz e a f r a m e w o r k to\na particula r a p p l i c a t i o n by creatin g a p p l i c a t i o n - s p e c i f i c s u b c l a s s e s of abstrac t c l a s s e s\nfrom the framework. The framewor k dictate s the architectur e of your application . It w i ll defin e the o v e r -\nall structure , its partitionin g into c l a s s e s and o b j e c t s , the key r e s p o n s i b i l i t i e s thereof ,\nhow the classes and objects collaborate, a n d t h e thread of control. A framework prede-\nfines these design parameters so that you, the application designer/implementer, can\n\nptgSECTION 1.6 HOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 27\nconcentrat e on t he s p e c i f i c s of your a p p l i c a t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 147, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_design_patterns_gof_chunk_0148_d7948cf6", "text": "T he framewor k capture s t he d e s i g n\nd e c i s i o n s that are c o m m o n to its applicatio n domain . Framework s thus e m p h a s i z e de-\nsign reuse o v er c o de r e u s e , t h o u g h a framewor k w i ll u s u a l l y i n c l u d e c o n c r e t e s u b c l a s s e s\nyou can put to work i m m e d i a t e l y . Reus e on this l e v el l e a ds to an i n v e r s i o n of c o n t r o l betwee n t he a p p l i c a t i o n a nd t he\nsoftwar e on w h i c h i t 's based . Whe n you use a t o o l k i t (or a c o n v e n t i o n a l subroutin e\nlibrar y for that matter) , you write the main body of the a p p l i c a t i o n and c a ll the c o de\nyou want to r e u s e . Whe n you use a framework , you r e u se the main b o dy and write\nthe c o de it c a l l s. Y o u ' l l have to write operation s with particula r name s and c a l l i n g\nc o n v e n t i o n s , but that r e d u c e s the d e s i g n d e c i s i o n s you have to make.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 148, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_design_patterns_gof_chunk_0149_670ab6c6", "text": "Y o u ' l l have to write operation s with particula r name s and c a l l i n g\nc o n v e n t i o n s , but that r e d u c e s the d e s i g n d e c i s i o n s you have to make. Not o n ly can you b u i ld a p p l i c a t i o n s faste r as a r e s u l t , but the a p p l i c a t i o n s have s i m i l a r\nstructures . T h ey a re e a s i e r to maintain , a nd they s e em m o re c o n s i s t e n t to t h e ir u s e r s . On t he other hand , y ou l o se s o me c r e a t i v e freedom , s i n ce many d e s i g n d e c i s i o n s have\nb e en made for you. If a p p l i c a t i o n s are hard to d e s i g n , and t o o l k i t s are harder , then framework s are ha r de s t\nof a l l. A framewor k d e s i g n e r g a m b l e s that one architectur e w i ll work f or all a p p l i c a t i o n s\nin t he d o m a i n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 149, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 825}}
{"id": "computer_science_design_patterns_gof_chunk_0150_a45ca243", "text": "A framewor k d e s i g n e r g a m b l e s that one architectur e w i ll work f or all a p p l i c a t i o n s\nin t he d o m a i n . A ny s u b s t a n t i v e c h a n g e to t he framework' s d e s i g n w o u l d r e d u c e i ts \nbenefit s c o n s i d e r a b l y , s i n ce the framework' s main contributio n to an a p p l i c a t i o n is\nthe architectur e it defines . T h e r e f o r e it's i m p e r a t i v e to d e s i g n the framewor k to be as\nf l e x i b l e a nd e x t e n s i b l e as p o s s i b l e . Furthermore , b e c a u s e application s are so dependen t on the framewor k for their de-\ns i g n, they are particularl y s e n s i t i v e to c h a n g e s in framewor k interfaces . As a frame-\nwork e v o l v e s , application s have to e v o l v e with i t. That make s l o o se c o u p l i n g a ll t he\nm o re i m p o r t a n t ; o t h e r w i s e e v en a m i n o r c h a n g e to t he framewor k w i ll h a ve m a j o r\nr e p e r c u s s i o n s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 150, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_design_patterns_gof_chunk_0151_1afb8a35", "text": "That make s l o o se c o u p l i n g a ll t he\nm o re i m p o r t a n t ; o t h e r w i s e e v en a m i n o r c h a n g e to t he framewor k w i ll h a ve m a j o r\nr e p e r c u s s i o n s . T he d e s i g n i s s u e s just d i s c u s s e d a re m o st c r i t i c a l to framewor k d e s i g n . A framewor k\nthat a d d r e s s e s them using d e s i g n pattern s is f ar m o re l i k e ly to a c h i e v e h i gh l e v e ls of\nd e s i g n and c o de r e u se than one that doesn't . Matur e framework s usuall y incorporat e\ns e v e r a l d e s i g n patterns . T he pattern s h e lp make t he framework' s architectur e s u i t a b l e\nto many differen t application s withou t r e d e s i g n . An added benefi t c o m e s when the framewor k is d o c u m e n t e d w i th the d e s i g n pattern s\nit u s es [ B J 9 4 ] . P e o p l e who know the pattern s g a in i n s i g h t into the framewor k faster .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 151, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_design_patterns_gof_chunk_0152_cb7bccc6", "text": "P e o p l e who know the pattern s g a in i n s i g h t into the framewor k faster . E v en p e o p l e who don't know the pattern s can benefi t from the structur e they l e nd to\nthe framework' s documentation . E n h a n c i n g documentatio n is importan t for all t y p es\nof software , but it's particularl y importan t for frameworks. Framework s often p o se a\ns t e ep l e a r n i n g c u r ve that must be o v e r c o m e befor e they'r e useful . W h i l e d e s i g n pattern s\nmigh t not f l a t t e n the l e a r n i n g c u r ve e n t i r e l y , they can make it l e ss s t e ep by makin g key\nelement s of t he framework' s d e s i g n more e x p l i c i t . B e c a u s e pattern s and framework s have s o me s i m i l a r i t i e s , p e o p l e often wonde r how or\ne v e n if they differ. They are different i n three major ways:\n\nptg28 INTRODUCTION CHAPTER 1\n1. Design patterns are more abstract than frameworks.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 152, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_design_patterns_gof_chunk_0153_5a97ab4f", "text": "They are different i n three major ways:\n\nptg28 INTRODUCTION CHAPTER 1\n1. Design patterns are more abstract than frameworks. Framework s can be e m b o d i e d\nin c o d e, b ut o n ly examples of pattern s c an be e m b o d i e d in c o d e. A strengt h of\nframework s is that they can be writte n down in programmin g l a n g u a g e s and not\no n ly studie d but e x e c u t e d and r e u s e d d i r e c t l y . In contrast , the d e s i g n pattern s in\nthis book have to be implemente d e a ch time they'r e u s e d. D e s i g n pattern s a l so\nexplai n the intent , trade-offs , and c o n s e q u e n c e s of a d e s i g n . 2. Design patterns are smaller architectural elements than frameworks. A typica l frame-\nwork contain s s e v e r a l d e s i g n patterns, but the r e v e r s e is n e v er true. 3. Design patterns are less specialized than frameworks. Framework s alway s have a\nparticula r applicatio n domain .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 153, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_design_patterns_gof_chunk_0154_86c15487", "text": "3. Design patterns are less specialized than frameworks. Framework s alway s have a\nparticula r applicatio n domain . A graphica l edito r framewor k m i g h t be u s ed in\na factor y simulation , but it won' t be mistake n for a simulatio n framework . In\ncontrast , the d e s i g n pattern s in this catalo g can be u s ed in nearl y any kind of ap-\np l i c a t i o n . W h i l e m o re s p e c i a l i z e d d e s i g n pattern s than ours are certainl y p o s s i b l e\n( s a y, d e s i g n pattern s for distribute d system s or concurren t programming) , e v en\nthese wouldn' t dictat e an applicatio n architectur e l i ke a framewor k would. Framework s are becomin g i n c r e a s i n g l y commo n and important . T h ey are the way that\no b j e c t - o r i e n t e d s y s t e m s a c h i e v e t he most r e u s e . L a r g e r object-oriente d a p p l i c a t i o n s w i ll\nend up c o n s i s t i n g of layer s of framework s that c o o p e r a t e with e a ch o t h e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 154, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_design_patterns_gof_chunk_0155_7e12d7b7", "text": "L a r g e r object-oriente d a p p l i c a t i o n s w i ll\nend up c o n s i s t i n g of layer s of framework s that c o o p e r a t e with e a ch o t h e r . M o st of the\nd e s i g n and c o de in the applicatio n w i ll c o me f r om or be influence d by the framework s\ni t uses. 1 . 7 How to Select a D e s i g n P a t t e r n\nWith m o re than 20 d e s i g n pattern s in the catalo g to c h o o s e from , it m i g h t be hard to find\nt he o ne that a d d r e s s e s a particula r d e s i g n p r o b l e m , e s p e c i a l l y if t he catalo g is n ew a nd\nunfamilia r to you. H e re are s e v e r a l differen t approache s to findin g the d e s i g n patter n\nthat's right for your p r o b l e m :\n• Consider how design patterns solve design problems.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 155, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 763}}
{"id": "computer_science_design_patterns_gof_chunk_0156_fa0ebfaa", "text": "H e re are s e v e r a l differen t approache s to findin g the d e s i g n patter n\nthat's right for your p r o b l e m :\n• Consider how design patterns solve design problems. S e c t i o n 1 .6 d i s c u s s e s how d e s i g n\npattern s help you find appropriat e o b j e c t s , determin e o b j e c t granularity , specif y\no b j e c t interfaces , a nd s e v e r a l other ways in whic h d e s i g n pattern s s o l ve d e s i g n\np r o b l e m s . Referrin g to these d i s c u s s i o n s can help g u i de your s e a r c h for the r i g ht\npattern. • Scan Intent sections. S e c t i o n 1 .4 (page 8) l i s ts t he Inten t s e c t i o n s from a ll t he pattern s\nin the c a t a l o g . Read throug h e a ch pattern' s inten t to find one or m o re that s o u nd\nrelevan t to your p r o b l e m . You can use the c l a s s i f i c a t i o n s c h e m e p r e s e n t e d in\nT a b le 1 .1 (page 1 0) to narro w your s e a r c h . • Study h ow patterns interrelate.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 156, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_design_patterns_gof_chunk_0157_def2aa7c", "text": "You can use the c l a s s i f i c a t i o n s c h e m e p r e s e n t e d in\nT a b le 1 .1 (page 1 0) to narro w your s e a r c h . • Study h ow patterns interrelate. F i g u r e 1 .1 (page 1 2) s h o w s relationship s b et we e n\nd e s i g n pattern s g r a p h i c a l l y . Studyin g t h e se r e l a t i o n s h i p s c an help d i r e c t y ou to\nthe right pattern or group of patterns. ptgSECTION 1.8 HOW TO USE A DESIGN PATTERN 29\n• Study patterns of like purpose. The c a t a l o g (page 79) has three chapters , one for\ncreationa l patterns , anothe r for structura l patterns , and a third for behaviora l\npatterns . Each chapte r starts off with introductor y comment s on the pattern s and\nc o n c l u d e s with a s e c t i o n that compare s and contrast s them . T h e s e s e c t i o n s g i ve\nyou i n s i g h t into t he s i m i l a r i t i e s and difference s betwee n pattern s of l i ke purpose. • Examine a cause of redesign.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 157, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_design_patterns_gof_chunk_0158_36791a35", "text": "T h e s e s e c t i o n s g i ve\nyou i n s i g h t into t he s i m i l a r i t i e s and difference s betwee n pattern s of l i ke purpose. • Examine a cause of redesign. L o ok at the c a u s e s of r e d e s i g n startin g on page 24 to\nsee if your proble m i n v o l v e s one or more of them . T h en l o ok at the pattern s that\nhelp you a v o id the cause s of redesign. • Consider what should be variable in your design. T h is approac h is the o p p o s i t e of\nfocusin g on the c a u s e s of r e d e s i g n . Instea d of c o n s i d e r i n g what migh t force a\nchang e to a d e s i g n , c o n s i d e r what you want to be able to chang e withou t r e d e s i g n . The focus h e re is on encapsulating the concept that varies, a them e of many d e s i g n\npatterns . T a b le 1 .2 l i s ts t he d e s i g n aspect(s ) that d e s i g n pattern s l et y ou vary\nindependently, thereby letting you change them without redesign. 1 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 158, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_design_patterns_gof_chunk_0159_f1950af3", "text": "T a b le 1 .2 l i s ts t he d e s i g n aspect(s ) that d e s i g n pattern s l et y ou vary\nindependently, thereby letting you change them without redesign. 1 . 8 How to Use a D e s i g n P a t t e r n\nO n ce you'v e p i c k e d a d e s i g n pattern , how do you use it? H e r e ' s a s t e p - b y - s t e p approac h\nto applyin g a d e s i g n patter n effectively:\n1. Read the pattern once through for an overview. Pay particula r attentio n to the A p p l i c -\nabilit y and C o n s e q u e n c e s s e c t i o n s to ensur e the patter n is right for your p r o b l e m . 2. Go back and study the Structure, Participants, and Collaborations sections. Make s u re\nyou understan d the c l a s s e s and o b j e c t s in the patter n and how they relate to one\nanother. 3. Look at the Sample Code section to see a concrete example of the pattern in code. Studyin g\nthe c o de h e l ps you learn how to implemen t the pattern. 4.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 159, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 932}}
{"id": "computer_science_design_patterns_gof_chunk_0160_0f6baac2", "text": "3. Look at the Sample Code section to see a concrete example of the pattern in code. Studyin g\nthe c o de h e l ps you learn how to implemen t the pattern. 4. Choose names for pattern participants that are meaningful in the application context. The name s for participant s in d e s i g n pattern s are usuall y too abstrac t to appea r\nd i r e c t l y in an a p p l i c a t i o n . N e v e r t h e l e s s , i t 's usefu l to incorporat e the participan t \nname into the name that appear s in the application . That h e l ps make the patter n\nm o re e x p l i c i t in the implementation . For e x a m p l e , if you use the Strateg y patter n\nf or a text c o m p o s i t i n g algorithm , then you migh t have c l a s s e s SimpleLayoutStrat-\ne gy or TeXLayoutStrategy. 5. Define the classes. D e c l a r e their interfaces , e s t a b l i s h their inheritanc e r e l a t i o n s h i p s ,\nand defin e the instanc e v a r i a b l e s that r e p r e s e n t data and o b j e c t r e f e r e n c e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 160, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_design_patterns_gof_chunk_0161_6cea4498", "text": "Identif y\ne x i s t i n g c l a s s e s in your a p p l i c a t i o n that the patter n w i ll a f f e c t , and modif y them\na c c o r d i n g l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 161, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 149}}
{"id": "computer_science_design_patterns_gof_chunk_0162_5a408893", "text": "ptg3 0 INTRODUCTION CHAPTER 1\nPurpos e\nCreational\nStructural\nB e h a v i o r a lDesig n Patter n\nAbstrac t Factor y ( 8 7)\nBuilde r ( 9 7 )\nF a c t o r y M e t h o d ( 1 0 7)\nP r o t o t y p e ( 1 1 7)\nS i n g l e t o n ( 1 2 7) \nAdapte r ( 1 3 9 )\nBridg e ( 1 5 1)\nC o m p o s i t e ( 1 6 3)\nDecorato r ( 1 7 5 )\nFacad e ( 1 8 5 )\nFlyweigh t ( 1 9 5 )\nProxy ( 2 0 7 )\nC h a in of R e s p o n s i b i l i t y ( 2 2 3)\nComman d ( 2 3 3)\nInterprete r ( 2 4 3 )\nIterato r ( 2 5 7 )\nMediato r ( 2 7 3 )\nM e m e n t o ( 2 8 3 )\nO b s e r v e r ( 2 9 3 )\nS t a te ( 3 0 5 )\nStrateg y ( 3 1 5)\nT e m p l a t e Metho d ( 3 2 5)\nV i s i t o r (331)Aspect(s ) That Can Vary\nfamilie s of produc t o b j e c t s \nh ow a c o m p o s i t e o b j e c t g e ts c r e a t e d\ns u b c l a s s of o b j e c t that is instantiate d \nc l a ss of objec t that is instantiate d \nt he s o le instanc e of a c l a ss \ninterfac e to an objec t \nimplementatio n of an o b j e c t \nstructur e a nd c o m p o s i t i o n of an o b j e c t\nr e s p o n s i b i l i t i e s of an objec t \nwithou t s u b c l a s s i n g \ninterfac e to a subsyste m \nstorag e c o s ts of o b j e c t s \nh ow an o b j e c t is a c c e s s e d ; i ts locatio n \no b j e c t that c an fulfil l a r e q u e s t \nwhen and how a reques t is fulfille d\ngramma r and interpretatio n of a languag e\nh ow an a g g r e g a t e ' s e l e m e n t s a re a c c e s s e d , \ntraverse d \nhow and whic h o b j e c t s interac t with \neach other \nwhat p r i v a t e informatio n is s t o r ed o u t s i d e \nan o b j e c t , and when \nnumbe r of object s that depen d on anothe r \no b j e c t ; how the dependen t o b j e c t s stay \nup to date \nstates of an o b j e c t \nan algorith m \ns t e ps of an algorith m \noperations that can be applied t o object(s)\nwithout changing their class(es)\nT a b l e 1.2: Design aspects that design patterns let you vary\n\nptgSECTION 1.8 HOW TO USE A DESIGN PATTERN 31\n6.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 162, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1937}}
{"id": "computer_science_design_patterns_gof_chunk_0163_3cc0af0c", "text": "Define application-specific names for operations in the pattern. H e re a g a i n , the name s\ng e n e r a l l y depen d on t he application . U se t he r e s p o n s i b i l i t i e s a nd c o l l a b o r a t i o n s\na s s o c i a t e d with e a ch operatio n as a g u i d e . A l s o, be c o n s i s t e n t in your namin g\nc o n v e n t i o n s . For e x a m p l e , you migh t use the \" C r e a t e - \" prefix c o n s i s t e n t l y to\nd e n o t e a factor y m e t h o d . 7. Implement the operations to carry out the responsibilities and collaborations in the pattern. The Implementatio n s e c t i o n offer s hints to g u i de you in the implementation . The\ne x a m p l e s in t he S a m p l e C o de s e c t i o n c an help as w e l l . T h e se are just g u i d e l i n e s to get you started . O v er time y o u ' l l d e v e l o p your own way of\nworkin g with d e s i g n patterns.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 163, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_design_patterns_gof_chunk_0164_02cffa96", "text": "T h e se are just g u i d e l i n e s to get you started . O v er time y o u ' l l d e v e l o p your own way of\nworkin g with d e s i g n patterns. No d i s c u s s i o n of how to use d e s i g n pattern s woul d be c o m p l e t e withou t a few word s\non how not to use them . D e s i g n pattern s s h o u l d not be a p p l i e d i n d i s c r i m i n a t e l y . Often\nthey a c h i e v e f l e x i b i l i t y a nd variabilit y by introducin g additiona l l e v e ls of i n d i r e c t i o n ,\nand that can complicat e a d e s i g n a n d / o r c o st you s o me performance . A d e s i g n patter n\ns h o u l d o n l y be applied when the f l e x i b i l i t y i t affords i s actually needed. The Conse -\nq u e n c e s sections are most helpful when evaluating a pattern's benefits and liabilities.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 164, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 807}}
{"id": "computer_science_design_patterns_gof_chunk_0165_f37d29f2", "text": "The Conse -\nq u e n c e s sections are most helpful when evaluating a pattern's benefits and liabilities. ptg\nThis page intentionally left blank \n\nptgC h a p t e r 2\nA C a se S t u d y : \nD e s i g n i n g a D o c u m e n t E d i t o r\nT h is chapte r p r e s e n t s a c a se study in t he d e s i g n of a \" W h a t - Y o u - S e e - I s - W h a t - Y o u - G e t \"\n( or \" W Y S I W Y G \" ) documen t e d i t o r c a l l ed Lexi. 1 W e ' ll s ee h ow d e s i g n pattern s captur e\ns o l u t i o n s to d e s i g n p r o b l e m s in L e xi a nd a p p l i c a t i o n s l i ke i t. By t he e nd of t h is chapte r\nyou w i ll have g a i n e d e x p e r i e n c e with e i g ht patterns , l e a r n i n g them by e x a m p l e . F i g u r e 2 .1 d e p i c t s L e x i ' s u s er i n t e r f a c e . A W Y S I W Y G r e p r e s e n t a t i o n of t he d o c u m e n t\no c c u p i e s t he l a r ge rectangula r a r ea in t he c e n t e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 165, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_design_patterns_gof_chunk_0166_729c08ea", "text": "A W Y S I W Y G r e p r e s e n t a t i o n of t he d o c u m e n t\no c c u p i e s t he l a r ge rectangula r a r ea in t he c e n t e r . T he documen t c an m ix text a nd\ng r a p h i c s freely in a variet y of formattin g s t y l e s . Surroundin g the documen t are the\nusual pull-dow n menu s and s c r o ll bars, p l us a c o l l e c t i o n of page i c o ns for jumpin g to\na particular page in the document. 2 . 1 Design Problems\nWe w i ll examin e s e v en p r o b l e m s in L e x i ' s d e s i g n :\n1. Document structure. T he c h o i c e of interna l representatio n f or t he documen t affect s\nnearl y e v e ry a s p e c t of L e x i ' s d e s i g n . A ll e d i t i n g , formatting , d i s p l a y i n g , a nd\ntextua l analysi s w i ll requir e traversin g the representation . The way we o r g a n i z e\nthis informatio n w i ll i m p a c t t he d e s i g n of t he r e st of t he application. 2. Formatting.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 166, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 929}}
{"id": "computer_science_design_patterns_gof_chunk_0167_d2189ade", "text": "The way we o r g a n i z e\nthis informatio n w i ll i m p a c t t he d e s i g n of t he r e st of t he application. 2. Formatting. How d o es L e xi actuall y arrang e text and g r a p h i c s into l i n es and\ncolumns ? Wha t o b j e c t s are r e s p o n s i b l e for c a r r y i n g out differen t formattin g p o l i -\nc i e s? How do t h e se p o l i c i e s interac t with the document' s interna l representation? 1 L e x i ' s d e s i g n is b a s ed on D o c, a text editin g applicatio n d e v e l o p e d by Calde r [ C L 9 2 ] . 3 3\n\nptg3 4 A C A S E S T U D Y : D E S I G N I N G A D O C U M E N T E D I T O R CHAPTER 2\nF i g u r e 2 . 1 : L e x i ' s u s e r i n t e r f a c e\n\nptgSECTION 2 .2 DOCUMENT STRUCTURE 3 5\n3. Embellishing t he user interface. L e x i ' s u s er interfac e i n c l u d e s s c r o ll b a r s , b o r d e r s ,\nand drop shadow s that e m b e l l i s h the W Y S I W Y G documen t interface .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 167, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_design_patterns_gof_chunk_0168_0c94bfb3", "text": "Embellishing t he user interface. L e x i ' s u s er interfac e i n c l u d e s s c r o ll b a r s , b o r d e r s ,\nand drop shadow s that e m b e l l i s h the W Y S I W Y G documen t interface . S u ch em-\nb e l l i s h m e n t s a re l i k e ly to c h a n g e as L e x i ' s u s er interfac e e v o l v e s . H e n c e i t 's i m -\nportan t to be a b le to add and remov e e m b e l l i s h m e n t s e a s i ly withou t affectin g the\nr e st of t he a p p l i c a t i o n . 4. Supporting multiple look-and-feel standards. L e xi s h o u l d adap t e a s i ly to differen t\nl o o k - a n d - f e e l standard s s u ch as M o t if and Presentatio n Manage r ( P M) withou t\nmajo r modification. 5. Supporting multiple window systems. Differen t l o o k - a n d - f e e l standard s are usuall y\ni m p l e m e n t e d on differen t windo w s y s t e m s . L e x i ' s d e s i g n s h o u l d be as indepen-\nd e nt of t he w i n d o w s y s t e m as p o s s i b l e . 6. User operations.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 168, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_design_patterns_gof_chunk_0169_e02fce8d", "text": "L e x i ' s d e s i g n s h o u l d be as indepen-\nd e nt of t he w i n d o w s y s t e m as p o s s i b l e . 6. User operations. U s e rs c o n t r o l L e xi throug h variou s u s er interfaces , i n c l u d i n g but-\ntons a nd p u l l - d o w n menus . T he functionalit y b e h i n d these interface s is s c a t t e r e d\nthroughou t the o b j e c t s in the a p p l i c a t i o n . The c h a l l e n g e h e re is to p r o v i d e a u n i -\nform m e c h a n i s m both for a c c e s s i n g this scattere d functionalit y and for undoin g\nits effects. 7. Spelling checking a nd hyphenation. H ow d o es L e xi suppor t analytica l o p e r a t i o n s\ns u ch as c h e c k i n g for m i s s p e l l e d word s and determinin g hyphenatio n points ? How can we minimiz e the numbe r of c l a s s e s we have to modif y to add a new\nanalytica l operation? We d i s c u s s t h e se d e s i g n p r o b l e m s in t he s e c t i o n s that f o l l o w .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 169, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_design_patterns_gof_chunk_0170_3d5822a3", "text": "How can we minimiz e the numbe r of c l a s s e s we have to modif y to add a new\nanalytica l operation? We d i s c u s s t h e se d e s i g n p r o b l e m s in t he s e c t i o n s that f o l l o w . E a ch p r o b l e m h as an\na s s o c i a t e d s et of g o a ls p l us constraint s on h ow we a c h i e v e t h o se g o a l s . We e x p l a i n t he\ng o a ls a nd constraint s in d e t a i l befor e p r o p o s i n g a s p e c i f i c s o l u t i o n . T he p r o b l e m a nd \ni ts s o l u t i o n w i ll illustrat e o ne or m o re d e s i g n patterns . T he d i s c u s s i o n f or e a ch p r o b l e m\nw i l l c u l m i n a t e in a brief introduction to the relevant patterns. 2 . 2 Document S t r u c t u r e\nA documen t is ultimatel y just an arrangemen t of b a s ic g r a p h i c a l e l e m e n t s s u ch as c h a r -\na c t e r s , l i n e s, p o l y g o n s , a nd other s h a p e s . T h e s e e l e m e n t s captur e t he total informatio n\nconten t of the document .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 170, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 990}}
{"id": "computer_science_design_patterns_gof_chunk_0171_9c321f63", "text": "T h e s e e l e m e n t s captur e t he total informatio n\nconten t of the document . Yet an autho r often v i e w s t h e se e l e m e n t s not in g r a p h i c a l\nterms but in terms of the document' s p h y s i c a l s t r u c t u r e — l i n e s , c o l u m n s , figures , ta-\nb l e s, and o t h er substructures. 2 In turn, these substructure s have substructure s of their\no w n, a nd so o n . L e x i ' s user interfac e s h o u l d l et u s e rs manipulat e these substructure s d i r e c t l y . F or e x -\na m p l e , a u s er s h o u l d be able to treat a diagra m as a unit rathe r than as a c o l l e c t i o n of\n2 Author s often v i ew the documen t in terms of its logical structur e as w e l l, that is, in terms of s e n t e n c e s ,\nparagraphs , s e c t i o n s , s u b s e c t i o n s , a nd chapters . To k e ep this exampl e s i m p l e , o ur interna l r e p r e s e n t a t i o n \nwon' t s t o re informatio n abou t the l o g i c a l structur e exp licitly .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 171, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_design_patterns_gof_chunk_0172_9a4fb807", "text": "To k e ep this exampl e s i m p l e , o ur interna l r e p r e s e n t a t i o n \nwon' t s t o re informatio n abou t the l o g i c a l structur e exp licitly . But the d e s i g n s o l u t i o n we d e s c r i b e work s\nequally well for representing such information. ptg36 A C A SE S T U D Y - DESIGNING A DOCUMENT EDITOR CHAPTER 2\nindividua l graphica l primitives . The user shoul d be able to refer to a table as a w h o l e ,\nnot as an unstructure d mass of text and graphics . That helps make the interfac e s i m p l e\nand intuitive . To g i ve L e x i ' s implementatio n simila r q u a l i t i e s , we'll c h o o s e an interna l\nrepresentatio n t h at matche s the document' s physica l structure. In particular , the interna l representatio n shoul d suppor t the following:\n• Maintainin g the document' s physica l structure , t h at is, the arrangemen t of text\nand graphic s into l i n e s, columns , tables , etc. • Generatin g and presentin g the documen t v i s u a l l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 172, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_design_patterns_gof_chunk_0173_e0561702", "text": "• Generatin g and presentin g the documen t v i s u a l l y . • Mappin g position s on the displa y to element s in the interna l representation . T h is\nl e ts L e xi determin e w h at the user is referrin g to when he point s to somethin g in\nthe visua l representation. In additio n to these g o a ls are s o me constraints . F i r s t, we s h o u l d treat text and graphic s\nuniformly . The application' s interfac e l e ts the user e m b e d text withi n graphic s freely\nand v i ce versa . We shoul d a v o id treatin g graphic s as a s p e c i a l c a se of text or text\nas a s p e c i a l c a se of g r a p h i c s ; otherwis e we'll end up with redundan t f o r m a t t i n g and\nm a n i p u l a t i o n m e c h a n i s m s . O ne s et of m e c h a n i s m s s h o u l d suffic e f or both t e xt a nd\ng r a p h i c s . S e c o n d , our implementatio n shouldn' t have to distinguis h betwee n s i n g le element s and\ng r o u p s of element s in the interna l representation .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 173, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_design_patterns_gof_chunk_0174_dbd7b595", "text": "S e c o n d , our implementatio n shouldn' t have to distinguis h betwee n s i n g le element s and\ng r o u p s of element s in the interna l representation . L e xi shoul d be a b le to treat s i m p l e\nand c o m p l e x element s uniformly , thereb y a l l o w i n g arbitraril y c o m p l e x documents . The \ntenth e l e m e n t in l i ne five of colum n t w o, for i n s t a n c e , c o u ld be a s i n g le characte r or an\nintricat e diagra m with many subelements . As long as we know this elemen t can draw\ni t s e lf and specif y its d i m e n s i o n s , its complexit y has no bearin g on how and w h e r e it\nshoul d appea r on the page. O p p o s i n g the s e c o n d constraint , however , is the n e ed to analyz e the text for such t h i n g s\nas s p e l l i n g error s and potentia l hyphenatio n points . Often we don't c a re whethe r the\ne l e m e n t of a l i ne is a s i m p l e or c o m p l e x object . B ut sometime s an analysi s depend s on\nthe object s b e i ng analyzed .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 174, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_design_patterns_gof_chunk_0175_73b4863c", "text": "Often we don't c a re whethe r the\ne l e m e n t of a l i ne is a s i m p l e or c o m p l e x object . B ut sometime s an analysi s depend s on\nthe object s b e i ng analyzed . It make s little s e n s e , for e x a m p l e , to c h e ck the s p e l l i n g of a\npolygo n or to hyphenat e it. The interna l representation' s d e s i g n s h o u l d take this and\nother potentiall y conflictin g constraint s into account. Recursiv e Composition\nA commo n way to represen t hierarchicall y structure d informatio n is throug h a t e c h -\nnique c a l l ed recursiv e composition , whic h entail s buildin g i n c r e a s i n g l y c o m p l e x e l e -\nment s out of s i m p l e r o n e s. R e c u r s i v e compositio n g i v es us a way to c o m p o s e a d o c u -\nment out of s i m p l e graphica l elements . As a first s t e p, we can tile a set of character s\nand graphic s f r om left to right to f o rm a l i ne in the document .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 175, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_design_patterns_gof_chunk_0176_9c0f0d58", "text": "As a first s t e p, we can tile a set of character s\nand graphic s f r om left to right to f o rm a l i ne in the document . T h en multipl e l i n es\ncan be arrange d to f o rm a c o l u m n , multipl e column s can f o rm a p a g e, and so on ( s ee\nF i g u r e 2 . 2 ) . ptgSECTION 2 . 2 DOCUMENT S T R U C T U R E 37\nF i g u r e 2 . 3 : O b j e c t structure for recursive composition of text and g r a p h i c s\nFgure 2.2: Recusive coposition of text and graphics\n\nptg3 8 A CASE STUDY- DESIGNING A D O C U M E N T EDITOR CHAPTER 2\nF i g u r e 2 . 4: Partia l Glyp h c l a ss h i e r a r c h y\nWe c an r e p r e s e n t this p h y s i c a l structur e by dev ot in g an o b j e c t to e a ch importan t e l e -\nment . T h at i n c l u d e s not just the v i s i b l e e l e m e n t s l i ke the character s and g r a p h i c s but \nt he i n v i s i b l e , structura l e l e m e n t s as well—th e l i n es a nd t he c o l u m n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 176, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 934}}
{"id": "computer_science_design_patterns_gof_chunk_0177_2782a2a8", "text": "T he r e s u lt is t he\no b j e c t structur e s h o w n in F i g u r e 2 . 3 . By using an o b j e c t for e a ch characte r and graphica l e l e m e n t in the document , we\npromot e f l e x i b i l i t y at t he fines t l e v e ls of L e x i ' s d e s i g n . We c an treat text a nd g r a p h i c s\nuniforml y with r e s p e c t to how they are drawn , formatted , and e m b e d d e d withi n e a ch\no t h e r . We c an e x t e n d L e xi to suppor t n ew characte r s e ts withou t disturbin g other\nfunctionality . L e x i ' s o b j e c t structur e m i m i c s the document' s p h y s i c a l structure. T h is approac h h as t wo importan t i m p l i c a t i o n s . T he f i r st is o b v i o u s : T he o b j e c t s n e ed\nc o r r e s p o n d i n g c l a s s e s . T he s e c o n d i m p l i c a t i o n , w h i c h m a y b e l e ss o b v i o u s , is that t h e se \nc l a s s e s must have c o m p a t i b l e interfaces , b e c a u s e we want to treat the o b j e c t s uniformly .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 177, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_design_patterns_gof_chunk_0178_db640fb8", "text": "The way to make interface s c o m p a t i b l e in a l a n g u a g e l i ke C++ is to relate the c l a s s e s\nthrough inheritance. G l y p h s\nW e ' ll defin e a G l y p h abstrac t c l a ss for all o b j e c t s that can appea r in a documen t\ns t r u c t u r e . 3 I ts s u b c l a s s e s defin e both p r i m i t i v e g r a p h i c a l e l e m e n t s ( l i ke character s a n d\n3 Calde r w as t he f i r st to u se t he term \" g l y p h \" in t h is c o n t e x t [ C L 9 0 ] . M o st contemporar y d o c u m e n t e d i t o r s\nd o n ' t u s e a n o b j e c t f o r every character, presumably for efficiency r e a s o n s . C a l d e r d e m o n s t r a t e d t h a t t h i s\n\nptgSECTION 2 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 178, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 699}}
{"id": "computer_science_design_patterns_gof_chunk_0179_1eb38150", "text": "C a l d e r d e m o n s t r a t e d t h a t t h i s\n\nptgSECTION 2 . 2 DOCUMENT STRUCTURE 3 9\nR e s p o n s i b i l i t y\nappearance\nh it d e t e c t i o n\nstructureO p e r a t i o n s\nv i r t u a l \nv i r t u a l \nv i r t u a l \nv i r t u a l \nv i r t u a l \nv i r t u a l \nv i r t u a lv o id D r aw ( W i n d o w * ) \nv o id B o u n d s ( R e c t & ) \nbool I n t e r s e c t s ( c o n s t P o i n t & )\nvo id I n s e r t ( G l y p h * , \nv o i d R e m o v e (Glyph*)\nGlyph* C h i l d ( i n t )\nG l y p h * P a r e n t ( )i n t )\nT a b le 2 . 1: B a s ic g l y ph interface\ni m a g e s ) and structura l element s ( l i ke r o ws a nd columns) . F i g u r e 2 .4 depict s a r e p r e s e n -\ntative part of the Glyp h c l a ss h i e r a r c h y , and T a b le 2.1 present s the basic glyph interfac e\nin m o re d e t a i l u s i ng C ++ n o t a t i o n . 4\nGlyph s have three b a s ic r e s p o n s i b i l i t i e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 179, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 919}}
{"id": "computer_science_design_patterns_gof_chunk_0180_95e5aee6", "text": "4\nGlyph s have three b a s ic r e s p o n s i b i l i t i e s . T h ey know (1) how to draw themselves , (2)\nwhat s p a c e they o c c u p y , a nd ( 3) their c h i l d r e n a nd parent. Glyp h s u b c l a s s e s redefin e the D r aw operatio n to rende r t h e m s e l v e s onto a w i n d o w . T h ey are p a s s e d a referenc e to a W i n d o w o b j e c t in the c a ll to D r a w . The Windo w c l a ss\ndefine s g r a p h i c s operation s for renderin g text and b a s ic shape s in a windo w on the\ns c r e e n . A Rectangl e s u b c l a s s of Glyp h migh t redefin e D r aw as follows:\nv o id R e c t a n g l e : : D r a w ( W i n d o w * w) {\nw - > D r a w R e c t ( _ x O , _ y O, _ x l, _ _ y l ) ;\n}\nwher e _ x O, _y 0, _ x l, and _y 1 are data member s of R e c t a n g l e that defin e two o p p o s i n g\ncorner s of the r e c t a n g l e . D r a w R e c t is the Windo w operatio n tha t make s the r e c t a n g l e \nappea r on t he s c r e e n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 180, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_design_patterns_gof_chunk_0181_e0d3def8", "text": "D r a w R e c t is the Windo w operatio n tha t make s the r e c t a n g l e \nappea r on t he s c r e e n . A paren t g l y ph often n e e ds to know how much s p a ce a c h i ld glyph o c c u p i e s , for\ne x a m p l e , to arrang e it a nd o t h er g l y p h s in a l i ne so that none o v e r l a p s ( as show n in\nF i g u r e 2 . 2 ). The B o u n d s operatio n return s the rectangula r area that the glyph o c c u p i e s . It return s the o p p o s i t e c o r n e r s of the s m a l l e s t r e c t a n g l e that contain s the g l y p h . Glyp h\ns u b c l a s s e s redefin e this operatio n to retur n the rectangula r area in whic h they draw. The I n t e r s e c t s operatio n return s whethe r a s p e c i f i e d point i n t e r s e c t s the glyph . Wheneve r t he u s er c l i c ks s o m e w h e r e in t he document , L e xi c a l ls this operatio n to\ndetermin e whic h g l y ph or g l y ph structur e is unde r t he mouse .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 181, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_design_patterns_gof_chunk_0182_93f8183f", "text": "Wheneve r t he u s er c l i c ks s o m e w h e r e in t he document , L e xi c a l ls this operatio n to\ndetermin e whic h g l y ph or g l y ph structur e is unde r t he mouse . T he Rectangl e c l a ss\nredefine s this operatio n to comput e t he i n t e r s e c t i o n of t he r e c t a n g l e a nd t he g i v en\npoint. a p p r o a c h is f e a s i b l e in h is t h e s is [ C a l 9 3 ] . O ur g l y p h s a re l e ss s o p h i s t i c a t e d than h is in that we h a ve r e s t r i c t e d\nours to strict hierarchie s for s i m p l i c i t y . Calder' s glyph s can be s h a r e d to reduc e storag e c o s t s , thereb y formin g\nd i r e c t e d - a c y c l i c graph structures . We can apply the F l y w e i g h t ( 1 9 5) patter n to get the s a me effect , but we'll \nleave that as an e x e r c i s e for the r e a d e r . 4 The interfac e we d e s c r i b e here is purposel y minima l to k e ep the d i s c u s s i o n s i m p l e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 182, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_design_patterns_gof_chunk_0183_ee4ac200", "text": "4 The interfac e we d e s c r i b e here is purposel y minima l to k e ep the d i s c u s s i o n s i m p l e . A c o m p l e t e interfac e\nwould include operations for managing graphical attributes such as color, font, and coordinate transforma -\nt i o n s , plus operations for more sophisticated child management. ptg40 A C A SE S T U D Y - DESIGNING A DOCUMENT EDITOR CHAPTER 2\nB e c a u s e g l y p h s can have c h i l d r e n , we n e ed a c o m m o n interfac e to add, r e m o v e , and\na c c e s s those c h i l d r e n . F or e x a m p l e , a Row' s c h i l d r e n a re t he g l y p h s it arrange s into a\nr o w. The I n s e r t operatio n insert s a g l y ph at a p o s i t i o n s p e c i f i e d by an i n t e g e r i n d e x . 5\nT he R e m o v e operatio n r e m o v e s a s p e c i f i e d glyph if it is i n d e e d a c h i l d . The C h i l d operatio n return s the c h i ld (if any) at the g i v en i n d e x .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 183, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 934}}
{"id": "computer_science_design_patterns_gof_chunk_0184_adcbb1e4", "text": "5\nT he R e m o v e operatio n r e m o v e s a s p e c i f i e d glyph if it is i n d e e d a c h i l d . The C h i l d operatio n return s the c h i ld (if any) at the g i v en i n d e x . G l y p h s l i ke Row\nthat can have c h i l d r e n s h o u l d use C h i l d internall y i n s t e a d of a c c e s s i n g the c h i ld data\nstructur e d i r e c t l y . That way you won' t have to modif y operation s l i ke D r aw that iterat e\nthroug h the c h i l d r e n when you chang e the data structur e from , s a y, an array to a l i n k e d\nl i s t. S i m i l a r l y , P a r e n t p r o v i d e s a standar d interfac e to the g l y p h ' s parent , if a n y. G l y p h s \nin L e xi store a referenc e to their parent , and their P a r e n t operatio n s i m p l y return s t h is\nreference. C o m p o s i t e P a t t e r n\nRecursiv e c o m p o s i t i o n is g o od for more than just documents . We can use it to r e p r e s e n t\na ny potentiall y c o m p l e x , h i e r a r c h i c a l structure .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 184, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_design_patterns_gof_chunk_0185_a2284a90", "text": "We can use it to r e p r e s e n t\na ny potentiall y c o m p l e x , h i e r a r c h i c a l structure . T he C o m p o s i t e ( 1 6 3) patter n c a p t u r e s\nt he e s s e n c e of r e c u r s i v e c o m p o s i t i o n in object-oriente d terms . N ow woul d be a g o od\ntime to turn to that pattern and study it, referring back to this scenario as needed. 2 . 3 Formatting\nW e ' v e s e t t l e d on a way to represent the document' s p h y s i c a l structure . Next , we n e ed\nto figur e out how to construc t a particular p h y s i c a l structure , one that c o r r e s p o n d s to a\nproperl y formatte d document . Representatio n and formattin g are d i s t i n c t : The a b i l i t y\nto captur e the document' s p h y s i c a l structur e doesn' t t e ll us how to a r r i ve at a particula r\nstructure . T h is r e s p o n s i b i l i t y r e s ts mostl y on L e x i.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 185, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 884}}
{"id": "computer_science_design_patterns_gof_chunk_0186_39b057c8", "text": "T h is r e s p o n s i b i l i t y r e s ts mostl y on L e x i. It must break text into l i n e s, l i n es into\nc o l u m n s , a nd so o n, takin g into a c c o u n t t he user' s h i g h e r - l e v e l d e s i r e s . F or e x a m p l e , t he\nu s er migh t want to vary margi n widths , indentation , and tabulation ; s i n g le or d o u b l e\ns p a c e ; and p r o b a b l y many other formattin g constraints. 6 L e x i ' s formattin g algorith m\nmust take all of these into a c c o u n t . By the way, w e ' ll r estr ic t \"formatting \" to mean breakin g a c o l l e c t i o n of g l y p h s into\nl i n e s. In fact, w e ' ll use the terms \"formatting \" and \" l i n e b r e a k i n g \" i n t e r c h a n g e a b l y . T he t e c h n i q u e s we'll d i s c u s s apply e q u a l l y w e ll to breakin g l i n es into c o l u m n s a nd to\nbreakin g c o l u m n s into p a g e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 186, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 887}}
{"id": "computer_science_design_patterns_gof_chunk_0187_9050a0d7", "text": "T he t e c h n i q u e s we'll d i s c u s s apply e q u a l l y w e ll to breakin g l i n es into c o l u m n s a nd to\nbreakin g c o l u m n s into p a g e s . BAn intege r index is probabl y not the b e st way to specif y a g l y p h ' s c h i l d r e n , dependin g on the data \nstructur e the glyph u s e s. If it s t o r es its c h i l d r e n in a l i n k e d l i s t, then a pointe r into the l i st woul d be m o re\nefficient . W e ' ll s ee a bette r s o l u t i o n to t he indexin g p r o b l e m in S e c t i o n 2 . 8, when we d i s c u s s d o c u m e n t\nanalysis. 6 The u s er will have e v en m o re to say abou t the document' s logical structure—th e s e n t e n c e s , paragraphs ,\ns e c t i o n s , chapters , a nd so forth . T he physical structur e is l e ss interestin g by c o m p a r i s o n . M o st p e o p l e don't \ncare wher e the linebreak s in a paragrap h o c c ur as l o ng as the paragrap h is formatte d p r o p e r l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 187, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_design_patterns_gof_chunk_0188_e1222b65", "text": "M o st p e o p l e don't \ncare wher e the linebreak s in a paragrap h o c c ur as l o ng as the paragrap h is formatte d p r o p e r l y . The s a me\nis true for formattin g column s and p a g e s . T h us u s e rs end up s p e c i f y i n g o n ly h i g h - l e v e l c o n s t r a i n t s on the\np h y s i c a l structure, leaving Lexi to do the hard work of satisfying them. ptgSECTION 2.3 FORMATTING 41\nR e s p o n s i b i l i t y\nwhat to format\nwhen to formatO p e r a t i o n s \nv o id S e t C o m p o s i t i o n ( C o m p o s i t i o n * )\nv i r t u a l v o i d C o m p o s e ( )\nT a b l e 2.2: B a s i c compositor interface\nE n c a p s u l a t i n g t he F o r m a t t i n g A l g o r i t h m\nT he formattin g p r o c e s s , with a ll i ts c o n s t r a i n t s a nd d e t a i l s , i s n 't e a sy to automate . T h e re are many approache s to the p r o b l e m , and peopl e have c o me up with a variet y\nof formattin g algorithm s with differen t strength s and w e a k n e s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 188, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_design_patterns_gof_chunk_0189_50ec4293", "text": "T h e re are many approache s to the p r o b l e m , and peopl e have c o me up with a variet y\nof formattin g algorithm s with differen t strength s and w e a k n e s s e s . B e c a u s e L e xi is a\nW Y S I W Y G e d i t o r , an importan t t r a d e - o f f to c o n s i d e r is t he b a l a n c e b e t w e e n formattin g\nqualit y and formattin g s p e e d . We want g e n e r a l l y g o od r e s p o n s e from the edito r with-\nout s a c r i f i c i n g how g o od the documen t l o o k s . T h is trade-of f is subjec t to many factors ,\nn ot a ll of w h i c h c an be a s c e r t a i n e d at c o m p i l e - t i m e . F or e x a m p l e , t he u s er m i g h t t o l -\nerate s l i g h t l y s l o w e r r e s p o n s e in e x c h a n g e for bette r formatting . That trade-of f migh t\nmake an e n t i r e l y differen t formattin g algorith m more appropriat e than the curren t\no n e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 189, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_design_patterns_gof_chunk_0190_7108f9e8", "text": "That trade-of f migh t\nmake an e n t i r e l y differen t formattin g algorith m more appropriat e than the curren t\no n e. A n o t h e r , m o re i m p l e m e n t a t i o n - d r i v e n trade-of f b a l a n c e s formattin g s p e ed a nd\nstorag e requirements : It may be p o s s i b l e to d e c r e a s e formattin g time by c a c h i n g more\ninformation. B e c a u s e formattin g algorithm s tend to be c o m p l e x , i t 's a l so d e s i r a b l e to keep them w e l l -\ncontaine d or—bette r yet—completel y independen t of the documen t structure . Ideall y\nwe c o u ld add a new kind of Glyp h s u b c l a s s withou t r e g a r d to the formattin g algorithm . C o n v e r s e l y , addin g a new formattin g algorith m shouldn' t r e q u i r e modifyin g e x i s t i n g\ng l y p h s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 190, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 801}}
{"id": "computer_science_design_patterns_gof_chunk_0191_8f7ef8e4", "text": "C o n v e r s e l y , addin g a new formattin g algorith m shouldn' t r e q u i r e modifyin g e x i s t i n g\ng l y p h s . T h e s e c h a r a c t e r i s t i c s s u g g e s t we s h o u l d d e s i g n L e xi so that i t 's e a sy to c h a n g e t he\nformattin g algorith m at least at c o m p i l e - t i m e , if not at run-tim e as w e l l. We can isolat e\nthe algorith m and make it e a s i ly r e p l a c e a b l e at the same time by encapsulatin g it\nin an o b j e c t . M o re s p e c i f i c a l l y , w e ' ll defin e a s e p a r a t e c l a ss h i e r a r c h y f or o b j e c t s that\nencapsulat e formattin g algorithms . The root of the hierarch y w i ll defin e an interfac e\nthat support s a w i de range of formattin g algorithms , and each s u b c l a s s w i ll implemen t\nt he i n t e r f a c e to c a r ry o ut a p a r t i c u l a r a l g o r i t h m .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 191, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_design_patterns_gof_chunk_0192_f45b1539", "text": "T h en we c an i n t r o d u c e a G l y p h s u b c l a s s\nthat will structure its children automatically using a given algorithm object. C o m p o s i t o r a nd C o m p o s i t i o n\nW e ' ll d e f i n e a C o m p o s i t o r c l a ss f or o b j e c t s that c an e n c a p s u l a t e a formattin g a l g o r i t h m . The interfac e ( T a b l e 2 . 2) l e ts the composito r know what g l y p h s to f o r m a t and when to do\nthe formatting . The g l y p h s it format s are the c h i l d r e n of a s p e c i a l Glyp h s u b c l a s s c a l l e d\nC o m p o s i t i o n . A c o m p o s i t i o n g e ts an i n s t a n c e of a C o m p o s i t o r s u b c l a s s ( s p e c i a l i z e d\nfor a particula r l i n e b r e a k i n g algorithm ) when it is c r e a t e d , and it t e l ls the composito r to\nC o m p o s e its g l y p h s when n e c e s s a r y , for e x a m p l e , when the user change s a document .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 192, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_design_patterns_gof_chunk_0193_d551950e", "text": "F i g u r e 2.5 d e p i c t s the relationships between the Composition a n d Compositor c l a s s e s . ptg4 2 A CASE S T U D Y - DESIGNING A D O C U M E N T EDITOR CHAPTER 2\nF i g u r e 2 . 5: Compositio n a nd C o m p o s i t o r c l a ss r e l a t i o n s h i p s\nAn unformatte d C o m p o s i t i o n o b j e c t c o n t a i n s o n ly the v i s i b l e g l y p h s that make up\nthe document' s b a s ic content . It d o e s n ' t contai n g l y p h s that determin e the document' s\nphysica l structure , s u ch as R ow a nd Column . T he c o m p o s i t i o n is in this state just a f t er\nit's create d and i n i t i a l i z e d with the g l y p h s it s h o u l d f o r m a t . Whe n the c o m p o s i t i o n\nn e e ds formatting , it c a l ls its compositor' s C o m p o s e operation . The c o m p o s i t o r in turn\niterate s throug h the c o m p o s i t i o n ' s c h i l d r e n and i n s e r t s new Row and C o l u m n g l y p h s\na c c o r d i n g to i ts linebreakin g algorithm.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 193, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_design_patterns_gof_chunk_0194_dd92347c", "text": "7 F i g u r e 2 .6 show s t he r e s u l t i n g o b j e c t structure . G l y p h s that the composito r create d and i n s e r t e d into the o b j e c t structur e appea r with \ngray background s in the figure. Each Composito r s u b c l a s s c an i m p l e m e n t a differen t l i n e b r e a k i n g algorithm . F or e x -\nample , a S i m p l e C o m p o s i t o r migh t do a q u i ck p a ss withou t r e g a r d for s u ch e s o t e r i c a\nas t he document' s \" c o l o r . \" G o od c o l or mean s havin g an e v en distributio n of text a nd\nwhitespace . A T e X C o m p o s i t o r woul d implemen t the full T j ?X algorith m [ K n u 8 4 ] , w h i c h\ntakes thing s l i ke c o l or into a c c o u n t in e x c h a n g e for l o n g e r formattin g t i m e s . T he C o m p o s i t o r - C o m p o s i t i o n c l a ss s p l it e n s u r e s a stron g separatio n betwee n c o de\nthat support s the document' s p h y s i c a l structur e and the c o de for differen t formattin g \nalgorithms .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 194, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_design_patterns_gof_chunk_0195_3db69cdb", "text": "We c an a dd n ew C o m p o s i t o r s u b c l a s s e s withou t touchin g t he g l y ph c l a s s e s ,\nand v i ce versa . In fact, we can c h a n g e the l i n e b r e a k i n g algorith m at run-tim e by a d d i n g\na s i n g le S e t C o m p o s i t o r operatio n to C o m p o s i t i o n ' s b a s ic g l y ph interface. S t r a t e g y P a t t e r n\nEncapsulatin g an algorith m in an o b j e c t is t he inten t of t he Strateg y ( 3 1 5) pattern . The key participant s in the pattern are Strateg y o b j e c t s ( w h i c h encapsulat e differen t\nalgorithms ) and the c o n t e x t in whic h they operate . C o m p o s i t o r s are s t r a t e g i e s ; they en-\n7 The c o m p o s i t o r must get the characte r c o d es of Characte r g l y p h s in order to comput e the l i n e b r e a k s . In S e c t i o n 2.8 w e ' ll see how to get t h is informatio n polymorphicall y withou t addin g a character-specifi c \no p e r a t i o n to the Glyph interface. ptgSECTION 2 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 195, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_design_patterns_gof_chunk_0196_691b998f", "text": "In S e c t i o n 2.8 w e ' ll see how to get t h is informatio n polymorphicall y withou t addin g a character-specifi c \no p e r a t i o n to the Glyph interface. ptgSECTION 2 . 4 EMBELLISHING THE U S E R I N T E R F A C E 43\nF i g u r e 2 . 6: O b j e c t structur e reflectin g c o m p o s i t o r - d i r e c t e d l i n e b r e a k i n g\ncapsulat e differen t f o r m a t t i n g algorithms . A c o m p o s i t i o n is the contex t for a c o m p o s i t o r\ns t r a t e g y . The key to a p p l y i n g the S t r a t e g y patter n is d e s i g n i n g interface s for the strateg y and\nits c o n t e x t that are g e n e r a l e n o u g h to s u p p o r t a range of a l g o r i t h m s . You shouldn' t\nhave to c h a n g e the strateg y or c o n t e x t interfac e to suppor t a new algorithm .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 196, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 802}}
{"id": "computer_science_design_patterns_gof_chunk_0197_b51e158f", "text": "You shouldn' t\nhave to c h a n g e the strateg y or c o n t e x t interfac e to suppor t a new algorithm . In our\ne x a m p l e , t he b a s ic Glyp h interface' s suppor t f or c h i ld a c c e s s , i n s e r t i o n , a nd remova l is\ng e n e r a l e n o u g h to l et C o m p o s i t o r s u b c l a s s e s c h a n g e t he d o c u m e n t ' s p h y s i c a l s t r u c t u r e ,\nr e g a r d l e s s of the algorith m they use to do it. L i k e w i s e , the C o m p o s i t o r interfac e g i v es\nc o m p o s i t i o n s w h a t e v e r t h e y n e e d to initiate formatting. 2 . 4 Embellishing t h e User Interface\nWe c o n s i d e r two e m b e l l i s h m e n t s in L e x i ' s user interface . The first adds a b o r d e r aroun d\nt he t e xt e d i t i n g a r ea to d e m a r c a t e t he p a ge of t e x t. T he s e c o n d a d ds s c r o ll b a rs that l et\nthe u s er v i ew differen t parts of the p a g e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 197, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_design_patterns_gof_chunk_0198_ccc46985", "text": "T he s e c o n d a d ds s c r o ll b a rs that l et\nthe u s er v i ew differen t parts of the p a g e. To make it e a sy to add and r e m o v e t h e se\ne m b e l l i s h m e n t s ( e s p e c i a l l y at run-time) , we shouldn' t use inheritanc e to add them\nto t he user interface . We a c h i e v e t he m o st f l e x i b i l i t y if other u s er interfac e o b j e c t s\ndon't e v en know the e m b e l l i s h m e n t s are there . That w i ll let us add and remov e the\ne m b e l l i s h m e n t s withou t changin g other c l a s s e s . T r a n s p a r e n t E n c l o s u r e\nF r om a programmin g p o i nt of v i e w, e m b e l l i s h i n g t he u s er interfac e i n v o l v e s e x t e n d i n g\ne x i s t i n g c o d e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 198, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 737}}
{"id": "computer_science_design_patterns_gof_chunk_0199_2f260681", "text": "T r a n s p a r e n t E n c l o s u r e\nF r om a programmin g p o i nt of v i e w, e m b e l l i s h i n g t he u s er interfac e i n v o l v e s e x t e n d i n g\ne x i s t i n g c o d e . U s i n g i n h e r i t a n c e t o d o such extension precludes rearranging e m b e l l i s h -\n\nptg44 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2\nment s at run-time , but an e q u a l l y s e r i o u s p r o b l e m is the e x p l o s i o n of c l a s s e s that can\nresul t from an i n h e r i t a n c e - b a s e d approach. We c o u ld add a borde r to C o m p o s i t i o n by s u b c l a s s i n g it to y i e ld a B o r d e r e d C o m p o s i -\ntion c l a s s . Or we c o u ld add a s c r o l l i n g interfac e in the same way to y i e ld a S c r o l l a b l e -\nComposition . If we want both s c r o ll bars and a b o r d e r , we migh t produc e a B o r d e r e d -\nS c r o l l a b l e C o m p o s i t i o n , and so f o r t h .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 199, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_design_patterns_gof_chunk_0200_a8621552", "text": "If we want both s c r o ll bars and a b o r d e r , we migh t produc e a B o r d e r e d -\nS c r o l l a b l e C o m p o s i t i o n , and so f o r t h . In the extreme , we end up with a c l a ss for e v e ry\np o s s i b l e c o m b i n a t i o n of e m b e l l i s h m e n t s , a s o l u t i o n that q u i c k l y b e c o m e s unworkabl e\nas the variet y of e m b e l l i s h m e n t s g r o w s . O b j e c t compositio n o f f e r s a potentiall y more workabl e and fl exi bl e e x t e n s i o n m e c h a -\nn i s m . But what object s do we c o m p o s e ? S i n ce we know we're e m b e l l i s h i n g an e x i s t i n g\ng l y p h , we c o u ld make the e m b e l l i s h m e n t i t s e lf an objec t ( s a y, an instanc e of c l a ss B o r -\nder). That g i v es us two candidate s for c o m p o s i t i o n , the glyph and the b o r d e r . The next\nstep is to d e c i d e who c o m p o s e s whom .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 200, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 912}}
{"id": "computer_science_design_patterns_gof_chunk_0201_46b7b0f4", "text": "That g i v es us two candidate s for c o m p o s i t i o n , the glyph and the b o r d e r . The next\nstep is to d e c i d e who c o m p o s e s whom . We c o u ld have the borde r contai n the g l y p h ,\nwhic h make s s e n se g i v en that the borde r w i ll surroun d the g l y ph on the s c r e e n . Or\nwe c o u ld do the opposite—pu t the b o r d e r into the glyph—bu t then we must make\nmodification s to the c o r r e s p o n d i n g Glyp h s u b c l a s s to make it awar e of the b o r d e r . Our\nfirst c h o i c e , c o m p o s i n g the glyph in the b o r d e r , k e e ps the border-drawin g c o de entirel y\nin t he B o r d e r c l a s s, l e a v i n g other c l a s s e s alone. Wha t d o es the Borde r c l a ss l o ok l i k e? The f a ct that border s have an appearanc e s u g g e s t s\nthey s h o u l d a c t u a l l y be g l y p h s ; that i s, B o r d e r s h o u l d be a s u b c l a s s of Glyph .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 201, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_design_patterns_gof_chunk_0202_387051b5", "text": "The f a ct that border s have an appearanc e s u g g e s t s\nthey s h o u l d a c t u a l l y be g l y p h s ; that i s, B o r d e r s h o u l d be a s u b c l a s s of Glyph . B ut\nthere' s a more c o m p e l l i n g reaso n for d o i ng t h i s: C l i e n t s shouldn' t c a re whethe r g l y p h s\nhave border s or not. T h ey s h o u l d treat g l y p h s uniformly . Whe n c l i e n t s t e ll a plain , \nunbordere d glyph to draw itself , it s h o u l d do so withou t e m b e l l i s h m e n t . If that g l y ph\nis c o m p o s e d in a b o r d e r , c l i e n t s shouldn' t have to treat the borde r containin g the g l y ph\nany differently ; they just t e ll it to draw i t s e lf as they t old the p l a in g l y ph before . T h is\ni m p l i e s that the B o r d e r interfac e matche s the Glyp h interface . We s u b c l a s s B o r d e r from\nGlyp h to guarante e this relationship.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 202, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 896}}
{"id": "computer_science_design_patterns_gof_chunk_0203_2bbd38d3", "text": "T h is\ni m p l i e s that the B o r d e r interfac e matche s the Glyp h interface . We s u b c l a s s B o r d e r from\nGlyp h to guarante e this relationship. All this leads us to the c o n c e p t of transparen t e n c l o s u r e , w h i c h c o m b i n e s the notion s\nof ( 1) s i n g l e - c h i l d ( or single-component ) c o m p o s i t i o n a nd ( 2) c o m p a t i b l e interfaces . C l i e n t s g e n e r a l l y can't t e ll whethe r they'r e d e a l i n g with the componen t or its e n c l o s u r e\n( i . e ., t he c h i l d ' s parent) , e s p e c i a l l y if t he e n c l o s u r e s i m p l y d e l e g a t e s a ll i ts o p e r a t i o n s to\nits component . But the e n c l o s u r e can a l so augment the component' s b e h a v i o r by d o i ng\nwork of its own befor e a n d / o r a f t er delegatin g an operation . The e n c l o s u r e can a l so \neffectively a d d state to the component. We'll see how next.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 203, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_design_patterns_gof_chunk_0204_458a9d80", "text": "The e n c l o s u r e can a l so \neffectively a d d state to the component. We'll see how next. M o n o g l y p h\nWe c an apply t he c o n c e p t of transparen t e n c l o s u r e to a ll g l y p h s that e m b e l l i s h other\ng l y p h s . To m a k e t h i s c o n c e p t c o n c r e t e , we'll define a subclass of Glyph called Mono-\nG l y p h to serve as an abstract class for \"embellishment glyphs,\" like Border (see Fig -\nure 2.7). MonoGlyph stores a reference to a component and forwards all requests to it. ptgSECTION 2 . 4 EMBELLISHING THE U S E R INTERFACE 4 5\nFigur e 2 . 7: MonoGlyp h c l a ss relationships\nT h at m a k e s M o n o G l y p h totall y transparen t to c l i e n t s by default . F or e x a m p l e , M o n o -\nGlyp h implement s the D r aw operatio n like this:\nvoid M o n o G l y p h : : D r a w ( W i n d o w* w) {\n_component->Draw(w) ;\n}\nMonoGlyp h s u b c l a s s e s reimplemen t at least one of these forwardin g opera-\ntions .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 204, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_design_patterns_gof_chunk_0205_d71ce5f8", "text": "B o r d e r : : D r a w , for instance , first invoke s the paren t c l a ss operatio n\nM o n o G l y p h : : D r aw on the componen t to let the componen t do its p a r t — t h a t is, draw\neverythin g but the b o r d e r . Then B o r d e r : : D r aw draw s the borde r by c a l l i n g a privat e\noperatio n c a l l ed D r a w B o r d e r , the detail s of whic h we'll omit:\nvoid Border::Dra w ( W i n d o w* w) { \nMonoGlyph::Draw(w) ; \nD r a w B o r d e r ( w ) ;\n}\nNotic e how B o r d e r : : D r aw effectivel y extends the paren t c l a ss operatio n to draw the\nb o r d e r . T h is is in contras t to m e r e l y replacing t he paren t c l a ss operation , whic h woul d \nomit the c a ll to M o n o G l y p h : : D r a w . Anothe r M o n o G l y p h s u b c l a s s a p p e a r s in F i g u r e 2 . 7.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 205, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 811}}
{"id": "computer_science_design_patterns_gof_chunk_0206_83e79cb3", "text": "Anothe r M o n o G l y p h s u b c l a s s a p p e a r s in F i g u r e 2 . 7. S c r o l l e r is a M o n o G l y p h that\ndraw s its componen t in d i f f e r e n t location s based on the position s of two s c r o ll bars,\nw h i c h it a d ds as e m b e l l i s h m e n t s . When S c r o l l e r draw s i ts c o m p o n e n t , it t e l ls t he g r a p h -\nics syste m to c l ip to its bounds . Clippin g parts of the componen t t h at are s c r o l l e d out\nof v i ew k e e ps them from a p p e a r i n g on t he s c r e e n . Now we have all the p i e c e s we need to add a borde r and a s c r o l l i n g interfac e to Lexi' s\ntext e d i t i n g a r e a. We c o m p o s e t he e x i s t i n g C o m p o s i t i o n i n s t a n c e in a S c r o l l e r i n s t a n c e\nto add the s c r o l l i n g interface , and we compos e t h at in a Borde r instance . The resultin g\no b j e c t structure appears in Figure 2.8.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 206, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_design_patterns_gof_chunk_0207_0e376b99", "text": "The resultin g\no b j e c t structure appears in Figure 2.8. ptg4 6 A CASE STUDY- DESIGNING A D O C U M E N T E D I T O R CHAPTER 2\nF i g u r e 2 . 8 : E m b e l l i s h e d o b j e c t structure\n\nptgSECTION 2.5 SUPPORTING MULTIPLE LOOK-AND-FEEL STANDARDS 47\nNote that we can r e v e r s e the order of c o m p o s i t i o n , puttin g the bordere d compositio n\ninto the S c r o l l e r instance . In that c a se the borde r woul d be s c r o l l e d along with the text,\nwhic h may or may not be d e s i r a b l e . The point is, transparen t e n c l o s u r e make s it e a sy to\nexperimen t with differen t alternatives , and it k e e ps c l i e n t s free of e m b e l l i s h m e n t c o d e . Note a l so h ow t he borde r c o m p o s e s o ne g l y p h , n ot t wo or m o r e . T h is is unlik e c o m p o -\ns i t i o n s we'v e define d so far, in w h i c h paren t o b j e c t s w e re a l l o w e d to have arbitraril y\nmany c h i l d r e n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 207, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_design_patterns_gof_chunk_0208_29f6204a", "text": "T h is is unlik e c o m p o -\ns i t i o n s we'v e define d so far, in w h i c h paren t o b j e c t s w e re a l l o w e d to have arbitraril y\nmany c h i l d r e n . H e r e, puttin g a borde r aroun d somethin g i m p l i e s that \" s o m e t h i n g \" is\ns i n g u l a r . We c o u ld a s s i g n a meanin g to e m b e l l i s h i n g m o re than one o b j e c t at a t i m e, but\nthen we'd have to mix many kinds of c o m p o s i t i o n in with the notio n of e m b e l l i s h m e n t :\nrow e m b e l l i s h m e n t , c o l u m n e m b e l l i s h m e n t , and so f o r t h . That won' t help us, s i n ce we\nalread y have c l a s s e s to do those kinds of c o m p o s i t i o n s . So i t 's bette r to u se e x i s t i n g\nc l a s s e s for c o m p o s i t i o n and add new c l a s s e s to e m b e l l i s h the result .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 208, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 834}}
{"id": "computer_science_design_patterns_gof_chunk_0209_448c6cbf", "text": "So i t 's bette r to u se e x i s t i n g\nc l a s s e s for c o m p o s i t i o n and add new c l a s s e s to e m b e l l i s h the result . K eep in g e m b e l l -\ni s h m e n t independen t of other k i n ds of compositio n both s i m p l i f i e s the e m b e l l i s h m e n t\nc l a s s e s and r e d u c e s their n u m b e r . It a l so keeps us from r e p l i c a t i n g e x i s t i n g compositio n\nfunctionality. The Decorato r ( 1 7 5) patter n capture s c l a ss and o b j e c t relationship s t h at suppor t em-\nb e l l i s h m e n t by transparen t e n c l o s u r e . The term \" e m b e l l i s h m e n t \" actuall y has broade r\nmeanin g than what w e ' ve c o n s i d e r e d h e r e. In the Decorato r pattern , e m b e l l i s h m e n t\nrefers to anythin g that adds r e s p o n s i b i l i t i e s to an object .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 209, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 835}}
{"id": "computer_science_design_patterns_gof_chunk_0210_a605c474", "text": "In the Decorato r pattern , e m b e l l i s h m e n t\nrefers to anythin g that adds r e s p o n s i b i l i t i e s to an object . We can think for ex amp l e of\ne m b e l l i s h i n g an abstrac t synta x t r ee with semanti c a c t i o n s , a finite state automato n\nwith new transitions , or a networ k of persisten t o b j e c t s with attribut e tags. Decorato r\ng e n e r a l i z e s the approach we've used in Lexi to make i t more widely applicable. 2 . 5 Supporting Multiple L o o k - a n d - F e e l S t a n d a r d s\nA c h i e v i n g portabilit y a c r o s s hardwar e and softwar e platform s is a majo r p r o b l e m in\ns y s t e m d e s i g n . Retargetin g L e xi to a new p l a t f o r m shouldn' t r e q u i r e a majo r overhaul ,\nor it wouldn' t be worth retargeting . We s h o u l d make portin g as easy as p o s s i b l e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 210, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 849}}
{"id": "computer_science_design_patterns_gof_chunk_0211_957e74e2", "text": "Retargetin g L e xi to a new p l a t f o r m shouldn' t r e q u i r e a majo r overhaul ,\nor it wouldn' t be worth retargeting . We s h o u l d make portin g as easy as p o s s i b l e . O ne o b s t a c l e to portabilit y is t he diversit y of look-and-fee l standards , whic h a re i n -\nt e n d e d to enforc e uniformit y betwee n applications . T h e s e standard s defin e g u i d e l i n e s\nfor how a p p l i c a t i o n s appea r and r e a ct to the u s e r. W h i l e e x i s t i n g standard s aren' t that\ndifferen t from e a ch o t h e r , p e o p l e c e r t a i n l y won' t confus e one for the other—Moti f ap-\np l i c a t i o n s don't l o ok and feel exactl y l i ke their counterpart s on other platforms , and\nv i ce v e r s a . An applicatio n that runs on m o re than one platfor m must confor m to the\nu s er interfac e s t y le g u i de on e a ch platform.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 211, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 882}}
{"id": "computer_science_design_patterns_gof_chunk_0212_2530111c", "text": "An applicatio n that runs on m o re than one platfor m must confor m to the\nu s er interfac e s t y le g u i de on e a ch platform. Our d e s i g n g o a ls are to make L e xi confor m to multipl e e x i s t i n g look-and-fee l standard s\nand to make it easy to add s u p p o r t for new standards as they (invariably) emerge. W e\nDecorator Pattern\n\nptg48 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2\na l so want our d e s i g n to suppor t the ultimat e in flexibility : c h a n g i n g L e x i ' s l o ok and\nfeel at run-time. A b s t r a c t i n g Objec t C r e a t i o n\nEverythin g we s ee a nd interac t with in L e x i ' s u s er interfac e is a g l y ph c o m p o s e d in\no t h e r , i n v i s i b l e g l y p h s l i ke R ow a nd Column . T he i n v i s i b l e g l y p h s c o m p o s e v i s i b l e\no n es l i ke Butto n a nd Characte r a nd l ay them o ut p r o p e r l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 212, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_design_patterns_gof_chunk_0213_15f11b45", "text": "T he i n v i s i b l e g l y p h s c o m p o s e v i s i b l e\no n es l i ke Butto n a nd Characte r a nd l ay them o ut p r o p e r l y . S t y le g u i d e s have much\nto say abou t the l o ok and feel of s o - c a l l e d \" w i d g e t s , \" anothe r term for v i s i b l e g l y p h s\nl i ke buttons , s c r o ll bars, and menu s that act as c o n t r o l l i n g e l e m e n t s in a u s er interface . W i d g e t s m i g h t u se s i m p l e r g l y p h s s u ch as c h a r a c t e r s , c i r c l e s , r e c t a n g l e s , a nd p o l y g o n s\nto presen t data. W e ' ll assum e we have t wo s e ts of widge t g l y ph c l a s s e s with whic h to i m p l e m e n t\nmultipl e look-and-fee l standards:\n1. A s et of abstrac t Glyp h s u b c l a s s e s f or e a ch categor y of w i d g e t g l y p h .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 213, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 810}}
{"id": "computer_science_design_patterns_gof_chunk_0214_7b291dac", "text": "A s et of abstrac t Glyp h s u b c l a s s e s f or e a ch categor y of w i d g e t g l y p h . F or e x -\na m p l e , an abstrac t c l a ss S c r o l l B a r w i ll augmen t the b a s ic g l y ph interfac e to add\ngenera l s c r o l l i n g o p e r a t i o n s ; Butto n is an abstrac t c l a ss that adds button-oriente d \no p e r a t i o n s ; a nd so o n . 2. A set of c o n c r e t e s u b c l a s s e s for e a ch abstrac t s u b c l a s s that i m p l e m e n t differen t\nlook-and-fee l standards . F or e x a m p l e , S c r o l l B a r migh t have M o t if S c r o l l B a r a nd \nP M S c r o l l B a r s u b c l a s s e s that i m p l e m e n t M o t if a nd Presentatio n M a n a g e r - s t y l e\ns c r o ll b a r s, r e s p e c t i v e l y . L e xi must d i s t i n g u i s h betwee n widge t glyph s for differen t l o o k - a n d - f e e l s t y l e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 214, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 869}}
{"id": "computer_science_design_patterns_gof_chunk_0215_ee4bf845", "text": "L e xi must d i s t i n g u i s h betwee n widge t glyph s for differen t l o o k - a n d - f e e l s t y l e s . For\ne x a m p l e , when L e xi n e e ds to put a butto n in its interface , it must instantiat e a Glyp h\ns u b c l a s s for the right s t y le of butto n (MotifButton , P M B u t t o n , MacButton , e t c . ) . I t 's c l e ar that L e x i ' s implementatio n can't do t h is d i r e c t l y , s a y, using a constructo r c a ll\nin C++. T h at woul d har d- cod e the butto n of a particula r s t y l e, makin g it i m p o s s i b l e\nto s e l e ct the s t y le at run-time . W e 'd a l so have to track down and c h a n g e e v e ry s u ch\nconstructo r c a ll to port L e xi to anothe r platform . And button s are o n ly one of a v a r i e t y\nof widget s in L e x i ' s us er interface .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 215, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 807}}
{"id": "computer_science_design_patterns_gof_chunk_0216_be2158b6", "text": "And button s are o n ly one of a v a r i e t y\nof widget s in L e x i ' s us er interface . Litterin g o ur c o de with constructo r c a l ls to s p e c i f i c\nlook-and-fee l c l a s s e s y i e l d s a maintenanc e nightmare—mis s just o n e, and you c o u ld\nend up with a M o t if menu in the middl e of your Mac a p p l i c a t i o n . L e xi n e e ds a way to determin e the l o o k - a n d - f e e l standar d that's b e i ng targete d in o rder\nto creat e the appropriat e widgets . Not o n ly must we a v o id makin g e x p l i c i t c o n s t r u c t o r\nc a l l s; we must a l so be a b le to r e p l a c e an e n t i re widge t s et e a s i l y . We c an a c h i e v e both\nby abstracting the process of o b j e c t c r e a t i o n . An example will illustrate what we mean.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 216, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 786}}
{"id": "computer_science_design_patterns_gof_chunk_0217_45a5b6a6", "text": "We c an a c h i e v e both\nby abstracting the process of o b j e c t c r e a t i o n . An example will illustrate what we mean. ptgSECTION 2.5 SUPPORTING MULTIPLE LOOK-AND-FEEL STANDARDS 49\nFactorie s a nd P r o d u c t C l a s s e s\nNormall y we migh t creat e an i n s t a n c e of a Motif s c r o ll bar glyph with the followin g\nC ++ c o d e :\nS c r o l l B a r * sb = n ew M o t i f S c r o l l B a r ;\nT h is is t he k i nd of c o de to a v o id if y ou want to m i n i m i z e L e x i ' s look-and-fee l d e p e n -\nd e n c i e s . B ut suppos e we i n i t i a l i z e sb as follows:\nS c r o l l B a r * sb = g u i F a c t o r y - > C r e a t e S c r o l l B a r ( ) ;\nwher e g u i F a c t o r y is an i n s t a n c e of a MotifFactor y c l a s s. C r e a t e S c r o l l B a r return s\na new i n s t a n c e of t he prope r S c r o l l B a r s u b c l a s s for t he l o ok and feel d e s i r e d , M o t if in t h is\nc a s e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 217, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 934}}
{"id": "computer_science_design_patterns_gof_chunk_0218_581f5080", "text": "C r e a t e S c r o l l B a r return s\na new i n s t a n c e of t he prope r S c r o l l B a r s u b c l a s s for t he l o ok and feel d e s i r e d , M o t if in t h is\nc a s e. As far as c l i e n t s a re c o n c e r n e d , t he effec t is t he s a me as c a l l i n g t he M o t i f S c r o l l B a r \nconstructo r d i r e c t l y . But t h e r e ' s a c r u c i a l difference : T h e r e ' s no l o n g e r anythin g in the\nc o de that mention s Motif by name . The g u i F a c t o r y o b j e c t abstract s the p r o c e s s of\nc r e a t i n g not just M o t if s c r o ll bars but s c r o ll bars for any look-and-fee l standard . And\ng u i F a c t o r y i s n 't l i m i t e d to producin g s c r o ll bars. It can manufactur e a full r a n ge of\nwidge t g l y p h s , i n c l u d i n g s c r o ll bars, buttons , entry fields , menus , and so forth.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 218, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 862}}
{"id": "computer_science_design_patterns_gof_chunk_0219_d580b4f6", "text": "It can manufactur e a full r a n ge of\nwidge t g l y p h s , i n c l u d i n g s c r o ll bars, buttons , entry fields , menus , and so forth. A ll t h is is p o s s i b l e b e c a u s e MotifFactor y is a s u b c l a s s of G U I F a c t o r y , an a b s t r a c t c l a ss\nthat define s a g e n e r a l interfac e for c r e a t i n g widge t g l y p h s . It i n c l u d e s operation s l i ke\nC r e a t e S c r o l l B a r and C r e a t e B u t t o n for i n s t a n t i a t i n g differen t k i n ds of w i d g e t\ng l y p h s . S u b c l a s s e s of GUIFactor y i m p l e m e n t t h e se operation s to retur n g l y p h s s u ch\nas M o t i f S c r o l l B a r a nd P M B u t t o n that i m p l e m e n t a p a r t i c u l a r l o ok a nd f e e l. F i g u r e 2 .9\ns h o w s the r e s u l t i n g c l a ss hierarch y for g u i F a c t o r y o b j e c t s . We say that factorie s creat e produc t o b j e c t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 219, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 920}}
{"id": "computer_science_design_patterns_gof_chunk_0220_4670fdba", "text": "F i g u r e 2 .9\ns h o w s the r e s u l t i n g c l a ss hierarch y for g u i F a c t o r y o b j e c t s . We say that factorie s creat e produc t o b j e c t s . M o r e o v e r , the product s that a factor y\nproduce s are r e l a t e d to one another ; in t h is c a s e, the product s are all widget s for the\ns a me l o ok a nd feel. F i g u r e 2 . 10 s h o w s s o me of t he produc t c l a s s e s n e e d e d to make\nfactorie s work for widge t g l y p h s . The l a st q u e s t i o n we have to answe r is, Wher e d o es the G U I F a c t o r y i n s t a n c e c o me\nfrom ? T he a n s w e r i s, A n y w h e r e that's c o n v e n i e n t . T he v a r i a b l e g u i F a c t o r y c o u ld\nbe a g l o b a l , a static membe r of a w e l l - k n o w n c l a s s, or e v en a l o c al variabl e if the\ne n t i re u s er i n t e r f a c e is c r e a t e d w i t h i n o ne c l a ss or f u n c t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 220, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_design_patterns_gof_chunk_0221_bf5e4b0e", "text": "T h e r e ' s e v en a d e s i g n\npattern , S i n g l e t o n ( 1 2 7 ) , f or managin g w e l l - k n o w n , o n e - o f - a - k i n d o b j e c t s l i ke t h i s. T he\nimportan t t h i n g , t h o u g h , is to i n i t i a l i z e g u i F a c t o r y at a p o i nt in t he p r o g r a m before\nit's e v er used to creat e w i d g e t s but after i t 's c l e ar whic h l o ok and feel is d e s i r e d . If t he l o ok a nd feel is know n at c o m p i l e - t i m e , then g u i F a c t o r y c an be i n i t i a l i z e d w i th\na s i m p l e assignmen t of a new factor y i n s t a n c e at the b e g i n n i n g of the program:\nG U I F a c t o r y * g u i F a c t o r y = n ew M o t i f F a c t o r y ;\nIf the user can specif y the l o ok and feel with a string name at startu p t i m e, then the\nc o d e to create the factory might be\n\nptg5 0 A CASE STUDY- DESIGNING A D O C U M E N T E D I T O R CHAPTER 2\nF i g u r e 2 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 221, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 931}}
{"id": "computer_science_design_patterns_gof_chunk_0222_b0b2ec75", "text": "1 0 : A b s t r a c t p r o d u c t c l a s s e s and concrete subclasses\nFgure 2.9: GUFactory class hierarchy\n\nptgSECTION 2.6 SUPPORTING MULTIPLE WINDOW SYSTEMS 51\nGUIFactory * guiFactory ; \nc o n st c h a r* s t y l e N a me = getenv(\"LOOK_AND_FEEL\");\n// u s er or e n v i r o n m e n t supplies this at startup\nif (strcmp(styleName , \"Motif\") = =0) {\nguiFactor y = new MotifFactory;\n} else if (strcmp(styleName , \"Presentation_Manager\" ) == 0) {\nguiFactor y - new PMFactory;\n} else { \ng u i F a c t o r y = n ew D e f a u l t G U I F a c t o r y ;\n}\nT h e re are more sophisticate d ways to s e l e c t the factor y at run-time . For e x a m p l e , you\ncould maintai n a registr y that maps string s to factor y o b j e c t s . That l e ts you r e g i s t e r\ni n s t a n c e s of new factor y s u b c l a s s e s withou t modifyin g e x i s t i n g c o d e, as the p r e c e d i n g\napproac h requires . And you don't have to link all platform-specifi c factorie s into the\napplication .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 222, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_design_patterns_gof_chunk_0223_dd642fe5", "text": "And you don't have to link all platform-specifi c factorie s into the\napplication . That' s important , b e c a u s e it migh t not be p o s s i b l e to l i nk a MotifFactor y\non a p l a t f o r m t h at doesn' t suppor t Motif. But the point is that o n ce we've configure d the applicatio n with the right factor y\no b j e c t , its l o ok and feel is set f r om then on. If we chang e our m i n d s , we can r e i n i t i a l i z e\ng u i F a c t o r y with a f a c t o r y for a differen t l o ok and feel and then reconstruc t the\ninterface . Regardles s of how and when we d e c i d e to initializ e g u i F a c t o r y , we know\nt h at o n ce we do, the applicatio n can creat e the appropriat e l o ok and feel withou t\nmodification. A b s t r a c t F a c t o r y P a t t e r n\nF a c t o r i e s a nd p r o d u c t s a re t he k ey p a r t i c i p a n t s in t he Abs tr ac t F a c t o r y ( 8 7) pattern .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 223, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_design_patterns_gof_chunk_0224_ffbc4cdf", "text": "A b s t r a c t F a c t o r y P a t t e r n\nF a c t o r i e s a nd p r o d u c t s a re t he k ey p a r t i c i p a n t s in t he Abs tr ac t F a c t o r y ( 8 7) pattern . T h is\npatter n capture s how to creat e familie s of relate d produc t object s withou t instantiatin g\nc l a s s e s d i r e c t l y . It's most appropriat e when the numbe r and g e n e r a l kinds of produc t\nobject s stay constant , and there are difference s in s p e c i f i c produc t families . We c h o o s e\nbetwee n familie s by instantiatin g a particula r c o n c r e t e factor y and using it consistentl y\nto creat e product s thereafter . We can a l so swap entire familie s of product s by r e p l a c i n g\nthe concret e f a c t o r y with an instanc e of a differen t o n e. The Abstrac t Factor y pattern's\nemphasi s on families of product s d i s t i n g u i s h e s it from o t h er c r e a t i o n a l patterns , w h i c h\ninvolve only one kind of product o b j e c t . 2 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 224, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_design_patterns_gof_chunk_0225_8d873c8b", "text": "2 . 6 Supporting Multiple Window S y s t e m s\nL o ok and feel is j u st one of many portabilit y i s s u e s . Another is the windowin g en-\nvironmen t in whic h L e xi runs. A platform' s windo w syste m create s the i l l u s i o n of\nmultiple overlapping windows o n a bitmapped display. It manages screen space for\n\nptg52 A C A SE S T U D Y - DESIGNING A DOCUMENT EDITOR CHAPTER 2\nwindow s and route s input to them f r om the keyboar d and mouse . S e v e r a l importan t\nand l a r g e l y i n c o m p a t i b l e windo w s y s t e m s e x i st today ( e . g ., Macintosh , Presentatio n\nManager , Windows , X ). W e 'd l i ke L e xi to run on as many of them as p o s s i b l e for exactl y\nthe same reason s we suppor t multipl e look-and-fee l standards. C an We U se an A b s t r a c t F a c t o r y ? At first g l a n c e this may l o ok l i ke anothe r opportunit y to apply the Abstrac t Factor y\npattern .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 225, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 920}}
{"id": "computer_science_design_patterns_gof_chunk_0226_27158db3", "text": "C an We U se an A b s t r a c t F a c t o r y ? At first g l a n c e this may l o ok l i ke anothe r opportunit y to apply the Abstrac t Factor y\npattern . But the constraint s for windo w syste m portabilit y d i f f er significantl y f r om\nthose for look-and-fee l independence. In applyin g the Abstrac t Factor y pattern , we a s s u m e d we woul d defin e the c o n c r e t e\nwidge t glyph c l a s s e s for e a ch look-and-fee l standard . That mean t we c o u ld deriv e e a ch\nc o n c r e t e produc t for a particula r standar d ( e . g ., M o t i f S c r o l l B a r and M a c S c r o l l B a r ) f r om\nan abstrac t produc t c l a ss ( e . g ., S c r o l l B a r ) . B ut suppos e we alread y have s e v e r a l c l a ss\nh i e r a r c h i e s from differen t v e n d o r s , o ne f or e a ch l o o k - a n d - f e e l s t a n d a r d . Of c o u r s e , i t 's\nh i g h l y unlikel y these h i e r a r c h i e s are compatibl e in any w a y.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 226, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_design_patterns_gof_chunk_0227_5c792d20", "text": "Of c o u r s e , i t 's\nh i g h l y unlikel y these h i e r a r c h i e s are compatibl e in any w a y. H e n c e we won' t have a\ncommo n abstrac t produc t c l a ss for each kind of w i d g e t ( S c r o l l B a r , Button , Menu , etc.)—\nand the Abstrac t Factor y patter n won' t work withou t those c r u c i a l c l a s s e s . We have\nto make the differen t widge t h i e r a r c h i e s adher e to a commo n set of abstrac t produc t\ninterfaces . Only then c o u ld we d e c l a r e the C r e a t e . . . operation s properl y in our\nabstrac t factory' s interface. We s o l v e d this p r o b l e m f or widget s by developin g our own abstrac t and c o n c r e t e prod-\nuct c l a s s e s . Now we're faced with a s i m i l a r p r o b l e m when we try to make L e xi work\non e x i s t i n g windo w s y s t e m s ; n a m e l y , differen t w i n d o w s y s t e m s have incompatibl e\nprogrammin g interfaces .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 227, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_design_patterns_gof_chunk_0228_e4944e73", "text": "T h i n g s are a bit toughe r this t i m e, though , b e c a u s e we can't\naffor d to i m p l e m e n t o ur o wn nonstandar d w i n d o w s y s t e m . But there' s a s a v i n g grace . L i ke look-and-fee l standards , windo w syste m interface s\naren' t r a d i c a l l y differen t from o ne a n o t h e r , b e c a u s e a ll w i n d o w s y s t e m s do g e n e r a l l y\nthe same thing . We n e ed a unifor m set of windowin g abstraction s that lets us take\ndifferen t windo w s y s t e m implementation s and s l i de any one of them unde r a commo n\ninterface. E n c a p s u l a t i n g I m p l e m e n t a t i o n Dependencies\nIn S e c t i o n 2.2 we introduce d a W i n d o w c l a ss for d i s p l a y i n g a glyph or g l y ph structur e\non the d i s p l a y . We didn' t s p e c i f y the windo w s y s t e m that this o b j e c t worke d with,\nb e c a u s e the t r u th is that it doesn' t c o me from any particula r windo w s y s t e m .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 228, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_design_patterns_gof_chunk_0229_bd7f579e", "text": "We didn' t s p e c i f y the windo w s y s t e m that this o b j e c t worke d with,\nb e c a u s e the t r u th is that it doesn' t c o me from any particula r windo w s y s t e m . The\nW i n d o w class encapsulates the things windows tend to do across window systems:\n• T h e y p r o v i d e o p e r a t i o n s for drawing basic geometric shapes. • T h e y can i c o n i f y and de-iconify t h e m s e l v e s . ptgSECTION 2 . 6 SUPPORTING MULTIPLE WINDOW SYSTEMS 53\nR e s p o n s i b i l i t y\nw i n d o w m a n a g e m e n t\ng r a p h i c sO p e r a t i o ns\nvirtual \nvirtual \nvirtual \nvirtual \nvirtual\nvirtual\nvirtual\nvirtual\nvirtualvoid Redraw ()\nvoid Raise ()\nvoid L o w er ( )\nvoid I c o n i fy ( )\nvoid DeiconifyO\nvoid D r a w L i ne ( . . .)\nvoid D r a w R e ct (...) \nv o id D r a w P o l y g o n ( . . .)\nvoid DrawText ( . . . )\nT a b le 2 . 3: Windo w c l a ss interface\n• They can r e s i ze themselves.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 229, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_design_patterns_gof_chunk_0230_1bc72293", "text": ". .)\nvoid D r a w R e ct (...) \nv o id D r a w P o l y g o n ( . . .)\nvoid DrawText ( . . . )\nT a b le 2 . 3: Windo w c l a ss interface\n• They can r e s i ze themselves. • T h ey can (re)dra w their content s on demand , for example , when they are de-\niconifie d or when an overlappe d and obscure d portio n of their s c r e e n s p a ce is\nexposed. The Windo w c l a ss must span the functionalit y of window s from d i f f e r e n t windo w\nsystems . Let's conside r two extrem e philosophies:\n1. Intersection of functionality. T he Windo w c l a ss interfac e provide s only functionalit y\nthat's c o m m o n to a ll w i n d o w s y s t e m s . T he p r o b l e m with t h is a p p r o a c h is that o ur\nWindo w interfac e wind s up being only as powerfu l as the least capabl e windo w \nsystem . We can't take advantag e of more advance d feature s e v en if most (but not\nall) windo w system s suppor t them. 2. Union of functionality.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 230, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_design_patterns_gof_chunk_0231_c1945d5d", "text": "We can't take advantag e of more advance d feature s e v en if most (but not\nall) windo w system s suppor t them. 2. Union of functionality. C r e a t e an interfac e that i n c o r p o r a t e s the c a p a b i l i t i e s of all\nexistin g systems . The troubl e here is that the resultin g interfac e may w e ll be huge\nand incoherent . B e s i d e s , we'll have to chang e it (and L e x i, whic h depend s on it)\nanytim e a vendo r r e v i s e s its windo w syste m interface. N e i t h e r e x t r e m e is a v i a b l e s o l u t i o n , so o ur d e s i g n w i ll fall s o m e w h e r e betwee n t he\ntwo. The Windo w c l a ss w i ll provid e a convenien t interfac e that support s the most\npopula r w i n d o w i n g features . B e c a u s e L e xi w i ll d e al with t h is c l a ss d i r e c t l y , t he W i n d o w\nc l a ss must also suppor t the thing s L e xi know s about , n a m e l y , g l y p h s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 231, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_design_patterns_gof_chunk_0232_be878f17", "text": "B e c a u s e L e xi w i ll d e al with t h is c l a ss d i r e c t l y , t he W i n d o w\nc l a ss must also suppor t the thing s L e xi know s about , n a m e l y , g l y p h s . That mean s\nWindow' s interfac e must includ e a basic set of graphic s operation s that lets g l y p h s\ndraw themselve s in the window . T a b le 2.3 g i v es a samplin g of the operation s in the\nWindo w c l a ss interface. Windo w is an abstrac t c l a s s. C o n c r e t e s u b c l a s s e s of Windo w suppor t the d i f f e r e n t kinds\nof window s t h at users deal with. For example , applicatio n windows , i c o n s , and warnin g\nd i a l o g s are all windows , but they have somewha t differen t behaviors . So we can defin e\ns u b c l a s s e s l i k e A p p l i c a t i o n W i n d o w , Icon W i n d o w , and DialogWindow to capture these\n\nptg54 A C A SE S T U D Y - DESIGNING A DOCUMENT EDITOR CHAPTER 2\nd i f f e r e n c e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 232, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_design_patterns_gof_chunk_0233_6eedcf2f", "text": "T he r e s u l t i n g c l a ss h i e r a r c h y g i v es a p p l i c a t i o n s l i ke L e xi a unifor m a nd\nintuitiv e windowin g abstraction , one that doesn' t depen d on any particula r vendor' s\nwindow system:\nNow that we've define d a windo w interfac e for L e xi to work with, wher e d o es the\nr e al platform-specifi c windo w c o me in? If we're not implementin g our own windo w\ns y s t e m , then at s o me point our windo w abstractio n must be implemente d in terms of \nwhat the targe t windo w syste m provides . So wher e d o es that implementatio n l i v e ? O ne approac h is to implemen t multipl e v e r s i o n s of t he Windo w c l a ss a nd i ts s u b c l a s s e s ,\no ne v e r s i o n f or e a ch w i n d o w i n g platform . W e 'd h a ve to c h o o s e t he v e r s i o n to u se w h en\nwe b u i ld L e xi for a g i v en platform .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 233, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 863}}
{"id": "computer_science_design_patterns_gof_chunk_0234_2a4fbaab", "text": "W e 'd h a ve to c h o o s e t he v e r s i o n to u se w h en\nwe b u i ld L e xi for a g i v en platform . But imagin e the maintenanc e headache s we'd\nhave keep i n g track of multipl e c l a s s e s , all name d \" W i n d o w \" but each implemente d\non a differen t windo w s y s t e m . A l t e r n a t i v e l y , we c o u ld creat e implementation-specifi c\ns u b c l a s s e s of e a ch c l a ss in the Windo w hierarchy—an d end up with anothe r s u b c l a s s\ne x p l o s i o n p r o b l e m l i ke the one we had tryin g to add e m b e l l i s h m e n t s . Both of these\na l t e r n a t i v e s h a ve anothe r drawback : Neithe r g i v es us the flexibilit y to chang e the\nwindo w syste m we use a f t er we've c o m p i l e d the program . So we'll have to keep\ns e v e r a l differen t e x e c u t a b l e s aroun d as w e l l . Neithe r alternativ e is v e ry appealing , but w h at e l se can we do?", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 234, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_design_patterns_gof_chunk_0235_49e88ee0", "text": "So we'll have to keep\ns e v e r a l differen t e x e c u t a b l e s aroun d as w e l l . Neithe r alternativ e is v e ry appealing , but w h at e l se can we do? The same thing we\ndid for formattin g and e m b e l l i s h m e n t , n a m e l y , encapsulate the concept that varies. Wha t\nv a r i e s in t h is c a se is t he w i n d o w s y s t e m i m p l e m e n t a t i o n . If we e n c a p s u l a t e a w i n d o w\ns y s t e m ' s functionalit y in an object , then we can implemen t our Windo w c l a ss and\ns u b c l a s s e s in terms of that object' s interface . M o r e o v e r , if t h at interfac e can s e r ve all\nt he windo w system s we're i n t e r e s t e d i n, then we won' t have to c h a n g e W i n d o w or\nany of its s u b c l a s s e s to suppor t differen t windo w systems . We can configur e windo w\no b j e c t s to the windo w syste m we want s i m p l y by p a s s i n g them the right windo w\ns y s t e m - e n c a p s u l a t i n g o b j e c t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 235, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_design_patterns_gof_chunk_0236_d22abad7", "text": "We can configur e windo w\no b j e c t s to the windo w syste m we want s i m p l y by p a s s i n g them the right windo w\ns y s t e m - e n c a p s u l a t i n g o b j e c t . We can even configure t h e window at run-time. ptgSECTION 2 . 6 SUPPORTING M U L T I P L E WINDOW SYSTEMS 5 5\nWindo w a nd Windowlmp\nW e ' ll defin e a separat e Windowlm p c l a ss hierarch y in whic h to hide d i f f e r e n t windo w\nsyste m implementations . Windowlm p is an abstrac t c l a ss for o b j e c t s that encapsulat e\nwindo w system-dependen t c o d e. To make L e xi work on a particula r windo w s y s -\ntem, we configur e each windo w objec t with an instanc e of a Windowlm p s u b c l a s s for\nthat system .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 236, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 708}}
{"id": "computer_science_design_patterns_gof_chunk_0237_c185011b", "text": "To make L e xi work on a particula r windo w s y s -\ntem, we configur e each windo w objec t with an instanc e of a Windowlm p s u b c l a s s for\nthat system . The followin g diagra m show s the relationshi p betwee n the Windo w and\nWindowlmp hierarchies:\nBy hidin g the implementation s in Windowlm p c l a s s e s , we a v o id pollutin g the Windo w\nc l a s s e s with windo w syste m d e p e n d e n c i e s , whic h k e e ps the W i n d o w c l a ss hierarch y\ncomparativel y s m a ll and s t a b l e . Meanwhil e we can e a s i ly exten d the implementatio n\nhierarch y to suppor t new windo w systems. Windowlm p S u b c l a s s e s\nS u b c l a s s e s of W i n d o w l m p c o n v e r t r e q u e s t s i n to w i n d o w s y s t e m - s p e c i f i c o p e r a t i o n s . Conside r the exampl e we used in S e c t i o n 2 . 2.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 237, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 838}}
{"id": "computer_science_design_patterns_gof_chunk_0238_71d66e24", "text": "Conside r the exampl e we used in S e c t i o n 2 . 2. We define d the R e c t a n g l e : : D r aw in\nterms of the D r a w R e c t operatio n on the Windo w instance:\nvoid Rectangle::Dra w ( W i n d o w* w) {\nw->DrawRect(_xO , _yO, _xl, _yl);\n}\nThe defaul t implementatio n of D r a w R e c t uses the abstrac t operatio n for drawin g\nrectangle s declare d by Windowlmp:\nvoid Window::DrawRec t (\nC o o rd xO, C o o rd yO, C o o rd xl, C o o rd yl\n) {\n_imp->DeviceRect(xO , yO, xl, yl);\n}\n\nptg56 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2\nw h e r e _ i mp is a m e m b e r v a r i a b l e of W i n d o w t h at s t o r e s t he W i n d o w l m p with w h i c h t he\nW i n d o w is c o n f i g u r e d . T he w i n d o w i m p l e m e n t a t i o n is d e f i n e d by t he i n s t a n c e of t he\nW i n d o w l m p s u b c l a s s t h at _ i mp p o i n t s t o.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 238, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 871}}
{"id": "computer_science_design_patterns_gof_chunk_0239_216d1a9f", "text": "T he w i n d o w i m p l e m e n t a t i o n is d e f i n e d by t he i n s t a n c e of t he\nW i n d o w l m p s u b c l a s s t h at _ i mp p o i n t s t o. F or an X W i n d o w I m p ( t h at i s, a W i n d o w l m p\ns u b c l a s s f or t he X W i n d o w S y s t e m ) , t he D e v i c e R e c t ' s i m p l e m e n t a t i o n m i g h t l o ok\nl i k e\nvoid X W i n d o w I m p : : D e v i c e R e c t ( \nC o o r d x O, Coor d y O, C o o r d x l, C o o r d y l\n) {\ni nt x = r o u n d ( m i n ( x O , x l )) ; \ni nt y = r o u n d ( m i n ( y O , y l ) ) ; \ni nt w = r o u n d ( a b s ( x O - x l )) ; \ni nt h = r o u n d ( a b s ( y O - y l) ) ;\nX D r a w R e c t a n g l e ( _ d p y , _ w i n i d , _ g c, x, y, w, h) ;\n}\nD e v i c e R e c t is d e f i n e d l i ke t h is b e c a u s e X D r a w R e c t a n g l e ( t he X i n t e r f a c e for d r a w -\ni ng a r e c t a n g l e ) d e f i n e s a r e c t a n g l e in t e r m s of i ts l o w e r left c o r n e r , i ts w i d t h , a nd i ts\nh e i g h t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 239, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1013}}
{"id": "computer_science_design_patterns_gof_chunk_0240_d479dff9", "text": "D e v i c e R e c t m u st c o m p u t e t h e se v a l u e s f r om t h o se s u p p l i e d . F i r st it a s c e r t a i n s\nt he l o w e r left c o r n e r ( s i n c e ( x O, y O) m i g h t be a ny o ne of t he r e c t a n g l e ' s f o ur c o r n e r s )\na nd t h en c a l c u l a t e s t he widt h a nd h e i g h t . P M W i n d o w I m p (a s u b c l a s s of W i n d o w l m p f or P r e s e n t a t i o n M a n a g e r ) w o u l d d e f i n e\nD e v i c e R e c t differently:\nvoid PMWindowImp::DeviceRec t (\nCoord xO, Coord yO, Coord xl, Coord yl\n) {\nCoord left = m i n f x O, xl);\nCoord right = max(xO, xl);\nCoord bottom = min(yO, yl);\nCoord top = max(yO, yl);\nP P O I N TL point[4];\npoint[0]. x = left; point[0]. y = top;\npoint[l]. x = right; point[1]. y = top;\npoint[2]. x = right; point[2]. y = bottom;\npoint[3]. x = left; point[3].", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 240, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 845}}
{"id": "computer_science_design_patterns_gof_chunk_0241_a4085672", "text": "x = left; point[0]. y = top;\npoint[l]. x = right; point[1]. y = top;\npoint[2]. x = right; point[2]. y = bottom;\npoint[3]. x = left; point[3]. y = bottom;\nif ( \n(GpiBeginPath(_hps , 1L) == false) I I\n(GpiSetCurrentPosition(_hps , &point[3] ) == false) II\n(GpiPolyLine(_hps , 4 L, point) == GPI_ERROR ) I I\n( G p i E n d P a t h ( _ h p s ) == false)\n) { \n// r e p o rt e r r o r\n} else {\nG p i S t r o k e P a t h ( _ h p s , 1L, OL);\n}\n}\n\nptgSECTION 2.6 SUPPORTING MULTIPLE WINDOW SYSTEMS 57\nWhy is this so differen t from the X v e r s i o n ? W e l l, PM doesn' t have an o p e r a t i o n for\ndrawin g r e c t a n g l e s e x p l i c i t l y as X d o e s. Instead , PM has a m o re genera l interfac e for\ns p e c i f y i n g v e r t i c e s of m u l t i s e g m e n t s h a p e s ( c a l l e d a path) a nd f or o u t l i n i n g or f i l l i ng\nt he a r ea they e n c l o s e . P M 's implementatio n of D e v i c e R e c t is o b v i o u s l y quite differen t from X ' s, but that\ndoesn' t matter .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 241, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_design_patterns_gof_chunk_0242_437ba482", "text": "P M 's implementatio n of D e v i c e R e c t is o b v i o u s l y quite differen t from X ' s, but that\ndoesn' t matter . Windowlm p h i d es variation s in windo w s y s t e m interface s behin d a\npotentiall y l a r ge but s t a b le interface . That l e ts W i n d o w s u b c l a s s writer s focus on the\nwindo w abstractio n and not on windo w s y s t e m details . It a l so l e ts us add suppor t for\nnew windo w system s withou t disturbin g the Windo w c l a s s e s . C o n f i g u r i n g W i n d o w s w i th W i n d o w l m p s\nA k ey i s s ue we h a v e n ' t a d d r e s s e d is h ow a w i n d o w g e ts c o n f i g u r e d w i th t he p r o p e r\nW i n d o w l m p s u b c l a s s in t he first p l a c e . S t a t e d a n o t h e r w a y, w h en d o es _ i mp g et i n i -\nt i a l i z e d , a nd w ho k n o w s what w i n d o w s y s t e m ( a nd c o n s e q u e n t l y w h i c h W i n d o w l m p\ns u b c l a s s ) is in u s e?", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 242, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_design_patterns_gof_chunk_0243_2c7f152b", "text": "T he w i n d o w w i ll n e ed s o me k i nd of W i n d o w l m p bef or e it c an do\na n y t h i n g i n t e r e s t i n g . T h e re a re s e v e r a l p o s s i b i l i t i e s , b ut w e ' ll focus on o ne that u s es t he Abstrac t F a c t o r y ( 8 7)\npattern . We can defin e an abstrac t factor y c l a ss W i n d o w S y s t e m F a c t o r y that p r o v i d e s\nan interfac e f or c r e a t i n g differen t k i n ds of windo w system-dependen t i m p l e m e n t a t i o n\no b j e c t s :\nc l a s s W i n d o w S y s t e m F a c t o r y {\np u b l i c :\nv i r t u a l W i n d o w l m p * C r e a t e W i n d o w I m p ( ) = 0;\nv i r t u a l C o l o r l m p * C r e a t e C o l o r l m p ( ) = 0; \nv i r t u a l F o n t l m p * C r e a t e F o n t l m p ( ) = 0 ;\n// a \" C r e a t e . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 243, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 798}}
{"id": "computer_science_design_patterns_gof_chunk_0244_7613846a", "text": ". . \" o p e r a t i o n f or a ll windo w syste m r e s o u r c e s\n} ;\nNow we can defin e a c o n c r e t e factor y for e a ch windo w system:\nc l a s s P M W i n d o w S y s t e m F a c t o r y : p u b l i c W i n d o w S y s t e m F a c t o r y {\nv i r t u a l W i n d o w l m p * C r e a t e W i n d o w I m p ( ) \n{ r e t u r n n ew P M W i n d o w I m p ; } \n// . . . } ;\nc l a ss X W i n d o w S y s t e m F a c t o r y : public WindowSystemFactor y {\nvirtual Wi nd owlmp * C r e a t e W i n d o w I m p ( )\n{ r e t u rn new X W i n d o w I m p ; }\n// . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 244, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 565}}
{"id": "computer_science_design_patterns_gof_chunk_0245_9d5ae4f4", "text": ". . } ;\nc l a ss X W i n d o w S y s t e m F a c t o r y : public WindowSystemFactor y {\nvirtual Wi nd owlmp * C r e a t e W i n d o w I m p ( )\n{ r e t u rn new X W i n d o w I m p ; }\n// . . . } ;\nThe W i n d o w b a se c l a ss constructo r can use the W i n d o w S y s t e m F a c t o r y interfac e to\ni n i t i a l i z e the _imp member with the Windowlmp that's right for the window system:\n\nptg58 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2\nW i n d o w : : W i n d o w ( ) {\n_ i mp = w i n d o w S y s t e m F a c t o r y - > C r e a t e W i n d o w I m p ( ) ;\n}\nThe w i n d o w S y s t e m F a c t o r y v a r i a b l e is a well-know n instanc e of a W i n d o w S y s t e m -\nFactor y s u b c l a s s , akin to the well-know n g u i F a c t o r y variabl e definin g the l o ok and\nfeel. The w i n d o w S y s t e m F a c t o r y variabl e can be initialize d in the same w a y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 245, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 900}}
{"id": "computer_science_design_patterns_gof_chunk_0246_b452e65b", "text": "The w i n d o w S y s t e m F a c t o r y variabl e can be initialize d in the same w a y . B r i d g e P a t t e r n\nThe Windowlm p c l a ss define s an interfac e to commo n windo w syste m f a c i l i t i e s , but\ni ts d e s i g n is d r i v e n by differen t c o n s t r a i n t s than W i n d o w ' s i n t e r f a c e . A p p l i c a t i o n p r o -\ngrammer s won' t deal with Windowimp' s interfac e d i r e c t l y ; they o n ly deal with W i n -\nd ow o b j e c t s . So Windowlmp' s interfac e needn' t matc h t he a p p l i c a t i o n programmer' s\nv i ew of the w o r l d , as was our concer n in the d e s i g n of the W i n d o w c l a ss hierarch y\nand interface . Windowlmp' s interfac e can more c l o s e l y reflec t what windo w system s\na c t u a l l y p r o v i d e , warts a nd a l l. It c an be b i a s e d towar d e i t h er an i n t e r s e c t i o n or a u n i on\nof functionalit y approach , whicheve r suits the targe t windo w system s best.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 246, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_design_patterns_gof_chunk_0247_390e6f41", "text": "It c an be b i a s e d towar d e i t h er an i n t e r s e c t i o n or a u n i on\nof functionalit y approach , whicheve r suits the targe t windo w system s best. The importan t thing to realiz e is that Window' s interfac e cater s to the application s\np r o g r a m m e r , w h i le Windowlm p c a t e rs to w i n d o w s y s t e m s . S e p a r a t i n g w i n d o w i n g\nfunctionalit y into Windo w and Windowlm p h i e r a r c h i e s l e ts us implemen t and s p e c i a l -\ni ze these interface s i n d e p e n d e n t l y . O b j e c t s from t h e se h i e r a r c h i e s cooperat e to l et L e xi \nwork withou t modificatio n on multipl e windo w systems. T he relationshi p betwee n Windo w a nd Windowlm p is an exampl e of t he B r i d g e ( 1 5 1)\npattern . T he inten t b e h i n d B r i d g e is to a l l ow separat e c l a ss h i e r a r c h i e s to work togethe r\ne v en as they e v o l v e independently .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 247, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_design_patterns_gof_chunk_0248_627b2e45", "text": "T he inten t b e h i n d B r i d g e is to a l l ow separat e c l a ss h i e r a r c h i e s to work togethe r\ne v en as they e v o l v e independently . Our d e s i g n c r i t e r i a led us to creat e two separat e\nc l a ss h i e r a r c h i e s , one that support s the l o g i c a l notio n of w i n d o w s , and anothe r for\nc a p t u r i n g differen t i m p l e m e n t a t i o n s of w i n d o w s . T he B r i d g e patter n l e ts us m a i n t a i n\nand e n h a n c e our logical windowing abstractions without touching window system-\ndependent code, and vice versa. 2 . 7 User Operations\nS o me of L e x i ' s functionalit y is availabl e throug h t he document' s W Y S I W Y G r e p r e s e n -\nt a t i o n . Y ou enter a nd d e l e te t e x t, move t he i n s e r t i o n point , a nd s e l e ct range s of text by\np o i n t i n g , c l i c k i n g , a nd typin g d i r e c t l y in t he document .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 248, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_design_patterns_gof_chunk_0249_48852655", "text": "Y ou enter a nd d e l e te t e x t, move t he i n s e r t i o n point , a nd s e l e ct range s of text by\np o i n t i n g , c l i c k i n g , a nd typin g d i r e c t l y in t he document . Othe r functionalit y is a c c e s s e d \ni n d i r e c t l y throug h user operation s in L e x i ' s pull-dow n menus , buttons , and keyboar d\na c c e l e r a t o r s . The functionality includes operations for\n• c r e a t i n g a new document,\n• o p e n i n g , s a v i n g , and printing an existing document,\n\nptgSECTION 2.7 USER OPERATIONS 59\n• cuttin g s e l e c t e d text out of the documen t and pastin g it back i n ,\n• changin g the font and style of s e l e c t e d text,\n• c h a n g i n g the f o r m a t t i n g of text, such as its alignmen t and justification,\n• quittin g the application,\n• and on and on. L e xi provide s differen t u s er interface s for these operations .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 249, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 885}}
{"id": "computer_science_design_patterns_gof_chunk_0250_b63c7b96", "text": "L e xi provide s differen t u s er interface s for these operations . But we don't want to\na s s o c i a t e a particula r u s er o p e r a t i o n w i th a particula r u s er i n t e r f a c e , b e c a u s e we m ay\nwant multipl e u s er interface s to the same operatio n (you can turn the page using e i t h e r\na page butto n or a menu operation , for example) . We may a l so want to c h a n g e the\ninterfac e in the f u t u r e . Furthermore , t h e se operation s are implemente d in many differen t c l a s s e s . We as i m p l e -\nmentor s want to a c c e s s their functionalit y withou t creatin g a lot of d e p e n d e n c i e s be-\ntwee n implementatio n and u ser interfac e c l a s s e s . Otherwis e we'll end up with a tightl y\nc o u p l e d i m p l e m e n t a t i o n , w h i ch w i ll be h a r d e r to u n d e r s t a n d , e x t e n d , a nd m a i n t a i n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 250, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 885}}
{"id": "computer_science_design_patterns_gof_chunk_0251_ace73fa5", "text": "Otherwis e we'll end up with a tightl y\nc o u p l e d i m p l e m e n t a t i o n , w h i ch w i ll be h a r d e r to u n d e r s t a n d , e x t e n d , a nd m a i n t a i n . To f u r t h e r complicat e matters , we want L e xi to suppor t undo and r e d o 8 of m o st but\nn ot a ll i ts f u n c t i o n a l i t y . S p e c i f i c a l l y , we want to be a b le to undo d o c u m e n t - m o d i f y i n g\noperation s l i ke d e l e t e , with whic h a user can destro y lots of data inadvertently . But we\nshouldn' t try to undo an operatio n l i ke s a v i n g a drawin g or quittin g the application . T h e se operation s s h o u l d have no e f f e c t on the undo p r o c e s s . We a l so don't want an\narbitrar y l i m it on the numbe r of l e v e ls of undo and redo. It's c l e ar that suppor t for user operation s permeate s the application . The c h a l l e n g e is\nto c o me up with a s i m p l e and e x t e n s i b l e m e c h a n i s m that satisfie s all of t h e se n e e d s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 251, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_design_patterns_gof_chunk_0252_b57a006f", "text": "The c h a l l e n g e is\nto c o me up with a s i m p l e and e x t e n s i b l e m e c h a n i s m that satisfie s all of t h e se n e e d s . Encapsulatin g a Request\nF r om our perspectiv e as d e s i g n e r s , a pull-dow n menu is j u st anothe r k i nd of g l y ph that\ncontain s other g l y p h s . Wha t d i s t i n g u i s h e s pull-dow n menu s from other g l y p h s that\nhave c h i l d r e n is that most g l y p h s in menu s do s o me work in r e s p o n s e to an u p - c l i c k . Let's assum e that t h e se work-performin g g l y p h s are instance s of a G l y p h s u b c l a s s\nc a l l ed Menulte m and that they do their work in r e s p o n s e to a reques t f r om a c l i e n t . 9\nCarryin g out the reques t migh t i n v o l v e an operatio n on one object , or many operation s\non many o b j e c t s , or s o m e t h i n g in b e t w e e n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 252, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 869}}
{"id": "computer_science_design_patterns_gof_chunk_0253_0edb4675", "text": "9\nCarryin g out the reques t migh t i n v o l v e an operatio n on one object , or many operation s\non many o b j e c t s , or s o m e t h i n g in b e t w e e n . We could defin e a s u b c l a s s of Menulte m for every us er operatio n and then hard-cod e\ne a ch s u b c l a s s to c a r ry o ut t he r e q u e s t . B ut that's n ot r e a l ly r i g h t; we d o n 't n e ed a\ns u b c l a s s of Menulte m for e a ch reques t any more than we n e ed a s u b c l a s s for each text\n8 That is, redoin g an operatio n that was j u st undone. 9 Conceptually , the clien t is L e x i ' s u s e r, but in realit y it's anothe r objec t (such as an event dispatcher ) that\nmanages inputs from t h e user. ptg60 A C A SE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2\ns t r i ng in a p u l l - d o w n menu . M o r e o v e r , t h is approac h c o u p l e s the r e q u e s t to a particula r\nuser interface , makin g it hard to f u l f i l l the reques t throug h a differen t u s er interface.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 253, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_design_patterns_gof_chunk_0254_7181bbac", "text": "M o r e o v e r , t h is approac h c o u p l e s the r e q u e s t to a particula r\nuser interface , makin g it hard to f u l f i l l the reques t throug h a differen t u s er interface. To illustrate , suppos e you c o u ld advanc e to the last page in the documen t both throug h\na Menulte m in a pull-dow n menu and by p r e s s i n g a page i c on at the botto m of L e x i ' s\ninterfac e ( w h i c h m i g h t be m o re c o n v e n i e n t f or s h o rt d o c u m e n t s ) . If we a s s o c i a t e t he\nreques t with a Menulte m throug h inheritance , then we must do the same for the page\ni c on and any other kind of widge t t h at migh t i s s ue s u ch a request . That can g i ve rise\nto a numbe r of c l a s s e s approachin g the produc t of the numbe r of widge t types and the\nnumbe r of requests. What' s m i s s i n g is a mechanis m that lets us parameteriz e menu i t e ms by the reques t\nthey shoul d fulfill .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 254, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 931}}
{"id": "computer_science_design_patterns_gof_chunk_0255_b0bda60a", "text": "What' s m i s s i n g is a mechanis m that lets us parameteriz e menu i t e ms by the reques t\nthey shoul d fulfill . That way we avoid a proliferatio n of s u b c l a s s e s and a l l ow for greate r\nflexibilit y at run-time . We could parameteriz e Menulte m with a functio n to c a l l, but\nthat's not a complet e solutio n for at least three reasons:\n1. It doesn' t addres s t he u n d o / r e d o problem. 2. It's hard to associat e state with a function . For example , a functio n t h at change s\nthe f o nt n e e ds to know which f o n t . 3. Function s are hard to extend , and it's hard to reuse parts of them. T h e s e r e a s o n s s u g g e s t t h at we shoul d parameteriz e Menultem s with an object, not a\nfunction . T h en we c an use inheritanc e to exten d and r e u se the request' s implementation . We also have a place to store state and implemen t u n d o / r e d o functionality .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 255, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 908}}
{"id": "computer_science_design_patterns_gof_chunk_0256_4d0d4050", "text": "T h en we c an use inheritanc e to exten d and r e u se the request' s implementation . We also have a place to store state and implemen t u n d o / r e d o functionality . H e re we \nhave anothe r exampl e of encapsulatin g the c o n c e p t that v a r i e s , in this c a se a request . W e ' ll encapsulat e e a ch r e q u e s t in a c o m m a n d o b j e c t . C o m m a n d C l a ss a nd S u b c l a s s e s\nF i r st we defin e a C o m m a n d abstrac t c l a ss to provid e an interfac e for i s s u i n g a request . T he b a s ic interfac e c o n s i s t s of a s i n g le abstrac t operatio n c a l l ed \" E x e c u t e . \" S u b c l a s s e s\nof C o m m a n d i m p l e m e n t E x e c u t e in differen t ways to fulfil l differen t r e q u e s t s . S o me\ns u b c l a s s e s may delegat e part or all of the work to other objects . Othe r s u b c l a s s e s may be\nin a positio n to fulfil l t he reques t entirel y on their o wn ( s ee F i g u r e 2 . 1 1 ).", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 256, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_design_patterns_gof_chunk_0257_185228a1", "text": "Othe r s u b c l a s s e s may be\nin a positio n to fulfil l t he reques t entirel y on their o wn ( s ee F i g u r e 2 . 1 1 ). To t he r e q u e s t e r ,\nhowever , a Comman d objec t is a Comman d object—the y are treate d uniformly. N ow M e n u l t e m c an s t o re a C o m m a n d o b j e c t that e n c a p s u l a t e s a r e q u e s t ( F i g u r e 2 . 1 2 ). We g i ve each menu item o b j e c t an instanc e of the Comman d s u b c l a s s that's suitabl e\nfor that menu item, just as we specif y the text to appea r in the menu i t e m. Whe n a u s er\nc h o o s e s a particula r menu i t e m, the Menulte m simpl y c a l ls Execut e on its Comman d\no b j e c t to carry out the request . Note that b u t t o n s and other widget s can use command s\nin the same way menu items do. ptgSECTION 2 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 257, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 808}}
{"id": "computer_science_design_patterns_gof_chunk_0258_c9ea98c5", "text": "Note that b u t t o n s and other widget s can use command s\nin the same way menu items do. ptgSECTION 2 . 7 USER O P E R A T I O N S 61\nF i g u r e 2.11: Partial Command class hierarchy\nF i g u r e 2.12: Menultem-Command r e l a t i o n s h i p\n\nptg62 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2\nUndoability\nU n d o / r e d o is an importan t capabilit y in interactiv e applications . To undo and r e do\ncommands , we add an Unexecut e operatio n to Command' s interface . Unexecut e re-\nv e r s e s the effect s of a p r e c e d i n g Execut e operatio n using whateve r undo informatio n\nExecut e s t o r e d . In the c a se of a FontCommand , for example , the Execut e operatio n\nwoul d store the range of text a f f e c t e d by the f o nt chang e along with the o r i g i n a l font(s) . FontCommand' s Unexecut e operatio n woul d restor e the range of text to its o r i g i n a l\nfont(s). S o m e t i m e s undoabilit y must be determine d at run-time .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 258, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_design_patterns_gof_chunk_0259_bda636b0", "text": "FontCommand' s Unexecut e operatio n woul d restor e the range of text to its o r i g i n a l\nfont(s). S o m e t i m e s undoabilit y must be determine d at run-time . A r e q u e s t to chang e the f o nt\nof a s e l e c t i o n d o es nothin g if the text alread y appear s in that f o n t. S u p p o s e the u s er\ns e l e c t s s o me t e xt a nd t h en r e q u e s t s a s p u r i o u s font c h a n g e . Wha t s h o u l d be t he r e s u l t\nof a s u b s e q u e n t undo request ? S h o u l d a m e a n i n g l e s s chang e c a u se the undo r e q u e s t to\ndo somethin g e q u a l l y m e a n i n g l e s s ? P r o b a b l y not. If the u s er repeat s the spuriou s f o nt\nchang e s e v e r a l t i m e s , he shouldn' t have to perfor m e x a c t l y the same numbe r of undo\noperation s to get back to the last meaningfu l operation . If the net effec t of executin g a\ncomman d was nothing , then there' s no n e ed for a c o r r e s p o n d i n g undo request.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 259, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_design_patterns_gof_chunk_0260_83d17141", "text": "If the net effec t of executin g a\ncomman d was nothing , then there' s no n e ed for a c o r r e s p o n d i n g undo request. So to determin e if a comman d is undoable , we a dd an abstrac t R e v e r s i b l e operatio n\nto the Comman d interface . R e v e r s i b l e return s a B o o l e a n value . S u b c l a s s e s can redefin e\nthis operatio n to retur n true or false b a s ed on run-tim e criteria. C o m m a n d H i s t o r y\nThe final s t ep in supportin g arbitrary-leve l undo and redo is to defin e a c o m m a n d\nh i s t o r y , or l i st of command s that have b e en execute d ( or unexecuted , if s o me command s\nhave been undone). Conceptually, the command history looks like this:\nEach c i r c le represent s a Comman d object . In this c a se the u s er has i s s u e d f o ur c o m -\nmands . The leftmos t comman d was i s s u e d first, followe d by the second-leftmost , and\nso on until the m o st recentl y i s s u e d command , whic h is rightmost .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 260, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_design_patterns_gof_chunk_0261_7f724bd1", "text": "The leftmos t comman d was i s s u e d first, followe d by the second-leftmost , and\nso on until the m o st recentl y i s s u e d command , whic h is rightmost . The l i ne marke d\n\" p r e s e n t \" keeps track of the most recently executed (and unexecuted) command. T o undo the last command, we simply call Unexecute on the most recent command:\n\nptgSECTION 2 . 7 USER OPERATIONS 6 3\nA f t er unexecutin g the command , we move the \" p r e s e n t \" l i ne one comman d to the left. If the user c h o o s e s undo again , the next-mos t recentl y i s s u e d comman d w i ll be undon e\nin the same way, a n d we're left in the state depicted here:\nY ou c an s ee that by s i m p l y repeatin g this procedur e we g et multipl e l e v e ls of undo . T he numbe r of l e v e ls is l i m i t e d o n ly by t he lengt h of t he comman d h i s t o r y . To redo a comman d that's just been undone , we do the same thing in r e v e r s e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 261, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 934}}
{"id": "computer_science_design_patterns_gof_chunk_0262_9eed622f", "text": "T he numbe r of l e v e ls is l i m i t e d o n ly by t he lengt h of t he comman d h i s t o r y . To redo a comman d that's just been undone , we do the same thing in r e v e r s e . C o m -\nmand s to the right of the presen t l i ne are command s that may be redon e in the f u t u r e . To redo the last undon e command , we c a ll Execut e on the comman d to the right of the\npresent line:\nT h en we advanc e the presen t l i ne so that a s u b s e q u e n t r e do w i ll c a ll r e do on the\nfollowing command in the f u t u r e . ptg64 A CASE STUDY: D E S I G N I N G A D O C U M E N T E D I T O R CHAPTER 2\nOf c o u r s e , if t he s u b s e q u e n t operatio n is n ot anothe r r e do b ut an undo , then t he\ncomman d to t he left of t he p r e s e n t l i ne w i ll be undone . T h us t he user c an effectivel y go\nback and f o r th in time as neede d to r e c o v e r from e r r o r s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 262, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_design_patterns_gof_chunk_0263_59e118b2", "text": "T h us t he user c an effectivel y go\nback and f o r th in time as neede d to r e c o v e r from e r r o r s . C o m m a n d P a t t e r n\nL e x i ' s command s are an applicatio n of the Comman d ( 2 3 3) pattern , whic h d e s c r i b e s\nhow to encapsulat e a r e q u e s t . The Comman d patter n p r e s c r i b e s a unifor m interfac e\nfor i s s u i n g r e q u e s t s that l e ts you configur e c l i e n t s to handl e differen t r e q u e s t s . The\ninterfac e s h i e l d s c l i e n t s from the r e q u e s t ' s implementation . A comman d may delegat e \na l l, part, or none of the r e q u e s t ' s implementatio n to other o b j e c t s . T h is is perfec t for\napplication s l i ke L e xi that must provid e centralize d a c c e s s to functionalit y scattere d\nthroughou t the a p p l i c a t i o n . The patter n a l so d i s c u s s e s undo and redo m e c h a n i s m s\nbuilt on the basic Command interface. 2 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 263, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_design_patterns_gof_chunk_0264_11254f7a", "text": "The patter n a l so d i s c u s s e s undo and redo m e c h a n i s m s\nbuilt on the basic Command interface. 2 . 8 Spelling Checking and Hyphenation\nT he l a st d e s i g n proble m i n v o l v e s textua l a n a l y s i s , s p e c i f i c a l l y c h e c k i n g for m i s s p e l l i n g s\na nd i n t r o d u c i n g h y p h e n a t i o n p o i n t s w h e r e n e e d e d f or g o od formatting. The constraint s here are s i m i l a r to those we had for the formattin g d e s i g n p r o b l e m in\nS e c t i o n 2 . 3. As w as t he c a se f or l i n e b r e a k i n g s t r a t e g i e s , t h e r e ' s m o re than o ne w ay to\nc h e ck s p e l l i n g and comput e hyphenatio n p o i n t s . So h e re too we want to suppor t multi-\np le a l g o r i t h m s . A d i v e r s e s et of algorithm s c an p r o v i d e a c h o i c e of space/time/qualit y\ntrade-offs . We s h o u l d make it e a sy to add new algorithm s as w e l l .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 264, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_design_patterns_gof_chunk_0265_e8192824", "text": "A d i v e r s e s et of algorithm s c an p r o v i d e a c h o i c e of space/time/qualit y\ntrade-offs . We s h o u l d make it e a sy to add new algorithm s as w e l l . We a l so want to a v o id wirin g this functionalit y into t he documen t structure . T h is g o al is\ne v en more importan t h e re than it was in the formattin g c a s e, becaus e s p e l l i n g c h e c k i n g\nand hyphenation are just two of potentiall y many kinds of analyse s we may w a nt\nL e xi to support . Inevitabl y w e ' ll want to expan d L e x i ' s analytica l a b i l i t i e s o v er time. We migh t add s e a r c h i n g , w o rd counting , a calculatio n facilit y for addin g up tabula r\nv a l u e s , gramma r c h e c k i n g , and so f o r t h . But we don't want to c h a n g e the G l y p h c l a ss\na n d a l l i t s subclasses every time we introduce new functionality of this sort.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 265, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 882}}
{"id": "computer_science_design_patterns_gof_chunk_0266_4165fc1d", "text": "But we don't want to c h a n g e the G l y p h c l a ss\na n d a l l i t s subclasses every time we introduce new functionality of this sort. ptgSECTION 2.8 SPELLING CHECKING AND HYPHENATION 65\nT h e re are actuall y two p i e c e s to this puzzle : ( 1) a c c e s s i n g the informatio n to be analyzed ,\nwhic h we have scattere d o v er the g l y p h s in the documen t structure , and (2) doing the\nanalysis . W e ' ll l o ok at these two p i e c e s separately. Accessin g S c a t t e r e d Information\nMany kinds of a n a l y s i s r e q u i r e examinin g the text characte r by character . The text we\nn e ed to analyz e is scattere d throughou t a hierarchica l structur e of glyph objects . To\nexamin e text in such a structure , we n e ed an a c c e s s mechanis m that has knowledg e\nabou t the data structure s in whic h object s are stored .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 266, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 854}}
{"id": "computer_science_design_patterns_gof_chunk_0267_a0028839", "text": "To\nexamin e text in such a structure , we n e ed an a c c e s s mechanis m that has knowledg e\nabou t the data structure s in whic h object s are stored . S o me glyph s migh t store their\nc h i l d r e n in l i n k e d l i s t s, other s m i g h t u se arrays , a nd s t i ll other s m i g h t u se more e s o t e r i c\ndata structures . Our a c c e s s mechanis m must be a b le to handl e all of t h e se p o s s i b i l i t i e s . An added c o m p l i c a t i o n is that differen t a n a l y s e s a c c e s s informatio n in differen t ways . Most analyse s w i ll travers e the text from b e g i n n i n g to e n d. But s o me do the opposite— a\nr e v e r s e s e a r c h , for e x a m p l e , needs to p r o g r e s s throug h the text backwar d rathe r than\nforward . Evaluatin g algebrai c e x p r e s s i o n s c o u ld requir e an inorde r traversal.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 267, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 863}}
{"id": "computer_science_design_patterns_gof_chunk_0268_fa83471d", "text": "Evaluatin g algebrai c e x p r e s s i o n s c o u ld requir e an inorde r traversal. So our a c c e s s mechanis m must accommodat e differin g data structures , and we must\nsuppor t differen t kinds of traversals , such as preorder , postorder , and i n o r d e r . E n c a p s u l a t i n g Acces s a nd T r a v e r s a l\nR i g h t now our g l y ph interfac e u s es an intege r index to let c l i e n t s refer to c h i l d r e n . Althoug h that migh t be reasonabl e for glyph c l a s s e s that s t o re their c h i l d r e n in an\narray , it may be inefficien t for g l y p h s that use a l i n k e d l i s t. An importan t r o le of the \ng l y ph abstractio n is to hide the data structur e in whic h c h i l d r e n are stored . That way\nwe can c h a n g e the data structur e a g l y ph c l a ss u s es withou t affectin g o t h er c l a s s e s . Therefor e o n ly the g l y ph can know the data structur e it uses.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 268, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_design_patterns_gof_chunk_0269_44939a8f", "text": "That way\nwe can c h a n g e the data structur e a g l y ph c l a ss u s es withou t affectin g o t h er c l a s s e s . Therefor e o n ly the g l y ph can know the data structur e it uses. A corollar y is that the\ng l y ph interfac e shouldn' t be b i a s e d towar d one data structur e or another . It shouldn' t\nbe bette r s u i t ed to array s than to l i n k e d l i s t s, for e x a m p l e , as it is n o w . We can s o l ve this p r o b l e m and suppor t severa l differen t kinds of traversal s at the\ns a me time. We can put multipl e a c c e s s and traversa l c a p a b i l i t i e s d i r e c t l y in the glyph\nc l a s s e s and p r o v i d e a way to c h o o s e amon g them , perhap s by supplyin g an enumerate d\nconstan t as a parameter . The c l a s s e s pass this paramete r aroun d durin g a traversa l to\ne n s u r e they'r e all doing the same kind of traversal . T h ey have to pass aroun d any\ni n f o r m a t i o n t h e y ' v e a c c u m u l a t e d durin g t r a v e r s a l .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 269, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_design_patterns_gof_chunk_0270_051f5a64", "text": "T h ey have to pass aroun d any\ni n f o r m a t i o n t h e y ' v e a c c u m u l a t e d durin g t r a v e r s a l . We migh t add the followin g abstrac t operation s to Glyph' s interfac e to suppor t this\napproach:\n\nptg66 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2\nv o id F i r s t ( T r a v e r s a l k i n d )\nv o id N e x t ( ) \nb o ol I s D o n e ( )\nG l y p h * G e t C u r r e n t ( ) \nv o id I n s e r t ( G l y p h * )\nOperation s F i r s t , N e x t , and I s D o n e contro l the traversal . F i r s t i n i t i a l i z e s the\ntraversal . It takes the k i nd of traversa l as a paramete r of type T r a v e r s a l , an e n u -\nmerate d constan t with v a l u e s s u ch as C H I L D R E N (to travers e the glyph' s immediat e\nc h i l d r e n o n l y ) , P R E O R D E R (to travers e the entire structur e in preorder) , P O S T O R D E R ,\nand I N O R D E R .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 270, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_design_patterns_gof_chunk_0271_111ff000", "text": "N e xt advance s to the next g l y ph in the traversal , and I s D o n e report s\nwhethe r the traversa l is over or not. G e t C u r r e n t r e p l a c e s the C h i l d operation ; it\na c c e s s e s the curren t g l y ph in the traversal . I n s e r t r e p l a c e s the old o p e r a t i o n ; it i n s e r t s\nthe g i v en glyph at the curren t position. An analysi s woul d use the followin g C++ c o de to do a preorde r traversa l of a glyph\nstructur e roote d at g:\nG l y p h * g ;\nf or ( g - > F i r s t ( P R E O R D E R ) ; ! g - > I s D o n e ( ) ; g - > N e x t ( ) ) { \nG l y p h * c u r r e n t = g - > G e t C u r r e n t ( ) ;\n// do some a n a l y s i s\n}\nNotic e that we've banishe d the intege r i n d ex from the glyph interface . T h e r e ' s no l o n g e r\nanythin g that b i a s e s the interfac e towar d one kind of c o l l e c t i o n or another . W e ' v e a l so\ns a v ed c l i e n t s from havin g to implemen t commo n kinds of traversal s themselves.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 271, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_design_patterns_gof_chunk_0272_048f0ba9", "text": "W e ' v e a l so\ns a v ed c l i e n t s from havin g to implemen t commo n kinds of traversal s themselves. But this approac h s t i ll has problems . For one thing , it can't suppor t new traversal s\nwithou t e i t h e r extendin g the set of enumerate d v a l u e s or addin g new operations . Say we wante d to have a variatio n on preorde r traversa l that automaticall y s k i ps n o n -\ntextua l g l y p h s . W e 'd have to chang e the T r a v e r s a l enumeratio n to includ e somethin g\nl i ke T E X T U A L - P R E O R D E R . W e 'd l i ke to a v o id changin g e x i s t i n g declarations . Puttin g the traversa l mechanis m en-\ntirely in the Glyp h c l a ss hierarch y make s it hard to modif y or e x t e n d withou t changin g\nl o ts of c l a s s e s . It's a l so difficul t to reuse t h e. mechanis m to travers e other k i n ds of o b j e c t\nstructures . And we can't have mor e t h an one traversa l in p r o g r e s s on a structure.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 272, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 957}}
{"id": "computer_science_design_patterns_gof_chunk_0273_95dcf5d5", "text": "It's a l so difficul t to reuse t h e. mechanis m to travers e other k i n ds of o b j e c t\nstructures . And we can't have mor e t h an one traversa l in p r o g r e s s on a structure. O n ce again , a bette r solutio n is to encapsulat e the c o n c e p t that v a r i e s , in this c a se the\na c c e s s a nd traversa l m e c h a n i s m s . We c an introduc e a c l a ss of o b j e c t s c a l l ed i t e r a t o r s\nwhos e s o le purpos e is to defin e differen t s e ts of t h e se mechanisms . We c an u se i n h e r -\nitanc e to let us a c c e s s differen t data structure s uniforml y and suppor t new kinds of\nt r a v e r s a l s as w e l l. A nd we won' t h a ve to c h a n g e g l y ph i n t e r f a c e s or distur b e x i s t i n g\nglyph implementations to do it. ptgSECTION 2 . 8 SPELLING C H E C K I N G A N D H Y P H E N A T I O N 67\nF i g u r e 2 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 273, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 869}}
{"id": "computer_science_design_patterns_gof_chunk_0274_08381c3e", "text": "ptgSECTION 2 . 8 SPELLING C H E C K I N G A N D H Y P H E N A T I O N 67\nF i g u r e 2 . 1 3 : I t e r a t o r c l a s s and s u b c l a s s e s\nIterato r C l a ss a nd S u b c l a s s e s\nW e ' ll u se an a b s t r a c t c l a ss c a l l ed I t e r a t o r to defin e a g e n e r a l interfac e f or a c c e s s a nd t r a -\nversal . C o n c r e t e s u b c l a s s e s l i ke Arraylterato r and Listlterato r implemen t the interfac e \nto provid e a c c e s s to array s and l i s t s, while P r e o r d e r l t e r a t o r , P o s t o r d e r l t e r a t o r , and the\nl i ke implemen t differen t traversal s on s p e c i f i c structures . Each Iterato r s u b c l a s s has a\nreferenc e to the structur e it traverses . S u b c l a s s instance s are initialize d with this refer-\ne n ce when they are created . F i g u r e 2 . 13 illustrate s the Iterato r c l a ss along with severa l\ns u b c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 274, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_design_patterns_gof_chunk_0275_3b08c9b5", "text": "S u b c l a s s instance s are initialize d with this refer-\ne n ce when they are created . F i g u r e 2 . 13 illustrate s the Iterato r c l a ss along with severa l\ns u b c l a s s e s . Notic e t h at we've adde d a Createlterato r abstrac t operatio n to the Glyp h\nc l a ss interfac e to suppor t iterators. The Iterato r interfac e provide s operation s F i r s t, Next , and I s D o n e for controllin g the\nt r a v e r s a l . T he L i s t l t e r a t o r c l a ss i m p l e m e n t s F i r st to p o i nt to t he first e l e m e n t in t he l i s t,\nand Next advance s the iterato r to the next item in the list. I s D o n e return s whethe r or\nnot the l i st pointe r point s beyon d the last elemen t in the l i s t. Currentlte m dereference s\nthe iterato r to retur n the g l y ph it point s to. An A r r a y l t e r a t o r c l a ss woul d do s i m i l a r\nthings but on an array of glyphs.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 275, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 904}}
{"id": "computer_science_design_patterns_gof_chunk_0276_e3a74ea2", "text": "Currentlte m dereference s\nthe iterato r to retur n the g l y ph it point s to. An A r r a y l t e r a t o r c l a ss woul d do s i m i l a r\nthings but on an array of glyphs. Now we can access the children of a glyph structure without knowing its r e p r e s e n t a -\nt i o n :\n\nptg68 A C A SE S T U D Y - DESIGNING A DOCUMENT EDITOR CHAPTER 2\nG l y p h * g ;\nI t e r a t o r < G l y p h * > * i = g - > C r e a t e ! t e r a t o r ( ) ;\nf or ( i - > F i r s t ( ) ; ! i - > I s D o n e () ; i - > N e x t ( ) ) { \nG l y p h * c h i l d = i - > C u r r e n t ! t e m ( ) ;\n// do s o m e t h i n g w i th c u r r e n t c h i l d\n}\nCreatelterato r return s a Nulllterato r instanc e by default . A Nulllterato r is a degenerat e\niterato r for g l y p h s t h at have no children , that i s, l e af glyphs . Nulllterator' s I s D o n e\noperatio n alway s return s true.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 276, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 868}}
{"id": "computer_science_design_patterns_gof_chunk_0277_c4c42d8b", "text": "A Nulllterato r is a degenerat e\niterato r for g l y p h s t h at have no children , that i s, l e af glyphs . Nulllterator' s I s D o n e\noperatio n alway s return s true. A g l y ph s u b c l a s s t h at has c h i l d r e n w i ll overrid e Createlterato r to retur n an instanc e\nof a differen t Iterato r s u b c l a s s . Which s u b c l a s s depend s on the structur e t h at store s the\nc h i l d r e n . If the Row s u b c l a s s of Glyp h s t o r es its c h i l d r e n in a l i st . c h i l d r e n , then its\nCreatelterato r operatio n woul d l o ok like this:\nI t e r a t o r < G l y p h * > * R o w : : C r e a t e I t e r a t o r () {\nr e t u r n n ew L i s t I t e r a t o r < G l y p h * > ( _ c h i l d r e n ) ;\n}\nIterator s for preorde r and inorde r traversal s implemen t their traversal s in terms of\ng l y p h - s p e c i f i c iterators . The iterator s for these traversal s are s u p p l i e d the r o ot glyph in\nthe structur e they traverse .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 277, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_design_patterns_gof_chunk_0278_027b6bed", "text": "The iterator s for these traversal s are s u p p l i e d the r o ot glyph in\nthe structur e they traverse . T h ey c a ll Createlterato r on the g l y p h s in the structur e and\nuse a stack to k e ep track of the resultin g iterators. For e x a m p l e , c l a ss P r e o r d e r It e r at or g e ts the iterato r from the root g l y p h , i n i t i a l i z e s\nit to point to its first e l e m e n t , and then p u s h e s it onto the s t a c k :\nvoid Preorderlterator::Firs t () { \nIterator<Glyph*> * i = _root->Create!terator();\nif ( i) {\ni->First();\n..iterator s . R e m o v e A l l ( ) ;\n_ i t e r a t o r s . P u s h ( i ) ;\n}\n}\nC u r r e n t 1 1 em w o u l d s i m p l y c a l l Cur r e n t 1 1 e m o n t h e iterator at the top of the stack:\n\nptgSECTION 2.8 SPELLING CHECKING AND HYPHENATION 69\nG l y p h* Preorderlterator::Currentlte m () c o n st {\nr e t u r n\n_iterators.Size( ) > 0 ?", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 278, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 896}}
{"id": "computer_science_design_patterns_gof_chunk_0279_511cfa34", "text": "_iterators.Top()->CurrentItem( ) : 0;\n}\nThe N e xt operatio n g e ts the top iterato r on the stack and asks its curren t item to\ncreat e an iterator , in an e f f o r t to d e s c e n d the glyph structur e as far as p o s s i b l e (this\nis a preorde r traversal , a f t er a l l ). N e xt s e ts the new iterato r to the first item in the\ntraversa l and p u s h e s it on the stack . T h en N e xt tests the latest iterator ; if its I s D o n e \noperatio n return s true, then we've finishe d traversin g the curren t subtre e (or leaf) in the\ntraversal . In that c a s e, N e xt p o ps t he t op iterato r o ff t he s t a ck a nd r e p e a t s t h is p r o c e s s\nuntil it finds the next incomplet e traversal , if there is o n e; if not, then we have finishe d\ntraversin g the structure. void P r e o r d e r l t e r a t o r : .-Nex t () { \nI t e r a t o r < G l y p h * > * i =\n_ i t e r a t o r s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 279, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 906}}
{"id": "computer_science_design_patterns_gof_chunk_0280_5c356cd1", "text": "void P r e o r d e r l t e r a t o r : .-Nex t () { \nI t e r a t o r < G l y p h * > * i =\n_ i t e r a t o r s . T o p ( ) - > C u r r e n t I t e m ( ) - > C r e a t e I t e r a t o r ( ) ;\ni - > F i r s t ( ) ;\n_ i t e r a t o r s . P u s h ( i ) ;\nw h i l e (\n_ i t e r a t o r s . S i z e ( ) > 0 && _ i t e r a t o r s . T o p ( ) - > I s D o n e ( )\n) {\nd e l e t e _ i t e r a t o r s . P o p ( ) ;\n_ i t e r a t o r s . T o p ( ) - > N e x t ( ) ;\n}\nNotic e how the Iterato r c l a ss hierarch y lets us add new k i n ds of traversal s withou t\nmodifyin g glyph classes—w e s i m p l y subclas s I t e r a t o r and add a new traversa l as\nwe have with P r e o r d e r l t e r a t o r . Glyp h subclasse s use the s a me interfac e to g i ve\nc l i e n t s a c c e s s to t h e ir c h i l d r e n withou t r e v e a l i n g the underlyin g data structur e they\nuse to store them .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 280, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 887}}
{"id": "computer_science_design_patterns_gof_chunk_0281_4fa1b51d", "text": "Glyp h subclasse s use the s a me interfac e to g i ve\nc l i e n t s a c c e s s to t h e ir c h i l d r e n withou t r e v e a l i n g the underlyin g data structur e they\nuse to store them . Becaus e iterator s store their own copy of the state of a traversal ,\nwe can carry on multipl e traversal s simultaneously , e v en on the same structure . And\nthoug h o ur t r a v e r s a l s h a ve b e en o v er g l y ph s t r u c t u r e s in t h is e x a m p l e , t h e r e ' s no\nreaso n we can't parameteriz e a c l a ss like P r e o r d e r l t e r a t o r by the type of objec t in\nthe structure . We'd use template s to do that in C + +. T h en we can reuse the machiner y\nin P r e o r d e r l t e r a t o r to travers e other structures. Iterato r Pattern\nThe Iterato r ( 2 5 7) patter n capture s t h e se t e c h n i q u e s for supportin g a c c e s s and traversa l\nover objec t structures . It's applicabl e not o n ly to composit e structure s but to c o l l e c t i o n s\na s w e l l .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 281, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 997}}
{"id": "computer_science_design_patterns_gof_chunk_0282_ebeeaa7e", "text": "It's applicabl e not o n ly to composit e structure s but to c o l l e c t i o n s\na s w e l l . It a b s t r a c t s the traversal algorithm and shields c l i e n t s f r o m the internal structure\n\nptg70 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2\nof t he o b j e c t s they traverse . T he Iterato r patter n illustrate s o n ce m o re h ow e n c a p s u l a t i n g\nt he c o n c e p t that varie s h e l ps us g a in flexibilit y a nd r e u s a b i l i t y . E v en s o, t he proble m of\niteratio n has surprisin g d e p t h , and the Iterato r patter n c o v e r s many more nuance s and\ntrade-off s than we've c o n s i d e r e d h e r e . T r a v e r s a l v e r s u s T r a v e r s a l Actions\nNow that we have a way of traversin g the glyph structure , we n e ed to c h e ck the s p e l l i n g\nand do the hyphenation . B o th analyse s i n v o l v e accumulatin g informatio n durin g the\ntraversal.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 282, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_design_patterns_gof_chunk_0283_ba08f3b0", "text": "B o th analyse s i n v o l v e accumulatin g informatio n durin g the\ntraversal. F i r st we have to d e c i d e wher e to put the r e s p o n s i b i l i t y for a n a l y s i s . We c o u ld put it in the\nIterato r c l a s s e s , thereb y makin g analysi s an integra l part of traversal . But we get m o re\nflexibilit y and potentia l f or r e u se if we d i s t i n g u i s h betwee n the traversa l and the a c t i o n s\nperforme d durin g traversal . That' s becaus e differen t a n a l y s e s often r e q u i r e the s a me\nk i nd of traversal . H e n c e we can r e u se the same set of iterator s for differen t analyses . For\ne x a m p l e , preorde r traversa l is commo n to many a n a l y s e s , i n c l u d i n g s p e l l i n g c h e c k i n g ,\nhyphenation , f o r w a r d s e a r c h , and word count. So a n a l y s i s a nd traversa l s h o u l d be separate . W h e r e e l se c an we p ut t he r e s p o n s i b i l i t y\nfor analysis ?", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 283, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_design_patterns_gof_chunk_0284_7b7a61cc", "text": "So a n a l y s i s a nd traversa l s h o u l d be separate . W h e r e e l se c an we p ut t he r e s p o n s i b i l i t y\nfor analysis ? We know there are many kinds of analyse s we m i g h t want to do. Each\nanalysi s w i ll do d i f f e r e n t t h i n g s at differen t point s in the traversal . S o me g l y p h s are\nmore s i g n i f i c a n t than other s d e p e n d i n g on t he k i nd of a n a l y s i s . If we're c h e c k i n g\ns p e l l i n g or hyphenating , we want to c o n s i d e r characte r g l y p h s and not graphica l o n es\nl i ke l i n es and bitmappe d i m a g e s . If we're makin g c o l or separations , we'd want to\nc o n s i d e r v i s i b l e g l y p h s and not i n v i s i b l e o n e s. Inevitably , differen t a n a l y s e s will analyz e\ndifferen t g l y p h s . Therefor e a g i v en analysi s must be a b le to d i s t i n g u i s h differen t kinds of g l y p h s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 284, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 912}}
{"id": "computer_science_design_patterns_gof_chunk_0285_4058746b", "text": "Inevitably , differen t a n a l y s e s will analyz e\ndifferen t g l y p h s . Therefor e a g i v en analysi s must be a b le to d i s t i n g u i s h differen t kinds of g l y p h s . An\no b v i o u s approac h is to p ut t he analytica l capabilit y i n to t he g l y ph c l a s s e s t h e m s e l v e s . For e a ch analysi s we can add one or more abstrac t o p e r a t i o n s to the Glyp h c l a ss and\nhave s u b c l a s s e s i m p l e m e n t them in accordanc e with the r o le they play in the a n a l y s i s . But the troubl e with that approac h is that we'll have to c h a n g e every g l y ph c l a ss\nwheneve r we a dd a n ew k i nd of analysis . We c an e a se t h is proble m in s o me c a s e s :\nIf o n ly a f ew c l a s s e s p a r t i c i p a t e in t he a n a l y s i s , or if m o st c l a s s e s do t he a n a l y s i s t he\nsame way, then we can suppl y a defaul t implementatio n for the abstrac t operatio n in\nthe Glyp h c l a s s.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 285, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_design_patterns_gof_chunk_0286_7fd9b541", "text": "The defaul t operatio n woul d c o v er the c o m m o n c a s e. T h us we'd l i m it\nc h a n g e s to j u st the Glyp h c l a ss and t h o se s u b c l a s s e s that deviat e from the norm. Yet e v en if a defaul t implementatio n reduce s the numbe r of c h a n g e s , an i n s i d i o u s\nproble m r e m a i n s : Glyph' s interfac e expand s with every new analytica l c a p a b i l i t y . O v er\nt i me the analytica l operation s w i ll start to obscur e the b a s ic Glyp h interface . It b e c o m e s\nhard to see that a g l y p h ' s ma in purpos e is to defin e and structur e object s that have\nappearance and shape—that interface gets lost in the noise. ptgSECTION 2 . 8 SPELLING C H E C K I N G A N D HYPHENATION 7 1\nE n c a p s u l a t i n g t he Analysis\nF r om a ll i n d i c a t i o n s , we n e ed to e n c a p s u l a t e t he a n a l y s i s in a s e p a r a t e o b j e c t , much l i ke\nwe've done many t i m es before .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 286, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_design_patterns_gof_chunk_0287_205531c2", "text": "We c o u ld put the machiner y for a g i v en analysi s into\nits own c l a s s. We c o u ld use an instanc e of this c l a ss in conjunctio n with an appropriat e\niterator . The iterato r woul d \" c a r r y \" the instanc e to e a ch glyph in the structure . The\nanalysi s o b j e c t c o u ld then perfor m a p i e ce of the analysi s at e a ch point in the traversal . T he a n a l y z e r a c c u m u l a t e s informatio n of i n t e r e s t ( c h a r a c t e r s in t h is c a s e) as t he t r a v e r s a l\np r o c e e d s :\nThe f u n d a m e n t a l questio n with this approac h is how the analysi s objec t distinguishe s\ndifferen t kinds of g l y p h s withou t resortin g to type tests or downcasts .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 287, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 710}}
{"id": "computer_science_design_patterns_gof_chunk_0288_ca02164b", "text": "We don't want\na S p e l l i n g C h e c k e r c l a ss to includ e (pseudo)cod e l i k e\nv o id S p e l l i n g C h e c k e r : : C h e c k ( G l y p h * g l y p h ) {\nC h a r a c t e r * c ;\nR o w* r; \nI m a g e * i ;\ni f ( c = d y n a m i c _ c a s t < C h a r a c t e r * > ( g l y p h ) ) {\n/ / a n a l y z e t h e c h a r a c t e r\n} e l s e i f ( r = d y n a m i c _ c a s t < R o w * > ( g l y p h ) ) {\n/ / p r e p a r e t o a n a l y z e r ' s children\n\nptg72 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2\n} else if (i = dynamic_cast<Image*>(glyph) ) {\n// do n o t h i ng\n}\n}\nT h is c o de is p r e t t y u g l y. It r e l i es on fairly e s o t e r i c c a p a b i l i t i e s like type-saf e c a s t s . I t 's\nh a rd to e x t e n d as well. W e ' l l h a ve to r e m e m b e r to c h a n g e t he b o dy of t h is f u n c t i o n\nw h e n e v e r we c h a n g e t he G l y p h c l a ss h i e r a r c h y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 288, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_design_patterns_gof_chunk_0289_b460d650", "text": "I t 's\nh a rd to e x t e n d as well. W e ' l l h a ve to r e m e m b e r to c h a n g e t he b o dy of t h is f u n c t i o n\nw h e n e v e r we c h a n g e t he G l y p h c l a ss h i e r a r c h y . In fact, t h is is t he k i nd of c o de t h at\no b j e c t - o r i e n t e d l a n g u a g e s w e re i n t e n d e d to e l i m i n a t e . We want to avoid s u ch a b r u t e - f o r c e a p p r o a c h , b ut h o w? L e t 's c o n s i d e r w h at h a p p e n s\nw h en we a dd t he followin g a b s t r a c t o p e r a t i o n to t he G l y p h c l a s s :\nv o id C h e c k M e ( S p e l l i n g C h e c k e r & )\nWe defin e C h e c k M e in e v e ry Glyp h s u b c l a s s as follows:\nv o id G l y p h S u b c l a s s : : C h e c k M e ( S p e l l i n g C h e c k e r k c h e c k e r ) {\nc h e c k e r . C h e c k G l y p h S u b c l a s s ( t h i s ) ;\n}\nw h e r e G l y p h S u b c l a s s woul d be r e p l a c e d by t he n a me of t he g l y ph s u b c l a s s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 289, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_design_patterns_gof_chunk_0290_fc648971", "text": "C h e c k G l y p h S u b c l a s s ( t h i s ) ;\n}\nw h e r e G l y p h S u b c l a s s woul d be r e p l a c e d by t he n a me of t he g l y ph s u b c l a s s . N o te\nthat w h en C h e c k M e is c a l l e d , t he s p e c i f i c Glyp h s u b c l a s s is known—afte r a l l, w e ' re \nin o ne of i ts o p e r a t i o n s . In t u r n, t he S p e l l i n g C h e c k e r c l a ss interfac e i n c l u d e s an\no p e r a t i o n like C h e c k G l y p h S u b c l a s s for e v e ry Glyp h subclass 10:\nc l a s s S p e l l i n g C h e c k e r {\np u b l i c :\nS p e l l i n g C h e c k e r ( ) ;\nv i r t u a l v o id C h e c k C h a r a c t e r ( C h a r a c t e r * ) ;\nv i r t u a l v o id C h e c k R o w ( R o w * ) ; \nv i r t u a l v o id C h e c k l m a g e ( I m a g e * ) ;\n// ...", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 290, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 791}}
{"id": "computer_science_design_patterns_gof_chunk_0291_b4ccced9", "text": "a nd so f o r t h\nL i s t < c h a r * > & G e t M i s s p e l l i n g s ( ) ;\np r o t e c t e d : \nvirtual bool IsMisspelled(cons t char*);\nprivate: \nc h ar _ c u r r e n t W o r d [ M A X _ W O R D _ S I Z E ] ;\nL i s t < c h a r * > _ m i s s p e l l i n g s ;\n} ;\nS p e l l i n g C h e c k e r ' s c h e c k i n g o p e r a t i o n for C h a r a c t e r g l y p h s m i g h t l o ok s o m e -\nt h i ng like t h i s :\n10 We c o u ld u se functio n o v e r l o a d i n g to give e a ch of t h e se m e m b e r f u n c t i o n s t he s a me n a m e , s i n ce t h e ir\np a r a m e t e r s alread y differentiat e t h e m . W e ' v e g i v en t h em differen t n a m e s h e re to e m p h a s i z e t h e ir d i f f e r e n c e s , \nespecially when they're called. ptgSECTION 2 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 291, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 778}}
{"id": "computer_science_design_patterns_gof_chunk_0292_336d3781", "text": "W e ' v e g i v en t h em differen t n a m e s h e re to e m p h a s i z e t h e ir d i f f e r e n c e s , \nespecially when they're called. ptgSECTION 2 . 8 SPELLING CHECKING A N D H Y P H E N A T I O N 73\nv o id S p e l l i n g C h e c k e r : : C h e c k C h a r a c t e r ( C h a r a c t e r * c) {\nc o n st c h ar ch = c->GetCharCode();\nif ( i s a l p h a ( c h ) ) { \n// a p p e nd a l p h a b e t i c c h a r a c t e r to _ c u r r e n t W o r d\n} e l se { \n/ / we hit a n o n a l p h a b e t i c c h a r a c t e r\nif ( I s M i s s p e l l e d ( _ c u r r e n t W o r d ) ) { \n// a dd _ c u r r e n t W o r d to _ m i s s p e l l i n g s \n_ m i s s p e l l i n g s . A p p e n d ( s t r d u p ( _ c u r r e n t W o r d ) ) ;\n}\n_ c u r r e n t W o r d [ 0 ] = ' \\ 0' ;\n// rese t _ c u r r e n t W o r d to chec k n e xt word\n}\n}\nN o t i c e we've define d a s p e c i a l G e t C h a r C o d e operatio n on j u st the C h a r a c t e r c l a s s.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 292, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_design_patterns_gof_chunk_0293_6ef0b596", "text": "The s p e l l i n g c h e c k e r can deal with s u b c l a s s - s p e c i f i c operation s withou t resortin g to\ntype t e s ts or c a s t s — i t l e ts us treat object s s p e c i a l l y . C h e c k C h a r a c t e r accumulate s alphabeti c character s into the _ c u r r e n t W o r d buffer . When it encounter s a nonalphabeti c character , s u ch as an u n d e r s c o r e , it u s es the\nI s M i s s p e l l e d operatio n to c h e ck the s p e l l i n g of the word in _ c u r r e n t W o r d . n If\nthe word is m i s s p e l l e d , then C h e c k C h a r a c t e r adds the word to the l i st of m i s s p e l l e d\nw o r d s . T h en it must c l e ar out the _ c u r r e n t W o r d b u f f e r to ready it for the next word . When t he traversa l is o v e r, y ou c an retriev e t he l i st of m i s s p e l l e d word s with t he \nG e t M i s s p e l l i n g s operation.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 293, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 889}}
{"id": "computer_science_design_patterns_gof_chunk_0294_6cd0baeb", "text": "When t he traversa l is o v e r, y ou c an retriev e t he l i st of m i s s p e l l e d word s with t he \nG e t M i s s p e l l i n g s operation. Now we can travers e the glyph structure , c a l l i n g C h e c k M e on e a ch glyph with\nt he s p e l l i n g c h e c k e r as an argument . T h is effectivel y identifie s e a ch g l y ph to t he\nS p e l l i n g C h e c k e r a nd p r o m p t s t he c h e c k e r to do t he n e xt i n c r e m e n t in t he s p e l l i n g\nc h e c k . S p e l l i n g C h e c k e r S p e l l i n g C h e c k e r ;\nC o m p o s i t i o n * c;\n// . . . G l y p h* g;\nP r e o r d e r l t e r a t o r i ( c ) ;\n11 I s M i s s p e l l e d implement s the s p e l l i n g algorithm , whic h we won' t detai l h e re b e c a u s e we've made\nit i n d e p e n d e n t of L e x i ' s d e s i g n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 294, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 822}}
{"id": "computer_science_design_patterns_gof_chunk_0295_2a7a8886", "text": "We can suppor t differen t algorithm s by s u b c l a s s i n g S p e l l i n g C h e c k e r ;\nalternatively , we can apply the Strateg y ( 3 1 5) patter n (as we did for formattin g in S e c t i o n 2 . 3) to s u p p o r t\ndifferent spelling checking a l g o r i t h m s . ptg7 4 A CASE S T U D Y - DESIGNING A D O C U M E N T EDITOR CHAPTER 2\nfor ( i. First ( ); ! i . I s D o ne () ; i.NextO ) {\ng = i.Currentltem() ;\ng->CheckMe(spellingChecker);\n}\nThe followin g interactio n diagra m illustrate s how C h a r a c t e r g l y p h s and the\nS p e l l i n g C h e c k e r o b j e c t work together:\nT h is approac h work s for findin g s p e l l i n g e r r o r s , but how d o es it help us s u p -\nport multipl e kinds of a n a l y s i s ? It l o o ks l i ke we have to add an operatio n l i ke\nC h e c k M e ( S p e l 1 i n g C h e c k e r &) to Glyp h and its s u b c l a s s e s wheneve r we add a new\nkind of analysis .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 295, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_design_patterns_gof_chunk_0296_b057f0ac", "text": "It l o o ks l i ke we have to add an operatio n l i ke\nC h e c k M e ( S p e l 1 i n g C h e c k e r &) to Glyp h and its s u b c l a s s e s wheneve r we add a new\nkind of analysis . That' s true if we i n s i st on an independent c l a ss for e v e ry a n a l y s i s . But\nthere' s no reaso n why we can't g i ve all a n a l y s i s c l a s s e s the same interface . D o i n g so\nl e ts us use them polymorphically . That mean s we can r e p l a c e a n a l y s i s - s p e c i f i c o p e r -\nation s l i ke C h e c k M e ( S p e l l i n g C h e c k e r & ) with an analysis-independen t operatio n\nthat takes a more genera l parameter. Visito r C l a ss a nd S u b c l a s s e s\nW e ' ll use the term visito r to refer generall y to c l a s s e s of o b j e c t s that \" v i s i t \" other\no b j e c t s durin g a traversa l and do somethin g appropriate. 12 In this c a se we can defin e a\nV i s i t o r class that defines an abstract interface for visiting glyphs in a structure.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 296, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_design_patterns_gof_chunk_0297_8f1133a3", "text": "12 In this c a se we can defin e a\nV i s i t o r class that defines an abstract interface for visiting glyphs in a structure. 12 \" V i s i t \" is just a slightl y more genera l term for \" a n a l y z e . \" It foreshadow s the terminolog y we use in the\nd e s i g n pattern we're leading to. ptgSECTION 2.8 SPELLING CHECKING AND HYPHENATION 75\nclass Visitor {\npublic:\nv i r t u al v o id V i s i t C h a r a c t e r ( C h a r a c t e r * ) { }\nvirtual void VisitRow(Row* ) { } \nvirtual void VisitImage(Image*) { }\n// . . . a n d s o forth\nC o n c r e t e s u b c l a s s e s of V i s i t o r perfor m differen t a n a l y s e s . For e x a m p l e , we\nc o u ld h a ve a S p e l l i n g C h e c k i n g V i s i t o r s u b c l a s s f or c h e c k i n g s p e l l i n g , a nd\na H y p h e n a t i o n V i s i t o r s u b c l a s s f or hyphenation .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 297, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 848}}
{"id": "computer_science_design_patterns_gof_chunk_0298_1fc84b2c", "text": "S p e l l i n g C h e c k i n g V i s i t o r\nwoul d be implemente d exactl y as we i m p l e m e n t e d Spel 1 i n g C h e c k e r a b o v e , e x c e p t\nt he o p e r a t i o n n a m e s w o u l d r e f l e c t t he m o re g e n e r a l V i s i t o r i n t e r f a c e . F or e x a m p l e ,\nC h e c k C h a r a c t e r woul d be c a l l ed V i s i t C h a r a c t e r . S i n ce C h e c k M e isn't appropriat e for v i s i t o r s that don't c h e ck anything , w e ' ll g i ve it\na more genera l name : A c c e p t . Its argumen t must a l so chang e to take a V i s i t o r & ,\nr e f l e c t i n g t he fact that it c an a c c e p t a ny v i s i t o r . N ow a d d i n g a n ew a n a l y s i s r e q u i r e s\njust definin g a new s u b c l a s s of v i s i t o r — w e don't have to touch any of the g l y ph\nc l a s s e s . We suppor t all f u t u r e analyse s by addin g this one operatio n to G l y p h and its\ns u b c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 298, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_design_patterns_gof_chunk_0299_331eddd7", "text": "We suppor t all f u t u r e analyse s by addin g this one operatio n to G l y p h and its\ns u b c l a s s e s . W e ' v e a l r e a d y s e en h ow s p e l l i n g c h e c k i n g w o r k s . We u se a s i m i l a r a p p r o a c h\nin H y p h e n a t i o n V i s i t o r to accumulat e text. But o n ce H y p h e n a t i o n V i s i t o r ' s\nV i s i t C h a r a c t e r operatio n has a s s e m b l e d an e n t i re w o r d , it work s a l i t t le differ-\ne n t l y. I n s t e a d of c h e c k i n g t he w o rd f or m i s s p e l l i n g , it a p p l i e s a h y p h e n a t i o n a l g o r i t h m\nto determin e the potentia l hyphenatio n point s in the word , if a n y. T h en at e a ch hyphen-\nation p o i n t , it i n s e r t s a discretionar y g l y ph i n to t he c o m p o s i t i o n . D i s c r e t i o n a r y g l y p h s\nare i n s t a n c e s of D i s c r e t i o n a r y , a s u b c l a s s of G l y p h .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 299, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_design_patterns_gof_chunk_0300_abbd6e5f", "text": "D i s c r e t i o n a r y g l y p h s\nare i n s t a n c e s of D i s c r e t i o n a r y , a s u b c l a s s of G l y p h . A discretionar y g l y ph has one of two p o s s i b l e appearance s d e p e n d i n g on whethe r or\nnot it is the last characte r on a l i n e. If it's the l a st character , then the discretionar y l o o ks\nl i ke a h y p h e n ; if i t 's n ot at t he e nd of a l i n e, then t he d i s c r e t i o n a r y h as no a p p e a r a n c e\nwhatsoever . T he discretionar y c h e c k s i ts paren t (a R ow object ) to s ee if it is t he l a st c h i l d . The discretionar y make s this c h e ck wheneve r it's c a l l ed on to draw i t s e lf or calculat e\ni ts b o u n d a r i e s . T he formattin g s t r a t e g y t r e a ts d i s c r e t i o n a r i e s t he s a me as w h i t e s p a c e ,\nmakin g them candidate s for e n d i n g a l i n e. The followin g diagra m s h o w s how an\ne m b e d d e d d i s c r e t i o n a r y can appear.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 300, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_design_patterns_gof_chunk_0301_24920f7a", "text": "The followin g diagra m s h o w s how an\ne m b e d d e d d i s c r e t i o n a r y can appear. ptg76 A C A S E S T U D Y : D E S I G N I N G A D O C U M E N T E D I T O R CHAPTER 2\nV i s i t o r P a t t e r n\nWha t we've d e s c r i b e d h e re is an a p p l i c a t i o n of t he Visito r ( 3 3 1) pattern . T he Visito r\nc l a ss and its s u b c l a s s e s d e s c r i b e d earlie r are the key participant s in the pattern . The\nVisito r patter n capture s the techniqu e we've used to a l l ow an open-ende d numbe r of\nanalyse s of g l y ph structure s withou t havin g to chang e t he g l y ph c l a s s e s t h e m s e l v e s . Anothe r n i ce featur e of v i s i t o r s is that t h ey c an be a p p l i e d n ot just to c o m p o s i t e s l i ke\no ur g l y p h s t r u c t u r e s b ut to a ny o b j e c t structure . T h at i n c l u d e s s e t s, l i s t s, e v en d i r e c t e d -\na c y c l i c g r a p h s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 301, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_design_patterns_gof_chunk_0302_fd12583e", "text": "T h at i n c l u d e s s e t s, l i s t s, e v en d i r e c t e d -\na c y c l i c g r a p h s . Furthermore , the c l a s s e s that a v i s i t o r can v i s it needn' t be relate d to\neach other throug h a c o m m o n paren t c l a s s. That mean s v i s i t o r s can work a c r o s s c l a ss \nhierarchies. An importan t q u e s t i o n to ask y o u r s e l f befor e applyin g the V i s i t o r patter n is, W h i c h c l a ss\nh i e r a r c h i e s chang e most o f t e n ? The patter n is most suitabl e when you want to be a b le\nto do a variet y of differen t t h i n g s to o b j e c t s that have a s t a b le c l a ss structure . A d d i n g\na n ew k i nd of v i s i t o r r e q u i r e s no c h a n g e to that c l a ss s t r u c t u r e , w h i ch is e s p e c i a l l y\nimportan t when the c l a ss structur e is l a r g e . But wheneve r you add a s u b c l a s s to the\nstructure , you'l l a l so have to updat e all your visito r interface s to includ e a V i s i t . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 302, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_design_patterns_gof_chunk_0303_02548df0", "text": "But wheneve r you add a s u b c l a s s to the\nstructure , you'l l a l so have to updat e all your visito r interface s to includ e a V i s i t . . . operatio n for that s u b c l a s s . In our exampl e that mean s addin g a new G l y p h s u b c l a s s\nc a l l ed Foo w i ll r e q u i r e c h a n g i n g V i s i t o r and all its s u b c l a s s e s to i n c l u d e a V i s i t F o o\no p e r a t i o n . B ut g i v en o ur d e s i g n c o n s t r a i n t s , w e ' re m u ch m o re l i k e ly to a dd a n ew k i nd\nof a n a l y s i s to L e xi than a n ew k i nd of G l y p h . So t he V i s i t o r patter n is w e l l - s u i t e d to o ur \nn e e d s . 2 . 9 Summary\nW e ' v e applied eight different p a t t e r n s to Lexi's design:\n1 . C o m p o s i t e (163) to represent the document's physical structure,\n2. S t r a t e g y ( 3 1 5 ) to allow different f o r m a t t i n g algorithms,\n\nptgSECTION 2.9 SUMMARY 77\n3. Decorato r ( 1 7 5) for embellishin g the user interface,\n4.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 303, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_design_patterns_gof_chunk_0304_677aa418", "text": "S t r a t e g y ( 3 1 5 ) to allow different f o r m a t t i n g algorithms,\n\nptgSECTION 2.9 SUMMARY 77\n3. Decorato r ( 1 7 5) for embellishin g the user interface,\n4. Abstrac t Factor y ( 8 7) for supportin g multipl e look-and-fee l standards,\n5. Bridg e ( 1 5 1) to allow multipl e windowin g platforms,\n6. Comman d ( 2 3 3) f or undoabl e us er operations,\n7. Iterato r ( 2 5 7) for a c c e s s i n g and traversin g objec t structures , and\n8. Visito r ( 3 3 1) f or allowin g an o p e n - e n d e d numbe r of analytica l c a p a b i l i t i e s withou t\ncomplicatin g the documen t structure' s implementation. None of these d e s i g n i s s u e s is limite d to documen t editin g application s l i ke L e x i. Indeed , most nontrivia l application s w i ll have o c c a s i o n to use many of these pat-\nt e r n s , thoug h perhap s to do differen t things .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 304, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 868}}
{"id": "computer_science_design_patterns_gof_chunk_0305_52f91cbf", "text": "Indeed , most nontrivia l application s w i ll have o c c a s i o n to use many of these pat-\nt e r n s , thoug h perhap s to do differen t things . A financia l analysi s applicatio n migh t use\nComposit e to defin e investmen t portfolio s made up of subportfolio s and account s of\nd i f f e r e n t sorts . A c o m p i l e r migh t use the Strateg y patter n to a l l ow differen t r e g i s t e r\nallocatio n s c h e m e s for differen t targe t machines . Application s with a graphica l user\ninterfac e w i ll probabl y apply at least Decorato r and Comman d just as we have h e r e . Whil e we'v e c o v e r e d severa l majo r problem s in L e x i ' s d e s i g n , there are lots of other s\nwe haven' t d i s c u s s e d . T h en again , this book d e s c r i b e s more t h an j u st the e i g ht pattern s\nwe've u s ed h e r e. So as you study the remainin g patterns , think abou t how you migh t\nuse each one in Lexi. Or better yet, think about using them in your own designs!", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 305, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 990}}
{"id": "computer_science_design_patterns_gof_chunk_0306_cc02f0d6", "text": "So as you study the remainin g patterns , think abou t how you migh t\nuse each one in Lexi. Or better yet, think about using them in your own designs! ptg\nThis page intentionally left blank \n\nptgD e s i g n Pattern Catalog\n7 9\n\nptg\nThis page intentionally left blank \n\nptgC h a p t e r 3\nC r e a t i o n a l P a t t e r n s\nCreationa l d e s i g n pattern s abstrac t the instantiatio n p r o c e s s . T h ey help make a s y s t e m\ni n d e p e n d e n t of h ow i ts o b j e c t s a re c r e a t e d , c o m p o s e d , a nd r e p r e s e n t e d . A c l a ss c r e -\nationa l patter n u s es inheritanc e to vary the c l a ss that's instantiated , wherea s an o b j e c t\ncreationa l patter n w i ll delegat e instantiatio n to anothe r object. Creationa l pattern s becom e importan t as system s e v o l v e to depen d more on o b j e c t\nc o m p o s i t i o n than c l a ss i n h e r i t a n c e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 306, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 903}}
{"id": "computer_science_design_patterns_gof_chunk_0307_642e2e6c", "text": "Creationa l pattern s becom e importan t as system s e v o l v e to depen d more on o b j e c t\nc o m p o s i t i o n than c l a ss i n h e r i t a n c e . As that h a p p e n s , e m p h a s i s shifts away from hard-\nc o d i n g a fixed set of behavior s towar d definin g a s m a l l e r set of fundamenta l behavior s\nthat can be c o m p o s e d into any numbe r of more c o m p l e x o n e s. T h us creatin g object s\nwith p a r t i c u l a r b e h a v i o r s r e q u i r e s m o re than s i m p l y i n s t a n t i a t i n g a c l a s s . T h e re a re t wo r e c u r r i n g t h e m e s in t h e se patterns . F i r s t, t h ey a ll e n c a p s u l a t e k n o w l e d g e\nabou t w h i c h c o n c r e t e c l a s s e s t he s y s t e m u s e s. S e c o n d , they h i de h ow instance s of t h e se\nc l a s s e s are create d and put t o g e t h e r . All the syste m at l a r ge know s abou t the object s is\nt h e ir i n t e r f a c e s as define d by a b s t r a c t c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 307, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_design_patterns_gof_chunk_0308_aea5d749", "text": "All the syste m at l a r ge know s abou t the object s is\nt h e ir i n t e r f a c e s as define d by a b s t r a c t c l a s s e s . C o n s e q u e n t l y , t he c r e a t i o n a l pattern s g i ve\nyou a lot of flexibilit y in what g e ts c r e a t e d , who c r e a t e s it, how it g e ts created , and when. T h ey let you configur e a syste m with \" p r o d u c t \" o b j e c t s that vary w i d e l y in structur e\na nd f u n c t i o n a l i t y . C o n f i g u r a t i o n c an be static (that i s, s p e c i f i e d at c o m p i l e - t i m e ) or\ndynamic (at run-time). S o m e t i m e s creationa l pattern s are competitors . For e x a m p l e , there are c a s es when eithe r\nPrototyp e ( 1 1 7) or Abstrac t Factor y ( 8 7) c o u ld be u s ed profitably . At other t i m es they\nare complementary : Builde r ( 9 7) can use one of the other pattern s to implemen t w h i c h\ncomponent s g et built. Prototyp e ( 1 1 7) c an u se S i n g l e t o n ( 1 2 7) in i ts implementation.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 308, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_design_patterns_gof_chunk_0309_93f3dcf4", "text": "Prototyp e ( 1 1 7) c an u se S i n g l e t o n ( 1 2 7) in i ts implementation. B e c a u s e the creationa l pattern s are c l o s e l y related , we'll study all five of them togethe r\nto h i g h l i g h t their s i m i l a r i t i e s a nd d i f f e r e n c e s . W e ' ll a l so u se a c o m m o n e x a m p l e —\nbuildin g a maze for a compute r game—t o illustrat e their implementations . The maze\nand the game w i ll vary s l i g h t l y from patter n to pattern . Sometime s the game w i ll be\ns i m p l y to f i nd your w ay o ut of a m a z e ; in that c a se t he p l a y e r w i ll p r o b a b l y o n ly have\na local view of the maze. Sometimes mazes contain problems t o solve and d a n g e r s t o\n8 1\n\nptg8 2 CREATIONAL PATTERNS CHAPTER 3\no v e r c o m e , and these game s may provid e a map of the part of the maze that has b e en\ne x p l o r e d . W e ' ll i g n o r e many d e t a i l s of what can be in a maze and whethe r a maze game has a\ns i n g le or multipl e pla y ers .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 309, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_design_patterns_gof_chunk_0310_e75214d0", "text": "W e ' ll i g n o r e many d e t a i l s of what can be in a maze and whethe r a maze game has a\ns i n g le or multipl e pla y ers . Instead , we'll j u st focus on how maze s get created . We defin e \na maze as a set of r o o m s . A r o om know s its n e i g h b o r s ; p o s s i b l e neighbor s are anothe r\nr o o m , a w a l l, or a d o or to anothe r r o o m . The c l a s s e s R o o m , D o o r , and W a ll defin e the component s of the maze u s ed in all our\ne x a m p l e s . We defin e o n ly t he parts of t h e se c l a s s e s that a re importan t f or c r e a t i n g a\nmaze . W e ' ll i g n o r e p la y ers , operation s for displayin g and wanderin g aroun d in a maze ,\nand other important functionality that isn't relevant to building the maze. The following diagram shows the relationships between these classes:\nEach r o om has f o ur s i d e s . We use an enumeratio n D i r e c t !", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 310, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_design_patterns_gof_chunk_0311_3e683e8a", "text": "The following diagram shows the relationships between these classes:\nEach r o om has f o ur s i d e s . We use an enumeratio n D i r e c t ! on in C++ implementation s\nto specif y the north , south , e a s t, and west s i d es of a r o o m :\ne n um Directio n { N o r t h, South, East, West};\nT he S m a l l t a l k implementation s u se correspondin g s y m b o l s to r e p r e s e n t t h e se d i r e c -\nt i o n s . The c l a ss M a p S i t e is the commo n abstrac t c l a ss for all the component s of a maze . To simplif y the e x a m p l e , M a p S i t e define s only one operation , E n t e r . Its meanin g\nd e p e n d s on what you'r e entering . If you enter a r o o m , then your locatio n c h a n g e s . If\ny ou t ry to enter a d o o r, then o ne of t wo t h i n g s happen : If t he door is o p e n , y ou go i n to\nthe next room . If the door is c l o s e d , then you hurt your n o s e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 311, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 908}}
{"id": "computer_science_design_patterns_gof_chunk_0312_c3c10b48", "text": "If\ny ou t ry to enter a d o o r, then o ne of t wo t h i n g s happen : If t he door is o p e n , y ou go i n to\nthe next room . If the door is c l o s e d , then you hurt your n o s e . c l a s s M a p S i t e {\np u b l i c :\nv i r t u a l v o id E n t e r ( )\nE n t e r p r o v i d e s a s i m p l e b a s is for more s o p h i s t i c a t e d game operations . For e x a m p l e , if\nyou are in a r o om and say \"Go E a s t , \" the game can s i m p l y determin e whic h M a p S i t e\nis immediately t o t h e e a s t a n d t h e n c a l l E n t e r o n i t . T h e s u b c l a s s - s p e c i f i c E n t e r\n\nptgCREATIONAL PATTERNS 83\noperatio n will f i g u r e o ut w h e t h e r y o ur locatio n c h a n g e d or y o ur n o se g ot h u r t. In a r e al\ng a m e , E n t e r c o u ld take t he p l a y e r o b j e c t that' s m o v i n g a b o u t as an a r g u m e n t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 312, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_design_patterns_gof_chunk_0313_2e66c423", "text": "In a r e al\ng a m e , E n t e r c o u ld take t he p l a y e r o b j e c t that' s m o v i n g a b o u t as an a r g u m e n t . R o om is the c o n c r e t e s u b c l a s s of M a p S i t e that define s the key r e l a t i o n s h i p s b e t w e e n\nc o m p o n e n t s in the maze . It m a i n t a i n s r e f e r e n c e s to o t h er M a p S i t e o b j e c t s and s t o r e s a \nr o om n u m b e r . T he n u m b e r will identif y r o o m s in t he maze. c l a s s R o om : p u b l i c M a p S i t e {\np u b l i c :\nR o o m ( i n t r o o m N o ) ;\nMapSite* GetSide(Direction ) const;\nvoid SetSide(Direction , MapSite*);\nvirtual void Enter();\nprivate: \nMapSite* _sides[4] ;\ni nt _roomNumber;\n} ;\nT he followin g c l a s s e s r e p r e s e n t t he wall or d o or that o c c u r s on e a ch s i de of a r o o m .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 313, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 821}}
{"id": "computer_science_design_patterns_gof_chunk_0314_245fbec9", "text": "class Wall : public MapSite {\npublic:\nWallO ;\nvirtual void Enter();\n} ;\nclass D o or : public MapSite {\npublic:\nDoor(Room * = 0, Room* = 0);\nvirtual void Enter();\nRoom* OtherSideFrom(Room*);\nprivate: \nRoom* _rooml;\nRoom* _room2;\nb o ol _isOpen;\n} ;\nWe n e ed to k n ow a b o u t m o re t h an j u st t he p a r ts of a maze . W e ' l l a l so defin e a M a z e\nclass to r e p r e s e n t a c o l l e c t i o n of r o o m s . M a z e can a l so find a p a r t i c u l a r r o om g i v en a\nr o o m n u m b e r using its RoomNo operation. ptg84 CREATIONAL PATTERNS CHAPTER 3\nc l a ss M a ze {\npublic:\nMaze();\nvoid AddRoom(Room * ) ;\nRoom* RoomNo(int ) const;\nprivate:\n// . . . } ;\nRoomN o c o u ld do a l o o k - u p u s i ng a linea r s e a r c h , a h a sh t a b l e , or e v en a s i m p l e a r r a y . B ut we w o n ' t w o r r y a b o u t s u ch detail s h e r e. I n s t e a d , w e ' ll f o c us on h ow to specif y t he \nc o m p o n e n t s of a maze object.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 314, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_design_patterns_gof_chunk_0315_ac104003", "text": "B ut we w o n ' t w o r r y a b o u t s u ch detail s h e r e. I n s t e a d , w e ' ll f o c us on h ow to specif y t he \nc o m p o n e n t s of a maze object. A n o t h e r c l a ss we defin e is M a z e G a m e , w h i c h c r e a t e s the maze . One s t r a i g h t f o r w a r d\nway to c r e a t e a maze is with a s e r i e s of o p e r a t i o n s that add c o m p o n e n t s to a m a ze\na nd t h en i n t e r c o n n e c t t h e m .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 315, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 442}}
{"id": "computer_science_design_patterns_gof_chunk_0316_26e0fb62", "text": "One s t r a i g h t f o r w a r d\nway to c r e a t e a maze is with a s e r i e s of o p e r a t i o n s that add c o m p o n e n t s to a m a ze\na nd t h en i n t e r c o n n e c t t h e m . F or e x a m p l e , t he f o l l o w i n g m e m b e r f u n c t i o n will c r e a t e a\nmaze consistin g of t wo r o o m s with a d o or betwee n t h e m :\nMaze* MazeGame::CreateMaz e () {\nMaze* a M a ze = new Maze;\nRoom* rl = new Room(l);\nR o o m* r2 = n ew Room ( 2 ) ;\nD o o r* t h e D o or = n ew Door(rl, r2);\naMaze->AddRoom(rl) ;\naMaze->AddRoom(r2);\nrl->SetSide(North , new Wall);\nrl->SetSide(East , t h e D o o r ) ;\nrl->SetSide(South , new Wall);\nrl->SetSide(West , new Wall);\nr2->SetSide(North , new Wall);\nr2->SetSide(East , new Wall); \nr2->SetSide(South , new Wall);\nr2->SetSide(West , t h e D o o r ) ;\nr e t u rn aMaze;\n}\nT h is f u n c t i o n is prett y c o m p l i c a t e d , c o n s i d e r i n g that a ll it d o es is c r e a t e a m a ze with\nt wo r o o m s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 316, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_design_patterns_gof_chunk_0317_df0f4ffc", "text": "T h e r e a re o b v i o u s ways to m a ke it s i m p l e r . F or e x a m p l e , t he R o om c o n -\ns t r u c t o r c o u ld initializ e t he s i d es with walls a h e a d of time. B ut t h at j u st m o v e s t he\nc o de s o m e w h e r e e l s e. T he r e al p r o b l e m wit h t h is m e m b e r functio n i s n 't i ts s i ze b ut i ts\ninflexibility. It h a r d - c o d e s t he m a ze layout . C h a n g i n g t he l a y o u t m e a n s c h a n g i n g t h is\nm e m b e r function , e i t h e r by o v e r r i d i n g it—whic h m e a n s r e i m p l e m e n t i n g t he w h o l e\nt h i n g — o r by changing parts of it—which is error-prone a n d doesn't promote reuse. ptgCREATIONAL PATTERNS 8 5\nT he c r e a t i o n a l pattern s s h ow h ow to make t h is d e s i g n m o re f l e x i b l e , n ot n e c e s s a r i l y\ns m a l l e r . In particular , they w i ll m a ke it easy to chang e the c l a s s e s t h at defin e the\nc o m p o n e n t s of a maze.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 317, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_design_patterns_gof_chunk_0318_787bf315", "text": "In particular , they w i ll m a ke it easy to chang e the c l a s s e s t h at defin e the\nc o m p o n e n t s of a maze. S u p p o s e you wante d to reuse an e x i s t i n g maze layou t for a new game containin g (of\nall things ) enchante d mazes . The enchante d maze game has new kinds of components ,\nlike D o o r N e e d i n g S p e l l , a door t h at can be l o c k e d and o p e n e d subsequentl y o n ly\nwith a s p e l l; and E n c h a n t e d R o o m , a r oom that can have unconventiona l items in it,\nlike magi c keys or s p e l l s . How can you chang e C r e a t e M a z e e a s i ly so that it c r e a t e s\nmaze s with these n ew c l a s s e s of o b j e c t s ? In this c a s e, the b i g g e s t barrie r to c h a n g e l i es in hard-codin g the c l a s s e s that get instan-\ntiated.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 318, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 807}}
{"id": "computer_science_design_patterns_gof_chunk_0319_3eb267e2", "text": "In this c a s e, the b i g g e s t barrie r to c h a n g e l i es in hard-codin g the c l a s s e s that get instan-\ntiated. The creationa l pattern s provid e d i f f e r e n t ways to remov e e x p l i c i t reference s to\nc o n c r e t e c l a s s e s from c o de that n e e ds to instantiat e t h e m :\n• If C r e a t e M a z e c a l ls virtua l function s i n s t e a d of c o n s t r u c t o r c a l ls to c r e a te t he\nr o o m s , w a l l s , and doors it r e q u i r e s , then you can chang e the c l a s s e s t h at get\ni n s t a n t i a t e d by makin g a s u b c l a s s of M a z e G a m e and r e d e f i n i n g t h o se virtua l\nfunctions . T h is approac h is an exampl e of the Factor y Metho d ( 1 0 7) pattern. • If C r e a t e M a z e is passe d an objec t as a paramete r to use to c r e a t e r o o m s , w a l l s ,\nand doors , then you can chang e the c l a s s e s of r o o m s , walls , and doors by passin g\na differen t parameter .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 319, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_design_patterns_gof_chunk_0320_4b7f7926", "text": "T h is is an exampl e of the Abstrac t Factor y ( 8 7) pattern. • I f C r e a t e M a z e i s p a s s e d an o b j e c t that can creat e a new maze in its entiret y using\noperation s for addin g r o o m s , d o o r s , and walls to the maze it b u i l d s , then you can\nuse inheritanc e to c h a n g e parts of the maze or the way the maze is built. T h is is\nan exampl e of the Builde r ( 9 7) pattern. • If C r e a t e M a z e is parameterize d by variou s prototypica l r o o m , door, and wall\no b j e c t s , w h i c h it then c o p i e s a nd adds to t he m a z e , then y ou c an c h a n g e t he\nmaze' s compositio n by replacin g these prototypica l object s with differen t one s. T h is is an e x a m p l e of t he Prototyp e ( 1 1 7) pattern.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 320, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 756}}
{"id": "computer_science_design_patterns_gof_chunk_0321_d8757e43", "text": "T h is is an e x a m p l e of t he Prototyp e ( 1 1 7) pattern. T he r e m a i n i n g c r e a t i o n a l pattern , S i n g l e t o n ( 1 2 7 ) , c an e n s u r e t h e r e ' s o n ly o ne maze\nper game and that all game o b j e c t s have ready a c c e s s to it—withou t resortin g to g l o b a l\nv a r i a b l e s or functions . S i n g l e t o n a l so m a k e s it e a sy to e x t e n d or r e p l a c e t he maze\nwithout touching existing code. ptg\nThis page intentionally left blank \n\nptgA B S T R A C T FACTORY 87\nA B S T R A C T F A C T O R Y O b j e c t Creational\nI n t e n t\nProvid e an interfac e for creatin g familie s of relate d or dependen t object s withou t\ns p e c i f y i n g their concrete classes. Also Known A s\nKit\nMotivation\nC o n s i d e r a user interfac e toolki t t h at support s multipl e look-and-fee l standards ,\nsuch as Moti f and Presentatio n Manager .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 321, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_design_patterns_gof_chunk_0322_02b76ff6", "text": "Also Known A s\nKit\nMotivation\nC o n s i d e r a user interfac e toolki t t h at support s multipl e look-and-fee l standards ,\nsuch as Moti f and Presentatio n Manager . Differen t look-and-feel s defin e differen t\nappearance s and behavior s for user interfac e \" w i d g e t s \" l i ke s c r o ll bars, windows ,\nand buttons . To be portabl e a c r o s s look-and-fee l standards , an applicatio n shoul d\nnot hard-cod e its widget s for a particula r l o ok and feel. Instantiatin g l o o k - a n d -\nf eel-specifi c c l a s s e s of widget s throughou t the applicatio n make s it hard to chang e\nthe l o ok and feel later. We c an s o l ve t h is p r o b l e m by d e f i n i n g an a b s t r a c t W i d g e t F a c t o r y c l a ss that d e -\nc l a r es an interfac e for creatin g e a ch b a s ic kind of widget . T h e r e ' s a l so an abstrac t \nc l a ss for e a ch kind of widget , and concret e s u b c l a s s e s implemen t widget s for\nspecifi c look-and-fee l standards .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 322, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_design_patterns_gof_chunk_0323_cf85c869", "text": "T h e r e ' s a l so an abstrac t \nc l a ss for e a ch kind of widget , and concret e s u b c l a s s e s implemen t widget s for\nspecifi c look-and-fee l standards . WidgetFactory' s interfac e has an operatio n that \nreturn s a new widge t objec t for each abstrac t widge t c l a s s. Client s c a ll these o p e r -\na t i o n s to obtai n widge t instances , b ut c l i e n t s aren' t awar e of t he c o n c r e t e c l a s s e s\nthey're using. Thus clients stay independent of the prevailing look and f e e l . ptg8 8 CREATIONAL PATTERNS CHAPTER 3\nT h e re is a c o n c r e t e s u b c l a s s of WidgetFactor y for each look-and-fee l standard . Each s u b c l a s s implement s the operation s to creat e the appropriat e widge t for the\nl o ok and feel.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 323, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 762}}
{"id": "computer_science_design_patterns_gof_chunk_0324_439a7234", "text": "Each s u b c l a s s implement s the operation s to creat e the appropriat e widge t for the\nl o ok and feel. For e x a m p l e , the C r e a t e S c r o l l B a r operatio n on the MotifWidgetFac-\ntory instantiate s and return s a M o t if s c r o ll bar, while the c o r r e s p o n d i n g operatio n\non the PMWidgetFactor y return s a s c r o ll bar for Presentatio n Manager . C l i e n t s\ncreat e widget s s o l e ly throug h the WidgetFactor y interfac e and have no knowl-\ne d ge of the c l a s s e s that implemen t widget s for a particula r l o ok and feel. In other \nw o r d s , c l i e n t s o n ly have to commi t to an interfac e define d by an abstrac t c l a s s,\nnot a particula r c o n c r e t e c l a s s . A WidgetFactor y a l so enforce s d e p e n d e n c i e s betwee n the c o n c r e t e widge t c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 324, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 838}}
{"id": "computer_science_design_patterns_gof_chunk_0325_1fb152bd", "text": "A WidgetFactor y a l so enforce s d e p e n d e n c i e s betwee n the c o n c r e t e widge t c l a s s e s . A M o t if s c r o ll bar s h o u l d be used with a M o t if butto n and a Motif text e d i t o r , and\nthat constraint is enforced a u t o m a t i c a l l y a s a consequence of using a M o t i f W i d -\ng e t F a c t o r y . Applicability\nUse the Abstrac t Factor y patter n when\n• a syste m s h o u l d be independen t of how its product s are created , c o m p o s e d ,\nand represented. • a syste m shoul d be configure d with one of multipl e familie s of products. • a famil y of relate d produc t object s is d e s i g n e d to be u s ed together , and you\nn e ed to enforc e this constraint. • you want to provid e a c l a ss librar y of products , and you want to r e v e a l just\ntheir interfaces, n o t their implementations.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 325, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 849}}
{"id": "computer_science_design_patterns_gof_chunk_0326_7725d17e", "text": "• you want to provid e a c l a ss librar y of products , and you want to r e v e a l just\ntheir interfaces, n o t their implementations. S t r u c t u r e\n\nptgA B S T R A C T FACTORY 89\nP a r t i c i p a n t s\n• AbstractFactor y (WidgetFactory)\n- d e c l a r e s an interfac e for operation s that creat e abstrac t produc t objects. • ConcreteFactor y (MotifWidgetFactory , PMWidgetFactory)\n- implement s the operation s to creat e c o n c r e t e produc t o b j e c t s . • AbstractProduc t ( W i n d o w , S c r o l l B a r )\n- d e c l a r e s an interfac e for a type of produc t object. • ConcreteProduc t (MotifWindow , MotifScrollBar)\n- define s a produc t o b j e c t to be c r e a t e d by the correspondin g c o n c r e t e factory. - implement s the AbstractProduc t interface. • Client\n- u s es only interface s declare d by AbstractFactor y and AbstractProduc t\nc l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 326, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 890}}
{"id": "computer_science_design_patterns_gof_chunk_0327_23459f8d", "text": "- implement s the AbstractProduc t interface. • Client\n- u s es only interface s declare d by AbstractFactor y and AbstractProduc t\nc l a s s e s . C o l l a b o r a t i o n s\n• Normall y a s i n g l e instanc e of a ConcreteFactor y c l a ss is c r e a t e d at run-time . T h is concret e factor y c r e a t e s produc t o b j e c t s havin g a particula r implementa-\ntion. To creat e differen t produc t objects , c l i e n t s shoul d use a differen t concret e \nfactory. • AbstractFactory defers creation of p r o d u c t o b j e c t s to its ConcreteFactory sub -\nc l a s s . C o n s e q u e n c e s\nThe Abstrac t Factor y patter n has the followin g benefit s and l i a b i l i t i e s :\n1. It isolates concrete classes. The Abstrac t Factor y patter n h e l ps you contro l the\nc l a s s e s of object s t h at an applicatio n c r e a t e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 327, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 851}}
{"id": "computer_science_design_patterns_gof_chunk_0328_21416704", "text": "It isolates concrete classes. The Abstrac t Factor y patter n h e l ps you contro l the\nc l a s s e s of object s t h at an applicatio n c r e a t e s . B e c a u s e a factor y encapsulate s\nthe r e s p o n s i b i l i t y and the p r o c e s s of creatin g produc t o b j e c t s , it i s o l a t e s c l i e n t s\nf r om implementatio n c l a s s e s . C l i e n t s manipulat e instance s throug h their\nabstrac t interfaces . Produc t c l a ss name s are i s o l a t e d in the implementatio n\nof the c o n c r e t e factory ; they do not appea r in c l i e nt c o d e . 2. It makes exchanging product families easy. The c l a ss of a c o n c r e t e factor y appear s\no n ly o n ce in an application—tha t is, wher e it's instantiated . T h is make s it\ne a sy to chang e the concret e factor y an applicatio n u s e s. It can use differen t\nproduc t configuration s simpl y by changin g the concret e factory .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 328, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_design_patterns_gof_chunk_0329_ed62c3ff", "text": "T h is make s it\ne a sy to chang e the concret e factor y an applicatio n u s e s. It can use differen t\nproduc t configuration s simpl y by changin g the concret e factory . B e c a u s e an \na b s t r a c t factor y c r e a t e s a c o m p l e t e famil y of p r o d u c t s , t he w h o l e produc t\nfamil y c h a n g e s at o n c e. In our user interfac e e x a m p l e , we can switc h from\nM o t i f widget s to Presentatio n Manage r widget s simpl y by s w i t c h i n g the\ncorresponding f a c t o r y objects and recreating the interface. ptg90 CREATIONAL PATTERNS CHAPTER 3\n3. It promotes consistency among products. Whe n produc t object s in a famil y are\nd e s i g n e d to work t o g e t h e r , i t 's importan t that an a p p l i c a t i o n u se o b j e c t s from\nonly one famil y at a time. AbstractFactor y make s this easy to enforce. 4.Supporting new kinds of products is difficult. Extendin g abstrac t factorie s to\nproduc e new kinds of Product s isn't e a s y.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 329, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_design_patterns_gof_chunk_0330_2e0df345", "text": "AbstractFactor y make s this easy to enforce. 4.Supporting new kinds of products is difficult. Extendin g abstrac t factorie s to\nproduc e new kinds of Product s isn't e a s y. That' s becaus e the AbstractFactor y\ninterfac e fixes the set of product s that c an be created . Supportin g new kinds of\nproduct s r e q u i r e s extendin g the f a c t o r y interface , whic h i n v o l v e s changin g\nt he AbstractFactor y c l a ss a nd a ll of i ts s u b c l a s s e s . We d i s c u s s o ne s o l u t i o n to\nthis problem in the Implementation section. I m p l e m e n t a t i o n\nH e re are s o me usefu l technique s for implementin g the Abstrac t Factor y pattern. 1. Factories as singletons. An applicatio n t y p i c a l l y needs o n ly o ne instanc e of a\nConcreteFactor y p er produc t family . So it's usuall y b e st implemente d as a\nS i n g l e t o n ( 1 2 7 ) . 2.Creating the products. AbstractFactor y only d e c l a r e s an interface for creatin g\nproducts .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 330, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_design_patterns_gof_chunk_0331_11854686", "text": "So it's usuall y b e st implemente d as a\nS i n g l e t o n ( 1 2 7 ) . 2.Creating the products. AbstractFactor y only d e c l a r e s an interface for creatin g\nproducts . It's up to ConcreteProduc t s u b c l a s s e s to actuall y c r e a t e them . The\nmost commo n way to do this is to defin e a factor y metho d ( s ee Factor y\nMetho d ( 1 0 7 ) ) for each product . A concret e factor y w i ll s p e c i f y its product s\nby overridin g the f a c t o r y metho d for e a c h. Whil e this implementatio n is\ns i m p l e , it r e q u i r e s a new c o n c r e t e factor y s u b c l a s s for each produc t family , \ne v en if the produc t familie s d i f f er o n ly s l i g h t l y . If many produc t familie s are p o s s i b l e , the c o n c r e t e f a c t o r y can be i m p l e -\nmente d using the Prototyp e ( 1 1 7) pattern .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 331, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 840}}
{"id": "computer_science_design_patterns_gof_chunk_0332_271d660e", "text": "If many produc t familie s are p o s s i b l e , the c o n c r e t e f a c t o r y can be i m p l e -\nmente d using the Prototyp e ( 1 1 7) pattern . The concret e f a c t o r y is initialize d\nwith a prototypica l instanc e of e a ch produc t in the family , and it c r e a t e s a new\nproduc t by c l o n i n g its prototype . The Prototype-base d approac h e l i m i n a t e s\nthe n e ed for a new c o n c r e t e factor y c l a ss for e a ch new produc t family. H e r e ' s a way to implemen t a Prototype-base d factor y in Smalltalk . The\nc o n c r e t e factor y s t o r e s t he p r o t o t y p e s to be c l o n e d in a d i c t i o n a r y c a l l ed\np a r t C a t a l o g . The m e t h o d make: r e t r i e v e s the prototype and clones it:\nmake: partName\n(partCatalog at: partName) copy\nThe concrete factory has a method for adding parts to the catalog.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 332, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 868}}
{"id": "computer_science_design_patterns_gof_chunk_0333_bc8a04e6", "text": "The m e t h o d make: r e t r i e v e s the prototype and clones it:\nmake: partName\n(partCatalog at: partName) copy\nThe concrete factory has a method for adding parts to the catalog. addPart: partTemplat e named: partName\npartCatalog a t : partName put: partTemplate\nPrototypes are added t o t h e factory by identifying them with a symbol:\naFactory a d d P a r t : aPrototype named: #ACMEWidget\nA variatio n on the Prototype-base d approac h is p o s s i b l e in l a n g u a g e s that\ntreat classes as first-class objects (Smalltalk a n d Objective C , f o r example). You\n\nptgA B S T R A C T F A C T O R Y 9 1\ncan think of a c l a ss in these language s as a degenerat e factor y t h at create s\no n ly one kind of product . You can store classes i n s i d e a c o n c r e t e f a c t or y\nthat creat e the variou s concret e product s in v a r i a b l e s , much l i ke prototypes . T h e se c l a s s e s creat e new instance s on behal f of the concret e factory .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 333, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_design_patterns_gof_chunk_0334_df08b8fe", "text": "T h e se c l a s s e s creat e new instance s on behal f of the concret e factory . You\ndefin e a new f a c t o r y by initializin g an instanc e of a c o n c r e t e factor y with\nclasses of product s rathe r than by s u b c l a s s i n g . T h is approac h takes advantag e\nof languag e characteristics , wherea s the pure Pr ot oty pe -b as e d approac h is\nlanguage-independent. L i ke the Prototype-base d factor y in Smalltal k just d i s c u s s e d , the c l a s s - b a s e d\nv e r s i o n w i ll have a s i n g le instanc e variabl e p a r t C a t a l o g , whic h is a d i c t i o -\nnary whos e key is the name of the p a r t. Instea d of storin g prototype s to be\nc l o n e d , p a r t C a t a l o g s t o r e s the c l a s s e s of the products . The metho d m a k e :\nnow looks like this:\nmake: partName \n(partCatalog at: partName) new\n3.Defining extensible factories. AbstractFactor y usuall y define s a differen t op-\neratio n for e a ch kind of produc t it can produce .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 334, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_design_patterns_gof_chunk_0335_ff48f52a", "text": "AbstractFactor y usuall y define s a differen t op-\neratio n for e a ch kind of produc t it can produce . The kinds of product s are\ne n c o d e d in the operatio n signatures . Addin g a new kind of produc t r e q u i r e s\nchangin g the AbstractFactor y interfac e and all the c l a s s e s that d e p e n d on it. A m o re fl exib l e but l e ss safe d e s i g n is to add a paramete r to operation s that\ncreat e objects . T h is paramete r s p e c i f i e s the kind of o b j e c t to be c r e a t e d . It\nc o u ld be a c l a ss identifier , an i n t e g e r , a s t r i n g , or anything e l se that identifie s\nthe k i nd of product . In f a ct with this approach , AbstractFactor y o n ly n e e ds\na s i n g le \" M a k e \" operatio n with a paramete r indicatin g the k i nd of o b j e c t\nto c r e a t e . T h is is the techniqu e used in the Prototype - and the c l a s s - b a s e d\nabstrac t factorie s d i s c u s s e d e a r l i e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 335, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_design_patterns_gof_chunk_0336_10910cad", "text": "T h is is the techniqu e used in the Prototype - and the c l a s s - b a s e d\nabstrac t factorie s d i s c u s s e d e a r l i e r . T h is variatio n is e a s i e r to u se in a dynamicall y typed languag e l i ke S m a l l t a l k\nthan in a staticall y typed languag e l i ke C++. You can use it in C++ o n ly when\nall o b j e c t s have the same abstrac t ba se c l a ss or when the produc t o b j e c t s can\nbe safely c o e r c e d to the c o r r e c t type by the c l i e nt t h at r e q u e s t e d them . The\nimplementatio n s e c t i o n of F a c t o r y Metho d ( 1 0 7) s h o w s h ow to implemen t\nsuch parameterize d operation s in C++. But e v en when no c o e r c i o n is needed , an inheren t proble m r e m a i n s : A ll\nproduct s are returne d to the c l i e nt with the same abstrac t interfac e as g i v en\nby the retur n type. The c l i e nt w i ll not be a b le to differentiat e or make safe\nassumption s abou t the c l a ss of a product .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 336, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_design_patterns_gof_chunk_0337_8ad9fa9f", "text": "The c l i e nt w i ll not be a b le to differentiat e or make safe\nassumption s abou t the c l a ss of a product . If c l i e n t s n e ed to perfor m s u b c l a s s -\ns p e c i f i c o p e r a t i o n s , they won' t be a c c e s s i b l e throug h the abstrac t interface . Althoug h the c l i e nt c o u ld perfor m a downcas t ( e . g ., with d y n a m i c - c a s t in\nC++) , that's not alway s feasibl e or safe, becaus e the downcas t can fail. T h is\nis the classic trade-off f o r a highly flexible and e x t e n s i b l e interface. ptg92 CREATIONAL PATTERNS CHAPTER 3\nS a m p l e C o d e\nW e ' l l a p p ly t he Abstrac t F a c t o r y p a t t e r n to c r e a t i n g t he m a z e s we d i s c u s s e d at t he\nb e g i n n i n g of t h is c h a p t e r . C l a ss M a z e F a c tory c an c r e a t e c o m p o n e n t s of m a z e s . It b u i l d s r o o m s , w a l l s , a nd\nd o o r s betwee n r o o m s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 337, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_design_patterns_gof_chunk_0338_030aab96", "text": "C l a ss M a z e F a c tory c an c r e a t e c o m p o n e n t s of m a z e s . It b u i l d s r o o m s , w a l l s , a nd\nd o o r s betwee n r o o m s . It m i g h t be u s ed by a p r o g r a m that r e a d s p l a ns f or m a z e s\nf r om a file a nd b u i l d s t he c o r r e s p o n d i n g maze . Or it m i g h t be u s ed by a p r o g r a m \nt h at b u i l d s m a z e s r a n d o m l y . P r o g r a m s t h at b u i ld m a z e s t a ke a M a z e F a c t o r y as\nan a r g u m e n t so that t he p r o g r a m m e r c an specif y t he classe s of r o o m s , walls , a nd\nd o o r s to c o n s t r u c t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 338, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 614}}
{"id": "computer_science_design_patterns_gof_chunk_0339_e4488367", "text": "class MazeFactor y {\npublic:\nMazeFactory();\nvirtual Maze* MakeMaze O const\n{ return new Maze; }\nvirtual Wall* MakeWall( ) const\n{ return new Wall; } \nvirtual Room* MakeRoom(in t n) const\n{ return new Room(n); } \nvirtual Door* MakeDoor(Room* rl, Room* r2) const\n{ return new Door(rl, r2); }\nRecal l that the m e m b e r functio n C r e a t e M a z e ( p a ge 84) b u i l d s a s m a l l maze\nc o n s i s t i n g of t wo r o o m s w i th a d o or b e t w e e n t h e m . C r e a t e M a z e h a r d - c o d e s t he\nc l a s s names, making it difficult t o create mazes with different components. H e r e ' s a v e r s i o n o f C r e a t e M a z e t h a t r e m e d i e s t h a t s h o r t c o m i n g b y t a k i n g a\nM a z e F a c t o r y as a p a r a m e t e r :\nMaze* MazeGame::CreateMaz e (MazeFactory k factory) {\nMaze* a M a ze = f a c t o r y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 339, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 852}}
{"id": "computer_science_design_patterns_gof_chunk_0340_6c7b8883", "text": "M a k e M a z e ( ) ;\nRoom* rl = factory.MakeRoom(1);\nRoom* r2 = factory.MakeRoom(2);\nDoor* aDoor = factory.MakeDoor(rl , r2);\naMaze->AddRoom(rl) ;\naMaze->AddRoom(r2);\nrl->SetSide(North , factory.MakeWall()) ;\nrl->SetSide(East , aDoor);\nrl->SetSide(South , factory.MakeWall( ) ) ;\nrl->SetSide(West, factory.MakeWall());\n\nptgA B S T R A C T FACTORY 93\nr2->SetSide(North , factory.MakeWall()) ;\nr2->SetSide(East , factory.MakeWall()) ;\nr2->SetSide(South , factory.MakeWall()) ;\nr2->SetSide(West , aDoor);\nreturn aMaze;\n}\nWe can creat e E n c h a n t e d M a z e F a c t o r y , a factor y for enchante d mazes , by s u b -\nc l a s s i n g M a z e F a c t o r y . E n c h a n t e d M a z e F a c t o r y w i ll overrid e differen t mem-\nber function s and retur n d i f f e r e n t s u b c l a s s e s of Room , W ai 1, e t c .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 340, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 824}}
{"id": "computer_science_design_patterns_gof_chunk_0341_9927f7bb", "text": "E n c h a n t e d M a z e F a c t o r y w i ll overrid e differen t mem-\nber function s and retur n d i f f e r e n t s u b c l a s s e s of Room , W ai 1, e t c . class EnchantedMazeFactor y : public MazeFactor y {\npublic:\nEnchantedMazeFactory();\nvirtual Room* MakeRoom(in t n) const \n{ return new EnchantedRoom(n , CastSpell()) ; }\nvirtual Door* MakeDoor(Room * rl, Room* r2) const\n{ return new DoorNeedingSpell(rl , r2) ; }\nprotected:\nSpell* CastSpell( ) const;\n} ;\nNow suppos e we want to make a maze game in whic h a room can have a bomb\nset in it. If the bomb g o es o f f, it w i ll damag e the walls (at least) . We can make a \nsubclas s of R o om keep track of whethe r the room has a bomb in it and whethe r the\nbomb has g o ne o f f. W e ' l l a l so need a s u b c l a s s of W ai 1 to keep track of the damag e \ndone to the wall. W e ' ll c a ll these c l a s s e s R o o m W i t h A B o m b and B o m b e d W a l l .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 341, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_design_patterns_gof_chunk_0342_d7b7f79a", "text": "W e ' l l a l so need a s u b c l a s s of W ai 1 to keep track of the damag e \ndone to the wall. W e ' ll c a ll these c l a s s e s R o o m W i t h A B o m b and B o m b e d W a l l . The l a st c l a ss we'll defin e is B o m b e d M a z e F a c t o r y , a s u b c l a s s of M a z e F a c t o r y\nt h at e n s u r e s walls are of c l a ss B o m b e d W a l l and room s are of c l a ss\nR o o m W i t h A B o m b . B o m b e d M a z e F a c t o r y o n ly needs to overrid e two functions:\nWall* BombedMazeFactory::MakeWal l () const {\nreturn new BombedWall;\n}\nRoom* BombedMazeFactory::MakeRoom(in t n) const {\nreturn new RoomWithABomb(n);\n}\nTo build a s i m p l e maze that can contai n b o m b s , we simpl y c a ll G r e a t e M a z e with\na B o m b e d M a z e F a c t o r y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 342, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 785}}
{"id": "computer_science_design_patterns_gof_chunk_0343_41a1e718", "text": "MazeGame game;\nBombedMazeFactory factory;\ngame.CreateMaze ( f a c t o r y ) ,•\n\nptg94 CREATIONAL PATTERNS CHAPTER 3\nC r e a t e M a z e can take an i n s t a n c e of E n c h a n t e d M a z e F a c t o r y just as w e ll to\nb u i ld enchante d mazes. N o t i c e that t he M a z e F a c t o r y is just a c o l l e c t i o n of factor y m e t h o d s . T h is is t he\nm o st c o m m o n way to implemen t the Abstrac t Factor y pattern . A l so note that\nM a z e F a c t o r y is not an abstrac t c l a s s; thus it a c ts as both the AbstractFactor y and\nt he C o n c r e t e F a c t o r y . T h is is anothe r commo n implementatio n for s i m p l e a p p l i c a -\nt i o ns of the Abstrac t Factor y pattern . B e c a u s e the M a z e F a c t o r y is a c o n c r e t e c l a ss\nc o n s i s t i n g e n t i r e l y of factor y methods , it's e a sy to make a new M a z e F a c t o r y by\nmakin g a s u b c l a s s and overridin g the operation s that n e ed to c h a n g e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 343, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_design_patterns_gof_chunk_0344_ef39f467", "text": "C r e a t e M a z e used the S e t S i d e operatio n on r o o m s to s p e c i f y their s i d e s . If it\nc r e a t e s r o o m s with a B o m b e d M a z e F a c t o r y , then the maze w i ll be made up of\nR o o m W i t h A B o m b o b j e c t s with B o m b e d W a l l s i d e s . If R o o m W i t h A B o m b had to\na c c e s s a s u b c l a s s - s p e c i f i c membe r of B o m b e d W a l l , then it woul d have to c a st a\nr e f e r e n c e to its w a l ls from W a l l * to B o m b e d W a l l * . T h is d o w n c a s t i n g is safe as\nl o ng as the argumen t is in fact a B o m b e d W a l l , w h i c h is guarantee d to be true if\nw a l ls are built s o l e ly w i th a B o m b e d M a z e F a c t o r y . D y n a m i c a l l y typed language s s u ch as Smalltal k don't r e q u i r e d o w n c a s t i n g , of\nc o u r s e , but they m i g h t produc e run-tim e error s if they encounte r a W a ll wher e\nt h ey e x p e c t a subclass of Wa 1 1.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 344, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_design_patterns_gof_chunk_0345_de62cc19", "text": "U s i ng Abstrac t Factor y to b u i ld w a l ls h e l ps preven t\nt h e se r u n - t i m e error s by e n s u r i n g that o n ly certai n k i n ds of w a l ls c an be c r e a t e d . Let's c o n s i d e r a S m a l l t a l k v e r s i o n of M a z e F a c t o r y , one with a s i n g le m a ke\noperatio n that takes the k i nd of o b j e c t to make as a parameter . M o r e o v e r , the\nc o n c r e t e factory stores the classes of the products it creates. F i r s t , we'll write an equivalent of CreateMaze in Smalltalk:\nCreateMaze : a F a c t o ry \n| r o o ml r o o m2 a D o or | \nr o o ml := ( a F a c t o ry m a k e: # r o o m) n u m b e r: 1. r o o m2 := ( a F a c t o ry make: # r o o m) n u m b e r: 2. a D o or := ( a F a c t o ry make: # d o o r) f r o m: r o o ml to: r o o m 2. r o o ml atSide: t t n o r th put: ( a F a c t o ry make: # w a l l ). r o o ml atSide: #east put: a D o o r. r o o ml atSide: t t s o u th put: ( a F a c t o ry m a k e: # w a l l ).", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 345, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_design_patterns_gof_chunk_0346_542816b6", "text": "r o o ml atSide: t t n o r th put: ( a F a c t o ry make: # w a l l ). r o o ml atSide: #east put: a D o o r. r o o ml atSide: t t s o u th put: ( a F a c t o ry m a k e: # w a l l ). r o o ml atSide: t t w e st put: ( a F a c t o ry m a k e: # w a l l ). r o o m2 atSide: # n o r th put: ( a F a c t o ry make: # w a l l ). r o o m2 atSide: # e a st put: ( a F a c t o ry make: # w a l l ). r o o m2 atSide: t t s o u th put: ( a F a c t o ry m a k e: # w a l l ). r o o m2 atSide: f t w e st put: a D o o r. ~ Maze new addRoom: rooml; addRoom: r o o m 2 ; yourself\nAs we d i s c u s s e d in t he Implementatio n s e c t i o n , M a z e F a c t o r y n e e ds o n ly a s i n g le\ni n s t a n c e variabl e p a r t C a t a l o g to provid e a dictionar y whos e key is the c l a ss of\nt h e component.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 346, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 802}}
{"id": "computer_science_design_patterns_gof_chunk_0347_51590dcc", "text": "Also recall how we implemented t h e make: m e t h o d :\nmake: partName\n( p a r t C a t a l o g a t : partName) n e w\n\nptgA B S T R A C T F A C T O R Y 9 5\nNow we can creat e a M a z e F a c t o r y and use it to implemen t c r e a t e M a z e . W e ' ll\ncreate the factory using a method createMazeFactory of class MazeGame. createMazeFactor y \n\" ( M a z e F a c t o r y new \naddPart: Wall n a m e d: #wall;\naddPart: Room n a m e d: #room;\naddPart: D o or named: #door;\nyourself)\nA B o m b e d M a z e F a c t o r y or E n c h a n t e d M a z e F a c t o r y is create d by a s s o c i a t i n g\ndifferen t c l a s s e s with the keys.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 347, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 636}}
{"id": "computer_science_design_patterns_gof_chunk_0348_b00ffa98", "text": "For e x a m p l e , an E n c h a n t e d M a z e F a c t o r y c o u ld\nbe created like this:\ncreateMazeFactor y \n( M a z e F a c t o r y n ew \naddPart: Wall n a m e d: ttwall; \naddPart: EnchantedRoo m n a m e d: #room;\naddPart: DoorNeedingSpel l n a m e d: #door;\nyourself)\nK n o w n U s e s\nI n t e r v i e w s u s es the \" K i t\" s u f f ix [ L i n 9 2 ] to denot e AbstractFactor y c l a s s e s . It de-\nfines WidgetKi t and DialogKi t abstrac t factorie s for generatin g l o o k - a n d - f e e l -\nspecifi c user interfac e objects . I n t e r v i e w s also i n c l u d e s a LayoutKi t that g e n e r a t e s\ndifferen t compositio n o b j e c t s dependin g on the layou t d e s i r e d . For e x a m p l e , a\nlayou t that is conceptuall y horizonta l may requir e differen t compositio n object s\nd e p e n d i n g on the document' s orientatio n (portrai t or landscape).", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 348, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 884}}
{"id": "computer_science_design_patterns_gof_chunk_0349_5738c958", "text": "For e x a m p l e , a\nlayou t that is conceptuall y horizonta l may requir e differen t compositio n object s\nd e p e n d i n g on the document' s orientatio n (portrai t or landscape). ET++ [ W G M 8 8 ] u s es the Abstrac t Factor y patter n to a c h i e v e portabilit y a c r o s s\ndifferen t windo w s y s t e m s (X W i n d o w s and S u n V i e w , for example) . The W i n -\ndowSyste m abstrac t b a se c l a ss define s the interfac e for c r e a t i n g o b j e c t s that r e p r e -\ns e nt windo w s y s t e m r e s o u r c e s (MakeWindow , MakeFont , M a k e C o l o r , for exam-\nple). Concret e s u b c l a s s e s implemen t the interface s for a s p e c i f i c windo w s y s t e m . At run-time , ET++ create s an i n s t a n c e of a c o n c r e t e W i n d o w S y s t e m s u b c l a s s that\ncreates concrete system resource objects.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 349, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 856}}
{"id": "computer_science_design_patterns_gof_chunk_0350_e0b3e50d", "text": "At run-time , ET++ create s an i n s t a n c e of a c o n c r e t e W i n d o w S y s t e m s u b c l a s s that\ncreates concrete system resource objects. Related P a t t e r n s\nAbstractFactor y c l a s s e s are o f t en implemente d with f a c t o r y method s (Factor y\nMethod (107)), but they can also be implemented using Prototype (117). A concrete factory is often a singleton (Singleton (127)). ptg\nThis page intentionally left blank \n\nptgBUILDER 97\nBUILDER O b j e c t Creational\nIntent\nSeparat e the constructio n of a c o m p l e x objec t from its representatio n so that the\nsame construction process can create different r e p r e s e n t a t i o n s . M o t i v a t i o n\nA reade r f or the RTF (Rich T e xt Format ) documen t exchang e f o r m a t shoul d be able\nto conver t RTF to many text formats . The reade r migh t conver t RTF document s\ninto plain A S C I I text or into a text widge t that can be e d i t e d i n t e r a c t i v e l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 350, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_design_patterns_gof_chunk_0351_db50aad6", "text": "The reade r migh t conver t RTF document s\ninto plain A S C I I text or into a text widge t that can be e d i t e d i n t e r a c t i v e l y . The\np r o b l e m , h o w e v e r , is that t he n u m b e r of p o s s i b l e c o n v e r s i o n s is o p e n - e n d e d . So\nit shoul d be e a sy to add a new conversio n withou t modifyin g the reader. A solutio n is to configur e the RTFReade r c l a ss with a TextConverte r o b j e c t that\nconvert s RTF to anothe r textua l representation . As the R T F R e a d e r parse s the RTF\ndocument , it u s es the TextConverte r to perfor m the c o n v e r s i o n . Wheneve r the\nR T F R e a d e r r e c o g n i z e s an RTF token (eithe r plain text or an RTF c o n t r o l word) , it\ni s s u e s a reques t to the TextConverte r to conver t the token . TextConverte r o b j e c t s\nare r e s p o n s i b l e both for performin g the data c o n v e r s i o n and for representin g the\ntoken in a p a r t i c u l a r format.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 351, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_design_patterns_gof_chunk_0352_01d47027", "text": "TextConverte r o b j e c t s\nare r e s p o n s i b l e both for performin g the data c o n v e r s i o n and for representin g the\ntoken in a p a r t i c u l a r format. S u b c l a s s e s of T e x t C o n v e r t e r s p e c i a l i z e in differen t c o n v e r s i o n s a nd formats . F or\ne x a m p l e , an A S C I I C o n v e r t e r i g n o r e s request s to conver t anythin g e x c e p t plain \ntext. A T e X C o n v e r t e r , on the other hand , w i ll implemen t operation s for all request s\nin order to produc e a T p ^X representatio n that capture s all the s t y l i s t i c informatio n\nin the text. A TextWidgetConverte r w i ll produc e a comple x user interfac e o b j e c t\nthat lets the user see and edit the text. ptg9 8 CREATIONAL PATTERNS CHAPTER 3\nEach kind of converte r c l a ss takes the mechanis m for creatin g and a s s e m b l i n g a\ncomple x o b j e c t and puts it behin d an abstrac t interface .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 352, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_design_patterns_gof_chunk_0353_5195a1eb", "text": "ptg9 8 CREATIONAL PATTERNS CHAPTER 3\nEach kind of converte r c l a ss takes the mechanis m for creatin g and a s s e m b l i n g a\ncomple x o b j e c t and puts it behin d an abstrac t interface . The converte r is separat e\nfrom the reader , whic h is r e s p o n s i b l e for parsin g an RTF document. T he B u i l d e r patter n capture s a ll these relationships . Each converte r c l a ss is c a l l ed\na builde r in the pattern , and the reade r is c a l l ed the director . A p p l i e d to t h is\nexample , the Builde r patter n separate s the algorith m for interpretin g a textual\nf o r m a t (that is, the parse r for RTF documents ) from how a converte d f o r m a t g e ts\ncreate d and represented . T h is lets us r e u se the RTFReader' s parsin g algorith m\nto creat e differen t text representation s f r om RTF documents—jus t configur e the\nR T F R e a d e r with different s u b c l a s s e s of T e x t C o n v e r t e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 353, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_design_patterns_gof_chunk_0354_38feb13b", "text": "Applicability\nUse the Builde r patter n when\n• the algorith m for creatin g a c o m p l e x o b j e c t s h o u l d be i n d e p e n d e n t of the\nparts that make up the objec t and how they'r e a s s e m b l e d . • the constructio n p r o c e s s m u st a l l ow differen t representation s for the o b j e c t\nthat's c o n s t r u c t e d . S t r u c t u r e\nParticipants\n• Builder (TextConverter)\n- specifies an abstract interface for creating parts of a Product object. ptgBUILDER 9 9\n• ConcreteBuilde r (ASCIIConverter , TeXConverter , TextWidgetConverter)\n- construct s and a s s e m b l e s parts of the produc t by implementin g the B u i l d e r\ninterface. - define s and keep s track of the representatio n it creates. - provide s an interfac e for retrievin g the produc t ( e . g ., G e t A S C I I T e x t , G e t -\nT e xt Widget). • Directo r (RTFReader)\n- construct s an objec t using the Builde r interface.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 354, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 925}}
{"id": "computer_science_design_patterns_gof_chunk_0355_913bf1e4", "text": "- provide s an interfac e for retrievin g the produc t ( e . g ., G e t A S C I I T e x t , G e t -\nT e xt Widget). • Directo r (RTFReader)\n- construct s an objec t using the Builde r interface. • P r o d u c t ( A S C I I T e x t , T e X T e x t , TextWidget)\n- represent s the comple x o b j e c t unde r construction . ConcreteBuilde r build s\nthe product' s interna l representatio n and define s the p r o c e s s by w h i c h it's\nassembled. - include s c l a s s e s that defin e the constituen t parts , includin g interface s for\na s s e m b l i n g the parts into the final result. C o l l a b o r a t i o n s\n• The c l i e n t create s the D i r e c t o r objec t and configure s it with the d e s i r e d Builde r\nobject. •D i r e c t o r notifie s the builde r wheneve r a part of the produc t s h o u l d be built. •Builde r handle s request s from the directo r and adds parts to the product. •T he c l i e nt r e t r i e v e s t he produc t from t he b u i l d e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 355, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_design_patterns_gof_chunk_0356_83fa854b", "text": "•Builde r handle s request s from the directo r and adds parts to the product. •T he c l i e nt r e t r i e v e s t he produc t from t he b u i l d e r . The followin g interactio n diagra m illustrate s how Builde r and Directo r cooperat e\nwith a client. ptg100 CREATIONAL PATTERNS CHAPTER 3\nC o n s e q u e n c e s\nH e re are key c o n s e q u e n c e s of the Builde r pattern:\n1. It lets you vary a product's internal representation. The Builde r o b j e c t provide s\nthe directo r with an abstrac t interfac e for constructin g the product . The in-\nterfac e lets the builde r h i de the representatio n and interna l structur e of the\nproduct . It a l so h i d es how the produc t g e ts a s s e m b l e d . B e c a u s e the produc t\nis constructe d throug h an abstrac t interface , all you have to do to chang e the\nproduct' s interna l representatio n is defin e a new kind of b u i l d e r . 2. It isolates code for construction and representation.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 356, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_design_patterns_gof_chunk_0357_99836439", "text": "2. It isolates code for construction and representation. The B u i l d e r patter n i m p r o v e s\nmodularit y by encapsulatin g the way a comple x o b j e c t is constructe d and\nrepresented . C l i e n t s needn' t know anythin g abou t the c l a s s e s t h at defin e the\nproduct' s interna l structure ; such c l a s s e s don't appea r in Builder' s interface. Each C o n c r e t e B u i l d e r contain s all the c o de to creat e and a s s e m b l e a partic-\nular kind of product . The c o de is writte n o n c e; then differen t D i r e c t o r s can\nreuse it to build Produc t variant s from the same set of parts . In the e a r l i e r\nRTF e x a m p l e , we c o u ld defin e a reade r for a f o r m a t other than R T F, s a y,\nan S G M L R e a d e r , and use the same TextConverter s to generat e A S C I I T e x t ,\nT e X T e x t , a nd T e x t W i d g e t rendition s of S G M L documents. 3. It gives you finer control over the construction process.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 357, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_design_patterns_gof_chunk_0358_5764292b", "text": "3. It gives you finer control over the construction process. U n l i k e creationa l pat-\nterns that construc t product s in one s h o t, the B u i l d e r patter n construct s the\nproduc t step by step unde r the director' s c o n t r o l . Only when the produc t\nis finishe d d o es the directo r retriev e it f r om the b u i l d e r . H e n c e the B u i l d e r\ninterfac e reflect s the p r o c e s s of constructin g the produc t more than other c r e -\nationa l patterns . T h is g i v es you finer contro l over the constructio n p r o c e s s\nand consequently the internal structure of the resulting product. I m p l e m e n t a t i o n\nT y p i c a l l y there' s an abstrac t Builde r c l a ss that define s an operatio n for e a ch c o m -\nponen t t h at a directo r may ask it to c r e a t e . The operation s do nothin g by default . A C o n c r e t e B u i l d e r c l a ss override s operation s for component s it's intereste d in\nc r e a t i n g .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 358, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_design_patterns_gof_chunk_0359_bb58b793", "text": "The operation s do nothin g by default . A C o n c r e t e B u i l d e r c l a ss override s operation s for component s it's intereste d in\nc r e a t i n g . H e re are other implementatio n i s s u e s to c o n s i d e r :\n1. Assembly a nd construction interface. B u i l d e r s c o n s t r u c t t h e ir p r o d u c t s in s t e p -\nb y - s t e p fashion . Therefor e the B u i l d e r c l a ss interfac e must be genera l enoug h\nto allow the constructio n of product s for all kinds of concret e builders. A key d e s i g n i s s ue c o n c e r n s the mode l for the constructio n and a s s e m b l y\np r o c e s s . A mode l wher e the result s of constructio n request s are simpl y ap-\npende d to the produc t is usuall y sufficient . In the RTF example , the builde r\nconvert s and append s the next token to the text it has converte d so far. B ut s o m e t i m e s y ou m i g h t n e ed a c c e s s to parts of t he produc t c o n s t r u c t e d\ne a r l i e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 359, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_design_patterns_gof_chunk_0360_cca23d16", "text": "B ut s o m e t i m e s y ou m i g h t n e ed a c c e s s to parts of t he produc t c o n s t r u c t e d\ne a r l i e r . In the Maze example w e present in the Sample Code, the M a z e B u i l d e r\n\nptgBUILDER 1 0 1\ninterfac e l e ts you add a d o or betwee n existin g rooms . T r ee structure s such\nas parse trees t h at are built bottom-u p are anothe r example . In that c a s e,\nthe builde r woul d retur n c h i ld n o d e s to the d i r e c t o r , whic h then woul d pass\nthem back to the builde r to build the paren t n o d e s . 2. Why no abstract class for products? In the commo n c a s e, the product s produce d\nby the c o n c r e t e builder s d i f f er so greatl y in their representatio n t h at there\nis little to gain f r om g i v i n g differen t product s a commo n paren t c l a s s . In\nthe RTF example , the A S C I I T e x t and the T e x t W i d g e t object s are unlikel y to\nhave a commo n interface , nor do they n e ed o n e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 360, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_design_patterns_gof_chunk_0361_9ac01861", "text": "In\nthe RTF example , the A S C I I T e x t and the T e x t W i d g e t object s are unlikel y to\nhave a commo n interface , nor do they n e ed o n e. B e c a u s e the c l i e n t usuall y\nconfigure s the directo r with the prope r c o n c r e t e builder , the c l i e nt is in a\npositio n to know whic h concret e s u b c l a s s of B u i l d e r is in use and can handl e\ni ts p r o d u c t s a c c o r d i n g l y . 3.Empty methods as default in Builder. In C++, the build method s are intention-\na l ly not d e c l a r e d pure virtua l membe r functions . They'r e define d as empt y\nmethods instead, letting clients override only the operations they're inter -\ne s t e d in. Sample C o d e\nW e ' ll defin e a varian t of the C r e a t e M a z e membe r functio n (page 84) that takes a\nbuilde r of c l a ss M a z e B u i l d e r as an argument.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 361, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 851}}
{"id": "computer_science_design_patterns_gof_chunk_0362_49811b37", "text": "Sample C o d e\nW e ' ll defin e a varian t of the C r e a t e M a z e membe r functio n (page 84) that takes a\nbuilde r of c l a ss M a z e B u i l d e r as an argument. The M a z e B u i l d e r c l a ss define s the followin g interfac e for buildin g mazes:\nclass MazeBuilde r {\npublic:\nvirtual void BuildMaze O { } \nvirtual void BuildRoom(in t room) { } \nvirtual void BuildDoor(in t roomFrom , int roomTo) { }\nvirtual Maze* GetMaze( ) { return 0; }\nprotected:\nMazeBuilder() ;\n} ;\nT h is interfac e can creat e three things : (1) the maze , (2) room s with a particula r\nroom number , and (3) d o o rs betwee n numbere d rooms . The G e t M a z e operatio n\nreturn s the maze to the client . S u b c l a s s e s of M a z e B u i l d e r w i ll overrid e this\noperatio n to r e t u r n the maze that they build. All the maze-buildin g operation s of Ma z e Bu i 1 de r do nothin g by default .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 362, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_design_patterns_gof_chunk_0363_6b1cf768", "text": "S u b c l a s s e s of M a z e B u i l d e r w i ll overrid e this\noperatio n to r e t u r n the maze that they build. All the maze-buildin g operation s of Ma z e Bu i 1 de r do nothin g by default . T h e y ' r e\nnot d e c l a r e d pure virtua l to let derive d c l a s s e s overrid e only those method s in\nwhic h they'r e interested. Give n the M a z e B u i l d e r interface , we can chang e the C r e a t e M a z e membe r\nfunction to take this b u i l d e r as a parameter. ptg102 CREATIONAL PATTERNS CHAPTER 3\nMaze* MazeGame::CreateMaz e ( M a z e B u i l d e r & builder) {\nbuilder.BuildMaze();\nbuilder.BuildRoom(1) ;\nbuiIder.BuiIdRoom(2) ;\nbuilder.BuildDoor(1 , 2);\nreturn builder.GetMaze() ;\n}\nC o m p a r e t h is v e r s i o n of C r e a t e M a z e with t he o r i g i n a l .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 363, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 793}}
{"id": "computer_science_design_patterns_gof_chunk_0364_9afd4519", "text": "N o t i c e h ow t he b u i l d e r\nh i d es t he i n t e r n a l r e p r e s e n t a t i o n of t he Maze—tha t i s, t he c l a s s e s t h at defin e \nr o o m s , d o o r s , a nd walls—an d h ow t h e se p a r ts a re a s s e m b l e d to c o m p l e t e t he\nf i n al maze . S o m e o n e m i g h t g u e ss that t h e re a re c l a s s e s f or r e p r e s e n t i n g r o o m s\na nd d o o r s , b ut t h e re is no h i nt of o ne f or walls . T h is m a k e s it e a s i e r to c h a n g e t he\nway a m a ze is r e p r e s e n t e d , s i n ce n o ne of the c l i e n t s of M a z e B ui I d er has to be\nc h a n g e d . L i ke t he o t h er c r e a t i o n a l p a t t e r n s , t he B u i l d e r p a t t e r n e n c a p s u l a t e s h ow o b -\njects g et c r e a t e d , in t h is c a se t h r o u g h t he i n t e r f a c e d e f i n e d by M a z e B u i l d e r . T h at m e a n s we c an r e u se M a z e B u i l d e r to b u i ld d i f f e r e n t k i n d s of mazes .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 364, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_design_patterns_gof_chunk_0365_f5e6c8ac", "text": "T h at m e a n s we c an r e u se M a z e B u i l d e r to b u i ld d i f f e r e n t k i n d s of mazes . T he\nC r e a t e C o m p l e x M a z e o p e r a t i o n g i v es an e x a m p l e :\nMaze* MazeGame::CreateComplexMaz e ( M a z e B u i l d e r & builder) {\nbuiIder.BuiIdRoom(1);\n// . . . b u i I d e r . B u i I d R o o m ( 1 0 0 1 ) ;\nreturn builder.GetMaze() ;\n}\nN o te that M a z e B u i l d e r d o es n ot c r e a t e m a z e s itself ; i ts m a in p u r p o s e is j u st to\ndefin e an i n t e r f a c e f or c r e a t i n g m a z e s . It d e f i n e s e m p t y i m p l e m e n t a t i o n s p r i m a r i l y\nf or c o n v e n i e n c e . S u b c l a s s e s of M a z e B u i l d e r do t he a c t u a l w o r k . T he s u b c l a s s S t a n d a r d M a z e B u i l d e r is an i m p l e m e n t a t i o n t h at b u i l d s s i m p l e\nmazes . It k e e p s t r a ck of t he m a ze it's b u i l d i n g in t he v a r i a b l e _ c u r r e n t M a z e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 365, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_design_patterns_gof_chunk_0366_e1676784", "text": "It k e e p s t r a ck of t he m a ze it's b u i l d i n g in t he v a r i a b l e _ c u r r e n t M a z e . class StandardMazeBuilde r : public MazeBuilde r {\npublic:\nStandardMazeBuilder();\nvirtual void BuildMaze() ;\nvirtual void BuildRoom(int) ;\nvirtual void BuildDoor(int , int);\nvirtual Maze* GetMaze (),-\nprivate:\nDirectio n CommonWall(Room* , Room*);\nMaze* _currentMaze;\n} ;\n\nptgBUILDER 1 0 3\nC o m m o n W a l l is a utility operatio n that determine s the d i r e c t i o n of the commo n\nwall betwee n two r o o m s . The S t a n d a r d M a z e B u i l d e r c o n s t r u c t o r s i m p l y initialize s _ c u r r e n t M a z e . S t a n d a r d M a z e B u i l d e r : : S t a n d a r d M a z e B u i l d e r () {\n_ c u r r e n t M a z e = 0;\n}\nB u i l d M a z e instantiates a Maze that other operations will assemble a n d e v e n t u -\nally return to the client (with GetMaze).", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 366, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_design_patterns_gof_chunk_0367_e033bc41", "text": "void StandardMazeBuilder::BuildMaz e () {\n_currentMaz e = new Maze;\n}\nM a z e* S t a n d a r d M a z e B u i l d e r : : G e t M a z e () {\nr e t u r n _currentMaze;\n}\nThe BuildRoom operation creates a room and builds the walls around it:\nvoid StandardMazeBuilder::BuildRoo m ( i nt n) {\nif ( !", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 367, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 294}}
{"id": "computer_science_design_patterns_gof_chunk_0368_79580528", "text": "_ c u r r e n t M a z e - > R o o m N o ( n ) ) {\nRoom* r o om - new Room(n);\n_currentMaze->AddRoom(room);\nr o o m - > S e t S i d e ( N o r t h , n ew W a l l );\nroom->SetSide(South , new Wall);\nroom->SetSide(East , new Wall);\nroom->SetSide(West , new Wall);\n}\n}\nTo build a d o or b e t w e e n t wo r o o m s , S t a n d a r d M a z e B u i l d e r l o o ks up b o th\nr o o m s in the maze and finds their adjoining wall:\nvoid StandardMazeBuilder:rBuildDoo r ( i nt nl, int n2) {\nRoom* rl = _currentMaze->RoomNo(nl);\nRoom* r2 = _currentMaze->RoomNo(n2) ;\nD o o r* d = new Door(rl, r2);\nr l - > S e t S i d e ( C o m m o n W a l l ( r l , r 2 ) , d );\nr2->SetSide(CommonWall(r2,rl), d);\n}\nC l i e n t s c an n ow u se C r e a t e M a z e in c o n j u n c t i o n w i th S t a n d a r d M a z e B u i l d e r\nt o create a maze:\n\nptg104 CREATIONAL PATTERNS CHAPTER 3\nMaze* maze;\nMazeGame game;\nStandardMazeBuilde r builder;\ngame.CreateMaze(builder) ;\nmaze = builder.GetMaze();\nWe c o u ld h a ve put all the S t a n d a r d M a z e B u i l d e r o p e r a t i o n s in M a z e and let\ne a ch M a z e b u i ld itself .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 368, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1116}}
{"id": "computer_science_design_patterns_gof_chunk_0369_18a1d0c9", "text": "But m a k i n g M a z e s m a l l e r m a k e s it e a s i e r to u n d e r s t a n d\nand modify , and S t a n d a r d M a z e B u i l d e r is e a sy to s e p a r a t e f r om M a z e . M o st\ni m p o r t a n t l y , s e p a r a t i n g the two l e ts you h a ve a variet y of M a z e B u i l d e r s , e a ch\nu s i ng differen t c l a s s e s f or r o o m s , walls , a nd d o o r s . A m o re e x o t i c M a z e B u i l d e r is C o u n t i n g M a z e B u i l d e r . T h is b u i l d e r d o e s n ' t\nc r e a t e a m a ze at a l l; it j u st c o u n t s t he d i f f e r e n t k i n d s of c o m p o n e n t s t h at w o u l d\nh a ve b e en c r e a t e d .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 369, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 663}}
{"id": "computer_science_design_patterns_gof_chunk_0370_0145ff1f", "text": "T h is b u i l d e r d o e s n ' t\nc r e a t e a m a ze at a l l; it j u st c o u n t s t he d i f f e r e n t k i n d s of c o m p o n e n t s t h at w o u l d\nh a ve b e en c r e a t e d . class CountingMazeBuilde r : public MazeBuilde r {\npublic:\nCountingMazeBuilder();\nvirtual void BuildMaze() ; \nvirtual void BuildRoom(int) ; \nvirtual void BuildDoor(int , int);\nvirtual void AddWall(int , Direction);\nvoid GetCounts(int& , i n t &) const;\nprivate:\nint _doors;\nint _rooms;\n} ;\nT he c o n s t r u c t o r initialize s t he c o u n t e r s , a nd t he o v e r r i d d e n M a z e B u i l d e r o p e r -\na t i o n s i n c r e m e n t t h em a c c o r d i n g l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 370, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 666}}
{"id": "computer_science_design_patterns_gof_chunk_0371_031ee2ce", "text": "CountingMazeBuilder::CountingMazeBuilde r () {\n_rooms = _doors = 0;\n}\nvoid CountingMazeBuilder::BuildRoo m ( i n t) {\n_rooms++ ;\n}\nvoid CountingMazeBuilder::BuildDoo r ( i n t, int) {\n_doors++ ;\n}\nvoid CountingMazeBuilder::GetCount s (\ni n t& rooms, i n t& d o o r s\n) c o n st { \nr o o ms = _rooms;\nd o o r s = _doors;\n}\n\nptgBUILDER 105\nH e r e ' s how a client might use a Count ingMazeBuilder:\nint rooms, doors;\nMazeGame game;\nCountingMazeBuilde r builder;\ngame.CreateMaze(builder) ;\nbuilder.GetCounts(rooms , doors);\ncout « \" T he maze has \" « rooms « \" r o o ms and \" \n« doors « \" doors\" « endl;\nKnown U s e s\nThe RTF converte r applicatio n is from ET++ [ W G M 8 8 ] . Its text buildin g b l o ck\nu s es a builde r to p r o c e s s text s t o r ed in the RTF f o r m a t . Builde r is a commo n patter n in S m a l l t a l k - 8 0 [ P a r 9 0 ] :\n• The Parse r c l a ss in the c o m p i l e r subsyste m is a Directo r that takes a P r o -\ngramNodeBuilde r o b j e c t as an argument .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 371, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_design_patterns_gof_chunk_0372_96718da9", "text": "A Parse r o b j e c t notifie s its P r o -\ngramNodeBuilde r o b j e c t e a ch time it r e c o g n i z e s a syntacti c construct . Whe n\nthe parse r is d o n e , it a s ks the builde r for the parse tree it built and return s it\nto the client. • C l a s s B u i l d e r is a builde r that C l a s s e s use to c r e a te s u b c l a s s e s for themselves . In this c a se a C l a ss is both the D i r e c t o r and the Product. • B y t e C o d e S t r e a m is a builde r that create s a c o m p i l e d metho d as a byte ar-\nr a y. B y t e C o d e S t r e a m is a nonstandar d use of the Builde r pattern , b e c a u s e \nthe comple x o b j e c t it build s is e n c o d e d as a byte array , not as a norma l\nS m a l l t a l k object . But the interfac e to B y t e C o d e S t r e a m is typica l of a b u i l d e r ,\nand it woul d be e a sy to r e p l a c e B y t e C o d e S t r e a m with a differen t c l a ss that\nrepresente d program s as a composit e object.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 372, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_design_patterns_gof_chunk_0373_8f8e2b06", "text": "The S e r v i c e Configurator f r a m e w o r k from the Adaptiv e Communication s E n v i -\nronmen t uses a b u i l d e r to construc t networ k s e r v i c e component s that are l i n k e d\ninto a s e r v e r at run-tim e [ S S 9 4 ] . The component s are d e s c r i b e d with a config-\nuratio n languag e that's p a r s e d by an L A L R ( l ) parser . The semanti c a c t i o n s of\nthe parse r perfor m operation s on the builde r that add informatio n to the s e r v i c e\ncomponent. In this case, the parser is the Director. Related Patterns\nAbstrac t Factor y ( 8 7) is s i m i l a r to B u i l d e r in that it too may construc t c o m p l e x\no b j e c t s . The primar y differenc e is that the B u i l d e r patter n focuse s on constructin g a\nc o m p l e x o b j e c t step by s t e p. Abstrac t Factory' s e m p h a s i s is on familie s of produc t\no b j e c t s ( e i t h e r s i m p l e o r c o m p l e x ) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 373, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_design_patterns_gof_chunk_0374_1c6c3b92", "text": "Abstrac t Factory' s e m p h a s i s is on familie s of produc t\no b j e c t s ( e i t h e r s i m p l e o r c o m p l e x ) . B u i l d e r r e t u r n s t h e p r o d u c t a s a f i n a l step,\n\nptg1 06 CREATIONAL PATTERNS CHAPTER 3\nbut as far as the Abstrac t Factor y patter n is c o n c e r n e d , the produc t g e ts returne d\nimmediately. A Composite (163) i s what the builder often b u i l d s . ptgFACTORY M E T H O D 107\nF A C T O R Y METHOD C l a s s C r e a t i o n a l\nIntent\nDefin e an interfac e for creatin g an o b j e c t , but let s u b c l a s s e s d e c i d e w h i c h c l a ss to\ninstantiate. Factory Method lets a class defer instantiation to subclasses. Also Known As\nVirtual Constructor\nMotivation\nFramework s use abstrac t c l a s s e s to defin e and maintai n r e l a t i o n s h i p s betwee n\nobjects . A f r a m e w o r k is often r e s p o n s i b l e for creatin g t h e se object s as w e l l .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 374, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_design_patterns_gof_chunk_0375_5434c8f4", "text": "A f r a m e w o r k is often r e s p o n s i b l e for creatin g t h e se object s as w e l l . C o n s i d e r a framewor k for application s that can p r e s e n t multipl e document s to\nt he u s e r. T wo k ey abstraction s in t h is framewor k a re t he c l a s s e s Applicatio n a nd\nDocument . Both c l a s s e s are abstract , and c l i e n t s have to s u b c l a s s them to r e a l i z e\ntheir application-specifi c implementations . To creat e a drawin g a p p l i c a t i o n , for\ne x a m p l e , we defin e t he c l a s s e s DrawingApplicatio n a nd D r a w i n g D o c u m e n t . T he\nApplicatio n c l a ss is r e s p o n s i b l e f or managin g D o c u m e n t s a nd w i ll c r e a t e them as\nrequired—whe n the u ser s e l e c t s O p en or New from a menu , for example.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 375, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 795}}
{"id": "computer_science_design_patterns_gof_chunk_0376_3861b967", "text": "T he\nApplicatio n c l a ss is r e s p o n s i b l e f or managin g D o c u m e n t s a nd w i ll c r e a t e them as\nrequired—whe n the u ser s e l e c t s O p en or New from a menu , for example. B e c a u s e t he particula r D o c u m e n t s u b c l a s s to instantiat e is a p p l i c a t i o n - s p e c i f i c , t he\nApplicatio n c l a ss can't predic t t he s u b c l a s s of Documen t to instantiate—th e A p -\nplicatio n c l a ss o n ly know s when a new documen t s h o u l d be c r e a t e d , not what kind \nof D o c u m e n t to c r e a t e . T h is c r e a t e s a d i l e m m a : The framewor k must instantiat e\nc l a s s e s , but it o n ly know s abou t abstrac t c l a s s e s , whic h it c a n n o t instantiate. The Factor y M e t h o d patter n o f f e r s a s o l u t i o n . It encapsulate s the knowledg e\nof whic h D o c u m e n t s u b c l a s s to creat e a nd move s this knowledg e o ut of t he\nframework.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 376, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_design_patterns_gof_chunk_0377_8a7e980c", "text": "It encapsulate s the knowledg e\nof whic h D o c u m e n t s u b c l a s s to creat e a nd move s this knowledg e o ut of t he\nframework. ptg1 0 8 CREATIONAL PATTERNS CHAPTER 3\nApplicatio n s u b c l a s s e s redefin e an abstrac t CreateDocumen t operatio n on A p p l i -\nc a t i o n to retur n the appropriat e Documen t s u b c l a s s . O n ce an Applicatio n s u b -\nc l a ss is instantiated , it c an then instantiat e a p p l i c a t i o n - s p e c i f i c D o c u m e n t s with-\nout knowin g t h e ir c l a s s . We c a ll CreateDocumen t a factor y metho d becaus e i t 's\nr e s p o n s i b l e for \"manufacturing\" a n object. A p p l i c a b i l i t y\nU se t he F a c t o r y M e t h o d patter n w h e n\n• a c l a ss can't anticipat e the c l a ss of object s it must create. • a c l a ss want s its s u b c l a s s e s to specif y the o b j e c t s it c r e a t e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 377, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 882}}
{"id": "computer_science_design_patterns_gof_chunk_0378_187eb878", "text": "• a c l a ss want s its s u b c l a s s e s to specif y the o b j e c t s it c r e a t e s . • c l a s s e s delegat e r e s p o n s i b i l i t y to one of severa l helpe r s u b c l a s s e s , and you\nwant to localize the knowledge of which helper subclass is the delegate. S t r u c t u r e\nParticipants\nProduc t (Document)\n- define s the interfac e of object s the factor y metho d creates. C o n c r e t e P r o d u c t ( M y D o c u m e n t )\n- implement s the Produc t interface. Creato r (Application)\n- d e c l a r e s the factor y method , w h i c h return s an o b j e c t of type Product . C r e -\nator may a l so defin e a d e f a u l t implementatio n of the factor y metho d that\nreturns a default ConcreteProduct object. - may c a l l the factory method to create a Product o b j e c t . ptgFACTORY M E T H O D 109\n• ConcreteCreator (MyApplication)\n- overrides the factory method to return an instance of a C o n c r e t e P r o d u c t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 378, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 955}}
{"id": "computer_science_design_patterns_gof_chunk_0379_b1aee2cb", "text": "ptgFACTORY M E T H O D 109\n• ConcreteCreator (MyApplication)\n- overrides the factory method to return an instance of a C o n c r e t e P r o d u c t . C o l l a b o r a t i o n s\n• Creato r r e l i es on its s u b c l a s s e s to defin e the factor y metho d so t h at it return s\nan instance of the appropriate ConcreteProduct. C o n s e q u e n c e s\nFactor y method s eliminat e the n e ed to bind application-specifi c c l a s s e s into your\nc o d e. The c o de o n ly deals with the Produc t interface ; therefor e it can work with\nany user-define d ConcreteProduc t c l a s s e s . A potentia l disadvantag e of f a c t o r y method s is that c l i e n t s m i g h t have to s u b c l a s s\nthe Creato r c l a ss j u st to creat e a particula r ConcreteProduc t object . S u b c l a s s i n g is\nfine when the c l i e n t has to subclas s the Creato r c l a ss anyway , but otherwis e the\nc l i e nt now must deal with anothe r point of evolution.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 379, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 955}}
{"id": "computer_science_design_patterns_gof_chunk_0380_9a00f8ac", "text": "S u b c l a s s i n g is\nfine when the c l i e n t has to subclas s the Creato r c l a ss anyway , but otherwis e the\nc l i e nt now must deal with anothe r point of evolution. Here are two additiona l c o n s e q u e n c e s of the Factor y Metho d pattern:\n1. Provides hooks for subclasses. Creatin g object s i n s i d e a c l a ss with a f a c t or y\nmetho dis alway s m o re f l e x i b l e than c r e a t i n g an o b j e c t d i r e c t l y . F a c t o r y\nMetho dg i v es s u bcla ss e s a hook for providin g an extende d versio n of an \nobject. In the Documen t e x a m p l e , the Documen t c l a ss c o u ld defin e a f a c t o r y metho d\nc a l l ed C r e a t e F i l e D i a l o g that c r e a t e s a defaul t file d i a l o g o b j e c t f or openin g an\nexistin g document . A Documen t subclas s can defin e an application-specifi c\nfile dialo g by overridin g this f a c t o r y method .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 380, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 906}}
{"id": "computer_science_design_patterns_gof_chunk_0381_beb3ee11", "text": "A Documen t subclas s can defin e an application-specifi c\nfile dialo g by overridin g this f a c t o r y method . In this c a se the f a c t o r y metho d\nis not abstrac t but provide s a reasonabl e defaul t implementation. 2.Connects parallel class hierarchies. In the example s we'v e c o n s i d e r e d so far, the\nf a c t o r y metho d is only c a l l ed by Creators . But this doesn' t have to be the\nc a s e; client s can find factor y method s useful , e s p e c i a l l y in the c a se of paralle l\nc l a ss h i e r a r c h i e s . Paralle l c l a ss hierarchie s resul t when a c l a ss delegate s s o me of i ts r e s p o n s i b i l -\ni t i es to a separat e c l a s s. Conside r graphica l figure s t h at can be manipulate d\ninteractively ; that is, they can be stretched , m o v e d , or rotate d using the\nmouse . Implementin g such interaction s isn't alway s e a s y.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 381, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 887}}
{"id": "computer_science_design_patterns_gof_chunk_0382_d750e5dd", "text": "Implementin g such interaction s isn't alway s e a s y. It o f t en r e q u i r e s\nstorin g and updatin g informatio n that record s the state of the manipulatio n\nat a g i v en time. T h is state is neede d only durin g manipulation ; therefor e\nit needn' t be kept in the figur e object . M o r e o v e r , differen t figure s behav e\ndifferentl y when the u s er manipulate s them . For e x a m p l e , stretchin g a l i ne\nfigur e migh t have the effec t of movin g an endpoint , wherea s stretchin g a text\nfigur e may chang e its l i ne s p a c i n g . With t h e se c o n s t r a i n t s , i t 's bette r to use a s e p a r a t e Manipulato r o b j e c t that\nimplements the interaction a n d keeps track o f a n y manipulation-specific state\n\nptg1 1 0 CREATIONAL PATTERNS CHAPTER 3\nthat's needed . Differen t figure s w i ll use differen t Manipulato r s u b c l a s s e s to\nhandl e particula r interactions .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 382, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 919}}
{"id": "computer_science_design_patterns_gof_chunk_0383_ffdefeef", "text": "Differen t figure s w i ll use differen t Manipulato r s u b c l a s s e s to\nhandl e particula r interactions . The resultin g Manipulato r c l a ss hierarch y\nparallels (at least partially) the Figure class hierarchy:\nThe F i g u r e c l a ss provide s a CreateManipulato r factor y metho d that l e ts\nc l i e n t s c r e a t e a F i g u r e ' s correspondin g Manipulator . F i g u r e s u b c l a s s e s o v e r -\nride this metho d to retur n an instanc e of the Manipulato r s u b c l a s s that's right\nfor them . Alternatively , the F i g u r e c l a ss may implemen t CreateManipulato r \nto retur n a defaul t Manipulato r instance , and F i g u r e s u b c l a s s e s may s i m p l y\ninheri t that default . The F i g u r e c l a s s e s that do so n e ed no correspondin g\nManipulato r subclass—henc e the hierarchie s are o n ly partiall y parallel. Notic e how the f a c t or y metho d define s the connectio n betwee n the two c l a ss\nh i e r a r c h i e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 383, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_design_patterns_gof_chunk_0384_20499385", "text": "Notic e how the f a c t or y metho d define s the connectio n betwee n the two c l a ss\nh i e r a r c h i e s . It localizes knowledge of which classes belong together. I m p l e m e n t a t i o n\nConside r the followin g i s s u e s when applyin g the Factor y Metho d pattern:\n1.Two major varieties. The two main variations of the Factor y Metho d patter n are\n(1) the c a se when the Creato r c l a ss is an abstrac t c l a ss and d o es not provid e\nan implementatio n for the factor y metho d it d e c l a r e s , and (2) the c a se w h en\nthe Creato r is a c o n c r e t e c l a ss and provide s a defaul t implementatio n for\nthe factor y method . It's a l so p o s s i b l e to have an abstrac t c l a ss that define s a\ndefaul t implementation , but this is l e ss common. The first c a se requires s u b c l a s s e s to defin e an implementation,becaus e there' s\nno reasonabl e default . It g e ts aroun d the dilemm a of havin g to instantiate\nunforeseeabl e c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 384, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_design_patterns_gof_chunk_0385_742131d1", "text": "It g e ts aroun d the dilemm a of havin g to instantiate\nunforeseeabl e c l a s s e s . In the s e c o n d c a s e, the concret e Creato r u s es the fac-\ntory metho d primaril y for f l e x i b i l i t y . It's followin g a rule that s a y s, \" C r e a t e\nobject s in a separat e operatio n so that s u b c l a s s e s can overrid e the way they'r e\nc r e a t e d . \" T h is rule e n s u r e s t h at d e s i g n e r s of s u b c l a s s e s c an chang e t he c l a ss\no f objects their parent class instantiates if necessary. 2.Parameterized f a c t o r y m e t h o d s . Another variation o n t h e p a t t e r n l e t s the fac-\ntory method create multiple k i n d s of products. T h e factory m e t h o d t a k e s a\n\nptgFACTORY METHOD 1 1 1\nparamete r that identifie s the kind of objec t to c r e a t e . All object s the f a c t o r y\nmetho d create s w i ll s h a re the Produc t interface . In the Documen t e x a m p l e ,\nApplicatio n migh t suppor t differen t kinds of Documents .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 385, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_design_patterns_gof_chunk_0386_0ba3683b", "text": "All object s the f a c t o r y\nmetho d create s w i ll s h a re the Produc t interface . In the Documen t e x a m p l e ,\nApplicatio n migh t suppor t differen t kinds of Documents . You pass Create-\nDocumen t an extra paramete r to specif y the kind of documen t to create. The Unidra w graphica l editin g f r a m e w o r k [ V L 9 0 ] u s es this approac h for\nreconstructin g object s s a v ed on d i s k. Unidra w define s a C r e a t o r c l a ss with a\nf a c t o r y metho d C r e a t e that takes a c l a ss identifie r as an argument . The c l a ss\nidentifie r s p e c i f i e s the c l a ss to instantiate . Whe n Unidra w s a v es an o b j e c t to\nd i s k, it write s out the c l a ss identifie r f i r st and then its instanc e variables . Whe n it reconstruct s the o b j e c t f r om disk, it reads the c l a ss identifie r first. O n ce the c l a ss identifie r is r e a d, the framewor k c a l ls C r e a t e , p a s s i n g the\nidentifie r as the parameter .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 386, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_design_patterns_gof_chunk_0387_a99d5513", "text": "O n ce the c l a ss identifie r is r e a d, the framewor k c a l ls C r e a t e , p a s s i n g the\nidentifie r as the parameter . C r e a t e l o o ks up the constructo r for the c o r r e -\nspondin g c l a ss and uses it to instantiat e the object . Last, C r e a t e c a l ls the \nobject' s R e ad operation , whic h reads the remainin g informatio n on the d i sk\nand initialize s the object' s instanc e variables. A parameterize d f a c t o r y metho d has the followin g genera l form , wher e\nM y P r o d u c t and YourProduct are subclasses of Product:\nclass Creator {\npublic:\nvirtual Product* Create(Productld) ;\n} ;\nProduct* Creator::Creat e (Productl d id) { \nif (id == MINE) return new MyProduct ;\nif (id == YOURS) return new YourProduct ;\n// repeat for remainin g products... return 0;\n}\nOverridin g a parameterize d factor y metho d l e ts you e a s i ly and s e l e c t i v e l y\nexten d or chang e the product s t h at a Creato r produces .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 387, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 957}}
{"id": "computer_science_design_patterns_gof_chunk_0388_7a2d3280", "text": "return 0;\n}\nOverridin g a parameterize d factor y metho d l e ts you e a s i ly and s e l e c t i v e l y\nexten d or chang e the product s t h at a Creato r produces . You can introduc e\nn ew i d e n t i f i e r s f or n ew k i n ds of p r o d u c t s , or y ou c an a s s o c i a t e e x i s t i n g\nidentifiers with different p r o d u c t s . For example, a subclass MyCreator could swap MyProduct and Y o u r P r o d -\nuct and support a new TheirProduct s u b c l a s s :\nProduct* MyCreator::Creat e (Productl d id) {\nif (id == YOURS) return new MyProduct ;\nif ( id == MINE) return new YourProduct;\n// N.B.: switched YOURS and MINE\nif (id == THEIRS) return new TheirProduct;\nreturn Creator::Create(id) ; // called if all others fail\n}\nNotic e that the last thing this operatio n d o es is c a ll C r e a t e on the paren t\nc l a s s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 388, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 838}}
{"id": "computer_science_design_patterns_gof_chunk_0389_20857fac", "text": "T h a t ' s b e c a u s e MyCreator : : C r e a t e handles only YOURS, MINE, and\n\nptg1 12 CREATIONAL PATTERNS CHAPTER 3\nT H E I R S differentl y than the paren t c l a s s. It i s n 't i n t e r e s t e d in other c l a s s e s . H e n c e M y C r e a t o r extends the k i n ds of product s c r e a t e d , and it defer s re-\ns p o n s i b i l i t y for c r e a t i n g all but a few product s to its parent. 3.Language-specific variants a nd issues. Differen t l a n g u a g e s l e nd t h e m s e l v e s to\nother i n t e r e s t i n g variation s and caveats. S m a l l t a l k program s often use a metho d that return s the c l a ss of the o b j e c t\nto be instantiated . A Creato r f a c t o r y metho d can use t h is value to c r e a t e\na product , and a ConcreteCreato r may store or e v en comput e t h is value . T he r e s u l t is an e v en later b i n d i n g f or t he type of C o n c r e t e P r o d u c t to be\ninstantiated.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 389, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_design_patterns_gof_chunk_0390_f751a47c", "text": "T he r e s u l t is an e v en later b i n d i n g f or t he type of C o n c r e t e P r o d u c t to be\ninstantiated. A S m a l l t a l k v e r s i o n of the D o c u m e n t exampl e can defin e a d o c u m e n t C l a s s\nmetho d on A p p l i c a t i o n . The d o c u m e n t C l a s s metho d return s the\nprope r D o c u m e n t c l a ss for instantiatin g d o c u m e n t s . The i m p l e m e n t a t i o n of\nd o c u m e n t C l a s s in M y A p p l i c a t i o n return s the M y D o c u m e n t c l a s s. T h us\nin class A p p l i c a t i o n we have\nclientMethod\nd o c u m e nt := s e lf documentClas s n e w . documentClas s \ns e l f subclassResponsibility\nIn class MyApplication we have\nd o c u m e n t C l a s s\n~ MyDocument\nw h i c h return s the c l a ss M y D o c u m e n t to be instantiate d to A p p l i c a t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 390, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 838}}
{"id": "computer_science_design_patterns_gof_chunk_0391_58ed8a18", "text": "An e v en more flexibl e approac h a k in to parameterize d factor y method s is to \nstore the c l a ss to be c r e a t e d as a c l a ss variabl e of A p p l i c a t i o n . T h at way\nyou don't have to s u b c l a s s A p p l i c a t i o n to vary the product. Factor y method s in C++ are a l w a y s virtua l function s and are often pure v i r -\ntual. Just be carefu l not to c a ll factor y method s in the Creator' s constructor —\nthe factor y metho d in the ConcreteCreato r won' t be a v a i l a b l e yet. Y ou c an a v o id t h is by b e i ng carefu l to a c c e s s product s s o l e ly throug h a c c e s -\nsor operation s that creat e the produc t on demand . Instea d of c r e a t i n g the\nc o n c r e t e produc t in t he constructor , t he constructo r m e r e l y i n i t i a l i z e s it to 0. The a c c e s s o r return s the product . But first it c h e c k s to make s u re the produc t\ne x i s t s , a nd if it d o e s n ' t , t he a c c e s s o r c r e a t e s i t.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 391, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 990}}
{"id": "computer_science_design_patterns_gof_chunk_0392_95eaf235", "text": "The a c c e s s o r return s the product . But first it c h e c k s to make s u re the produc t\ne x i s t s , a nd if it d o e s n ' t , t he a c c e s s o r c r e a t e s i t. T h is t e c h n i q u e is s o m e t i m e s\nc a l l e d l a z y i n i t i a l i z a t i o n . T h e following code shows a typical implementa -\nt i o n :\n\nptgFACTORY M E T H O D 113\nclass Creato r {\npublic:\nP r o d u c t* GetProduct() ;\nprotected:\nvirtual Product* CreateProduct() ;\nprivate:\nProduct* _product ;\n} ;\nProduct* Creator::GetProduc t () {\nif ( _ p r o d u ct = =0) {\n_product = CreateProduct() ;\n}\nreturn _product ;\n}\n4. Using templates to avoid subclassing. As w e ' v e m e n t i o n e d , a n o t h e r p o t e n t i a l\np r o b l e m with f a c t o r y m e t h o d s is that t h ey m i g h t f o r ce y ou to s u b c l a s s j u st\nto c r e a t e t he a p p r o p r i a t e P r o d u c t o b j e c t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 392, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 898}}
{"id": "computer_science_design_patterns_gof_chunk_0393_029e8d02", "text": "A n o t h e r w ay to g et a r o u n d t h is in\nC ++ is to p r o v i d e a templat e s u b c l a s s of C r e a t o r t h a t ' s parameterize d by t he\nP r o d u c t c l a s s :\nc l a ss C r e a t or {\npublic:\nvirtual Product* CreateProduct( ) = 0 ;\n} ;\ntemplate <class T h e P r o d u c t > \nclass StandardCreator : public Creator {\npublic:\nvirtual Product* CreateProduct() ;\n} ;\ntemplate <class TheProduct>\nProduct* StandardCreator<TheProduct>::CreateProduc t () {\nreturn new TheProduct ;\n}\nWith t h is template , t he c l i e n t s u p p l i e s just t he p r o d u c t class—n o s u b c l a s s i n g\nof C r e a t o r is r e q u i r e d . class MyProduc t : public Product {\npublic:\nMyProduct();\n// . . . } ;\nStandardCreator<MyProduct > myCreator;\n5.Naming conventions. I t 's g o od p r a c t i c e to u se n a m i n g c o n v e n t i o n s that m a ke\nit c l e ar y o u ' r e u s i ng f a c t o r y m e t h o d s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 393, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_design_patterns_gof_chunk_0394_56671983", "text": "I t 's g o od p r a c t i c e to u se n a m i n g c o n v e n t i o n s that m a ke\nit c l e ar y o u ' r e u s i ng f a c t o r y m e t h o d s . F or e x a m p l e , t he M a c A p p M a c i n t o s h\napplicatio n framewor k [ A p p 8 9 ] alway s d e c l a r e s t he abstrac t o p e r a t i o n t h at\nd e f i n e s t he f a c t o r y m e t h o d as C l a s s * D o M a k e C l a s s () , w h e r e C l a s s is\nt h e Product class. ptg1 1 4 CREATIONAL P A T T E R N S CHAPTER 3\nS a m p l e Code\nThe functio n C r e a t e M a z e (page 84) b u i l d s and return s a maze . One p r o b l e m\nwith t h is functio n is that it h a r d - c o d e s t he c l a s s e s of m a z e , r o o m s , d o o r s , a nd\nw a l l s . W e ' ll introduc e factor y method s to let s u b c l a s s e s c h o o s e these c o m p o n e n t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 394, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 825}}
{"id": "computer_science_design_patterns_gof_chunk_0395_f83fe67a", "text": "W e ' ll introduc e factor y method s to let s u b c l a s s e s c h o o s e these c o m p o n e n t s . F i r st w e ' ll defin e factor y m e t h o d s in M az eGam e f or c r e a t i n g t he m a z e , r o o m , w a l l,\nand door objects:\nclass MazeGame {\npublic:\nMaze* CreateMaze();\n// factory methods:\nvirtual Maze* MakeMaze( ) c o n s t\n{ return new Maze; } \nvirtual R o o m* M a k e R o o m ( i n t n) c o n s t\n{ return new Room(n); }\nvirtual Wall* MakeWall( ) const\n{ r e t u rn new Wall; } \nvirtual Door* MakeDoor(Room* rl, Room* r2) const\n{ return new Door(rl, r2); }\nE a ch factor y metho d return s a maz e componen t of a g i v en t y p e. M a z e G a m e p r o -\nv i d es defaul t i m p l e m e n t a t i o n s that retur n t he s i m p l e s t k i n ds of m a z e , r o o m s ,\nw a l l s , and doors.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 395, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 816}}
{"id": "computer_science_design_patterns_gof_chunk_0396_2ab08b7f", "text": "M a z e G a m e p r o -\nv i d es defaul t i m p l e m e n t a t i o n s that retur n t he s i m p l e s t k i n ds of m a z e , r o o m s ,\nw a l l s , and doors. N o w we can rewrite CreateMaze to use these factory methods:\nMaze* MazeGame::CreateMaz e () {\nMaze* aMaze = MakeMaze (),-\nRoom* rl = MakeRoom ( 1) , -\nRoom* r2 = MakeRoom(2);\nDoor* t h e D o or = MakeDoor(rl , r2);\naMaze->AddRoom(rl) ;\naMaze->AddRoom(r2);\nrl->SetSide(North , MakeWall()) ;\nrl->SetSide(East , theDoor) ; \nr l - > S e t S i d e ( S o u t h , M a k e W a l l ( ) ) ;\nrl->SetSide(West , MakeWall());\nr2->SetSide(North , MakeWall()) ;\nr2->SetSide(East , MakeWall()) ;\nr2->SetSide(South , MakeWall()) ;\nr2->SetSide(West, theDoor);\n\nptgF A C T O R Y M E T H O D 115\nreturn aMaze;\n}\nDifferen t game s can s u b c l a s s Ma z e G a m e to s p e c i a l i z e parts of the maze . Ma z e G a m e\ns u b c l a s s e s can redefin e s o me or all of the factor y method s to specif y variation s\nin p r o d u c t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 396, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_design_patterns_gof_chunk_0397_3f419b36", "text": "Ma z e G a m e\ns u b c l a s s e s can redefin e s o me or all of the factor y method s to specif y variation s\nin p r o d u c t s . For e x a m p l e , a BombedMazeGam e can r e d e f i n e the Room and W a ll\nproducts t o return the bombed varieties:\nclass BombedMazeGam e : public MazeGame {\npublic:\nBombedMazeGame();\nvirtual Wall* MakeWall( ) const\n{ r e t u rn new BombedWall ; }\nvirtual Room* MakeRoom(in t n) const\n{ return new RoomWithABomb(n) ; }\n} ;\nAn Enchant edMaz e G a m e variant might be defined like this:\nclass EnchantedMazeGam e : public MazeGame {\npublic:\nEnchantedMazeGame();\nvirtual Room* MakeRoom(in t n) c o n s t\n{ return new EnchantedRoom(n , CastSpell()) ; }\nvirtual Door* MakeDoor(Room * rl, Room* r2) const\n{ r e t u rn new D o o r N e e d i n g S p e l l ( r l , r 2 ); } \nprotected:\nSpell* CastSpell( ) const;\n} ;\nK n o w n Uses\nFactor y method s pervad e toolkit s and frameworks .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 397, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 913}}
{"id": "computer_science_design_patterns_gof_chunk_0398_641dc799", "text": "The precedin g documen t ex-\nampl e is a t y p i c a l u se in MacAp p a nd ET++ [ W G M 8 8 ] . T he manipulato r ex amp l e\nis from Unidraw. C l a ss V i ew in the S m a l l t a l k - 8 0 Model/View/Controlle r framewor k has a metho d\ndefaultControlle r that create s a c o n t r o l l e r , and this migh t appea r to be a factor y\nmetho d [ P a r 9 0 ] . But s u b c l a s s e s of V i ew specif y the c l a ss of their defaul t c o n t r o l l e r\nby definin g d e f a u l t C o n t r o l l e r C l a s s , w h i c h return s t he c l a ss from w h i c h default-\nC o n t r o l l e r create s instances . So defaultControllerClas s is t he r e al factor y method ,\nt K at is, the metho d that s u b c l a s s e s s h o u l d o v e r r i d e . A more e s o t e r i c exampl e in S m a l l t a l k - 8 0 is the factor y metho d p a r s e r C l a s s define d\nb y Behavior (a superclass of all objects representing classes).", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 398, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_design_patterns_gof_chunk_0399_36012149", "text": "A more e s o t e r i c exampl e in S m a l l t a l k - 8 0 is the factor y metho d p a r s e r C l a s s define d\nb y Behavior (a superclass of all objects representing classes). This enables a class\n\nptg1 16 CREATIONAL PATTERNS CHAPTER 3\nto use a c u s t o m i z e d parse r for its s o u r c e c o d e. For e x a m p l e , a c l i e nt can defin e\na c l a ss S Q L P a r s e r to analyz e the sourc e c o de of a c l a ss with embedde d SQL\nstatements . The B e h a v i o r c l a ss implement s parserClas s to retur n the standar d\nS m a l l t a l k Parse r c l a s s. A c l a ss t h at i n c l u d e s embedde d S QL statement s o v e r r i d e s\nthis metho d (as a c l a ss method ) and return s the S Q L P a r s e r c l a s s . The Orbix ORB syste m from IONA T e c h n o l o g i e s [ I O N 9 4 ] uses Factor y Metho d to\ngenerat e an appropriat e type of proxy ( s ee Prox y (207) ) when an o b j e c t r e q u e s t s a\nr e f e r e n c e to a r e m o t e o b j e c t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 399, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_design_patterns_gof_chunk_0400_45554a5f", "text": "F a c t o r y M e t h o d m a k e s it e a sy to r e p l a c e t he defaul t\nproxy with one that uses client-side caching, for example. Related Patterns\nAbstrac t Factor y ( 8 7) is o f t en implemente d with f a c t o r y methods . The Motivatio n\nexampl e in the Abstrac t Factor y patter n illustrate s Factor y Metho d as w e l l . F a c t o r y m e t h o d s a re u s u a l l y c a l l e d withi n T e m p l a t e M e t h o d s ( 3 2 5 ) . In t he d o c u -\nment exampl e a b o v e , NewDocumen t is a templat e method. Prototype s ( 1 1 7) don't requir e s u b c l a s s i n g Creator . However , they often r e q u i r e\nan Initializ e operatio n on the Produc t c l a s s . Creato r u s es Initializ e to i n i t i a l i z e the\nobject. Factory Method doesn't require such an operation. ptgPROTOTYPE 117\nP R O T O T Y P E Object Creational\nIntent\nSpecif y the kinds of object s to creat e using a prototypica l instance , and creat e new\nobjects by copying this prototype.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 400, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_design_patterns_gof_chunk_0401_5c2e1e7a", "text": "ptgPROTOTYPE 117\nP R O T O T Y P E Object Creational\nIntent\nSpecif y the kinds of object s to creat e using a prototypica l instance , and creat e new\nobjects by copying this prototype. Motivation\nYou c o u ld build an edito r for musi c s c o r e s by customizin g a genera l framewor k\nf or g r a p h i c a l e d i t o r s a nd a d d i n g n ew o b j e c t s that r e p r e s e n t n o t e s , r e s t s, a nd\nstaves . The edito r f r a m e w o r k may have a palett e of t o o ls for addin g these musi c\nobject s to the s c o r e . The palett e woul d a l so includ e t o o ls for s e l e c t i n g , moving ,\na nd o t h e r w i s e manipulatin g m u s i c o b j e c t s . U s e rs w i ll c l i ck on t he quarter-not e\ntool and use it to add quarte r notes to the s c o r e . Or they can use the move tool to\nmove a note up or down on the s t a f f, thereb y changin g its pitch.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 401, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 884}}
{"id": "computer_science_design_patterns_gof_chunk_0402_dae16b60", "text": "Or they can use the move tool to\nmove a note up or down on the s t a f f, thereb y changin g its pitch. L e t 's a s s u m e t he framewor k p r o v i d e s an a b s t r a c t Graphi c c l a ss f or g r a p h i c a l c o m -\nponents , like notes and staves . M o r e o v e r , it'll provid e an abstrac t T o ol c l a ss for\ndefinin g t o o ls l i ke those in the palette . The f r a m e w o r k a l so predefine s a Graphic-\nT o ol s u b c l a s s f or t o o ls that c r e a te i n s t a n c e s of g r a p h i c a l o b j e c t s a nd a dd th em to\nthe document. But GraphicToo l present s a proble m to the framewor k d e s i g n e r . The c l a s s e s for\nnotes and stave s are s p e c i f i c to our application , but the G r a p h i c T o o l c l a ss b e l o n g s\nto the framework . GraphicToo l doesn' t know how to creat e instance s of our musi c\nc l a s s e s to add to the s c o r e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 402, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 898}}
{"id": "computer_science_design_patterns_gof_chunk_0403_6f24c458", "text": "GraphicToo l doesn' t know how to creat e instance s of our musi c\nc l a s s e s to add to the s c o r e . We c o u ld s u b c l a s s GraphicToo l for e a ch kind of musi c\no b j e c t , b ut that w o u l d p r o d u c e l o ts of s u b c l a s s e s that differ o n ly in t he k i nd of\nmusi c objec t they instantiate . We know objec t compositio n is a fl e xib l e alternativ e\nto s u b c l a s s i n g . The questio n is, how can the framewor k use it to parameteriz e\ni n s t a n c e s of G r a p h i c T o o l by t he class of Graphi c they'r e s u p p o s e d to c r e a t e ? The solutio n l i es in makin g GraphicToo l creat e a new Graphi c by copyin g or\n\" c l o n i n g \" an instanc e of a Graphi c s u b c l a s s . We c a ll this instanc e a prototype . G r a p h i c T o o l is p a r a m e t e r i z e d by t he prototyp e it s h o u l d c l o ne a nd a dd to t he\ndocument .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 403, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 893}}
{"id": "computer_science_design_patterns_gof_chunk_0404_6cbec82b", "text": "We c a ll this instanc e a prototype . G r a p h i c T o o l is p a r a m e t e r i z e d by t he prototyp e it s h o u l d c l o ne a nd a dd to t he\ndocument . If all Graphi c s u b c l a s s e s suppor t a C l o n e operation , then the Graphic-\nT o ol can c l o ne a ny kind of Graphic. So in o ur musi c e d i t o r , e a ch tool f or creatin g a musi c o b j e c t is an instanc e of\nGraphicToo l that's initialize d with a differen t prototype . Each G r a p h i c T o o l in-\nstanc e w i ll produc e a musi c o b j e c t by c l o n i n g its prototyp e and addin g the c l o ne\nto the score. ptg1 1 8 CREATIONAL PATTERNS CHAPTER 3\nWe can use the Prototyp e pattern to r e d u c e the numbe r of c l a s s e s e v en further . We have separat e c l a s s e s for whol e notes and h a lf n o t e s , but that's p r o b a b l y\nu n n e c e s s a r y . Instea d they c o u ld be instance s of t he same c l a ss i n i t i a l i z e d with\ndifferen t bitmap s and durations .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 404, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_design_patterns_gof_chunk_0405_9d9e1170", "text": "Instea d they c o u ld be instance s of t he same c l a ss i n i t i a l i z e d with\ndifferen t bitmap s and durations . A tool for c r e a t i n g whol e n o t es b e c o m e s just a\nG r a p h i c T o o l w h o s e prototyp e is a M u s i c a l N o t e i n i t i a l i z e d to be a w h o l e n o t e. T h is\nc an r e d u c e t he numbe r of c l a s s e s in t he s y s t e m dramatically . It a l so make s it e a s i e r\nto add a new kind of note to the music editor.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 405, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 472}}
{"id": "computer_science_design_patterns_gof_chunk_0406_80e74f62", "text": "T h is\nc an r e d u c e t he numbe r of c l a s s e s in t he s y s t e m dramatically . It a l so make s it e a s i e r\nto add a new kind of note to the music editor. Applicability\nUse the Prototyp e patter n when a syste m s h o u l d be independen t of how its\nproduct s are c r e a t e d , c o m p o s e d , and r e p r e s e n t e d ; and\n• when the c l a s s e s to instantiat e are s p e c i f i e d at run-time , for e x a m p l e , by\ndynami c l o a d i n g ; or\n• to a v o id b u i l d i n g a c l a ss hierarch y of factorie s that p a r a l l e l s the c l a ss hierar-\nc hy of p r o d u c t s ; o r\n• when i n s t a n c e s of a c l a ss can have one of o n ly a few differen t combination s\nof state. It may be more c o n v e n i e n t to i n s t a l l a c o r r e s p o n d i n g numbe r of\nprototype s and c l o ne them rathe r than instantiatin g the c l a ss manually , e a ch\ntime with the appropriate state.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 406, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_design_patterns_gof_chunk_0407_5ce10ba4", "text": "ptgPROTOTYPE 119\nS t r u c t u r e\nParticipants\n• Prototype (Graphic)\n- declares an interface for cloning itself. • ConcretePrototype ( S t a f f , WholeNote, HalfNote)\n- implements an o p e r a t i o n for cloning itself. • Client ( G r a p h i c T o o l )\n- creates a new object by asking a prototype to clone itself. C o l l a b o r a t i o n s\n• A client asks a prototype to clone itself. C o n s e q u e n c e s\nPrototyp e has many of the s a me c o n s e q u e n c e s that Abstrac t Factor y ( 8 7) and\nB u i l d e r ( 9 7) h a v e: It h i d es t he c o n c r e t e produc t c l a s s e s from t he c l i e n t , t h e r e b y\nreducin g the numbe r of name s c l i e n t s know about . M o r e o v e r , t h e se pattern s let a\nc l i e nt work with application-specifi c c l a s s e s withou t modification. Additiona l benefit s of the Prototyp e patter n are l i s t ed b e l o w . 1. Adding and removing products at run-time.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 407, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_design_patterns_gof_chunk_0408_401ac8cf", "text": "Additiona l benefit s of the Prototyp e patter n are l i s t ed b e l o w . 1. Adding and removing products at run-time. Prototype s let you incorporat e a\nnew c o n c r e t e produc t c l a ss into a syste m s i m p l y by r e g i s t e r i n g a prototyp-\ni c al instanc e with the c l i e n t . That' s a bit m o re flexibl e than other creationa l\npatterns, because a client can install and remove prototypes at run-time. 2. S p e c i f y i n g new objects b y varying v a l u e s . Highly dynamic systems let you de -\nfine new behavior through object composition—by specifying values for an\n\nptg1 20 CREATIONAL PATTERNS CHAPTER 3\nobject' s v a r i a b l e s , for example—an d not by definin g new c l a s s e s . You ef-\nf e c t i v e l y d e f i n e n ew k i n ds of o b j e c t s by i n s t a n t i a t i n g e x i s t i n g c l a s s e s a nd\nregisterin g t he i n s t a n c e s as prototype s of c l i e nt objects .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 408, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_design_patterns_gof_chunk_0409_cac65ede", "text": "A c l i e nt c an e x h i b i t\nnew behavio r by d e l e g a t i n g r e s p o n s i b i l i t y to the prototype. T h is k i nd of d e s i g n l e ts users defin e n ew \" c l a s s e s \" withou t programming . In fact, c l o n i n g a prototyp e is s i m i l a r to instantiatin g a c l a s s . The Prototyp e\npatter n can greatl y reduc e the numbe r of c l a s s e s a syste m n e e d s . In our musi c\neditor , o ne G r a p h i c T o o l c l a ss c an c r e a t e a l i m i t l e s s variet y of m u s i c o b j e c t s . 3.Specifying new objects by varying structure. Many application s build o b j e c t s\nf r om parts and subparts . Editor s for c i r c u i t d e s i g n , for e x a m p l e , b u i ld c i r -\nc u i ts o ut of s u b c i r c u i t s . 1 F or c o n v e n i e n c e , s u ch a p p l i c a t i o n s often l et y ou\ninstantiat e c o m p l e x , user-define d structures , s a y, to use a s p e c i f i c s u b c i r c u i t\na g a in a nd a g a i n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 409, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_design_patterns_gof_chunk_0410_6d730ba3", "text": "T he Prototyp e patter n support s t h is as w e l l. We s i m p l y a dd this s u b c i r c u i t as\na prototyp e to the palett e of availabl e c i r c u i t e l e m e n t s . As l o ng as the c o m -\nposit e c i r c u i t o b j e c t implement s C l o n e as a deep c o p y , c i r c u i t s with differen t\nstructure s can be prototypes. 4.Reduced subclassing. Factor y Metho d ( 1 0 7) often produce s a hierarch y of C r e -\nator c l a s s e s that p a r a l l e l s the produc t c l a ss h i e r a r c h y . The Prototyp e patter n\nl e ts you c l o ne a prototyp e instea d of a s k i n g a factor y metho d to make a new\nobject . H e n c e you don't n e ed a Creato r c l a ss hierarch y at all. T h is benefi t\napplie s primaril y to language s like C++ that don't treat c l a s s e s as first-clas s \nobjects . Language s that d o, l i ke Smalltal k a nd O b j e c t i v e C, deriv e l e ss b e n e -\nfit, s i n ce you can alway s use a c l a ss objec t as a c r e a t o r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 410, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_design_patterns_gof_chunk_0411_b0c13cc6", "text": "Language s that d o, l i ke Smalltal k a nd O b j e c t i v e C, deriv e l e ss b e n e -\nfit, s i n ce you can alway s use a c l a ss objec t as a c r e a t o r . C l a ss o b j e c t s alread y\na ct l i ke prototype s in t h e se languages. 5.Configuring an application with classes dynamically. S o me run-tim e e n v i r o n -\nment s l et y ou l o ad c l a s s e s into an applicatio n d y n a m i c a l l y . T he Prototyp e\npatter n is the key to e x p l o i t i n g s u ch facilitie s in a languag e l i ke C++. An applicatio n that want s to creat e i n s t a n c e s of a dynamicall y l o a d e d c l a ss\nwon' t be a b le to r e f e r e n c e i ts c o n s t r u c t o r s t a t i c a l l y . I n s t e a d , t he r u n - t i m e e n v i -\nronmen t c r e a t e s an instanc e of e a ch c l a ss automaticall y when i t 's l o a d e d , a nd\nit r e g i s t e r s the i n s t a n c e with a prototyp e manage r ( s ee the Implementatio n\ns e c t i o n ) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 411, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_design_patterns_gof_chunk_0412_0d5330a5", "text": "T h en the applicatio n can ask the prototyp e manage r for i n s t a n c e s of\nnewl y loade d c l a s s e s , c l a s s e s that weren' t l i n k e d with the progra m o r i g i n a l l y . The ET++ applicatio n framewor k [ W G M 8 8 ] has a run-tim e syste m that u s es\nt h is s c h e m e . The main liabilit y of the Prototyp e patter n is that e a ch s u b c l a s s of Prototyp e must\nimplemen t the C l o n e operation , w h i c h may be difficult . For e x a m p l e , a d d i n g\nC l o n e is difficul t w h en t he c l a s s e s u n d e r c o n s i d e r a t i o n a l r e a d y e x i s t. I m p l e m e n t -\ning C l o n e can be difficul t when t h e ir i n t e r n a l s i n c l u d e o b j e c t s that don't suppor t\nc o p y i n g or have circular references. 1Such applications reflect the Composite (163) a n d Decorator (175) p a t t e r n s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 412, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 863}}
{"id": "computer_science_design_patterns_gof_chunk_0413_38fd5d98", "text": "1Such applications reflect the Composite (163) a n d Decorator (175) p a t t e r n s . ptgPROTOTYPE 121\nI m p l e m e n t a t i o n\nPrototyp e is particularl y usefu l with static language s l i ke C++, wher e c l a s s e s are\nnot o b j e c t s , and little or no type informatio n is availabl e at run-time . It's l e ss\nimportan t in language s l i ke S m a l l t a l k or O b j e c t i v e C that provid e what amount s \nto a prototyp e ( i . e ., a c l a ss object ) for creatin g instance s of each c l a s s. T h is patter n is\nb u i lt into p r o t o t y p e - b a s e d l a n g u a g e s l i ke S e lf [ U S 8 7 ] , in w h i c h a ll o b j e c t creatio n\nhappen s by c l o n i n g a prototype. C o n s i d e r the followin g i s s u e s when implementin g prototypes:\n1. Using a prototype manager. Whe n the numbe r of prototype s in a syste m isn't\nfixed (that is, they can be create d and d e s t r o y e d dynamically) , k e ep a registr y\nof a v a i l a b l e prototypes .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 413, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_design_patterns_gof_chunk_0414_528c545b", "text": "Whe n the numbe r of prototype s in a syste m isn't\nfixed (that is, they can be create d and d e s t r o y e d dynamically) , k e ep a registr y\nof a v a i l a b l e prototypes . C l i e n t s won' t manag e prototype s t h e m s e l v e s but w i ll\nstore and retriev e them f r om the r e g i s t r y . A c l i e nt w i ll ask the registr y for a \nprototyp e befor e c l o n i n g it. We c a ll this registr y a prototyp e manager. A prototyp e manage r is an a s s o c i a t i v e store t h at return s the prototyp e match-\ning a g i v en k e y. It has operation s for registerin g a prototyp e unde r a key and\nfor unregisterin g it. C l i e n t s can chang e or even brows e throug h the registr y\nat run-time . T h is l e ts c l i e n t s exten d and take inventor y on the syste m withou t\nwritin g c o d e . 2. Implementing the Clone operation. The hardes t part of the Prototyp e patter n\nis implementin g the C l o n e operatio n c o r r e c t l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 414, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_design_patterns_gof_chunk_0415_f717e5b6", "text": "2. Implementing the Clone operation. The hardes t part of the Prototyp e patter n\nis implementin g the C l o n e operatio n c o r r e c t l y . It's particularl y tricky when\no b j e c t structure s contai n c i r c u l a r references. M o st language s provid e some suppor t for c l o n i n g o b j e c t s . For e x a m p l e ,\nSmalltal k p r o v i d e s an implementatio n of copy that's inherite d by all s u b -\nc l a s s e s of Object . C++ p r o v i d e s a c o py constructor . But t h e se facilitie s don't \ns o l ve t he \" s h a l l o w c o py versu s d e ep c o p y\" p r o b l e m [ G R 8 3 ] . That i s, d o es\nc l o n i n g an objec t in turn c l o ne its instanc e v a r i a b l e s , or do the c l o ne and\no r i g i n a l just share the variables? A s h a l l o w c o py is s i m p l e and often sufficient , and that's w h at Smalltal k\np r o v i d e s by default .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 415, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 884}}
{"id": "computer_science_design_patterns_gof_chunk_0416_a1f4ed68", "text": "A s h a l l o w c o py is s i m p l e and often sufficient , and that's w h at Smalltal k\np r o v i d e s by default . The defaul t c o py constructo r in C++ d o es a member-\nw i se c o p y, whic h mean s pointer s w i ll be share d betwee n the copy and the\no r i g i n a l . But c l o n i n g prototype s with comple x structure s usuall y r e q u i r e s a\nd e ep c o p y, b e c a u s e the c l o ne and the o r i g i n a l must be independent . Therefor e\nyou must ensur e that the c l o n e ' s component s are c l o n e s of the prototype' s \ncomponents . C l o n i n g force s you to d e c i d e what if anythin g w i ll be shared. If object s in the syste m provid e S a ve and Load operations , then you can use\nthem to provid e a defaul t implementatio n of C l o n e s i m p l y by s a v i n g the\no b j e c t and loadin g it back immediately .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 416, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 856}}
{"id": "computer_science_design_patterns_gof_chunk_0417_c2b23d4a", "text": "The S a ve operatio n s a v es the o b j e c t\ninto a memor y b u f f e r , and Load c r e a t e s a duplicat e by reconstructin g the\no b j e c t f r om the buffer. 3. Initializing clones. W h i l e s o me c l i e n t s are perfectl y happ y with the c l o ne as\nis, others will want t o i n i t i a l i z e s o m e o r a l l o f i t s i n t e r n a l s t a t e t o v a l u e s\n\nptg1 22 CREATIONAL PATTERNS CHAPTER 3\nof t h e ir c h o o s i n g . Y ou g e n e r a l l y c a n 't pass t h e se value s in t he C l o ne o p e r -\na t i o n , b e c a u s e t h e ir numbe r will vary betwee n c l a s s e s of prototypes . S o me\nprototype s migh t n e ed multipl e i n i t i a l i z a t i o n parameters ; other s won' t n e ed\na n y. P a s s i n g parameter s in t he C l o ne operatio n p r e c l u d e s a unifor m c l o n i n g\ninterface. It m i g h t be the c a se that your prototyp e c l a s s e s alread y d e f i n e operation s for\n(re)settin g k ey p i e c e s of state.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 417, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_design_patterns_gof_chunk_0418_e4d43f20", "text": "It m i g h t be the c a se that your prototyp e c l a s s e s alread y d e f i n e operation s for\n(re)settin g k ey p i e c e s of state. If s o, c l i e n t s m ay u se t h e se operation s i m m e d i -\nately a f t er c l o n i n g . If n o t, then you may have to i n t r o d u c e an I n i t i a l i z e\noperatio n ( s ee the S a m p l e C o de s e c t i o n ) that takes i n i t i a l i z a t i o n parame-\nters as argument s a nd s e ts t he c l o n e ' s interna l state a c c o r d i n g l y . B e w a r e of\nd e e p - c o p y i n g C l o n e operations—th e c o p i e s may have to be d e l e t e d (eithe r\ne x p l i c i t l y or within Initialize) before you reinitialize them. S a m p l e C o d e\nW e ' ll defin e a M a z e P r o t o t y p e F a c t o r y s u b c l a s s of the M a z e F a c t o r y c l a ss\n( p a ge 9 2 ).", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 418, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 838}}
{"id": "computer_science_design_patterns_gof_chunk_0419_56a1436e", "text": "S a m p l e C o d e\nW e ' ll defin e a M a z e P r o t o t y p e F a c t o r y s u b c l a s s of the M a z e F a c t o r y c l a ss\n( p a ge 9 2 ). M a z e P r o t o t y p e F a c t o r y w i ll be i n i t i a l i z e d with prototype s of the\no b j e c t s it w i ll creat e so that we don't have to s u b c l a s s it just to c h a n g e the c l a s s e s\no f walls or rooms it creates.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 419, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 389}}
{"id": "computer_science_design_patterns_gof_chunk_0420_6b05521b", "text": "M a z e P r o t o t y p e F a c t o r y a u g m e n t s t h e M a z e F a c t o r y i n t e r f a c e w i t h a c o n-\nstructor that takes t h e prototypes as arguments:\nc l a ss MazePrototypeFactor y : public MazeFactor y {\npublic:\nMazePrototypeFactor y (Maze*, Wall*, Room*, D o o r * ) , -\nvirtual Maze* MakeMaze( ) const; \nvirtual Room* MakeRoom(int ) c o n s t; \nvirtual Wall* MakeWall( ) const; \nvirtual D o o r* MakeDoor(Room* , Room*) const;\nprivate:\nMaze* _prototypeMaze;\nRoom* _prototypeRoom ; \nWall* _prototypeWall ; \nD o o r * _prototypeDoor;\nT h e new constructor simply initializes its prototypes:\nMazePrototypeFactory::MazePrototypeFactor y (\nMaze* m, Wall* w, Room* r, D o o r* d\n) {\n_prototypeMaz e = m;\n_prototypeWal l = w; \n__prototypeRoo m = r;\n_prototypeDoor = d;\n}\n\nptgPROTOTYPE 1 2 3\nT he m e m b e r f u n c t i o n s f or c r e a t i n g walls , r o o m s , a nd d o o r s a re s i m i l a r : E a ch\nc l o n e s a p r o t o t y p e a nd t h en initialize s i t.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 420, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_design_patterns_gof_chunk_0421_0fe39114", "text": "H e re a re t he d e f i n i t i o n s of M a k e W a l l\na nd M a k e D o o r :\nWall* MazePrototypeFactory::MakeWal l () c o n st {\nreturn _prototypeWall->Clone();\n}\nDoor* MazePrototypeFactory::MakeDoo r ( R o o m* rl, Room *r2) c o n st { \nDoor* door = _prototypeDoor->Clone() ;\ndoor->Initialize(rl , r2); \nreturn door;\n}\nWe can use M a z e P r o t o t y p e F a c t o r y to c r e a t e a p r o t o t y p i c a l or d e f a u l t m a ze\nj u st by initializin g it with p r o t o t y p e s of b a s ic m a ze c o m p o n e n t s :\nMa z eGame game;\nMazePrototypeFactor y simpleMazeFactory ( \nnew Maze, new Wall, new Room, new D o o r\nMaze* maze = game.CreateMaze(simpleMazeFactory);\nTo c h a n g e the type of m a z e , we initializ e M a z e P r o t o t y p e F a c t o r y with a dif-\nf e r e n t s et of p r o t o t y p e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 421, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 829}}
{"id": "computer_science_design_patterns_gof_chunk_0422_9b7aa494", "text": "T he followin g c a ll c r e a t e s a m a ze with a BombedDoo r\nand a R o o m W i t h A B o m b :\nMazePrototypeFactor y bombedMazeFactory (\nnew Maze, new BombedWall , \nnew RoomWithABomb , new Door\n) ;\nAn o b j e c t that c an be u s ed as a p r o t o t y p e , s u ch as an i n s t a n c e of W a l l , m u st\ns u p p o r t t he C l o n e o p e r a t i o n . It m u st a l so h a ve a c o py c o n s t r u c t o r f or c l o n i n g . It\nm ay a l so n e ed a s e p a r a t e o p e r a t i o n f or reinitializin g i n t e r n a l state . W e ' l l a dd t he\nI n i t i a l i z e o p e r a t i o n to D o or to let c l i e n t s initializ e the c l o n e ' s r o o m s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 422, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 669}}
{"id": "computer_science_design_patterns_gof_chunk_0423_8e67bccf", "text": "W e ' l l a dd t he\nI n i t i a l i z e o p e r a t i o n to D o or to let c l i e n t s initializ e the c l o n e ' s r o o m s . C o m p a r e t he followin g definitio n of Door to t he o ne on p a ge 8 3 :\nclass D o or : public MapSite {\npublic:\nDoor();\nDoor(cons t D o o r & ) ;\nvirtual void Initialize(Room* , Room*);\nvirtual Door* Clone() const;\n\nptg12 4 CREATIONAL PATTERNS CHAPTER 3\nvirtual void Enter();\nRoom* OtherSideFrom(Room*);\nprivate: \nRoom* _rooml;\nRoom* _room2;\n} ;\nDoor::Doo r ( c o n st D o o r& other) { \n_rooml - other._rooml ;\n_room2 = other._room2;\n}\nvoid Door::Initializ e ( R o o m* rl, Room* r2) { \n_rooml = rl;\n_room2 = r2;\n}\nDoor* Door::Clon e () const {\nreturn new Door(*this);\n}\nThe B o m b e d W a 11 s u b c l a s s must overrid e C1 one and implemen t a correspondin g\nc o p y constructor.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 423, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 823}}
{"id": "computer_science_design_patterns_gof_chunk_0424_bbf34028", "text": "class BombedWal l : public Wall {\npublic:\nBombedWall();\nBombedWall(cons t BombedWa11&);\nvirtual Wall* Clone() const;\nbool HasBomb();\nprivate: \nb o ol _bomb;\n} ;\nBombedWall::BombedWal l ( c o n st BombedWall k other) : Wall(other ) {\n_bomb = other._bomb ;\n}\nWall* BombedWall::Clon e () const {\nreturn new BombedWall(*this);\n}\nAlthoug h B o m b e d W a l l : : C l o n e return s a W a l l * , its implementatio n return s a\npointe r to a n ew instanc e of a s u b c l a s s , that i s, a BombedW a 11 *. We defin e C1 o ne\nl i ke this in the base c l a ss to ensur e that c l i e n t s that c l o ne the prototyp e don't have\nto know abou t their c o n c r e t e s u b c l a s s e s . C l i e n t s shoul d never n e ed to downcas t\nthe retur n value of C l o n e to the d e s i r e d type. In S m a l l t a l k , you can r e u se the standar d copy metho d i n h e r i t e d from O b j e c t\nto c l o n e a n y MapSite.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 424, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 919}}
{"id": "computer_science_design_patterns_gof_chunk_0425_951eaf25", "text": "In S m a l l t a l k , you can r e u se the standar d copy metho d i n h e r i t e d from O b j e c t\nto c l o n e a n y MapSite. You can use M a z e F a c t o r y t o produce t h e p r o t o t y p e s\n\nptgPROTOTYPE 1 2 5\nyou'l l n e e d; for e x a m p l e , you can creat e a room by supplyin g the name # r o o m . The M a z e F a c t o r y has a dictionar y that maps name s to prototypes . Its m a k e :\nmethod looks like this:\nmake: partName \n(partCatalog a t : partName) copy\nGive n appropriat e method s for initializin g the M a z e F a c t o r y with prototypes ,\nyou could create a simple maze with the following code:\nCreateMaz e \no n: (MazeFactor y n e w\nwith: Door new named: ttdoor;\nwith: Wall new named: ttwall;\nwith: Room new named: ttroom; \nyourself)\nwhere the definition of the on: c l a s s m e t h o d for CreateMaze would be\non: aFactory \nI rooml room2 I \nrooml := ( a F a c t o ry make: t t r o o m) location : 1 @ 1. room2 := ( a F a c t o ry make: ttroom) location : 2@1.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 425, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_design_patterns_gof_chunk_0426_a6373e8b", "text": "room2 := ( a F a c t o ry make: ttroom) location : 2@1. door := ( a F a c t o ry make: #door) from: rooml to: room2. rooml \nat Side:\natSide:\natSide:\natSide:\nroom2\natSide: \natSide:\natSide:\natSide :\nMaze new\naddRoom :\naddRoom :\nyourselittnorth\n#east \n#south\n#west\n#north\ntteast\nttsouth\nttwest\n: rooml\n: r o o m 2put :\nput :\nput\nput :\nput\nput :\nput\nput :: ( a F a c t o ry\ndoor;\n: ( a F a c t o ry\n( a F a c t o r y\n: ( a F a c t o ry\n( a F a c t o ry \n: ( a F a c t o r y\ndoor .make:\nmake :\nmake :\nmake :\nmake :\nmake :: ttwall)\n: ttwall)\nttwall) . : ttwall)\n#wall) ;\n: ttwall)\nKnown Uses\nPerhap s the first exampl e of the Prototyp e patter n was in Ivan Sutherland' s S k e t c h -\npad syste m [ S u t 6 3 ] . The first widel y know n applicatio n of the patter n in an o b j e c t -\noriente d languag e was in ThingLab , wher e users c o u ld f o rm a composit e o b j e c t\nand then promot e it to a prototyp e by installin g it in a librar y of reusabl e ob-\njects [ B o r 8 1 ] .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 426, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_design_patterns_gof_chunk_0427_d79b9266", "text": "Goldber g and Robso n mentio n prototype s as a p a t t e r n [ G R 8 3 1 , but\nC o p l i e n [ C o p 9 2 ] g i v es a much more complet e description . He d e s c r i b e s i d i o m s\nrelate d to the Prototyp e patter n for C++ and g i v es many example s and variations. Etgd b is a debugge r front-en d based on ET++ t h at provide s a p o i n t - a n d - c l i c k\ninterface t o different l i n e - o r i e n t e d d e b u g g e r s . E a c h debugger h a s a c o r r e s p o n d -\ning Debugger A d a p t o r s u b c l a s s . For example, Gdb A d a p t o r a d a p t s e t g d b t o t h e\n\nptg1 26 CREATIONAL PATTERNS CHAPTERS\nc o m m a n d synta x of G NU g d b, w h i le SunDbxAdapto r adapt s etgdb to S u n 's d bx\nd e b u g g e r . Etgd b d o es n ot have a s et of D e b u g g e r Adapto r c l a s s e s h a r d - c o d e d i n to\nit.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 427, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 846}}
{"id": "computer_science_design_patterns_gof_chunk_0428_5cf04000", "text": "Etgd b d o es n ot have a s et of D e b u g g e r Adapto r c l a s s e s h a r d - c o d e d i n to\nit. I n s t e a d , it reads the name of the adapto r to use from an e n v i r o n m e n t vari-\na b l e, l o o ks for a prototyp e with the s p e c i f i e d name in a g l o b a l t a b l e , and then\nc l o n e s the prototype . New d e b u g g e r s can be adde d to etgdb by l i n k i n g it with the\nDebuggerAdapto r that work s for that d e b u g g e r . T he \" i n t e r a c t i o n t e c h n i q u e library \" in M o d e C o m p o s e r s t o r e s prototype s of o b j e c t s\nthat suppor t variou s interactio n t e c h n i q u e s [ S h a 9 0 ] . A ny i n t e r a c t i o n t e c h n i q u e\nc r e a t e d by the Mod e C o m p o s e r can be used as a prototyp e by p l a c i n g it in t h is\nl i b r a r y . T he Prototyp e patter n l e ts M o d e C o m p o s e r suppor t an u n l i m i t e d s et of\ni n t e r a c t i o n t e c h n i q u e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 428, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_design_patterns_gof_chunk_0429_397afc9e", "text": "T he Prototyp e patter n l e ts M o d e C o m p o s e r suppor t an u n l i m i t e d s et of\ni n t e r a c t i o n t e c h n i q u e s . T he m u s i c e d i t o r e xa mp l e d i s c u s s e d e a r l i e r is b a s ed on t he Unidra w drawin g\nframework [ V L 9 0 ] . Related Patterns\nPrototyp e a nd Abstrac t Factor y ( 8 7) a re c o m p e t i n g pattern s in s o me w a y s , as we\nd i s c u s s at t he e nd of t h is c h a p t e r . T h ey c an a l so be u s ed t o g e t h e r , h o w e v e r . An\nAbstrac t Factor y m i g h t s t o re a set of prototype s from w h i c h to c l o ne and retur n\nproduc t o b j e c t s . D e s i g n s that make heav y u se of t he C o m p o s i t e ( 1 6 3) a nd Decorato r ( 1 7 5) pattern s\noften can benefit from Prototype as well. ptgSINGLETON 127\nS I N G L E T O N O b j e c t Creational\nI n t e n t\nEnsure a class only has one instance, and provide a global point of access to it.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 429, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_design_patterns_gof_chunk_0430_e9798058", "text": "ptgSINGLETON 127\nS I N G L E T O N O b j e c t Creational\nI n t e n t\nEnsure a class only has one instance, and provide a global point of access to it. Motivation\nIt's importan t for s o me c l a s s e s to have exactl y one instance . Althoug h there can be\nmany printer s in a s y s t e m , the re s h o u l d be o n ly o ne printe r s p o o l e r . T h e re s h o u l d\nbe o n ly o ne f i le s y s t e m a nd o ne windo w manager . A d i g i t a l filter w i ll have o ne\nA/D c o n v e r t e r . An accountin g s y s t e m w i ll be d e d i c a t e d to s e r v i n g one c o m p a n y . How do we e n s u r e that a c l a ss has o n ly one instanc e and that the instanc e is e a s i ly\na c c e s s i b l e ? A g l o b a l v a r i a b l e make s an o b j e c t a c c e s s i b l e , but it doesn' t k e ep you\nfrom instantiatin g multipl e o b j e c t s . A b e t t e r s o l u t i o n is to make t he c l a ss i t s e lf r e s p o n s i b l e for k e e p i n g t r a ck of i ts s o le\ninstance .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 430, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1000}}
{"id": "computer_science_design_patterns_gof_chunk_0431_4d5081b2", "text": "A b e t t e r s o l u t i o n is to make t he c l a ss i t s e lf r e s p o n s i b l e for k e e p i n g t r a ck of i ts s o le\ninstance . The c l a ss can e n s u r e that no other instanc e can be c rea te d (by i n t e r c e p t i n g\nr e q u e s t s to c r e a t e new o b j e c t s ) , and it can p r o v i d e a way to a c c e s s the instance . T h i s is the Singleton pattern. Applicability\nUse the S i n g l e t o n patter n when\n• there must be e x a c t l y one instanc e of a c l a s s, and it must be a c c e s s i b l e to\nc l i e n t s from a well-know n a c c e s s point. • when the s o le instanc e s h o u l d be e x t e n s i b l e by s u b c l a s s i n g , and c l i e n t s\ns h o u l d be able to use an extended instance without modifying their code. S t r u c t u r e\n\nptg1 2 8 CREATIONAL PATTERNS CHAPTER 3\nP a r t i c i p a n t s\n• Singleton\n- define s an Instanc e operatio n t h at l e ts c l i e n t s a c c e s s its uniqu e i n s t a n c e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 431, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_design_patterns_gof_chunk_0432_dd3cfb9e", "text": "S t r u c t u r e\n\nptg1 2 8 CREATIONAL PATTERNS CHAPTER 3\nP a r t i c i p a n t s\n• Singleton\n- define s an Instanc e operatio n t h at l e ts c l i e n t s a c c e s s its uniqu e i n s t a n c e . Instanc e is a c l a ss operatio n ( t h at is, a c l a ss metho d in Smalltal k and a static\nmember function i n C++). - may b e r e s p o n s i b l e f o r creating its own u n i q u e i n s t a n c e . C o l l a b o r a t i o n s\n• Clients access a Singleton instance solely through Singleton's Instance opera -\ntion. C o n s e q u e n c e s\nT he S i n g l e t o n patter n h as s e v e r a l b e n e f i t s :\n1. Controlled access to sole instance. Becaus e the S i n g l e t o n c l a ss encapsulate s its\ns o le instance , it can have stric t contro l o v er how and when c l i e n t s a c c e s s it. 2. Reduced name space. T he S i n g l e t o n pattern is an i m p r o v e m e n t o v er g l o b a l\nvariables .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 432, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 919}}
{"id": "computer_science_design_patterns_gof_chunk_0433_861e29b2", "text": "2. Reduced name space. T he S i n g l e t o n pattern is an i m p r o v e m e n t o v er g l o b a l\nvariables . It avoid s pollutin g the name s p a ce with g l o b a l variable s that store\ns o le instances. 3. Permits refinement of operations and representation. The S i n g l e t o n c l a ss may be\ns u b c l a s s e d , a nd i t 's e a sy to c o n f i g u r e an a p p l i c a t i o n with an i n s t a n c e of t h is\nextende d c l a s s . You can configur e the applicatio n with an instanc e of the\nc l a ss you n e ed at run-time. 4. Permits a variable number of instances. The patter n make s it e a sy to chang e your\nm i nd a nd a l l ow m o re than o ne i n s t a n c e of t he S i n g l e t o n c l a s s. M o r e o v e r ,\nyou can use the same approac h to contro l the numbe r of i n s t a n c e s that\nthe applicatio n u s e s. O n ly the operatio n that grant s a c c e s s to the S i n g l e t o n \ninstanc e need s to change. 5. More flexible than class operations.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 433, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_design_patterns_gof_chunk_0434_eb33f8d2", "text": "O n ly the operatio n that grant s a c c e s s to the S i n g l e t o n \ninstanc e need s to change. 5. More flexible than class operations. Anothe r way to packag e a s i n g l e t o n ' s func-\ntionalit y is to use c l a ss operation s (that i s, static membe r function s in C++ or\nc l a ss method s in Smalltalk) . But both of these languag e technique s make it\nhard to chang e a d e s i g n to allow more than one instanc e of a c l a s s. M o r e o v e r ,\ns t a t ic m e m b e r function s in C ++ a re n e v er v i r t u a l , so s u b c l a s s e s c a n 't o v e r r i d e\nthem polymorphically. Implementation\nHere are implementatio n i s s u e s to conside r when using the S i n g l e t o n pattern:\n1. Ensuring a unique instance. The S i n g l e t o n patter n make s the s o le instanc e a\nnormal instance of a class, but that class is written so that only one instance\n\nptgSINGLETON 1 2 9\nc an e v er be c r e a t e d .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 434, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_design_patterns_gof_chunk_0435_ced5fd2e", "text": "The S i n g l e t o n patter n make s the s o le instanc e a\nnormal instance of a class, but that class is written so that only one instance\n\nptgSINGLETON 1 2 9\nc an e v er be c r e a t e d . A c o m m o n w ay to do t h is is to h i de t he o p e r a t i o n that\ncreate s the instanc e behin d a c l a ss operatio n (that i s, eithe r a static membe r\nfunctio n or a c l a ss method ) that guarantee s o n ly one instanc e is created . T h is\noperatio n has a c c e s s to the variabl e t h at holds the uniqu e instance , and it\ne n s u r e s the variabl e is initialize d with the uniqu e instanc e befor e returnin g\nits value . T h is approac h e n s u r e s that a singleto n is c r e a t e d and i n i t i a l i z e d\nbefor e its first u s e . You can defin e the c l a ss operatio n in C++ with a static membe r functio n\nI n s t a n c e of the S i n g l e t o n c l a s s. S i n g l e t on a l so define s a static membe r\nvariable -instance that contains a pointer to its unique instance.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 435, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_design_patterns_gof_chunk_0436_9451dde3", "text": "S i n g l e t on a l so define s a static membe r\nvariable -instance that contains a pointer to its unique instance. The Singleton class is declared as\nclass Singleto n {\npublic:\nstatic Singleton * Instance() ;\nprotected:\nS i n g l e t o n ( ) ;\nprivate:\nstatic Singleton * _instance ;\n} ;\nT h e corresponding implementation is\nSingleton * Singleton::_instanc e = 0;\nSingleton * Singleton::Instanc e () {\nif ( _ i n s t a n c e == 0) {\n_instanc e = new Singleton ;\n}\nreturn _instance ;\n}\nC l i e n t s a c c e s s the s i n g l e t o n e x c l u s i v e l y throug h the I n s t a n c e m e m b e r func-\ntion. The variabl e - i n s t a n c e is i n i t i a l i z e d to 0, and the static membe r func-\nt i on I n s t a n c e return s i ts v a l u e , i n i t i a l i z i n g it with t he uniqu e i n s t a n c e if it\nis 0. I n s t a n c e u s es lazy initialization ; the value it return s isn't create d and\ns t o r ed until it's first a c c e s s e d . Notic e t h at the constructo r is protected .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 436, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_design_patterns_gof_chunk_0437_6cc37ef1", "text": "I n s t a n c e u s es lazy initialization ; the value it return s isn't create d and\ns t o r ed until it's first a c c e s s e d . Notic e t h at the constructo r is protected . A c l i e nt that t r i es to instantiat e\nS i n g l e t o n directl y w i ll get an e r r or at c o m p i l e - t i m e . T h is e n s u r e s t h at o n ly\none instanc e can e v er get created. M o r e o v e r , s i n ce the - i n s t a n c e is a pointe r toa S i n g l e t o n object , the\nI n s t a n c e m e m b e r functio n c an a s s i g n a p o i n t e rto a s u b c l a s s of S i n g l e -\nt on to this v a r i a b l e . W e ' ll g i ve an exampl e of this int he S a m p l e C o d e . T h e r e ' s anothe r thing to note abou t the C++ implementation . It isn't enoug h\nto defin e the s i n g l e t o n as a g l o b a l or static objec t and then r e ly on automati c\ninitialization .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 437, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_design_patterns_gof_chunk_0438_dd4b2978", "text": "T h e r e ' s anothe r thing to note abou t the C++ implementation . It isn't enoug h\nto defin e the s i n g l e t o n as a g l o b a l or static objec t and then r e ly on automati c\ninitialization . T h e re are three reason s for t h i s :\n(a) We can't guarante e that only one instanc e of a static objec t w i ll e v er be\nd e c l a r e d . ptg1 30 CREATIONAL PATTERNS CHAPTER 3\n(b) We migh t not have e n o u g h informatio n to instantiat e e v e ry s i n g l e t o n\nat static initializatio n time. A s i n g l e t o n migh t r e q u i r e v a l u e s that are\ncompute d later in the program' s e x e c u t i o n . (c) C++ doesn' t defin e the or d er in whic h constructor s for g l o b a l o b j e c t s are\nc a l l ed a c r o s s translatio n units [ E S 9 0 ] . T h is mean s that no d e p e n d e n c i e s\nc an e x i st betwee n s i n g l e t o n s ; if a ny d o, then e r r o r s a re i n e v i t a b l e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 438, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_design_patterns_gof_chunk_0439_60377e06", "text": "T h is mean s that no d e p e n d e n c i e s\nc an e x i st betwee n s i n g l e t o n s ; if a ny d o, then e r r o r s a re i n e v i t a b l e . An adde d (albei t small ) l i a b i l i t y of the global/stati c o b j e c t approac h is that\nit force s all s i n g l e t o n s to be c r ea te d whethe r they are u s ed or not. U s i ng a\nstatic membe r functio n avoid s all of these p r o b l e m s . In S m a l l t a l k , t he functio n that r e t u r n s t he u n i q u e i n s t a n c e is i m p l e m e n t e d\nas a c l a ss metho d on t he S i n g l e t o n c l a s s . To e n s u r e that o n ly o ne i n s t a n c e is\ncreated , overrid e the new operation . The r e s u l t i n g S i n g l e t o n c l a ss migh t have\nthe followin g two c l a ss methods , wher e S o l e l n s t a n c e i s a c l a ss variabl e\nthat is not used anywhere else:\nn e w\nself e r r o r: ' c a n n ot create new object'\ndefault \nSolelnstance isNil ifTrue: [ S o l e l n s t a n c e : = super new]. Solelnstance\n2.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 439, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_design_patterns_gof_chunk_0440_6a742711", "text": "Solelnstance\n2. Subclassing the Singleton class. The main i s s ue is not so much definin g the\ns u b c l a s s but installin g its uniqu e instanc e so that c l i e n t s w i ll be a b le to use \nit. In e s s e n c e , the variabl e t h at refers to the s i n g l e t o n i n s t a n c e must get\ninitialize d with an instanc e of the s u b c l a s s . The s i m p l e s t techniqu e is to \ndetermin e whic h s i n g l e t o n you want to use in the S i n g l e t o n ' s I n s t a n c e\noperation . An exampl e in the S a m p l e C o de show s how to implemen t t h is\ntechniqu e with environmen t v a r i a b l e s . Anothe r way to c h o o s e the s u b c l a s s of S i n g l e t o n is to take the implementatio n\nof I n s t a n c e o ut of t he paren t c l a ss ( e . g ., M a z e F a c t o r y ) a nd p ut it in t he\ns u b c l a s s . That l e ts a C++ programme r d e c i d e the c l a ss of s i n g l e t o n at l i n k -\ntime ( e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 440, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_design_patterns_gof_chunk_0441_c9a1dd96", "text": "g ., M a z e F a c t o r y ) a nd p ut it in t he\ns u b c l a s s . That l e ts a C++ programme r d e c i d e the c l a ss of s i n g l e t o n at l i n k -\ntime ( e . g ., by linkin g in an o b j e c t file containin g a differen t implementation )\nbut k e e ps it hidde n f r om the client s of the s i n g l e t o n . T he link approac h f i x es t he c h o i c e of s i n g l e t o n c l a ss at l i n k - t i m e , w h i c h\nmake s it hard to c h o o s e the s i n g l e t o n c l a ss at run-time . U s i ng c o n d i t i o n a l\nstatement s to determin e the s u b c l a s s is more f l e x i b l e , but it h a r d - w i r e s the\ns et of p o s s i b l e S i n g l e t o n c l a s s e s . Neithe r approac h is fl e xib l e enoug h in a ll\nc a s e s . A more f l e x i b l e approac h u s es a registr y of s i n g l e t o n s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 441, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 836}}
{"id": "computer_science_design_patterns_gof_chunk_0442_173e4ce1", "text": "Neithe r approac h is fl e xib l e enoug h in a ll\nc a s e s . A more f l e x i b l e approac h u s es a registr y of s i n g l e t o n s . Instea d of havin g\nI n s t a n c e defin e t he s et of p o s s i b l e S i n g l e t o n c l a s s e s , t he S i n g l e t o n c l a s s e s\ncan registe r their s i n g l e t o n instanc e by name in a well-know n r e g i s t r y . The registr y maps betwee n string name s and s i n g l e t o n s . Whe n I n s t a n c e\nn e e d s a singleton, it consults the registry, asking for the singleton by name. ptgSINGLETON 1 3 1\nThe registr y looks up the correspondin g singleto n (if it exists ) and return s it. T h is approac h frees I n s t a n c e f r om knowin g all p o s s i b l e S i n g l e t o n c l a s s e s\nor i n s t a n c e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 442, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 782}}
{"id": "computer_science_design_patterns_gof_chunk_0443_99516eba", "text": "T h is approac h frees I n s t a n c e f r om knowin g all p o s s i b l e S i n g l e t o n c l a s s e s\nor i n s t a n c e s . All it require s is a commo n interfac e for all S i n g l e t o n c l a s s e s\nthat i n c l u d e s operation s for the registry:\nc l a ss Singleton {\npublic:\nstatic void Register(cons t c h a r* name, Singleton*) ;\nstatic Singleton * Instance();\nprotected : \nstatic Singleton * L o o k u p ( c o n s t char* name);\nprivate: \ns t a t ic S i n g l e t o n * _ i n s t a n c e ; \nstatic List<NameSingletonPair>* _registry;\n} ;\nR e g i s t e r register s the S i n g l e t o n i n s t a n c e unde r the g i v en name . To keep\nt he r e g i s t r y s i m p l e , w e ' ll have it s t o re a l i st of Name s i n g le t o n P a i r o b j e c t s . Each N a m e S i n g l e t o n P a i r maps a name to a s i n g l e t o n . The L o o k u p op-\ne r a t i o n finds a s i n g l e t o n g i v en i ts n a m e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 443, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_design_patterns_gof_chunk_0444_a9ae8f3f", "text": "Each N a m e S i n g l e t o n P a i r maps a name to a s i n g l e t o n . The L o o k u p op-\ne r a t i o n finds a s i n g l e t o n g i v en i ts n a m e . W e ' ll a s s u m e that an e n v i r o n m e n t\nvariabl e specifie s the name of the singleto n desired. Singleton * Singleton::Instanc e () {\nif ( _ i n s t a n c e = =0) {\nc o n st c h a r* s i n g l e t o n N a m e = g e t e n v ( \" S I N G L E T O N \" ) ;\n// user or environmen t supplies this at startup\n_ i n s t a n ce = L o o k u p ( s i n g l e t o n N a m e ) ; \n// L o o k up returns 0 if t h e r e 's no s u ch singleton\n} \nr e t u r n _instance;\n}\nWher e do S i n g l e t o n c l a s s e s r e g i s t e r themselves ? O ne possibilit y is in their\nconstructor. For example, a MyS i n g l e t o n s u b c l a s s c o u l d do the f o l l o w i n g :\nMySingleton::MySingleton() {\n// . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 444, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 863}}
{"id": "computer_science_design_patterns_gof_chunk_0445_6df87927", "text": "O ne possibilit y is in their\nconstructor. For example, a MyS i n g l e t o n s u b c l a s s c o u l d do the f o l l o w i n g :\nMySingleton::MySingleton() {\n// . . . Singleton::Register(\"MySingleton\", this);\n}\nOf c o u r s e , the constructor won' t get c a l l ed u n l e s s s o m e o n e instantiate s the\nc l a s s, w h i c h e c h o e s t he p r o b l e m t he S i n g l e t o n p a t t e r n is trying to s o l v e ! We can get aroun d this proble m in C++ by definin g a static instanc e of\nM y S i n g l e t o n . For example, we can define\nstatic MySingleton theSingleton;\nin the file that contain s MyS i n g le t o n 's implementation. No l o n g e r is the S i n g l e t o n c l a ss responsibl e f or creatin g the s i n g l e t o n . I n s t e a d ,\nits primary responsibility is to make the singleton object of choice accessible\n\nptg1 32 CREATIONAL PATTERNS CHAPTER 3\nin the system .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 445, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_design_patterns_gof_chunk_0446_fc32987f", "text": "I n s t e a d ,\nits primary responsibility is to make the singleton object of choice accessible\n\nptg1 32 CREATIONAL PATTERNS CHAPTER 3\nin the system . The static o b j e c t approac h s t i ll has a potentia l drawback —\nnamel y that i n s t a n c e s of a ll p o s s i b l e S i n g l e t o n s u b c l a s s e s must be c r e a t e d , or\ne l s e t h e y won't get r e g i s t e r e d . S a m p l e C o d e\nS u p p o s e we d e f i n e a M a z e F a c t o r y c l a ss f or b u i l d i n g m a z e s as d e s c r i b e d on\npage 92. M a z e F a c t o r y define s an interfac e for buildin g differen t parts of a maze . S u b c l a s s e s c an r e d e f i n e t he o p e r a t i o n s to retur n i n s t a n c e s of s p e c i a l i z e d p r o d u c t\nc l a s s e s , l i ke B o m b e d W a l l o b j e c t s i n s t e a d of p l a in W a ll o b j e c t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 446, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 862}}
{"id": "computer_science_design_patterns_gof_chunk_0447_4389e88a", "text": "What' s relevan t h e re is that the Maze applicatio n needs o n ly one instanc e of\na maze factory , and that instanc e s h o u l d be a v a i l a b l e to c o de that build s any \npart of t he maze . T h is is wher e t he S i n g l e t o n patter n c o m e s i n. By makin g t he\nM a z e F a c t o r y a s i n g l e t o n , we make the maze o b j e c t g l o b a l l y a c c e s s i b l e withou t\nr e s o r t i n g to g l o b a l v a r i a b l e s . F or s i m p l i c i t y , l e t 's assum e w e ' ll n e v er s u b c l a s s M a z e F a c t o r y . ( W e ' l l c o n s i d e r\nthe alternativ e in a moment. ) We make it a S i n g l e t o n c l a ss in C++ by addin g a static\nI n s t a n c e o p e r a t i o n and a static - i n s t a n c e membe r to h o ld the one and o n ly\ninstance . We must a l so protec t the constructo r to preven t accidenta l instantiation ,\nw h i c h m i g h t l e a d to more than one instance.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 447, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_design_patterns_gof_chunk_0448_24ae8110", "text": "We must a l so protec t the constructo r to preven t accidenta l instantiation ,\nw h i c h m i g h t l e a d to more than one instance. class MazeFactor y {\npublic:\nstatic MazeFactory * Instance();\n// e x i s t i ng interfac e g o es h e re\nprotected:\nMazeFactory() ;\nprivate:\nstatic MazeFactory * _instance ;\n} ;\nT h e corresponding implementation i s\nM a z e F a c t o r y * M a z e F a c t o r y : : _ i n s t a n c e = 0 ;\nMazeFactory * MazeFactory::Instanc e () {\nif ( _ i n s t a n c e = =0) {\n_instanc e = new MazeFactory ;\n}\nr e t u r n _ i n s t a n c e ;\n}\nN ow l e t 's c o n s i d e r what h a p p e n s w h en t h e re a re s u b c l a s s e s of Ma z eFac t ory, a nd\nt he applicatio n must d e c i d e whic h o ne to u s e. W e ' ll s e l e ct t he k i nd of maze throug h\nan e n v i r o n m e n t v a r i a b l e a nd a dd c o de that i n s t a n t i a t e s t he p r o p e r M a z e F a c t o r y\ns u b c l a s s b a s ed on the environmen t variable' s v a l u e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 448, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_design_patterns_gof_chunk_0449_2dc8a754", "text": "The I n s t a n c e operatio n is\na good place to put this code, because it already instantiates M a z e F a c t o r y :\n\nptgSINGLETON 133\nMazeFactory * MazeFactory::Instanc e () {\nif ( _ i n s t a n c e = =0) {\nconst char* mazeStyl e - getenv(\"MAZESTYLE\");\nif ( s t r c m p ( m a z e S t y l e , \"bombed\" ) == 0) {\n_instanc e = new BombedMazeFactory;\n} else if (strcmp(mazeStyle , \"enchanted\" ) == 0) { \n_instanc e = new EnchantedMazeFactory;\n// . .. other possible subclasses\n} else { // default\n_instanc e = new MazeFactory ;\n}\n} \nreturn _instance;\n}\nNote that I n s t a n c e must be modifie d wheneve r you defin e a new s u b c l a s s of\nM a z e F a c t o r y . That migh t not be a proble m in this a p p l i c a t i o n , but it migh t be\nfor abstrac t factorie s define d in a framework. A p o s s i b l e solutio n woul d be to use the registr y approac h d e s c r i b e d in the I m p l e -\nmentatio n s e c t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 449, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_design_patterns_gof_chunk_0450_99a94153", "text": "A p o s s i b l e solutio n woul d be to use the registr y approac h d e s c r i b e d in the I m p l e -\nmentatio n s e c t i o n . Dynami c linkin g c o u ld be usefu l here as w e l l — i t woul d k e ep\nthe application from having to load all the subclasses that are not used. Known Uses\nAn exampl e of the S i n g l e t o n patter n in S m a l l t a l k - 8 0 [ P a r 9 0 ] is the set of c h a n g e s to\nthe c o d e, whic h is C h a n g e S e t c u r r e n t . A more subtl e exampl e is the r e l a t i o n -\ns h ip betwee n c l a s s e s a nd their metaclasses . A metaclas s is the c l a ss of a c l a s s, and\ne a ch m e t a c l a s s has one instance . M e t a c l a s s e s do not have name s ( e x c e p t i n d i r e c t l y\nthroug h thei r s o le instance) , but they k e ep track of their s o le instanc e and w i ll not\nnormall y creat e another.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 450, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 863}}
{"id": "computer_science_design_patterns_gof_chunk_0451_fe3533de", "text": "M e t a c l a s s e s do not have name s ( e x c e p t i n d i r e c t l y\nthroug h thei r s o le instance) , but they k e ep track of their s o le instanc e and w i ll not\nnormall y creat e another. The Interview s user interfac e toolki t [LCI +92] u s es the S i n g l e t o n patter n to a c c e s s\nt he uniqu e instanc e of i ts S e s s i o n a nd WidgetKi t c l a s s e s , amon g others . S e s s i o n\ndefine s the application' s main event dispatc h l o o p, s t o r e s the user' s database of\nstylisti c preferences , and manage s c o n n e c t i o n s to one or more physica l d i s p l a y s . WidgetKi t is an Abstrac t Factor y ( 8 7) for definin g the l o ok and feel of u s er interfac e\nwidgets . T he W i d g e t K i t : : i n s t a n c e ( ) operatio n determine s t he particula r\nWidgetKi t s u b c l a s s that's instantiate d based on an environmen t variabl e that\nS e s s i o n defines .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 451, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_design_patterns_gof_chunk_0452_83951b92", "text": "T he W i d g e t K i t : : i n s t a n c e ( ) operatio n determine s t he particula r\nWidgetKi t s u b c l a s s that's instantiate d based on an environmen t variabl e that\nS e s s i o n defines . A s i m i l a r operatio n on S e s s i o n determine s whethe r monochrom e\nor c o l or display s are supporte d and configure s the s i n g l e t o n S e s s i o n instanc e\na c c o r d i n g l y . ptg1 3 4 CREATIONAL PATTERNS CHAPTER 3\nRelated P a t t e r n s\nMany pattern s can be implemente d using the S i n g l e t o n pattern . See Abstrac t\nFactory (87), Builder (97), and P r o t o t y p e ( 1 1 7 ) . ptgDISCUSSION O F CREATIONAL PATTERNS 135\nDiscussion of Creational Patterns\nT h e re are two commo n ways to parameteriz e a syste m by the c l a s s e s of o b j e c t s it\nc r e a t e s . One way is to s u b c l a s s the c l a ss that c r e a t e s the o b j e c t s ; this correspond s to\nu s i ng the Factor y Metho d ( 1 0 7) pattern .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 452, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_design_patterns_gof_chunk_0453_983e4870", "text": "One way is to s u b c l a s s the c l a ss that c r e a t e s the o b j e c t s ; this correspond s to\nu s i ng the Factor y Metho d ( 1 0 7) pattern . The main drawbac k of this approac h is that it \ncan r e q u i r e creatin g a new s u b c l a s s just to c h a n g e the c l a ss of the product . S u ch change s\ncan c a s c a d e . For e x a m p l e , when the produc t creato r is i t s e lf c r e a t e d by a f a c t or y method ,\nthen you have to o v e r r i d e its c r e a t o r as w e l l . The other way to parameteriz e a syste m r e l i es more on o b j e c t c o m p o s i t i o n : Defin e an\nobjec t that's r e s p o n s i b l e for knowin g the c l a ss of the produc t o b j e c t s , and make it a\nparamete r of t he system . T h is is a k ey a s p e c t of t he Abstrac t Factor y ( 8 7 ), Builde r ( 9 7 ),\nand Prototyp e ( 1 1 7) patterns . All three i n v o l v e creatin g a new \"factor y o b j e c t \" whos e\nr e s p o n s i b i l i t y is to c r e a t e produc t o b j e c t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 453, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_design_patterns_gof_chunk_0454_9c939a3b", "text": "All three i n v o l v e creatin g a new \"factor y o b j e c t \" whos e\nr e s p o n s i b i l i t y is to c r e a t e produc t o b j e c t s . Abstrac t Factor y has the f a c t o r y o b j e c t p r o -\nducin g object s of s e v e r a l c l a s s e s . B u i l d e r has the f a c t o r y objec t buildin g a c o m p l e x \np r o d u c t i n c r e m e n t a l l y u s i ng a c o r r e s p o n d i n g l y c o m p l e x p r o t o c o l . P r o t o t y p e h as t he\nfactor y o b j e c t buildin g a produc t by c o p y i n g a prototyp e object . In this c a s e, the f a c t o r y\no b j e c t and the prototyp e are the same o b j e c t , b e c a u s e the prototyp e is r e s p o n s i b l e for\nr e t u r n i n g t he p r o d u c t . C o n s i d e r the drawin g e d i t o r framewor k d e s c r i b e d in the Prototyp e pattern .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 454, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 833}}
{"id": "computer_science_design_patterns_gof_chunk_0455_e9747112", "text": "C o n s i d e r the drawin g e d i t o r framewor k d e s c r i b e d in the Prototyp e pattern . T h e re are\ns e v e r a l ways to parameteriz e a GraphicToo l by the c l a ss of product:\n• By applyin g the Factor y Metho d pattern , a s u b c l a s s of G r a p h i c T o o l w i ll be c r e a t e d\nfor e a ch s u b c l a s s of Graphi c in the palette . G r a p h i c T o o l w i ll have a NewGraphi c\noperatio n t h a t e a ch G r a p h i c T o o l s u b c l a s s w i ll redefine. • By applyin g the Abstrac t F a c t o r y pattern , there w i ll be a c l a ss hierarch y of Graph-\ni c s F a c t o r i e s , one for e a ch Graphi c s u b c l a s s . E a ch factor y create s j u st one produc t\nin this c a s e: C i r c l e F a c t o r y w i ll creat e C i r c l e s , L i n e F a c t o r y w i ll creat e L i n e s , a nd\nso on. A G r a p h i c T o o l w i ll be parameterize d with a factor y for creatin g the appro-\npriate kind of Graphics.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 455, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_design_patterns_gof_chunk_0456_69e42e96", "text": "A G r a p h i c T o o l w i ll be parameterize d with a factor y for creatin g the appro-\npriate kind of Graphics. • By a p p l y i n g the Prototyp e pattern , e a ch s u b c l a s s of Graphic s w i ll implemen t the\nC l o n e o p e r a t i o n , and a G r a p h i c T o o l w i ll be parameterize d with a prototyp e of\nthe Graphi c it c r e a t e s . W h i c h patter n is b e st d e p e n d s on many factors . In o ur d r a w i n g e d i t o r framework , t he\nF a c t o r y Metho d patter n is e a s i e s t to use at first. I t 's e a sy to defin e a new s u b c l a s s of\nG r a p h i c T o o l , and the i n s t a n c e s of G r a p h i c T o o l are create d only when the palett e is\nd e f i n e d . T he m a in d i s a d v a n t a g e h e re is that G r a p h i c T o o l s u b c l a s s e s p r o l i f e r a t e , a nd\nnone of them d o es very much.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 456, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 864}}
{"id": "computer_science_design_patterns_gof_chunk_0457_8c939721", "text": "T he m a in d i s a d v a n t a g e h e re is that G r a p h i c T o o l s u b c l a s s e s p r o l i f e r a t e , a nd\nnone of them d o es very much. Abstrac t Factor y d o e s n ' t o f f er much of an improvement , becaus e it require s an e q u a l l y\nl a r ge G r a p h i c s F a c t o r y c l a ss h i e r a r c h y . Abs t rac t F a c t o r y w o u l d be p r e f e r a b l e to F a c t o r y\nMetho d only if there w e re alread y a GraphicsFactor y c l a ss hierarchy—eithe r becaus e\nt he c o m p i l e r p r o v i d e s it automaticall y ( as in S m a l l t a l k or Objectiv e C) or becaus e it's\nn e e d e d i n another part of the system. ptg1 36 CREATIONAL PATTERNS CHAPTER 3\nO v e r a l l , the Prototyp e patter n is probabl y the b e st for the drawin g e d i t o r framework ,\nbecaus e it o n ly r e q u i r e s implementin g a C l o ne operatio n on e a ch Graphic s c l a s s.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 457, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_design_patterns_gof_chunk_0458_96959816", "text": "That\nr e d u c e s the numbe r of c l a s s e s , and C l o n e can be u s ed for p u r p o s e s o t h er than pure\ninstantiatio n ( e . g ., a Duplicat e menu operation). Factor y Metho d make s a d e s i g n m o re customizabl e and o n ly a little m o re c o m p l i c a t e d . Othe r d e s i g n pattern s requir e new c l a s s e s , wherea s Factor y Metho d o n ly r e q u i r e s a new\noperation . P e o p l e often use Factor y Metho d as the standar d way to creat e o b j e c t s , but it\nisn't n e c e s s a r y when the c l a ss that's instantiate d n e v er c h a n g e s or when instantiatio n\ntakes place in an operatio n that s u b c l a s s e s can e a s i ly o v e r r i d e , s u ch as an initializatio n\noperation. D e s i g n s that use Abstrac t F a c t o r y , Prototype , or Bu ild e r are e v en m o re f l e x i b l e than\nthose that use Factor y Method , but they'r e a l so more c o m p l e x .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 458, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 925}}
{"id": "computer_science_design_patterns_gof_chunk_0459_5557f769", "text": "D e s i g n s that use Abstrac t F a c t o r y , Prototype , or Bu ild e r are e v en m o re f l e x i b l e than\nthose that use Factor y Method , but they'r e a l so more c o m p l e x . Often , d e s i g n s start out\nusing Factor y Metho d and e v o l v e towar d the other creationa l pattern s as the d e s i g n e r\nd i s c o v e r s wher e m o re flexibilit y is needed . Knowin g many d e s i g n pattern s g i v es y ou\nmore choices when trading off one design criterion against another. ptgC h a p t e r 4\nS t r u c t u r a l Patterns\nStructura l pattern s are c o n c e r n e d with how c l a s s e s and object s are c o m p o s e d to f o rm\nl a r g e r structures . Structura l class pattern s use inheritanc e to c o m p o s e interface s or im-\nplementations . As a s i m p l e e x a m p l e , c o n s i d e r how multipl e inheritanc e m i x e s two or\nm o re c l a s s e s into o n e. T he resul t is a c l a ss that c o m b i n e s t he propertie s of i ts paren t\nc l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 459, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_design_patterns_gof_chunk_0460_2205163d", "text": "T he resul t is a c l a ss that c o m b i n e s t he propertie s of i ts paren t\nc l a s s e s . T h is patter n is particularl y usefu l for makin g independentl y d e v e l o p e d c l a ss\nlibrarie s work together . Anothe r exampl e is the c l a ss f o rm of the Adapte r ( 1 3 9) pat-\ntern. In g e n e r a l , an adapte r make s one interfac e (the adaptee's ) confor m to another ,\nthereb y providin g a u n i f o r m abstractio n of differen t interfaces . A c l a ss adapte r a c c o m -\np l i s h e s this by inheritin g privatel y f r om an adapte e c l a s s. The adapte r then e x p r e s s e s\nits interfac e in terms of the adaptee's. Rathe r than composin g interface s or implementations , structura l object pattern s de-\ns c r i be ways to c o m p o s e object s to r e a l i z e new functionality .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 460, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 817}}
{"id": "computer_science_design_patterns_gof_chunk_0461_b00b2746", "text": "Rathe r than composin g interface s or implementations , structura l object pattern s de-\ns c r i be ways to c o m p o s e object s to r e a l i z e new functionality . The adde d fl exibi lit y of\no b j e c t c o m p o s i t i o n c o m e s from the a b i l i t y to chang e the compositio n at run-time , whic h\nis i m p o s s i b l e with static c l a ss composition. Composit e ( 1 6 3) is an exampl e of a structura l o b j e c t pattern . It d e s c r i b e s how to build\na c l a ss hierarch y made up of c l a s s e s for two kinds of objects : primitiv e and c o m p o s i t e . The composit e object s let you c o m p o s e primitiv e and other composit e object s into\na r b i t r a r i l y c o m p l e x s t r u c t u r e s . In t he P r o xy ( 2 0 7) p a t t e r n , a p r o xy a c ts as a c o n v e n i e n t\nsurrogat e or placeholde r for anothe r object . A proxy can be used in many ways . It can\nact as a l o c al representativ e for an o b j e c t in a remot e addres s s p a c e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 461, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1000}}
{"id": "computer_science_design_patterns_gof_chunk_0462_7268e9f7", "text": "A proxy can be used in many ways . It can\nact as a l o c al representativ e for an o b j e c t in a remot e addres s s p a c e . It can represen t\na l a r ge objec t that shoul d be loade d on demand . It migh t protec t a c c e s s to a s e n s i t i v e\nobject . P r o x i e s provid e a l e v el of indirectio n to specifi c p r o p e r t i e s of o b j e c t s . Henc e they\ncan r e s t r i c t , enhance , or alter these p r o p e r t i e s . The Flyweigh t ( 1 9 5) patter n define s a structur e for sharin g objects . Object s are share d\nfor at l e a st two r e a s o n s : efficienc y and c o n s i s t e n c y . F l y w e i g h t focuse s on sharin g for\ns p a ce efficiency . Application s that use lots of object s must pay carefu l attentio n to\nt he c o st of e a ch object . Substantia l s a v i n g s c an be h ad by sharin g object s instea d of\nreplicating them. But objects can be shared only if they don't define context-dependent\n1 3 7\n\nptg1 38 STRUCTURAL PATTERNS CHAPTER 4\nstate.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 462, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_design_patterns_gof_chunk_0463_ed4d65e0", "text": "But objects can be shared only if they don't define context-dependent\n1 3 7\n\nptg1 38 STRUCTURAL PATTERNS CHAPTER 4\nstate. F l y w e i g h t object s have no such state. Any additiona l informatio n they n e ed to\nperfor m their task is p a s s e d to them when n e e d e d . With no context-dependen t state,\nF l y w e i g h t object s may be s h a r e d f r e e l y . Wherea s F l y w e i g h t s h o w s h ow to make l o ts of little o b j e c t s , Facad e ( 1 8 5) s h o w s h ow\nto make a s i n g l e o b j e c t r e p r e s e n t an e n t i re s u b s y s t e m . A facad e is a representativ e for a\nset of o b j e c t s . The f a c a d e c a r r i e s out its r e s p o n s i b i l i t i e s by forwardin g m e s s a g e s to the\nobject s it represents . T he B r i d g e ( 1 5 1) patter n separate s an o b j e c t ' s abstractio n from i ts\nimplementatio n so that you can vary them independently.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 463, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_design_patterns_gof_chunk_0464_15294a1e", "text": "T he B r i d g e ( 1 5 1) patter n separate s an o b j e c t ' s abstractio n from i ts\nimplementatio n so that you can vary them independently. Decorato r ( 1 7 5) d e s c r i b e s h ow to a dd r e s p o n s i b i l i t i e s to o b j e c t s d y n a m i c a l l y . Decorato r\nis a structura l patter n that c o m p o s e s o b j e c t s r e c u r s i v e l y to a l l ow an o p e n - e n d e d numbe r\nof additiona l r e s p o n s i b i l i t i e s . F or e x a m p l e , a Decorato r o b j e c t c o n t a i n i n g a u s er interfac e\ncomponen t can add a decoratio n l i ke a borde r or shado w to the c o m p o n e n t , or it can\nadd functionalit y l i ke s c r o l l i n g and zooming . We can add two decoration s s i m p l y by\nnestin g o ne Decorato r o b j e c t withi n another , a nd so on f or additiona l d e c o r a t i o n s . To \na c c o m p l i s h t h i s, each Decorato r o b j e c t must confor m to the interfac e of its componen t\nand must forwar d m e s s a g e s to it.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 464, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_design_patterns_gof_chunk_0465_74c305c2", "text": "To \na c c o m p l i s h t h i s, each Decorato r o b j e c t must confor m to the interfac e of its componen t\nand must forwar d m e s s a g e s to it. The Decorato r can do its job (such as drawin g a\nborde r aroun d the component ) eithe r befor e or after forwardin g a m e s s a g e . Many structura l pattern s are r e l a t e d to s o me d e g r e e . W e ' ll d i s c u s s t h e se r e l a t i o n s h i p s\nat the end of the chapter. ptgA D A P T E D 139\nADAPTER Class, Object Structural\nI n t e n t\nConver t the interfac e of a c l a ss into anothe r interfac e c l i e n t s e x p e c t . Adapte r l e ts\nc l a s s e s w o r k t o g e t h e r t h a t c o u l d n ' t o t h e r w i s e b e c a u s e of incompatible interfaces. A l s o Known As\nWrapper\nMotivation\nS o m e t i m e s a toolki t c l a ss that's d e s i g n e d for r e u se i s n 't reusabl e o n ly becaus e its\ninterfac e doesn' t matc h the domain-specifi c interfac e an applicatio n r e q u i r e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 465, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_design_patterns_gof_chunk_0466_36722d57", "text": "C o n s i d e r f or exampl e a drawin g e d i t o r that l e ts u s e rs draw and arrang e graphica l\ne l e m e n t s ( l i n e s , p o l y g o n s , t e x t, e t c .) into p i c t u r e s and diagrams . The drawin g\neditor' s key abstractio n is the graphica l o b j e c t , whic h has an e d i t a b l e shape and\ncan draw itself . The interfac e for graphica l o b j e c t s is define d by an abstrac t c l a ss\nc a l l ed S h a p e . The edito r define s a s u b c l a s s of S h a p e for e a ch k i nd of graphica l\nobject : a L i n e S h a p e c l a ss for l i n e s, a P o l y g o n S h a p e c l a ss for p o l y g o n s , and so\nforth. C l a s s e s for elementar y geometri c s h a p e s l i ke L i n e S h a p e and P o l y g o n S h a p e are\nrathe r easy to i m p l e m e n t , becaus e their drawin g and editin g c a p a b i l i t i e s are \ninherentl y l i m i t e d .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 466, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_design_patterns_gof_chunk_0467_75fae469", "text": "But a T e x t S h a p e s u b c l a s s that can d i s p l a y and edit text is\nc o n s i d e r a b l y more difficul t to implement , s i n ce e v en b a s ic text editin g i n v o l v e s\nc o m p l i c a t e d s c r e e n u p d a t e and b u f f e r management . Meanwhile , an off-the-shel f\nuser interfac e toolki t migh t alread y provid e a sophisticate d T e x t V i e w c l a ss for\ndisplayin g and editin g text. I d e a l l y we'd like to r e u se T e x t V i e w to implemen t\nT e x t S h a p e , b ut t he toolki t wasn' t d e s i g n e d with S h a p e c l a s s e s in mind . So we\ncan't use T e x t V i e w and S h a p e o b j e c t s interchangeably. How can existin g and unrelate d c l a s s e s like T e x t V i e w work in an applicatio n that\ne x p e c t s c l a s s e s with a differen t and incompatibl e interface ?", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 467, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 839}}
{"id": "computer_science_design_patterns_gof_chunk_0468_22366fec", "text": "How can existin g and unrelate d c l a s s e s like T e x t V i e w work in an applicatio n that\ne x p e c t s c l a s s e s with a differen t and incompatibl e interface ? We c o u ld chang e the\nT e x t V i e w c l a ss so that it conform s to the Shap e interface , but that isn't an optio n\nunles s we have the toolkit' s s o u r c e c o d e. Even if we d i d, it wouldn' t make s e n se to\nchang e T e x t V i e w ; the toolki t shouldn' t have to adop t domain-specifi c interface s\njust to make one applicatio n work. Instead , we c o u ld defin e T e x t S h a p e so that it adapts the T e x t V i e w interfac e to\nS h a p e ' s . We can do this in one of two ways : (1) by inheritin g S h a p e ' s interfac e\nand T e xt View' s implementatio n or (2) by c o m p o s i n g a T e x t V i e w instanc e withi n\na TextShape a n d implementing TextShape i n terms of Text V i e w ' s i n t e r f a c e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 468, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 910}}
{"id": "computer_science_design_patterns_gof_chunk_0469_ec6d5b9c", "text": "T h e s e\n\nptg1 4 0 STRUCTURAL PATTERNS CHAPTER 4\ntwo approache s correspon d to the c l a ss and o b j e c t v e r s i o n s of the Adapte r pattern . W e call TextShape an adapter. T h is diagra m illustrate s t he o b j e c t adapte r c a s e. It s h o w s h ow B o u n d i n g B o x r e -\nq u e s t s , d e c l a r e d in c l a ss S h a p e , a re converte d to GetExten t r e q u e s t s define d in\nT e xt V i e w . S i n ce T e x t S h a p e adapt s T e xt V i ew to t he S h a p e interface , t he drawin g\nedito r c an r e u se t he oth erw is e incompatibl e T e xt V i ew c l a s s . Often the adapte r is r e s p o n s i b l e for functionalit y the adapte d c l a ss d o e s n ' t p r o -\nv i d e. The diagra m s h o w s how an adapte r can fulfil l s u ch r e s p o n s i b i l i t i e s . The\nuser s h o u l d be a b le to \" d r a g \" e v e ry S h a p e o b j e c t to a n ew l o c a t i o n i n t e r a c t i v e l y ,\nbut T e xt V i ew i s n 't d e s i g n e d to do that.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 469, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_design_patterns_gof_chunk_0470_98c9e7f0", "text": "The\nuser s h o u l d be a b le to \" d r a g \" e v e ry S h a p e o b j e c t to a n ew l o c a t i o n i n t e r a c t i v e l y ,\nbut T e xt V i ew i s n 't d e s i g n e d to do that. T e x t S h a p e can add this m i s s i n g function-\nality by implementin g S h a p e ' s CreateManipulato r operation , whic h return s an \ninstanc e of the appropriat e Manipulato r s u b c l a s s . Manipulato r is an abstrac t c l a ss for o b j e c t s that know how to animat e a S h a p e in\nr e s p o n s e to user input , l i ke draggin g the shape to a new location . T h e re are s u b -\nc l a s s e s of Manipulato r for differen t s h a p e s ; TextManipulator , for e x a m p l e , is the\ncorrespondin g s u b c l a s s for T e x t S h a p e . By returnin g a TextManipulato r i n s t a n c e ,\nT e x t S h a p e adds the functionality that Text V i e w lacks but Shape requires.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 470, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 881}}
{"id": "computer_science_design_patterns_gof_chunk_0471_da216ec2", "text": "By returnin g a TextManipulato r i n s t a n c e ,\nT e x t S h a p e adds the functionality that Text V i e w lacks but Shape requires. Applicability\nUse the Adapte r patter n when\n• you w a nt to use an e x i s t i n g c l a s s, and its interfac e d o es not matc h the one\ny ou n e e d . • you want to creat e a r e u s a b l e c l a ss that cooperate s with unrelate d or unfore-\ns e en c l a s s e s , that is, c l a s s e s t h at don't n e c e s s a r i l y have compatibl e interfaces. • (object adapter only) you need to use s e v e r a l e x i s t i n g s u b c l a s s e s , but it's un-\np r a c t i c a l to adap t t h e ir i n t e r f a c e by s u b c l a s s i n g e v e ry o n e. An o b j e c t a d a p t e r\ncan adapt the interface of its parent class.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 471, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 768}}
{"id": "computer_science_design_patterns_gof_chunk_0472_f37333a1", "text": "An o b j e c t a d a p t e r\ncan adapt the interface of its parent class. ptgADAPTER 141\nS t r u c t u r e\nA class adapter uses multiple inheritance to adapt one interface to another:\nAn object adapter relies on object composition:\nP a r t i c i p a n t s\n• Target (Shape)\n- defines the d o m a i n - s p e c i f i c interface that Client uses. • C l i e n t ( D r a w i n g E d i t o r )\n- collaborates with objects conforming to the T a r g e t i n t e r f a c e . • Adaptec ( T e x t V i e w )\n- defines an e x i s t i n g i n t e r f a c e t h a t n e e d s a d a p t i n g . • Adapter ( T e x t S h a p e )\n- adapts the interface of A d a p t e c to the Target i n t e r f a c e . C o l l a b o r a t i o n s\n• C l i e n t s c a ll o p e r a t i o n s on an Adapte r i n s t a n c e . In turn, t he a d a p t e r c a l ls\nAdaptec operations that carry out the request. ptg1 4 2 STRUCTURAL P A T T E R N S CHAPTER 4\nC o n s e q u e n c e s\nC l a ss and objec t adapter s have differen t trade-offs .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 472, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_design_patterns_gof_chunk_0473_00c097b7", "text": "ptg1 4 2 STRUCTURAL P A T T E R N S CHAPTER 4\nC o n s e q u e n c e s\nC l a ss and objec t adapter s have differen t trade-offs . A c l a ss adapter\n• adapt s Adapte e to T a r g e t by committin g to a c o n c r e t e Adapte e c l a s s . As a\nc o n s e q u e n c e , a c l a ss adapte r won' t work w h en we want to adap t a c l a ss and\na ll i ts s u b c l a s s e s . • l e ts Adapte r o v e r r i d e s o m e of A d a p t e e ' s b e h a v i o r , s i n ce Adapte r is a s u b c l a s s\nof Adaptee. • introduce s o n ly one object , and no additiona l pointe r i n d i r e c t i o n is n e e d e d\nto get to the adaptee. An objec t adapter\n• l e ts a s i n g le Adapte r work with many Adaptees—tha t i s, t he A d a p t e e i t s e lf\nand all of its s u b c l a s s e s (if any). The Adapte r can a l so add functionalit y to\na ll A d a p t e e s at o n c e . • make s it harde r to overrid e Adapte e behavior .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 473, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 919}}
{"id": "computer_science_design_patterns_gof_chunk_0474_05815aaf", "text": "The Adapte r can a l so add functionalit y to\na ll A d a p t e e s at o n c e . • make s it harde r to overrid e Adapte e behavior . It w i ll requir e s u b c l a s s i n g\nAdapte e a nd m a k i n g Adapte r refer to t he s u b c l a s s rathe r t h an t he A d a p t e e\nitself. Here are other issue s to conside r when using the Adapte r pattern:\n1. H ow much adapting does Adapter do ? Adapter s vary in t he amoun t of work t h ey\ndo to adap t Adapte e to the Targe t interface . Ther e is a spectru m of p o s s i b l e\nwork , f r om s i m p l e interfac e conversion—fo r example , c h a n g i n g the name s of\noperations—t o supportin g an entirel y differen t set of o p e r a t i o n s . The amoun t\nof work A d a p t e r d o es depend s on how s i m i l a r the T a r g e t interfac e is to\nAdaptee's. 2. Pluggable adapters. A c l a ss is more reusabl e when you minimiz e the assump-\nt i o ns other c l a s s e s must make to use it.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 474, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_design_patterns_gof_chunk_0475_efbe5b95", "text": "2. Pluggable adapters. A c l a ss is more reusabl e when you minimiz e the assump-\nt i o ns other c l a s s e s must make to use it. By b u i l d i n g interfac e adaptatio n i n to\na c l a s s , you eliminat e the assumptio n that other c l a s s e s see the same i n t e r -\nface. P ut a n o t h e r way, interfac e adaptatio n l e ts us i n c o r p o r a t e o ur c l a ss i n to\nexistin g s y s t e m s that migh t expec t d i f f e r e n t interface s to the c l a s s . Object-\nWorks\\Smalltal k [ P a r 9 0 ] u s es the term pluggabl e adapte r to d e s c r i b e c l a s s e s\nwith built-i n interfac e adaptation. C o n s i d e r a T r e e D i s p l a y widge t that can displa y tree structure s g r a p h i c a l l y . If this were a special-purpos e widget for use in j u st one application , then\nwe migh t requir e the object s that it display s to have a specifi c interface ; that \nis, all must d e s c e n d f r om a T r ee abstrac t c l a s s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 475, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_design_patterns_gof_chunk_0476_b73d8e85", "text": "But if we wante d to make\nT r e e D i s p l a y more reusabl e (say we wante d to make it part of a toolki t of\nusefu l w i d g e t s ) , t h en that r e q u i r e m e n t woul d be u n r e a s o n a b l e . A p p l i c a t i o n s\nwill defin e their own c l a s s e s for tree structures . T h e y shouldn' t be force d\nto use our T r ee abstrac t c l a s s . Differen t tree structure s w i ll have differen t\ninterfaces. ptgA D A P T E D 1 4 3\nIn a d i r e c t o r y h i e r a r c h y , f or e x a m p l e , c h i l d r e n m i g h t be a c c e s s e d with a\nGetSubdirectorie s operation , wherea s in an inheritanc e hierarchy , the c o r r e -\nspondin g operatio n migh t be c a l l ed G e t S u b c l a s s e s . A reusabl e T r e e D i s p l a y\nwidge t must be a b le to displa y both kinds of h i e r a r c h i e s e v en if they use\ndifferen t interfaces . In other w o r d s , the T r e e D i s p l a y shoul d have interfac e \nadaptatio n built into it.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 476, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_design_patterns_gof_chunk_0477_bfff33a2", "text": "In other w o r d s , the T r e e D i s p l a y shoul d have interfac e \nadaptatio n built into it. W e ' ll l o ok at differen t ways to build interfac e adaptatio n into c l a s s e s in the\nImplementatio n s e c t i o n . 3. Using two-way adapters to provide transparency. A potentia l proble m with\nadapter s is that they aren' t transparen t to all c l i e n t s . An adapte d objec t no\nl o n g e r conform s to the Adapte c interface , so it can't be u s ed as is whereve r\nan Adapte c o b j e c t c a n. Two-wa y adapter s can provid e such transparency . S p e c i f i c a l l y , they'r e usefu l when two differen t c l i e n t s n e ed to v i ew an o b j e c t\ndifferently. C o n s i d e r the two-wa y adapte r that integrate s Unidraw , a graphica l e d i -\nt or framewor k [ V L 9 0 ] , a nd Q O C A , a constraint-solvin g t o o l k i t [ H H M V 9 2 ] .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 477, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 869}}
{"id": "computer_science_design_patterns_gof_chunk_0478_068c5f4a", "text": "C o n s i d e r the two-wa y adapte r that integrate s Unidraw , a graphica l e d i -\nt or framewor k [ V L 9 0 ] , a nd Q O C A , a constraint-solvin g t o o l k i t [ H H M V 9 2 ] . Both s y s t e m s have c l a s s e s that represen t variable s e x p l i c i t l y : Unidra w has\nState V a r i a b l e , and Q O C A has ConstraintVariable . To make Unidra w work\nwith Q O C A , ConstraintVariabl e must be adapte d to State Variable ; to let\nQ O C A propagat e solution s to Unidraw , State Variabl e must be adapte d to\nC o n s t r a i n t V a r i a b l e . The solutio n i n v o l v e s a two-wa y c l a ss adapte r ConstraintStateVariable , a\ns u b c l a s s of both State Variabl e and ConstraintVariable , that adapt s the two\ninterface s to e a ch o t h e r . M u l t i p l e inheritanc e is a v i a b l e solutio n in t h is c a se\nbecaus e the interface s of the adapte d c l a s s e s are substantiall y different .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 478, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 929}}
{"id": "computer_science_design_patterns_gof_chunk_0479_a29f3c1d", "text": "M u l t i p l e inheritanc e is a v i a b l e solutio n in t h is c a se\nbecaus e the interface s of the adapte d c l a s s e s are substantiall y different . The\ntwo-wa y c l a ss adapte r conform s to both of the adapte d c l a s s e s and can work \ni n either system. I m p l e m e n t a t i o n\nAlthoug h the implementatio n of A d a p t e r is usuall y straightforward , here are\ns o m e issues to keep in mind:\n\nptg1 4 4 STRUCTURAL PATTERNS CHAPTER 4\n1. Implementing class adapters in C++. In a C++ implementatio n of a c l a ss adapter ,\nAdapte r woul d inheri t publicl y f r om T a r g e t and privatel y from Adaptec . T h us Adapte r woul d be a subtyp e of T a r g e t but not of Adaptec. 2. Pluggable adapters. Let's l o ok at t h r ee ways to implemen t p l u g g a b l e adapter s\nfor the T r e e D i s p l a y widge t d e s c r i b e d e a r l i e r , w h i c h can lay out and displa y\na h i e r a r c h i c a l structur e automatically.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 479, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_design_patterns_gof_chunk_0480_8c1a249a", "text": "T he first s t e p, w h i c h is commo n to a ll t hree of t he implementation s d i s c u s s e d\nh e r e, is to find a \" n a r r o w \" i n t e r f a c e f or A d a p t e c , that i s, t he s m a l l e s t s u b s e t\nof operation s that l e ts us do the adaptation . A narro w interfac e c o n s i s t i n g of\no n ly a c o u p l e of operation s is eas ie r to adap t than an interfac e with dozen s\nof operations . F or T r e e D i s p l a y , t he adapte e is a ny h i e r a r c h i c a l structure . A\nm i n i m a l i s t interfac e m i g h t i n c l u d e two operations , one that define s how to\npresen t a n o de in the h i e r a r c h i c a l structur e g r a p h i c a l l y , and anothe r that\nretrieve s the node' s c h i l d r e n . The narro w interfac e l e a ds to three implementatio n approaches:\n(a) Using abstract operations. Defin e c o r r e s p o n d i n g abstrac t operation s f or the\nnarro w Adapte e interfac e in t he T r e e D i s p l a y c l a s s.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 480, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_design_patterns_gof_chunk_0481_f47cea9f", "text": "Defin e c o r r e s p o n d i n g abstrac t operation s f or the\nnarro w Adapte e interfac e in t he T r e e D i s p l a y c l a s s. S u b c l a s s e s must i m -\nplemen t the abstrac t operation s and adap t the h i e r a r c h i c a l l y structure d\nobject . F or e x a m p l e , a D i r e c t o r y T r e e D i s p l a y s u b c l a s s w i ll i m p l e m e n t\nt h e s e o p e r a t i o n s by accessing the directory structure. D i r e c t o r y T r e e D i s p l a y s p e c i a l i z e s t he narro w interfac e so that it c an d i s -\nplay director y structures made up of F i l e S y s t e m E n t i t y objects. (b) Using delegate objects. In t h is approach , T r e e D i s p l a y forward s r e q u e s t s for\na c c e s s i n g the h i e r a r c h i c a l structur e to a delegat e object . T r e e D i s p l a y can\nuse a differen t adaptatio n strateg y by substitutin g a differen t delegate.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 481, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_design_patterns_gof_chunk_0482_5a499430", "text": "T r e e D i s p l a y can\nuse a differen t adaptatio n strateg y by substitutin g a differen t delegate. For example , s u p p o s e there e x i s ts a D i r e c t o r y B r o w s e r that u s es a T r e e -\nD i s p l a y . D i r e c t o r y B r o w s e r m i g h t make a g o od d e l e g a t e f or a d a p t i n g\nT r e e D i s p l a y to the hierarchica l director y structure . In dynamicall y typed\nlanguage s l i ke S m a l l t a l k or O b j e c t i v e C, t h is approac h o n ly r e q u i r e s an\ninterface for registering the delegate with the adapter. Then TreeDisplay\n\nptgA D A P T E D 1 4 5\nsimpl y f o r w a r d s the request s to the delegate . N E X T S T E P [Add94 ] u s e s\nt h is approac h heavil y to reduc e s u b c l a s s i n g . Staticall y typed language s l i ke C++ requir e an explici t interfac e defin-\ni t i on for the de le ga te .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 482, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 866}}
{"id": "computer_science_design_patterns_gof_chunk_0483_a0886dfa", "text": "Staticall y typed language s l i ke C++ requir e an explici t interfac e defin-\ni t i on for the de le ga te . We can specif y such an interfac e by puttin g the\nnarro w interfac e that T r e e D i s p l a y require s into an abstrac t T r e e A c c e s -\nsorDelegat e c l a s s . T h en we can mix this interfac e into the delegat e of\no ur ch oic e—D ire ct ory Br ow se r in t h is case—usin g inheritance . We u se\ns i n g le inheritanc e if the DirectoryBrowse r has no existin g paren t c l a s s,\nmultipl e inheritanc e if it d o e s. M i x i n g c l a s s e s togethe r l i ke t h is is e a s -\ni er than i n t r o d u c i n g a n ew T r e e D i s p l a y s u b c l a s s a nd i m p l e m e n t i n g i ts\noperations individually. (c)Parameterized adapters. The usual way to suppor t pluggabl e adapter s in\nSmalltal k is to parameteriz e an adapte r with one or more blocks . The\nb l o ck c o n s t r u c t s u p p o r t s adaptatio n withou t s u b c l a s s i n g .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 483, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_design_patterns_gof_chunk_0484_e0143725", "text": "The\nb l o ck c o n s t r u c t s u p p o r t s adaptatio n withou t s u b c l a s s i n g . A b l o ck c an\nadap t a r e q u e s t , and the adapte r can store a block for each individua l\nrequest . In our example , t h is mean s T r e e D i s p l a y s t o r e s one block for\nc o n v e r t i n g a n o de i n to a G r a p h i c N o d e a nd a n o t h e r b l o ck f or a c c e s s i n g\na n o d e ' s c h i l d r e n . For e x a m p l e , to creat e T r e e D i s p l a y on a director y hierarchy , we write\nd i r e c t o r y D i s p l a y := \n( T r e e D i s p l a y o n: treeRoot ) \ngetChildrenBlock:\n[mode | node getSubdirectories ]\ncreateGraphicNodeBlock:\n[ : n o de | n o de createGraphicNode]. If you'r e buildin g interfac e adaptatio n into a c l a s s, this approac h offer s\na convenient alternative to subclassing.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 484, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 828}}
{"id": "computer_science_design_patterns_gof_chunk_0485_75142cdf", "text": "If you'r e buildin g interfac e adaptatio n into a c l a s s, this approac h offer s\na convenient alternative to subclassing. ptg146 STRUCTURAL P A T T E R N S CHAPTER 4\nS a m p l e C o d e\nW e ' l l g i ve a b r i ef s k e t c h of t he i m p l e m e n t a t i o n of c l a ss a nd o b j e c t a d a p t e r s f or t he\nM o t i v a t i o n e x a m p l e b e g i n n i n g w i th t he c l a s s e s S h a p e a nd Text V i e w . class S h a pe {\npublic:\nShape(); \nvirtual void B o u n d i n g B o x (\nP o i n t& bottomLeft , P o i n t& topRight \n) const; \nvirtual Manipulator * CreateManipulator( ) const;\nclass TextView {\npublic:\nT e x t V i e w ( ) ; \nvoid GetOrigin(Coord k x, C o o r d& y) const; \nvoid GetExtent(Coord k width, C o o r d& height) const;\nvirtual b o ol IsEmptyO c o n s t ;\n} ;\nShap e a s s u m e s a b o u n d i n g b ox d e f i n e d by i ts o p p o s i n g c o r n e r s . In c o n t r a s t ,\nT e x t V i e w is define d by an o r i g i n , h e i g h t , a nd width .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 485, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_design_patterns_gof_chunk_0486_5345b51c", "text": "In c o n t r a s t ,\nT e x t V i e w is define d by an o r i g i n , h e i g h t , a nd width . Shap e a l so d e f i n e s a\nC r e a t e M a n i p u l a t o r o p e r a t i o n for c r e a t i n g a M a n i p u l a t o r o b j e c t , w h i c h\nk n o w s h ow to a n i m a t e a s h a p e w h en t he u s er m a n i p u l a t e s it.1 T e x t V i e w h as\nno e q u i v a l e n t o p e r a t i o n . T he c l a ss Text Shap e is an a d a p t e r b e t w e e n t h e se dif-\nf e r e n t i n t e r f a c e s . A c l a ss a d a p t e r u s es m u l t i p l e i n h e r i t a n c e to a d a p t interfaces . T he k ey to c l a ss\na d a p t e r s is to u se o ne i n h e r i t a n c e b r a n c h to i n h e r i t t he i n t e r f a c e a nd a n o t h e r\nb r a n c h to i n h e r i t t he i m p l e m e n t a t i o n . T he u s u a l w ay to m a ke t h is d i s t i n c t i o n in\nC ++ is to i n h e r i t t he interfac e p u b l i c l y a nd i n h e r i t t he i m p l e m e n t a t i o n p r i v a t e l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 486, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_design_patterns_gof_chunk_0487_2229fc15", "text": "T he u s u a l w ay to m a ke t h is d i s t i n c t i o n in\nC ++ is to i n h e r i t t he interfac e p u b l i c l y a nd i n h e r i t t he i m p l e m e n t a t i o n p r i v a t e l y . W e ' l l u se t h is c o n v e n t i o n to d e f i n e t he T e xt Shap e a d a p t e r . c l a ss TextShape : public S h a p e, private TextView {\npublic:\nTextShape();\nvirtual void BoundingBox(\nPointk bottomLeft , P o i n t& topRight \n) c o n s t; \nvirtual b o ol IsEmptyO const; \nvirtual Manipulator* CreateManipulator() const;\nThe B o u n d i n g B o x o p e r a t i o n c o n v e r t s T e x t v i e w ' s i n t e r f a c e t o c o n f o r m t o\nShape's. 1 C r e a t e M a n i p u l a t o r i s a n e x a m p l e o f a Factory Method (107).", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 487, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 737}}
{"id": "computer_science_design_patterns_gof_chunk_0488_a3c0e875", "text": "1 C r e a t e M a n i p u l a t o r i s a n e x a m p l e o f a Factory Method (107). ptgADAPTER 147\nvoid TextShape::BoundingBo x (\nP o i n t& bottomLeft , Point& topRight\n) const {\nCoord bottom, left, width, height;\nGetOrigin(bottom , left);\nGetExtent(width , height);\nbottomLef t = Point(bottom , left); \ntopRight = Point(bottom + height, left + width);\nT he I sEmpt y o p e r a t i o n d e m o n s t r a t e s t he d i r e c t f o r w a r d i n g of r e q u e s t s c o m m o n\ni n adapter implementations:\nbool TextShape::IsEmpt y () const {\nreturn TextView::IsEmpty();\n}\nF i n a l l y , we d e f i n e C r e a t e M a n i p u l a t o r ( w h i c h i s n 't s u p p o r t e d by T e x t V i e w )\nf r om s c r a t c h . A s s u m e w e ' v e a l r e a d y i m p l e m e n t e d a T e x t M a n i p u l a t o r c l a ss\nt h a t supports manipulation of a TextShape.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 488, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 868}}
{"id": "computer_science_design_patterns_gof_chunk_0489_ba9ff7b7", "text": "A s s u m e w e ' v e a l r e a d y i m p l e m e n t e d a T e x t M a n i p u l a t o r c l a ss\nt h a t supports manipulation of a TextShape. Manipulator * TextShape::CreateManipulato r () c o n st {\nreturn new TextManipulator(this);\n}\nT h e object adapter u s e s object composition to combine classes with different inter -\nfaces. In t h i s a p p r o a c h , the a d a p t e r T e x t S h a p e m a i n t a i n s a p o i n t e r to T e x t V i e w . class TextShap e : public S h a pe {\npublic:\nTextShape(TextView*);\nvirtual void BoundingBox(\nP o i n t& bottomLeft , Point& topRight \n) const; \nvirtual bool IsEmpty( ) const; \nvirtual Manipulator * CreateManipulator( ) const;\nprivate:\nTextView * _text;\n} ;\nT e x t S h a p e m u st i n i t i a l i z e t he p o i n t e r to t he T e x t V i e w i n s t a n c e , a nd it d o es so\nin t he c o n s t r u c t o r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 489, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 868}}
{"id": "computer_science_design_patterns_gof_chunk_0490_0a680bca", "text": "It m u st a l so c a ll o p e r a t i o n s on i ts T e x t V i e w o b j e c t w h e n e v e r\ni ts o wn o p e r a t i o n s a re c a l l e d . In t h is e x a m p l e , a s s u m e t h at t he c l i e n t c r e a t e s t he\nT e x t V i e w o b j e c t a n d passes it to the TextShape constructor:\nTextShape::TextShap e ( T e x t V i e w * t) {\n_text = t;\n}\n\nptg1 4 8 STRUCTURAL P A T T E R N S CHAPTER 4\nvoid TextShape::BoundingBo x (\nPoint& bottomLeft , Points topRight\n) c o n st {\nCoord bottom, left, width, height;\n_text->GetOrigin(bottom , left);\n__text->GetExten t (width, height) ;\nbottomLef t = Point(bottom , left); \ntopRight = Point(botto m + height, left + width);\n}\nbool TextShape::IsEmpt y () c o n st {\nreturn _text->IsEmpty();\n}\nC r e a t e M a n i p u la t o r 's implementatio n doesn' t chang e f r om the c l a ss adapte r\nv e r s i o n , s i n ce it's implemente d f r om scratc h and doesn' t r e u se any e x i s t i n g\nT e x t V i e w functionality.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 490, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_design_patterns_gof_chunk_0491_ec6abb5b", "text": "Manipulator * TextShape::CreateManipulato r () const {\nreturn new TextManipulator(this);\n}\nCompar e this c o de to the c l a ss adapte r c a s e. The objec t adapte r r e q u i r e s a l i t t le\nmore e f f o r t to write , but it's more f l e x i b l e . For e x a m p l e , the objec t adapte r v e r s i o n\nof T e x t S h a p e w i ll work e q u a l l y w e ll with s u b c l a s s e s of T e xt View—th e c l i e nt\ns i m p l y p a s s e s an instance o f a Text V i e w subclass to the TextShape constructor. K n o w n Uses\nThe Motivatio n exampl e c o m e s from ET++Draw , a drawin g applicatio n b a s ed on \nET++ [ W G M 8 8 ] . ET++Dra w r e u s e s the ET++ c l a s s e s for text e d i t i n g by using a\nT e x t S h a p e adapte r c l a s s . Interview s 2.6 define s an Interacto r abstrac t c l a ss for user interfac e e l e m e n t s s u ch\nas s c r o ll bars, buttons , a nd menu s [ V L 8 8 ] .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 491, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_design_patterns_gof_chunk_0492_90627b51", "text": "Interview s 2.6 define s an Interacto r abstrac t c l a ss for user interfac e e l e m e n t s s u ch\nas s c r o ll bars, buttons , a nd menu s [ V L 8 8 ] . It a l so define s a Graphi c abstrac t c l a ss\nfor structure d graphi c object s such as l i n e s, c i r c l e s , p o l y g o n s , and s p l i n e s . B o th\nInteractor s and Graphic s have graphica l appearances , but they have differen t \ninterface s and implementation s (they share no commo n paren t c l a s s) and are\ntherefor e incompatible—yo u can't e m b e d a structure d graphi c o b j e c t in, s a y, a\nd i a l o g b ox d i r e c t l y . Instead , I n t e r v i e w s 2 .6 define s an o b j e c t adapte r c a l l ed G r a p h i c B l o c k , a s u b c l a s s of\nInteracto r that c o n t a i n s a Graphi c instance . The G r a p h i c B l o c k adapt s the interfac e\nof the Graphi c c l a ss to t h at of Interactor .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 492, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 897}}
{"id": "computer_science_design_patterns_gof_chunk_0493_ab9534a7", "text": "The G r a p h i c B l o c k adapt s the interfac e\nof the Graphi c c l a ss to t h at of Interactor . The GraphicBloc k l e ts a Graphi c instanc e\nbe d i s p l a y e d , s c r o l l e d , and z o o m e d withi n an Interacto r structure. Pluggabl e adapter s are commo n in ObjectWorks\\Smalltal k [ P a r 9 0 ] . Standar d\nS m a l l t a l k d e f i n e s a ValueModel class for views that display a single value. Val-\nueModel defines a value, value: i n t e r f a c e f o r accessing the value. These are\n\nptgADAPTER 1 4 9\nabstrac t methods . Applicatio n writer s a c c e s s the value with more domain-specifi c\nname s l i ke w i d t h and w i d t h : , but they shouldn' t have to s u b c l a s s V a l u e M o d e l\nto adap t s u ch application-specifi c name s to the ValueMode l interface. I n s t e a d , O b j e c t W o r k s \\ S m a l l t a l k i n c l u d e s a s u b c l a s s of V a l u e M o d e l c a l l ed P l u g -\ngableAdaptor .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 493, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_design_patterns_gof_chunk_0494_93b0cfdb", "text": "I n s t e a d , O b j e c t W o r k s \\ S m a l l t a l k i n c l u d e s a s u b c l a s s of V a l u e M o d e l c a l l ed P l u g -\ngableAdaptor . A PluggableAdapto r o b j e c t adapt s other object s to the V a l u e M o d e l\ninterfac e ( v a l u e , v a l u e : ) . It can be parameterize d with b l o c k s for gettin g and\nsettin g the d e s i r e d value . PluggableAdapto r u s es t h e se b l o c k s internall y to im-\nplemen t the v a l u e , v a l u e : interface . PluggableAdapto r a l so l e ts you pass in\nt he s e l e c t o r n a m e s ( e . g ., w i d t h , w i d t h : ) d i r e c t l y f or s y n t a c t i c c o n v e n i e n c e . It\nconverts these selectors into the corresponding blocks automatically. Anothe r exampl e from ObjectWorks\\Smalltal k is the TableAdapto r c l a s s. A\nTableAdapto r can adap t a s e q u e n c e of o b j e c t s to a tabula r presentation . The table\nd i s p l a y s o ne o b j e c t p er r o w.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 494, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_design_patterns_gof_chunk_0495_f2a3a6e8", "text": "A\nTableAdapto r can adap t a s e q u e n c e of o b j e c t s to a tabula r presentation . The table\nd i s p l a y s o ne o b j e c t p er r o w. T he c l i e n t parameterize s TableAdapto r with t he s et\nof m e s s a g e s that a table can use to get the colum n value s from an o b j e c t . S o me c l a s s e s in N e X T ' s AppKi t [ A d d 9 4 ] u se d e l e g a t e o b j e c t s to perfor m i n t e r f a c e\nadaptation . An ex ampl e is the NXBrowse r c l a ss that can displa y h i e r a r c h i c a l l i s ts\nof data. NXBrowse r u s es a delegat e o b j e c t for a c c e s s i n g and adaptin g the data. Meyer' s \" M a r r i a g e of C o n v e n i e n c e \" [ M e y 8 8 ] is a f o rm of c l a ss adapter . Meye r\nd e s c r i b e s how a F i x e d S t a c k c l a ss adapt s the implementatio n of an Arra y c l a ss to\nt he interface of a S t a ck c l a s s. T he r e s u lt is a stack c o n t a i n i n g a f i x ed numbe r of\nentries.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 495, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_design_patterns_gof_chunk_0496_d109de9c", "text": "T he r e s u lt is a stack c o n t a i n i n g a f i x ed numbe r of\nentries. Related Patterns\nB r i d g e ( 1 5 1) h as a s t r u c t u r e s i m i l a r to an o b j e c t a d a p t e r , b ut B r i d g e h as a differen t\nintent : It is mean t to separat e an interfac e from its implementatio n so that they can\nbe varie d e a s i ly and independently . An adapte r is mean t to chang e the interfac e\nof an existing object. D e c o r a t o r (175) e n h a n c e s a n o t h e r o b j e c t without changing its interface. A deco -\nrator is thus more transparent t o t h e application than an adapter i s . A s a c o n s e -\n\nptg1 50 STRUCTURAL PATTERNS CHAPTER 4\nq u e n c e , D e c o r a t o r support s r e c u r s i v e c o m p o s i t i o n , w h i c h isn't p o s s i b l e with pure\nadapters. P r o xy ( 2 0 7) d e f i n e s a r e p r e s e n t a t i v e or s u r r o g a t e f or anothe r o b j e c t a nd d o es n ot\nc h a n g e its interface.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 496, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 955}}
{"id": "computer_science_design_patterns_gof_chunk_0497_6b94fe2f", "text": "P r o xy ( 2 0 7) d e f i n e s a r e p r e s e n t a t i v e or s u r r o g a t e f or anothe r o b j e c t a nd d o es n ot\nc h a n g e its interface. ptgBRIDGE 151\nB R I D G E Object Structural\nI n t e n t\nDecouple an abstraction from i t s implementation so that the two can vary inde -\npendently. Also Known As\nHandle/Body\nM o t i v a t i o n\nWhen an abstractio n can have one of s e v e r a l p o s s i b l e implementations , the usual\nway to accommodat e them is to use inheritance . An abstrac t c l a ss define s the in-\nterfac e to the abstraction , and c o n c r e t e s u b c l a s s e s implemen t it in differen t ways . B ut t h is a p p r o a c h i s n 't alway s f l e x i b l e e n o u g h . I n h e r i t a n c e b i n ds an i m p l e m e n -\ntation to the abstractio n permanently , w h i c h make s it difficul t to modify , e x t e n d ,\nand r e u se abstraction s and implementation s independently.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 497, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_design_patterns_gof_chunk_0498_84022612", "text": "C o n s i d e r the implementatio n of a portabl e Windo w abstractio n in a user interfac e\ntoolkit . T h is abstractio n shoul d e n a b l e us to write application s that work on both\nthe X W i n d o w S y s t e m and I B M ' s Presentatio n Manage r (PM) , for example . U s i ng\ninheritance , we could defin e an abstrac t c l a ss W i n d o w and s u b c l a s s e s X W i n d o w \nand P M W i n d o w that i m p l e m e n t the W i n d o w interfac e for the differen t platforms . But this approac h has two drawbacks:\n1. I t 's i n c o n v e n i e n t to exten d t he W i n d o w abstractio n to c o v er differen t k i n ds\nof window s or n ew platforms . Imagin e an I c on Windo w subclas s of Windo w\nthat s p e c i a l i z e s t he W i n d o w a b s t r a c t i o n f or i c o n s . To s u p p o r t I c on W i n d o w s\nfor both platforms , we have to implemen t two new c l a s s e s , XlconWindo w\nand P M I c o n W i n d o w .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 498, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_design_patterns_gof_chunk_0499_34dad1f7", "text": "To s u p p o r t I c on W i n d o w s\nfor both platforms , we have to implemen t two new c l a s s e s , XlconWindo w\nand P M I c o n W i n d o w . W o r s e , we'll have to defin e two c l a s s e s for every kind\nof w i n d o w . Supportin g a t h i rd p l a t f o r m require s yet anothe r new W i n d o w\nsubclass for every kind of window. ptg1 5 2 STRUCTURAL PATTERNS CHAPTER 4\n2. It m a k e s c l i e nt c o de p l a t f o r m - d e p e n d e n t . W h e n e v e r a c l i e nt c r e a t e s a w i n -\nd o w, it instantiate s a c o n c r e t e c l a ss that h as a s p e c i f i c i m p l e m e n t a t i o n . F or\ne x a m p l e , c r e a t i n g an X W i n d o w o b j e c t b i n ds t he W i n d o w abs tr act io n to t he\nX W i n d o w i m p l e m e n t a t i o n , w h i c h make s t he c l i e nt c o de d e p e n d e n t on t he\nX W i n d o w i m p l e m e n t a t i o n . T h i s, in turn, make s it harde r to port t he c l i e nt\nc o de to o t h er platforms.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 499, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_design_patterns_gof_chunk_0500_d8891da9", "text": "T h i s, in turn, make s it harde r to port t he c l i e nt\nc o de to o t h er platforms. C l i e n t s s h o u l d be a b le to c r e a t e a windo w withou t c o m m i t t i n g to a c o n -\nc r e te implementation . O n ly t he windo w implementatio n s h o u l d d e p e n d on\nt he platfor m on w h i c h t he applicatio n r u n s. T h e r e f o r e c l i e nt c o de s h o u l d\ninstantiat e window s withou t m e n t i o n i n g s p e c i f i c platforms. T he B r i d g e patter n a d d r e s s e s t h e se p r o b l e m s by puttin g t he W i n d o w abstractio n\na nd i ts implementatio n in separat e c l a ss h i e r a r c h i e s . T h e re is o ne c l a ss h i e r a r c h y\nf or windo w interface s ( W i n d o w , I c o n W i n d o w , T r a n s i e n t W i n d o w ) and a separat e\nhierarch y for platform-specifi c w i n d o w i m p l e m e n t a t i o n s , with Windowlm p as its\nr o o t.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 500, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 910}}
{"id": "computer_science_design_patterns_gof_chunk_0501_fc8796fd", "text": "T he X W i n d o w I m p s u b c l a s s , f or e x a m p l e , p r o v i d e s an i m p l e m e n t a t i o n b a s ed\no n t h e X W i n d o w S y s t e m . A ll operation s on W i n d o w s u b c l a s s e s a re i m p l e m e n t e d in terms of abstrac t o p e r -\na t i o n s from t he W i n d o w l m p i n t e r f a c e . T h is d e c o u p l e s t he w i n d o w a b s t r a c t i o n s\nfrom the variou s platform-specifi c i m p l e m e n t a t i o n s . We refer to the r e l a t i o n s h i p\nb e t w e e n W i n d o w a nd Windowlm p as a b r i d g e , b e c a u s e it b r i d g e s t he abstractio n\na n d its implementation, letting them vary independently. ptgBRIDGE 153\nApplicability\nUse the Bridg e patter n when\n• you w a nt to avoid a permanen t bindin g betwee n an abstractio n and its im-\nplementation . T h is m i g h t be the c a s e, for example , when the implementatio n\nmust be s e l e c t e d or s w i t c h e d at run-time.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 501, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_design_patterns_gof_chunk_0502_bef548d5", "text": "T h is m i g h t be the c a s e, for example , when the implementatio n\nmust be s e l e c t e d or s w i t c h e d at run-time. •both the abstraction s and their implementation s s h o u l d be e x t e n s i b l e by\ns u b c l a s s i n g . In t h is c a s e, t he B r i d g e patter n l e ts y ou c o m b i n e t he differen t\nabstraction s and implementation s and exten d them independently. • c h a n g e s in t he implementatio n of an abstractio n s h o u l d have no impac t on\nc l i e n t s ; that i s, t h e ir c o de s h o u l d n ot have to be r e c o m p i l e d . • (C++ ) you want to h i de the implementatio n of an abstractio n c o m p l e t e l y f r om\nc l i e n t s . In C ++ t he representatio n of a c l a ss is v i s i b l e in t he c l a ss interface. • you have a proliferatio n of c l a s s e s as s h o w n e a r l i e r in the first Motivatio n\ndiagram . S u ch a c l a ss hierarch y i n d i c a t e s the n e ed for splittin g an objec t into\nt wo p a r t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 502, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_design_patterns_gof_chunk_0503_8c75be87", "text": "S u ch a c l a ss hierarch y i n d i c a t e s the n e ed for splittin g an objec t into\nt wo p a r t s . Rumbaug h u s es t he t e rm \" n e s t e d g e n e r a l i z a t i o n s \" [ R B P + 9 1 ] to\nrefer to s u ch c l a ss hierarchies. • y ou want to s h a re an i m p l e m e n t a t i o n a m o n g m u l t i p l e o b j e c t s ( p e r h a p s u s i ng\nreferenc e c o u n t i n g ) , and t h is fact shoul d be hidde n f r om the client . A s i m p l e\nexampl e is C o p l i e n ' s S t r i ng c l a ss [ C o p 9 2 ] , in whic h multipl e object s c an share\nthe same string representation (StringRep). S t r u c t u r e\n\nptg1 5 4 STRUCTURAL P A T T E R N S CHAPTER 4\nParticipants\n• Abstractio n (Window)\n- define s the abstraction' s interface. - maintain s a referenc e to an objec t of type Implementor. • RefmedAbstractio n (IconWindow)\n- Extend s the interfac e define d by Abstraction. • Implemento r (Windowlmp)\n- define s the interfac e for implementatio n c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 503, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_design_patterns_gof_chunk_0504_81324b35", "text": "• RefmedAbstractio n (IconWindow)\n- Extend s the interfac e define d by Abstraction. • Implemento r (Windowlmp)\n- define s the interfac e for implementatio n c l a s s e s . T h is interfac e d o e s n ' t\nhave to correspon d exactl y to Abstraction' s interface ; in fact the two i n t e r -\nfaces can be quite d i f f e r e n t . T y p i c a l l y the Implemento r interfac e provide s\no n ly primitiv e operations , and Abstractio n define s h i g h e r - l e v e l operation s\nb a s e d on these primitives. • Concretelmplementor ( X W i n d o w I m p , P M W i n d o w I m p )\n- implements the I m p l e m e n t o r interface and defines i t s c o n c r e t e i m p l e m e n -\ntation. C o l l a b o r a t i o n s\n• Abstraction forwards client requests to its Implementor object. C o n s e q u e n c e s\nThe B r i d g e patter n has the followin g c o n s e q u e n c e s :\n1.Decoupling interface a nd implementation. An implementatio n is n ot boun d per-\nmanentl y to an interface .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 504, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_design_patterns_gof_chunk_0505_c96e22f4", "text": "An implementatio n is n ot boun d per-\nmanentl y to an interface . The implementatio n of an abstractio n can be config-\nured at run-time . It's e v en p o s s i b l e for an objec t to c h a n g e its implementatio n\nat run-time. D e c o u p l i n g Abstractio n and Implemento r also eliminate s c o m p i l e - t i m e\ndependencie s on the implementation . Changin g an implementatio n c l a ss\ndoesn' t r e q u i r e r e c o m p i l i n g the Abstractio n c l a ss and its c l i e n t s . T h is prop-\nerty is essentia l when you must ensur e binar y compatibilit y betwee n differ-\nent v e r s i o n s of a c l a ss library. Furthermore , this decouplin g encourage s layerin g that can l e ad to a better-\nstructure d system . The h i g h - l e v e l part of a syste m o n ly has to know abou t\nAbstraction and Implementor. 2.Improved e x t e n s i b i l i t y . You can extend the Abstraction and Implementor hier -\na r c h i e s i n d e p e n d e n t l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 505, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_design_patterns_gof_chunk_0506_0f474d7d", "text": "2.Improved e x t e n s i b i l i t y . You can extend the Abstraction and Implementor hier -\na r c h i e s i n d e p e n d e n t l y . 3.Hiding i m p l e m e n t a t i o n d e t a i l s from c l i e n t s . You can s h i e l d c l i e n t s from i m p l e -\nmentation details, like the sharing of implementor objects and the accompa -\nnying reference count mechanism (if a n y ) . ptgBRIDGE 155\nI m p l e m e n t a t i o n\nC o n s i d e r the followin g implementatio n i s s u e s whe n applyin g the B r i d g e pattern:\n1. Only o ne Implementor. In situation s wher e t h e r e ' s o n ly o ne implementation ,\nc r e a t i n g an abstrac t Implemento r c l a ss i s n 't n e c e s s a r y . T h is is a d e g e n e r a t e\nc a se of t he B r i d g e pattern ; t h e r e ' s a o n e - t o - o n e r e l a t i o n s h i p betwee n A b -\nstractio n a nd I m p l e m e n t o r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 506, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_design_patterns_gof_chunk_0507_f119c332", "text": "T h is is a d e g e n e r a t e\nc a se of t he B r i d g e pattern ; t h e r e ' s a o n e - t o - o n e r e l a t i o n s h i p betwee n A b -\nstractio n a nd I m p l e m e n t o r . N e v e r t h e l e s s , t h is separatio n is s t i ll usefu l w h en\na c h a n g e in the implementatio n of a c l a ss must not a f f e c t its e x i s t i n g c l i e n t s —\nthat is, they shouldn' t have to be r e c o m p i l e d , j u st r e l i n k e d . Carola n [ C a r 8 9 ] u s es t he term \" C h e s h i r e Cat\" to d e s c r i b e t h is separation . In\nC++, t he c l a ss interfac e of t he Implemento r c l a ss c an be define d in a privat e\nheade r f i le that isn't provide d to c l i e n t s . T h is l e ts you h i de an implementatio n \nof a c l a ss c o m p l e t e l y f r om i ts c l i e n t s . 2.Creating the right Implementor object. H o w , w h e n , and wher e do you d e c i d e\nw h i c h Implemento r c l a ss to instantiat e w h en there' s more than o n e ?", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 507, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_design_patterns_gof_chunk_0508_cc65ede5", "text": "2.Creating the right Implementor object. H o w , w h e n , and wher e do you d e c i d e\nw h i c h Implemento r c l a ss to instantiat e w h en there' s more than o n e ? If Abstractio n know s abou t a ll C o n c r e t e l m p l e m e n t o r c l a s s e s , t h en it c an\ninstantiat e o ne of them in i ts c o n s t r u c t o r ; it c an d e c i d e b e t w e e n t h em b a s ed\non parameter s p a s s e d to its c o n s t r u c t o r . If, for e x a m p l e , a c o l l e c t i o n c l a ss\nsupport s multipl e i m p l e m e n t a t i o n s , t he d e c i s i o n c an be b a s ed on t he s i ze of\nt he c o l l e c t i o n . A l i n k e d l i st implementatio n c an be u s ed f or s m a l l c o l l e c t i o n s\nand a hash table for l a r g e r o n e s . Anothe r approac h is to c h o o s e a defaul t implementatio n i n i t i a l l y and c h a n g e\nit later a c c o r d i n g to u s a g e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 508, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_design_patterns_gof_chunk_0509_f1141054", "text": "Anothe r approac h is to c h o o s e a defaul t implementatio n i n i t i a l l y and c h a n g e\nit later a c c o r d i n g to u s a g e . F or e x a m p l e , if t he c o l l e c t i o n g r o w s b i g g e r than\na certai n t h r e s h o l d , then it s w i t c h e s its implementatio n to one that's m o r e\nappropriat e for a large numbe r of i t e m s . I t 's a l so p o s s i b l e to d e l e g a t e t he d e c i s i o n to anothe r o b j e c t a l t o g e t h e r . In\nthe Window/Windowlm p e x a m p l e , we can introduc e a factor y o b j e c t ( s ee\nAbstrac t Factor y ( 8 7 )) w h o s e s o le duty is to e n c a p s u l a t e platform-specifics . The factor y know s what k i nd of Windowlm p objec t to c r e a t e for the platfor m\nin u s e; a W i n d o w s i m p l y a s ks it for a W i n d o w l m p , and it return s the right\nkind. A benefi t of t h is approac h is that Abstractio n is n ot c o u p l e d d i r e c t l y to\na ny of t he Implemento r c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 509, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 990}}
{"id": "computer_science_design_patterns_gof_chunk_0510_f187f155", "text": "A benefi t of t h is approac h is that Abstractio n is n ot c o u p l e d d i r e c t l y to\na ny of t he Implemento r c l a s s e s . 3.Sharing implementors. C o p l i e n illustrate s how the Handle/Bod y i d i om in C++\nc an be u s ed to s h a re i m p l e m e n t a t i o n s a m o n g s e v e r a l o b j e c t s [ C o p 9 2 ] . T he\nB o dy s t o r e s a referenc e coun t that the Handl e c l a ss i n c r e m e n t s and d e c r e -\nments . The c o de for a s s i g n i n g handle s with s h a r e d b o d i e s has the followin g\ng e n e r a l form:\n\nptg156 STRUCTURAL P A T T E R N S C H A P T E R 4\nH a n d l e& Handle::operator = ( c o n st H a n d l e& other) {\nother._body->Ref() ; \n_body->Unref();\nif (_body->RefCount( ) == 0) {\nd e l e te _body;\n} \n_body = other._body;\nr e t u r n *this;\n4. Using multiple inheritance. Y ou c an u se multipl e i n h e r i t a n c e in C ++ to c o m b i n e\nan i n t e r f a c e with i ts i m p l e m e n t a t i o n [ M a r 9 1 ] .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 510, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_design_patterns_gof_chunk_0511_0854c50f", "text": "Using multiple inheritance. Y ou c an u se multipl e i n h e r i t a n c e in C ++ to c o m b i n e\nan i n t e r f a c e with i ts i m p l e m e n t a t i o n [ M a r 9 1 ] . F or e x a m p l e , a c l a ss c an i n h e r i t \npublicl y f r om Abstractio n a nd privatel y from a C o n c r e t e l m p l e m e n t o r . B ut\nb e c a u s e t h is a p p r o a c h r e l i es on static i n h e r i t a n c e , it b i n d s an i m p l e m e n t a t i o n\np e r m a n e n t l y to i ts interface . T h e r e f o r e y ou c a n 't i m p l e m e n t a t r ue B r i d g e\nwith multiple inheritance—at least not in C + + . S a m p l e C o d e\nT he f o l l o w i n g C ++ c o de i m p l e m e n t s t he W i n d o w / W i n d o w l m p e x a m p l e f r om t he\nMotivatio n s e c t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 511, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 779}}
{"id": "computer_science_design_patterns_gof_chunk_0512_d63d5905", "text": "S a m p l e C o d e\nT he f o l l o w i n g C ++ c o de i m p l e m e n t s t he W i n d o w / W i n d o w l m p e x a m p l e f r om t he\nMotivatio n s e c t i o n . T he W i n d o w c l a ss d e f i n e s t he w i n d o w a b s t r a c t i o n f or c l i e n t\napplicat ions:\nclass W i n d ow {\npublic:\nW i n d o w ( V i e w * contents);\n/ '/ r e q u e s ts h a n d l ed by w i n d ow\nvirtual void D r a w C o n t e n t s ( ) ;\nvirtual void Open();\nvirtual void Close();\nvirtual void IconifyO ;\nvirtual void Deiconify();\n// r e q u e s ts f o r w a r d ed to implementatio n\nv i r t u al v o id S e t O r i g i n ( c o n s t P o i n ts a t );\nvirtual void SetExtent(cons t P o i n t& extent);\nvirtual void Raise(); \nvirtual void L o w e r ( ) ;\nvirtual void D r a w L i n e ( c o n s t P o i n t &, c o n st P o i n t & );\nvirtual void DrawRect(cons t P o i n t &, c o n st P o i n t & );\nvirtual void D r a w P o l y g o n ( c o n s t Point[], int n);\nvirtual void DrawText(const char*, const Point&);\np r o t e c t e d :\nWindowlmp* GetWindowImp();\nView* GetViewO;\n\nptgBRIDGE 157\nprivate:\nWindowlmp* _imp;\nView* _contents; // the window's contents\n} ;\nW i n d o w maintain s a referenc e to a W i n d o w l m p , the abstrac t c l a ss t h at d e c l a r e s an\ninterface to the underlying windowing system.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 512, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1309}}
{"id": "computer_science_design_patterns_gof_chunk_0513_c0d65745", "text": "c l a ss W i n d o w l m p {\npublic:\nvirtual void ImpTop() = 0; \nvirtual void ImpBottom( ) = 0; \nvirtual void ImpSetExtent(cons t Point&) = 0; \nvirtual void ImpSetOrigin(cons t Point&) = 0;\nvirtual void DeviceRect(Coord , Coord, Coord, Coord) = 0 ;\nvirtual void DeviceText(cons t char*, Coord, Coord) = 0;\nv i r t u al v o id D e v i c e B i t m a p ( c o n s t char*, Coord, C o o r d) = 0; \n// lots more function s for d r a w i ng on windows... protected:\nWindowlmp() ;\n} ;\nS u b c l a s s e s of W i n d o w defin e the differen t kinds of window s the applicatio n migh t\nu s e, s u ch as applicatio n windows , i c o n s , transien t window s for d i a l o g s , floatin g\npalette s of t o o l s, a nd so o n . For example , A p p l i c a t i o n W i n d o w w i l l implemen t D r a w C o n t e n t s to draw the\nV i e w instance it stores:\nclass ApplicationWindo w : public Window {\npublic:\n// . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 513, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_design_patterns_gof_chunk_0514_9458addd", "text": "For example , A p p l i c a t i o n W i n d o w w i l l implemen t D r a w C o n t e n t s to draw the\nV i e w instance it stores:\nclass ApplicationWindo w : public Window {\npublic:\n// . . . virtual void DrawContents();\n} ;\nvoid ApplicationWindow::DrawContent s () {\nGetView()->DrawOn(this) ;\n}\nI c o n W i n d o w stores the name of a bitmap for the icon it displays... class IconWindo w : public Window {\npublic:\n// . . . virtual void DrawContents();\nprivate: \nconst c h a r * _bitmapName;\n} ;\n. . . a n d it implements DrawContents to draw the bitmap on the window:\n\nptg1 5 8 STRUCTURAL P A T T E R N S CHAPTER 4\nvoid I c o n W i n d o w : : D r a w C o n t e n t s ( ) { \nW i n d o w l m p * imp - G e t W i n d o w I m p ( ) ;\nif ( i mp != 0) {\nimp->DeviceBitmap(_bitmapName , 0 . 0, 0 . 0 );\n}\n}\nM a ny o t h er variation s of W i n d o w are p o s s i b l e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 514, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 866}}
{"id": "computer_science_design_patterns_gof_chunk_0515_47129568", "text": "0, 0 . 0 );\n}\n}\nM a ny o t h er variation s of W i n d o w are p o s s i b l e . A T r a n s i e n t W i n d o w may n e ed\nto c o m m u n i c a t e with t he windo w that c r e a t e d it durin g t he d i a l o g ; h e n ce it k e e ps a\nr e f e r e n c e to that w i n d o w . A Pa 1 e 11 e W i n d o w a l w a y s f l o a ts a b o v e other w i n d o w s . An I c o n D o c k W i n d o w h o l d s I c o n W i n d o w s and a r r a n g e s them n e a t l y . W i n d o w o p e r a t i o n s are define d in terms of the W i n d o w l m p interface . For e x a m p l e ,\nDrawRe c t e x t r a c t s four c o o r d i n a t e s from its two P o i n t p a r a m e t e r s befor e c a l l i n g\nthe Windowlmp operation that draws the rectangle in the window:\nvoid W i n d o w : : D r a w R e c t ( c o n st P o i n ts pi, c o n st P o i n t& p 2) {\nW i n d o w l m p * imp = G e t W i n d o w I m p ( ) ;\nimp->DeviceRect(pl.X() , p l . Y O , p2.X(), p 2 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 515, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_design_patterns_gof_chunk_0516_0e8c7b57", "text": "Y O , p2.X(), p 2 . Y ( » ;\n}\nC o n c r e t e s u b c l a s s e s of W i n d o w l m p suppor t differen t w i n d o w s y s t e m s . T he\nX W i n d o w I m p subclass supports the X W i n d o w S y s t e m :\nc l a ss X W i n d o w I m p : public W i n d o w l m p {\np u b l i c :\nX W i n d o w I m p () , -\nvirtual void DeviceRect(Coord , Coord, C o o r d, C o o r d );\n// r e m a i n d er of public interface... private:\n// l o ts of X w i n d ow s y s t e m - s p e c i f i c state, i n c l u d i n g :\nD i s p l a y* _dpy;\nD r a w a b le _winid; // w i n d ow id \nGC _gc; // w i n d o w graphic context\n} ;\nFor Presentation Manager (PM), we define a PMWindowlmp class:\nc l a ss P M W i n d o w l m p : public W i n d o w l m p {\np u b l i c :\nP M W i n d o w l m p ( ) ; \nvirtual v o id DeviceRect(Coord , Coord, Coord, Coord);\n// r e m a i n d er of public interface.. .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 516, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 876}}
{"id": "computer_science_design_patterns_gof_chunk_0517_4d3504a6", "text": ". private:\n// l o ts of PM w i n d ow s y s t e m - s p e c i f i c state, i n c l u d i n g :\nHPS _hps;\n} ;\nT h e se s u b c l a s s e s i m p l e m e n t W i n d o w l m p o p e r a t i o n s in terms of w i n d o w s y s t e m\np r i m i t i v e s . F o r example, DeviceRect is implemented f o r X a s follows:\n\nptgBRIDGE 159\nvoid XWindowImp::DeviceRec t (\nC o o rd xO, Coord yO, Coord xl, Coord yl\n) {\nint x = round(min(xO , xl)); \nint y = round(min(yO , yl)); \nint w = r o u n d ( a b s ( x O - xl)); \nint h = r o u n d ( a b s ( y O - yl));\nXDrawRectangle(_dpy, _winid, _gc, x, y, w, h);\n}\nT h e PM implementation might look like this:\nvoid PMWindowImp::DeviceRec t (\nCoord xO, C o o rd yO, C o o rd xl, Coord yl\n) {\nCoord left = min(xO, xl) ;\nCoord r i g ht = max(xO, xl);\nCoord bottom = min(yO, yl) ;\nCoord top = maxfyO, yl) ;\nP P O I N TL point[4];\npoint[0]. x = left;p o i n t [ 0 ] . y = top;\npoint[l]. x = right;p o i n t [ 1 ] . y = top;\npoint[2]. x = right;point[2].", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 517, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_design_patterns_gof_chunk_0518_f8be76a9", "text": "x = left;p o i n t [ 0 ] . y = top;\npoint[l]. x = right;p o i n t [ 1 ] . y = top;\npoint[2]. x = right;point[2]. y = bottom;\np o i n t [ 3 ] . x = left;p o i n t [ 3 ] . y = bottom;\nif ( \n(GpiBeginPath(_hps , 1 L) == false) ||\n( G p i S e t C u r r e n t P o s i t i o n ( _ h p s , & p o i n t [ 3 ] ) == false)\n( G p i P o l y L i n e ( _ h p s , 4 L, point) == GPI_ERROR ) || \n( G p i E n d P a t h ( _ h p s ) == false)\n) { \n// report e r r o r\n} e l se {\nGpiStrokePath(_hps , 1L, OL);\n}\nHow d o es a windo w obtai n an i n s t a n c e of the right W i n d o w l m p s u b c l a s s ? W e ' ll\na s s u m e W i n d o w has that r e s p o n s i b i l i t y in this e x a m p l e . Its G e t W i n d o w I m p op-\neratio n g e ts the right i n s t a n c e f r om an abstrac t factor y ( s ee Abstrac t Factor y ( 8 7 ))\nthat effectively e n c a p s u l a t e s all window system s p e c i f i c s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 518, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_design_patterns_gof_chunk_0519_03c79853", "text": "Windowlmp * W i n d o w : : G e t W i n d o w I m p () {\nif ( _ i mp = =0) {\n_imp = WindowSystemFactory::Instance()->MakeWindowImp() ;\n}\nr e t u rn _imp;\n}\n\nptg1 6 0 STRUCTURAL P A T T E R N S CHAPTER 4\nW i n d o w S y s t e m F a c t o r y : : I n s t a n c e () r e t u r n s an abstract factory that manu -\nf a c t u r e s a l l window system-specific objects. F o r simplicity, we've made it a Sin-\ngleton (127) a n d have let the Window class access t h e factory directly. K n o w n Uses\nThe Windo w exampl e abov e come s f r om ET++ [ W G M 8 8 ] . In ET++ , Windowlm p\nis called \"WindowPort \" and has subclasse s s u ch as XWindowPor t and S u n W i n -\ndowPort . The Windo w objec t create s its correspondin g Implemento r o b j e c t by\nrequestin g it f r om an abstrac t f a c t o r y c a l l ed \" W i n d o w S y s t e m . \" WindowSyste m\nprovide s an interfac e for creatin g platform-specifi c object s such as fonts , cursors ,\nb i t m a p s , a nd so forth.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 519, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_design_patterns_gof_chunk_0520_703b3914", "text": "\" WindowSyste m\nprovide s an interfac e for creatin g platform-specifi c object s such as fonts , cursors ,\nb i t m a p s , a nd so forth. The ET++ Window/WindowPor t d e s i g n extend s the Bridg e patter n in that the\nWindowPor t also keep s a referenc e back to the W i n d o w . The WindowPor t i m -\nplemento r c l a ss uses this referenc e to n o t i f y Windo w abou t WindowPort-specifi c\ne v e n t s : the arriva l of input events , windo w r e s i z e s , etc. Both Coplie n [ C o p 9 2 ] a nd Stroustru p [ S t r 9 1 ] mentio n Handl e c l a s s e s a nd g i ve\nsome examples . T h e ir example s emphasiz e memor y managemen t i s s u e s like s h a r -\ning string representation s and suppor t for variable-size d objects . Our focus is more\non supportin g independen t extensio n of both an abstractio n and its implementa-\nt i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 520, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 848}}
{"id": "computer_science_design_patterns_gof_chunk_0521_750d8d18", "text": "Our focus is more\non supportin g independen t extensio n of both an abstractio n and its implementa-\nt i o n . libg+ + [ L e a 8 8 ] define s c l a s s e s that implemen t commo n data structures , s u ch as S e t,\nL i n k e d S e t , H a s h S e t , LinkedList , a nd HashTable . S et is an abstrac t c l a ss that define s\na set abstraction , while LinkedLis t and HashTabl e are concret e implementor s\nfor a l i n k e d l i st and a hash table , r e s p e c t i v e l y . L i n k e d S e t and HashSe t are Set\nimplementor s t h at bridg e betwee n Set and their concret e counterpart s LinkedLis t\nand HashTable . T h is is an example of a degenerat e bridge , becaus e there' s no\nabstrac t Implemento r c l a s s . NeXT' s AppKi t [Add94 ] uses the Bridg e patter n in the implementatio n and d i s -\nplay of graphica l images . An imag e can be represente d in severa l differen t ways .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 521, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_design_patterns_gof_chunk_0522_10e97d9a", "text": "NeXT' s AppKi t [Add94 ] uses the Bridg e patter n in the implementatio n and d i s -\nplay of graphica l images . An imag e can be represente d in severa l differen t ways . The optima l displa y of an imag e depend s on the propertie s of a displa y d e v i c e ,\nspecificall y its c o l or capabilitie s and its resolution . Withou t help from AppKit ,\ndeveloper s woul d have to determin e whic h implementatio n to use unde r variou s\ncircumstance s in every application. To reliev e developer s of this responsibility , AppKi t provide s an NXIm-\na g e / N X I m a g e R e p bridge . NXImag e define s the interfac e for handlin g images . T he implementatio n of image s is define d in a separat e NXImageRe p c l a ss h i -\nerarch y havin g s u b c l a s s e s s u ch as NXEPSImageRep , NXCachedlmageRep , and\nNXBitMapImageRep . NXImag e maintain s a referenc e to one or more NXIm-\na g e R e p o b j e c t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 522, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_design_patterns_gof_chunk_0523_0ac02ed0", "text": "NXImag e maintain s a referenc e to one or more NXIm-\na g e R e p o b j e c t s . If t h e re is m o re than o ne i m a g e i m p l e m e n t a t i o n , t h en N X I m a g e\ns e l e c t s the most appropriat e one for the curren t displa y d e v i c e . NXImag e is e v en\ncapable of converting one implementation to another if necessary. The interesting\n\nptgBRIDGE 161\na s p e c t o f this Bridge variant i s that NXImage can store more than o n e N X I r n -\nageRep implementation at a time. Related Patterns\nAn Abstrac t Factor y ( 8 7) can creat e and configur e a particula r B r i d g e . The Adapte r ( 1 3 9) patter n is g e a r e d towar d makin g unrelate d c l a s s e s work to-\ng e t h e r . It is usuall y applie d to s y s t e m s a f t er they'r e d e s i g n e d . B r i d g e , on the other\nhand , is u s ed up-fron t in a d e s i g n to let abstraction s and implementation s vary\nindependently.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 523, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 915}}
{"id": "computer_science_design_patterns_gof_chunk_0524_31c9ac5c", "text": "B r i d g e , on the other\nhand , is u s ed up-fron t in a d e s i g n to let abstraction s and implementation s vary\nindependently. ptg\nThis page intentionally left blank \n\nptgCOMPOSITE 163\nC O M P O S I T E O b j e c t Structural\nI n t e n t\nC o m p o s e objects into tree structures t o represent part-whole hierarchies. Com -\nposite lets clients treat individual objects and compositions of objects uniformly. M o t i v a t i o n\nGraphic s a p p l i c a t i o n s l i ke drawin g editor s a nd s c h e m a t i c captur e s y s t e m s l et\nu s e rs b u i ld c o m p l e x d i a g r a m s o ut of s i m p l e c o m p o n e n t s . T he u s er c an g r o up\nc o m p o n e n t s to form l a r g e r c o m p o n e n t s , w h i c h in turn c an be g r o u p e d to f o rm s t i ll\nl a r g e r c o m p o n e n t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 524, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 815}}
{"id": "computer_science_design_patterns_gof_chunk_0525_57ac1d21", "text": "T he u s er c an g r o up\nc o m p o n e n t s to form l a r g e r c o m p o n e n t s , w h i c h in turn c an be g r o u p e d to f o rm s t i ll\nl a r g e r c o m p o n e n t s . A s i m p l e implementatio n c o u ld defin e c l a s s e s for g r a p h i c a l\np r i m i t i v e s s u ch as T e xt a nd L i n es plus o t h er c l a s s e s that a ct as c o n t a i n e r s f or t h e se\np r i m i t i v e s . B ut t h e r e ' s a p r o b l e m w i th t h is a p p r o a c h : C o de t h at u s es t h e se c l a s s e s m u st treat\nprimitiv e a nd c o n t a i n e r object s differently , e v en if m o st of t he t i me t he u s er treats\nt h em i d e n t i c a l l y . Havin g to d i s t i n g u i s h t h e se object s make s t he applicatio n m o re\nc o m p l e x . T he C o m p o s i t e pattern d e s c r i b e s h ow to u se r e c u r s i v e c o m p o s i t i o n so\nthat clients don't have to make this distinction.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 525, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_design_patterns_gof_chunk_0526_4b15b43c", "text": "T he C o m p o s i t e pattern d e s c r i b e s h ow to u se r e c u r s i v e c o m p o s i t i o n so\nthat clients don't have to make this distinction. T he k ey to t he C o m p o s i t e patter n is an abstrac t c l a ss that r e p r e s e n t s both primi-\nt i v es a nd their c o n t a i n e r s . F or t he g r a p h i c s s y s t e m , this c l a ss is Graphic . Graphi c\nd e c l a r e s o p e r a t i o n s l i ke Draw that a re s p e c i f i c to g r a p h i c a l o b j e c t s . It a l so d e c l a r e s\no p e r a t i o n s that a ll c o m p o s i t e o b j e c t s s h a r e , s u ch as o p e r a t i o n s f or a c c e s s i n g a nd \nm a n a g i n g its children. ptg1 6 4 STRUCTURAL PATTERNS CHAPTER 4\nT he s u b c l a s s e s L i n e, R e c t a n g l e , a nd T e xt ( s ee precedin g c l a ss diagram ) defin e\nprimitiv e graphica l o b j e c t s . T h e se c l a s s e s implemen t Draw to draw l i n e s, r ec tan-\ng l e s, a nd text, r e s p e c t i v e l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 526, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_design_patterns_gof_chunk_0527_b2080cb4", "text": "T h e se c l a s s e s implemen t Draw to draw l i n e s, r ec tan-\ng l e s, a nd text, r e s p e c t i v e l y . S i n ce primitiv e graphic s have no c h i ld g r a p h i c s , none\nof t h e se s u b c l a s s e s implement s c h i l d - r e l a t e d o p e r a t i o n s . T he Pictur e c l a ss define s an aggregat e of Graphi c o b j e c t s . Pictur e i m p l e m e n t s\nDraw to c a ll Draw on its c h i l d r e n , and it implement s c h i l d - r e l a t e d operation s ac-\nc o r d i n g l y . Becaus e the Pictur e interfac e conform s to the Graphi c interface , P i c t u r e\no b j e c t s c an compos e o t h er P i c t u r e s r e c u r s i v e l y . The followin g diagra m show s a typica l c o m p o s i t e objec t structur e of recursivel y\nc o m p o s e d G r a p h i c o b j e c t s :\nA p p l i c a b i l i t y\nUse the C o m p o s i t e patter n when\n• you want to r e p r e s e n t part-whol e h i e r a r c h i e s of objects.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 527, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_design_patterns_gof_chunk_0528_cad9c994", "text": "• you want c l i e n t s to be a b le to i g n o r e the differenc e betwee n composition s of\nobject s a nd individua l objects . C l i e n t s will treat a ll o b j e c t s in t he c o m p o s i t e\nstructure uniformly. S t r u c t u r e\n\nptgCOMPOSITE 165\nA typical Composite o b j e c t structure might look like this:\nParticipants\n• C o m p o n e n t ( G r a p h i c )\n-d e c l a r e s t he i n t e r f a c e f or o b j e c t s in t he c o m p o s i t i o n . -i m p l e m e n t s defaul t b e h a v i o r f or t he i n t e r f a c e c o m m o n to a ll c l a s s e s , as\nappropriate. -d e c l a r e s an interfac e f or a c c e s s i n g a nd m a n a g i n g i ts c h i ld c o m p o n e n t s . - ( o p t i o n a l ) d e f i n e s an i n t e r f a c e f or a c c e s s i n g a c o m p o n e n t ' s p a r e n t in t he\nrecursive structure, and implements it if that's appropriate. • Leaf ( R e c t a n g l e , L i n e , Text, e t c . )\n- represents leaf objects in the composition.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 528, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_design_patterns_gof_chunk_0529_369d705d", "text": "• Leaf ( R e c t a n g l e , L i n e , Text, e t c . )\n- represents leaf objects in the composition. A leaf has no c h i l d r e n . - defines behavior for primitive objects in the c o m p o s i t i o n . • Composite ( P i c t u r e )\n-d e f i n e s b e h a v i o r for components having children. -s t o r e s c h i l d c o m p o n e n t s . -i m p l e m e n t s c h i l d - r e l a t e d o p e r a t i o n s in the C o m p o n e n t i n t e r f a c e . • C l i e n t\n- manipulates objects i n t h e c o m p o s i t i o n t h r o u g h the C o m p o n e n t i n t e r f a c e . C o l l a b o r a t i o n s\n• C l i e n t s u se t he C o m p o n e n t c l a ss interfac e to interac t with o b j e c t s in t he c o m -\nposit e structure . If t he r e c i p i e n t is a Leaf, t h en t he r e q u e s t is handle d d i r e c t l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 529, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 831}}
{"id": "computer_science_design_patterns_gof_chunk_0530_8b4e9a1c", "text": "If t he r e c i p i e n t is a Leaf, t h en t he r e q u e s t is handle d d i r e c t l y . If t he r e c i p i e n t is a C o m p o s i t e , then it usuall y forward s request s to i ts c h i ld\nc o m p o n e n t s , p o s s i b l y p e r f o r m i n g a d d i t i o n a l o p e r a t i o n s befor e and/o r after\nforwarding. ptg1 6 6 STRUCTURAL P A T T E R N S CHAPTER 4\nC o n s e q u e n c e s\nThe Composit e pattern\n• define s c l a ss hierarchie s c o n s i s t i n g of primitiv e object s a nd c o m p o s i t e o b -\nj e c t s. P r i m i t i v e o b j e c t s c an be c o m p o s e d i n to m o re c o m p l e x o b j e c t s , w h i ch in\nturn c an be c o m p o s e d , a nd so on r e c u r s i v e l y . W h e r e v e r c l i e nt c o de e x p e c t s a\nprimitiv e o b j e c t , it c an a l so take a composit e o b j e c t . • m a k e s t he c l i e nt s i m p l e . C l i e n t s c an treat c o m p o s i t e s t r u c t u r e s a nd i n d i -\nvidua l object s uniformly.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 530, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_design_patterns_gof_chunk_0531_d6e087fa", "text": "• m a k e s t he c l i e nt s i m p l e . C l i e n t s c an treat c o m p o s i t e s t r u c t u r e s a nd i n d i -\nvidua l object s uniformly. C l i e n t s normall y don't know (and shouldn' t care)\nwhethe r they'r e d e a l i n g with a l e af or a c o m p o s i t e c o m p o n e n t . T h is s i m p l i f i e s\nc l i e nt c o d e, becaus e it avoid s havin g to write t a g - a n d - c a s e - s t a t e m e n t - s t y l e\nfunction s o v er the c l a s s e s that defin e the c o m p o s i t i o n . • make s it e a s i e r to a dd n ew k i n ds of c o m p o n e n t s . Newl y d e f i n e d C o m p o s i t e\nor Leaf s u b c l a s s e s work automaticall y with existin g structure s and c l i e nt\ncode. C l i e n t s don't have to be change d for new Componen t c l a s s e s . • c an make your d e s i g n o v e r l y g e n e r a l . T he d i s a d v a n t a g e of m a k i n g it e a sy\nto add new component s is that it make s it harde r to restric t the c o m p o n e n t s\nof a composite .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 531, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1008}}
{"id": "computer_science_design_patterns_gof_chunk_0532_d224342a", "text": "T he d i s a d v a n t a g e of m a k i n g it e a sy\nto add new component s is that it make s it harde r to restric t the c o m p o n e n t s\nof a composite . S o m e t i m e s you want a composit e to have o n ly certai n c o m -\nponents . With C o m p o s i t e , you can't r e ly on the type s y s t e m to enforc e t h o se\nconstraints for you. You'll have to use run-time checks instead. Implementation\nT h e re are many i s s u e s to c o n s i d e r when implementin g the Composit e pattern:\n1. Explicit parent references. Maintainin g r e f e r e n c e s from c h i ld c o m p o n e n t s to\nt h e ir p a r e n t c an simplif y t he t r a v e r s a l a nd m a n a g e m e n t of a c o m p o s i t e s t r u c -\nture. The paren t referenc e simplifie s movin g up the structur e and d e l e t i n g\na component . Paren t reference s a l so h e lp suppor t t he C h a in of R e s p o n s i b i l -\nity ( 2 2 3) pattern.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 532, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_design_patterns_gof_chunk_0533_a90c40cd", "text": "The paren t referenc e simplifie s movin g up the structur e and d e l e t i n g\na component . Paren t reference s a l so h e lp suppor t t he C h a in of R e s p o n s i b i l -\nity ( 2 2 3) pattern. T he usual place to defin e t he paren t referenc e is in t he Componen t c l a s s. L e af a nd C o m p o s i t e c l a s s e s c an i n h e r i t t he r e f e r e n c e a nd t he o p e r a t i o n s t h at\nmanag e it. With paren t r e f e r e n c e s , it's e s s e n t i a l to maintai n the invarian t that all c h i l d r e n\nof a c o m p o s i t e have as t h e ir paren t the c o m p o s i t e that in turn has them as\nchildren . The e a s i e s t way to ensur e t h is is to c h a n g e a component' s paren t\nonly w h en i t 's b e i ng a d d e d or r e m o v e d from a c o m p o s i t e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 533, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 800}}
{"id": "computer_science_design_patterns_gof_chunk_0534_09cd7eb4", "text": "The e a s i e s t way to ensur e t h is is to c h a n g e a component' s paren t\nonly w h en i t 's b e i ng a d d e d or r e m o v e d from a c o m p o s i t e . If t h is c an be\nimplemente d o n ce in t he A dd a nd Remov e operation s of t he C o m p o s i t e\nc l a s s, t h en it c an be i n h e r i t e d by a ll t he s u b c l a s s e s , a nd t he i n v a r i a n t w i ll be\nmaintaine d automatically. 2.Sharing components. It's o f t en usefu l to share c o m p o n e n t s , for e x a m p l e , to\nr e d u c e s t o r a g e r e q u i r e m e n t s . B ut w h en a c o m p o n e n t c an h a ve no m o re than\none parent, sharing components becomes d i f f i c u l t . ptgCOMPOSITE 1 6 7\nA p o s s i b l e solutio n is for c h i l d r e n to store multipl e parents . But that can l e ad\nto ambiguitie s as a r e q u e s t propagate s up the structure . The Flyweigh t ( 1 9 5)\npatter n s h o w s how to rewor k a d e s i g n to a v o id storin g parent s altogether .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 534, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_design_patterns_gof_chunk_0535_935bf644", "text": "But that can l e ad\nto ambiguitie s as a r e q u e s t propagate s up the structure . The Flyweigh t ( 1 9 5)\npatter n s h o w s how to rewor k a d e s i g n to a v o id storin g parent s altogether . It\nwork s in c a s es w h e r e c h i l d r e n can a v o id s e n d i n g paren t request s by exter-\nnalizin g s o me or a ll of their state. 3. Maximizing the Component interface. One of the g o a ls of the Composit e patter n\nis to make c l i e n t s unawar e of t he s p e c i f i c L e af or C o m p o s i t e c l a s s e s t h e y ' r e\nusing . To attain t h is g o a l, t he Componen t c l a ss s h o u l d defin e as many com-\nmon operation s for C o m p o s i t e and L e af c l a s s e s as p o s s i b l e . The Componen t\nc l a ss usuall y provide s defaul t implementation s for t h e se operations , and\nLeaf and Composit e s u b c l a s s e s w i ll overrid e them.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 535, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 882}}
{"id": "computer_science_design_patterns_gof_chunk_0536_de392788", "text": "The Componen t\nc l a ss usuall y provide s defaul t implementation s for t h e se operations , and\nLeaf and Composit e s u b c l a s s e s w i ll overrid e them. H o w e v e r , t h is g o al w i ll s o m e t i m e s conflic t with t he principl e of c l a ss hierar-\nchy d e s i g n that s a ys a c l a ss shoul d o n ly defin e operation s that are meaningfu l \nto its s u b c l a s s e s . T h e re are many operation s that Componen t support s that\ndon't s e em to make s e n se for L e af c l a s s e s . How can Componen t provid e a\ndefaul t implementatio n for them? S o m e t i m e s a little creativit y s h o w s how an operatio n that woul d appea r to\nmake s e n se o n ly for C o m p o s i t e s can be implemente d for all Component s by\nmovin g it to the Componen t c l a s s. For e x a m p l e , the interfac e for a c c e s s i n g\nc h i l d r e n is a fundamenta l part of a Composit e c l a ss but not n e c e s s a r i l y L e af\nc l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 536, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_design_patterns_gof_chunk_0537_68382c72", "text": "For e x a m p l e , the interfac e for a c c e s s i n g\nc h i l d r e n is a fundamenta l part of a Composit e c l a ss but not n e c e s s a r i l y L e af\nc l a s s e s . But if we v i ew a Leaf as a Componen t that never has c h i l d r e n , then we\ncan defin e a defaul t operatio n for c h i ld a c c e s s in the Componen t c l a ss that\nn e v e r returns any c h i l d r e n . L e af c l a s s e s can use the defaul t implementation ,\nb ut C o m p o s i t e c l a s s e s w i ll r e i m p l e m e n t it to retur n t h e ir c h i l d r e n . The c h i ld managemen t operation s are more troublesom e and are d i s c u s s e d\nin t he next item. 4.Declaring the child management operations. Althoug h the C o m p o s i t e c l a ss imple-\nments the Add and R e m o v e operation s for managin g c h i l d r e n , an importan t\ni s s ue in t he C o m p o s i t e patter n is whic h c l a s s e s declare t h e se operation s in t he\nC o m p o s i t e c l a ss h i e r a r c h y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 537, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_design_patterns_gof_chunk_0538_5783f742", "text": "S h o u l d we d e c l a r e t h e se operation s in t he C o m -\nponen t and make them meaningfu l for Leaf c l a s s e s , or shoul d we declar e\na nd defin e them o n ly in C o m p o s i t e a nd i ts s u b c l a s s e s ? The d e c i s i o n i n v o l v e s a trade-of f betwee n safet y and transparency:\n• Definin g the c h i ld managemen t interfac e at the root of the c l a ss hierarch y\ng i v es y ou t r a n s p a r e n c y , b e c a u s e y ou c an treat a ll c o m p o n e n t s u n i f o r m l y . It c o s ts you safety , h o w e v e r , b e c a u s e c l i e n t s may try to do m e a n i n g l e s s\nt h i n g s l i ke add and remov e object s from l e a v e s . • D e f i n i n g c h i ld managemen t in the Composit e c l a ss g i v es you safety ,\nb e c a u s e any attemp t to add or r e m o v e o b j e c t s f r om leave s w i ll be caugh t\nat c o m p i l e - t i m e in a staticall y typed languag e l i ke C++.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 538, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_design_patterns_gof_chunk_0539_8b9caaa6", "text": "But you l o se\ntransparency, because leaves and composites have different i n t e r f a c e s . ptg1 68 STRUCTURAL PATTERNS CHAPTER 4\nWe have emphasize d transparenc y o v er safet y in this pattern . If you opt for\nsafety , then at t i m es you may l o se type informatio n and have to conver t a\ncomponen t into a composite . How can you do t h is withou t r e s o r t i n g to a\ntype-unsaf e cast? O ne approac h is to d e c l a r e an operatio n C o m p o s i t e * G e t C o m p o s i t e ( ) in\nthe Componen t c l a s s. Componen t p r o v i d e s a defaul t operatio n that return s\na null pointer . The Composit e c l a ss redefine s this operatio n to retur n i t s e lf\nthroug h the t h is pointer:\nc l a ss Composite;\nc l a ss C o m p o n e nt {\npublic:\n//. . . virtual Composite * GetComposite( ) { r e t u rn 0; }\n} ;\nc l a ss Composit e : public Component {\npublic:\nvoid Add(Component*) ;\n// . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 539, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_design_patterns_gof_chunk_0540_ce9126fb", "text": ". . virtual Composite * GetComposite( ) { r e t u rn 0; }\n} ;\nc l a ss Composit e : public Component {\npublic:\nvoid Add(Component*) ;\n// . . . virtual Composite * GetComposite( ) { r e t u rn this; }\n} ;\nc l a ss Leaf : public C o m p o n e nt {\n// . . . } ;\nG e t C o m p o s i t e l e ts you query a componen t to see if i t 's a c o m p o s i t e . You\ncan perfor m Add and R e m o v e safely on the c o m p o s i t e it returns. Composite * aComposit e = new Composite ;\nLeaf* a L e af = new Leaf;\nC o m p o n e nt * a C o m p o n e n t ;\nComposite * test;\na C o m p o n e n t = aComposite ; \nif ( t e st = aComponent->GetComposite() ) {\ntest->Add(ne w Leaf);\n}\na C o m p o n e n t = a L e af , -\nif ( t e st = aComponent->GetComposite() ) {\ntest->Add(ne w Leaf); // will not add leaf\n}\nS i m i l a r tests for a Composit e can be d o ne using the C++ d y n a m i c - c a s t\nconstruct. Of c o u r s e , t he proble m h e re is that we don't treat a ll component s uniformly .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 540, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_design_patterns_gof_chunk_0541_0a6e9f40", "text": "Of c o u r s e , t he proble m h e re is that we don't treat a ll component s uniformly . We have to rever t to t e s t i n g f or differen t t y p es befor e takin g the appropriat e\naction. ptgCOMPOSITE 1 6 9\nThe o n ly way to provid e transparenc y is to defin e defaul t Add and Remov e\noperation s in Component . That create s a new problem : T h e r e ' s no way to im-\np l e m e n t C o m p o n e n t : : A dd withou t i n t r o d u c i n g t he p o s s i b i l i t y of it f a i l i n g . You c o u ld make it do nothing , but that i g n o r e s an importan t consideration ;\nthat i s, an attemp t to add somethin g to a leaf probabl y indicate s a bug. In\nthat c a s e, the Add operatio n produce s garbage . You c o u ld make it d e l e t e its\nargument , but that migh t not be w h at c l i e n t s expect.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 541, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 817}}
{"id": "computer_science_design_patterns_gof_chunk_0542_6ea548db", "text": "In\nthat c a s e, the Add operatio n produce s garbage . You c o u ld make it d e l e t e its\nargument , but that migh t not be w h at c l i e n t s expect. U s u a l l y i t 's bette r to make Add and Remov e fail by defaul t (perhap s by\nraisin g an exception ) if the componen t isn't allowe d to have childre n or if\nthe argumen t of Remov e isn't a c h i ld of the component , r e s p e c t i v e l y . Anothe r alternativ e is to chang e t he meanin g of \" r e m o v e \" s l i g h t l y . If\nthe componen t maintain s a paren t r e f e r e n c e , then we could redefin e \nC o m p o n e n t : : R e m o v e to remov e i t s e lf from its parent . However , there s t i ll\nisn't a meaningfu l interpretatio n for a correspondin g Add. 5. Should Component implement a list of Components? You migh t be tempte d to\ndefin e the set of c h i l d r e n as an instanc e variabl e in the Componen t c l a ss\nwher e the c h i ld a c c e s s and managemen t operation s are declared .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 542, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_design_patterns_gof_chunk_0543_709d1bfe", "text": "You migh t be tempte d to\ndefin e the set of c h i l d r e n as an instanc e variabl e in the Componen t c l a ss\nwher e the c h i ld a c c e s s and managemen t operation s are declared . But puttin g\nthe c h i ld pointe r in the base c l a s s incur s a s p a ce penalt y for every leaf, e v en\nthoug h a l e af n e v er has children . T h is is worthwhil e o n ly if there are relativel y\nfew c h i l d r e n in the structure. 6. Child ordering. Many d e s i g n s specif y an orderin g on the c h i l d r e n of Com-\np o s i t e . In t he e a r l i e r G r a p h i c s e x a m p l e , o r d e r i n g m ay reflec t front-to-bac k\no r d e r i n g . If C o m p o s i t e s represen t parse t r e e s, then compoun d statement s\ncan be instance s of a C o m p o s i t e w h o s e childre n must be ordere d to reflec t\nthe program.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 543, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 832}}
{"id": "computer_science_design_patterns_gof_chunk_0544_5a5a5f72", "text": "If C o m p o s i t e s represen t parse t r e e s, then compoun d statement s\ncan be instance s of a C o m p o s i t e w h o s e childre n must be ordere d to reflec t\nthe program. Whe n c h i ld orderin g is an i s s u e , you must d e s i g n c h i ld a c c e s s and man-\nagemen t interface s carefull y to manag e t he s e q u e n c e of c h i l d r e n . T he Itera-\ntor ( 2 5 7) p a t t e r n can guide you in this. 7. Caching to improve performance. If y ou n e ed to t r a v e r s e or s e a r c h c o m p o s i t i o n s\nfrequently , the Composit e c l a ss can cache traversa l or s e a r c h informatio n\nabou t its c h i l d r e n . The Composit e can c a c he actua l result s or j u st informatio n\nthat l e ts it short-circui t the traversa l or s e a r c h . For example , the Pictur e c l a ss\nf r om the Motivatio n exampl e c o u ld cache the boundin g box of its children .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 544, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 893}}
{"id": "computer_science_design_patterns_gof_chunk_0545_d241295a", "text": "For example , the Pictur e c l a ss\nf r om the Motivatio n exampl e c o u ld cache the boundin g box of its children . D u r i n g drawin g or s e l e c t i o n , t h is c a c h e d b o u n d i n g b ox l e ts t he P i c t u r e a v o id\ndrawin g or s e a r c h i n g when its c h i l d r e n aren' t v i s i b l e in the curren t window. C h a n g e s to a c o m p o n e n t w i ll r e q u i r e i n v a l i d a t i n g t he c a c h e s of i ts p a r e n t s . T h is work s best when component s know their parents . So if you'r e using\nc a c h i n g , you n e ed to defin e an interfac e for t e l l i n g composite s that their\nc a c h e s a re i n v a l i d . 8. Who should delete components? In language s withou t garbag e c o l l e c t i o n , it's\nusuall y b e st to make a C o m p o s i t e r e s p o n s i b l e for d e l e t i n g its c h i l d r e n w h en\nit's destroyed . An exceptio n to t h is rule is when Leaf object s are immutabl e\nand thus can be shared.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 545, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_design_patterns_gof_chunk_0546_1a7aa96b", "text": "An exceptio n to t h is rule is when Leaf object s are immutabl e\nand thus can be shared. ptg1 70 STRUCTURAL PATTERNS CHAPTER 4\n9. What's the best data structure for storing components? C o m p o s i t e s may use a\nvariet y of data structures to s t o re their c h i l d r e n , i n c l u d i n g l i n k e d l i s t s, t r e e s,\narrays , a nd hash t a b l e s . T he c h o i c e of data structur e d e p e n d s ( as always ) on\nefficiency . In fact, it i s n 't e v en n e c e s s a r y to use a general-purpos e data struc-\nture at a l l. S o m e t i m e s c o m p o s i t e s have a variabl e for e a ch c h i l d , althoug h\nt h is require s e a ch s u b c l a s s of C o m p o s i t e to implemen t i ts o wn managemen t\ninterface. S e e Interpreter (243) f o r a n example. Sample Code\nEquipmen t s u ch as computer s and s t e r eo component s are often organize d into\npart-whol e or containmen t h i e r a r c h i e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 546, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 931}}
{"id": "computer_science_design_patterns_gof_chunk_0547_01a43cad", "text": "S e e Interpreter (243) f o r a n example. Sample Code\nEquipmen t s u ch as computer s and s t e r eo component s are often organize d into\npart-whol e or containmen t h i e r a r c h i e s . F or e x a m p l e , a c h a s s i s c an c o n t a i n d r i v e s\nand plana r b o a r d s , a bus can contai n c a r d s , and a c a b i n e t can c o n t a i n c h a s s i s ,\nb u s e s , and so forth . S u ch structure s can be m o d e l e d naturall y with the Composit e\npattern. E q u i p m e n t c l a ss define s an interfac e for all equipmen t in the part-whol e hierar-\nc h y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 547, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 581}}
{"id": "computer_science_design_patterns_gof_chunk_0548_937827b3", "text": "S u ch structure s can be m o d e l e d naturall y with the Composit e\npattern. E q u i p m e n t c l a ss define s an interfac e for all equipmen t in the part-whol e hierar-\nc h y . class Equipment {\npublic:\nvirtual \" E q u i p m e n t ( ) ;\nc o n st c h a r* N a m e () { r e t u rn _name; }\nvirtual Watt P o w e r ( ); \nvirtual C u r r e n cy NetPrice() ;\nvirtual C u r r e n cy DiscountPrice();\nvirtual void Add(Equipment*) ; \nvirtual void Remove(Equipment*) ; \nvirtual Iterator<Equipment*> * Createlterator();\np r o t e c t e d :\nE q u i p m e n t ( c o n s t char*);\nprivate:\nc o n st c h a r* _name;\n} ;\nE q u i p m e n t d e c l a r e s operation s that retur n the attribute s of a p i e ce of equipment ,\nlike i ts powe r consumptio n a nd c o s t. S u b c l a s s e s i m p l e m e n t t h e se o p e r a t i o n s f or\ns p e c i f i c kinds of equipment .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 548, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 868}}
{"id": "computer_science_design_patterns_gof_chunk_0549_fd9c4531", "text": "S u b c l a s s e s i m p l e m e n t t h e se o p e r a t i o n s f or\ns p e c i f i c kinds of equipment . E q u i p m e n t a l so d e c l a r e s a C r e a t e l t e r a t o r op-\neratio n that return s an I t e r a t o r ( s ee Appendi x C) for a c c e s s i n g its parts . The\ndefaul t implementatio n for t h is operatio n return s a Nulllterator , whic h iterate s\no v er the empt y s e t . S u b c l a s s e s of E q u i p m e n t m i g h t i n c l u d e L e af c l a s s e s that represen t d i sk d r i v e s ,\nintegrated circuits, and switches:\n\nptgCOMPOSITE 171\nc l a ss F l o p p y D i s k : public Equipmen t {\npublic:\nF l o p p y D i s k ( c o n s t c h a r * );\nvirtual \" F l o p p y D i s k ( ) ;\nvirtual Watt P o w e r ( ); \nvirtual C u r r e n cy NetPrice() ;\nv i r t u a l C u r r e n c y DiscountPrice();\n} ;\nC o m p o s i t e E q u i p m e n t is the base c l a s s for e q u i p m e n t t h a t c o n t a i n s o t h e r e q u i p -\nment.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 549, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_design_patterns_gof_chunk_0550_b16af4fb", "text": "It's also a subclass o f E q u i p m e n t . c l a ss CompositeEquipmen t : public Equipmen t {\np u b l i c :\nvirtual ~CompositeEquipment();\nvirtual Watt P o w e r ( ); \nvirtual C u r r e n cy NetPrice() ; \nvirtual C u r r e n cy DiscountPrice();\nvirtual void Add(Equipment*) ; \nvirtual void Remove(Equipment*) ; \nvirtual Iterator<Equipment*> * Createlterator();\nprotected:\nCompositeEquipment(cons t char*);\nprivate:\nList<Equipment* > _equipment ;\n} ;\nC o m p o s i t e E q u i p m e n t define s the operation s for a c c e s s i n g and managin g\nsubequipment . The operation s Add and Remov e i n s e r t and d e l e t e equip-\nment f r om the l i st of equipmen t store d in the .equipmen t m e m b e r . The\no p e r a t i o n C r e a t e l t e r a t o r return s an iterato r ( s p e c i f i c a l l y , an i n s t a n c e of\nL i s t l t e r a t o r ) that w i ll travers e this l i s t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 550, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 893}}
{"id": "computer_science_design_patterns_gof_chunk_0551_cdd449c0", "text": "The\no p e r a t i o n C r e a t e l t e r a t o r return s an iterato r ( s p e c i f i c a l l y , an i n s t a n c e of\nL i s t l t e r a t o r ) that w i ll travers e this l i s t . A defaul t implementatio n of N e t P r i c e migh t use C r e a t e l t e r a t o r to sum the\nnet prices of the subequipment 2:\nC u r r e n cy CompositeEquipment::NetPric e () {\nIterator<Equipment*> * i = Createlterator() ;\nC u r r e n cy total = 0 ;\nf or ( i - > F i r s t ( ) ; ! i - > I s D o n e ( ) ; i - > N e x t ( ) ) {\ntotal += i->Current!tem()->NetPrice();\n} \ndelete i;\nr e t u rn total;\n}\n2 It's e a sy to forge t to d e l e t e the iterato r o n ce you'r e d o ne with it. The Iterato r patter n s h o w s how to guard\na g a i n s t s u c h b u g s on page 266. ptg1 72 STRUCTURAL PATTERNS CHAPTER 4\nNow we can r e p r e s e n t a compute r c h a s s i s as a s u b c l a s s of Compo s i t e E q u i p m e n t\nc a l l e d C h a s s i s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 551, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 937}}
{"id": "computer_science_design_patterns_gof_chunk_0552_129e6bfd", "text": "ptg1 72 STRUCTURAL PATTERNS CHAPTER 4\nNow we can r e p r e s e n t a compute r c h a s s i s as a s u b c l a s s of Compo s i t e E q u i p m e n t\nc a l l e d C h a s s i s . C h a s s i s i n h e r i t s t h e c h i l d - r e l a t e d o p e r a t i o n s f r o m C o m -\npos i t e E q u i p m e n t . c l a ss C h a s s is : public C o m p o s i t e E q u i p m e n t {\npublic:\nC h a s s i s ( c o n s t c h a r * );\nvirtual \" C h a s s i s ( ) ;\nvirtual Watt P o w e r ( ); \nvirtual C u r r e n cy NetPrice() ;\nvirtual C u r r e n cy DiscountPrice();\n} ;\nWe can defin e o t h er equipmen t c o n t a i n e r s s u ch as C a b i n e t and Bus in a s i m i l a r\nw a y.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 552, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 672}}
{"id": "computer_science_design_patterns_gof_chunk_0553_53fd7d40", "text": "T h at g i v es us e v e r y t h i n g we n e ed to a s s e m b l e equipmen t i n to a (prett y\ns i m p l e ) p e r s o n a l c o m p u t e r :\nCabinet* c a b i n et = new Cabinet(\"P C Cabinet\") ;\nC h a s s i s* c h a s s is = n ew Chassis(\"P C Chassis\");\ncabinet->Add(chassis);\nB u s* b us = n ew B u s ( \" M CA Bus\");\nb u s - > A d d ( n e w Card(\"16Mb s T o k en Ring\"));\nchassis->Add(bus) ; \nc h a s s i s - > A d d ( n e w FloppyDisk(\"3.Bin Floppy\"));\nc o u t « \"The n e t p r i c e i s \" « c h a s s i s - > N e t P r i c e ( ) « e n d l ;\nK n o w n Uses\nExample s of t he C o m p o s i t e patter n c an be found in a l m o s t a ll o b j e c t - o r i e n t e d\ns y s t e m s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 553, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 686}}
{"id": "computer_science_design_patterns_gof_chunk_0554_cfb8a98a", "text": "T he o r i g i n a l V i ew c l a ss of S m a l l t a l k M o d e l / V i e w / C o n t r o l l e r [ K P 8 8 ]\nwas a C o m p o s i t e , and nearl y e v e ry u s er interfac e toolki t or framewor k has fol-\nlowe d in i ts s t e p s , i n c l u d i n g ET++ (with i ts V O b j e c t s [ W G M 8 8 ] ) a nd I n t e r v i e w s\n( S t y l e s [ L C I + 9 2 ] , Graphic s [ V L 8 8 ] , a nd G l y p h s [ C L 9 0 ] ) . It's i n t e r e s t i n g to note\nthat t he o r i g i n a l V i ew of Model/View/Controlle r h ad a s et of s u b v i e w s ; in o t h er\nw o r d s , V i ew w as both t he C o m p o n e n t c l a ss a nd t he C o m p o s i t e c l a s s. R e l e a s e 4 .0\nof S m a l l t a l k - 8 0 r e v i s e d Model/View/Controlle r with a VisualComponen t c l a ss\nthat h as s u b c l a s s e s V i ew a nd C o m p o s i t e V i e w . T he R TL S m a l l t a l k c o m p i l e r framewor k [ J M L 9 2 ] u s es t he C o m p o s i t e patter n e x -\nt e n s i v e l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 554, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_design_patterns_gof_chunk_0555_a64a6a38", "text": "T he R TL S m a l l t a l k c o m p i l e r framewor k [ J M L 9 2 ] u s es t he C o m p o s i t e patter n e x -\nt e n s i v e l y . R T L E x p r e s s i o n is a Componen t c l a ss f or parse t r e e s. It h as s u b c l a s s e s , \ns u ch as B i n a r y E x p r e s s i o n , that c o n t a i n c h i ld R T L E x p r e s s i o n o b j e c t s . T h e se c l a s s e s\ndefin e a c o m p o s i t e structur e for parse t r e e s. RegisterTransfe r is the C o m p o n e n t\nc l a ss f or a program' s i n t e r m e d i a t e S i n g l e S t a t ic A s s i g n m e n t ( S S A ) form .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 555, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 588}}
{"id": "computer_science_design_patterns_gof_chunk_0556_105bfb6f", "text": "RegisterTransfe r is the C o m p o n e n t\nc l a ss f or a program' s i n t e r m e d i a t e S i n g l e S t a t ic A s s i g n m e n t ( S S A ) form . L e af\ns u b c l a s s e s of RegisterTransfer define different s t a t i c a s s i g n m e n t s s u c h as\n\nptgCOMPOSITE 1 7 3\n• primitiv e assignment s that p e r f o r m an operatio n on two register s and a s s i g n\nthe resul t to a third;\n• an assignmen t with a s o u r c e r e g i s t e r but no destinatio n register , whic h i n d i -\nc a t es that t he r e g i s t e r is u s ed after a r o u t i n e r e t u r n s ; a n d\n• an a s s i g n m e n t with a destinatio n registe r but no source , whic h indicate s that\nthe registe r is a s s i g n e d befor e the routin e starts. A n o t h e r s u b c l a s s , R e g i s t e r T r a n s f e r S e t , is a C o m p o s i t e c l a ss f or r e p r e s e n t i n g a s -\ns ig nment s that chang e severa l register s at o n c e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 556, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_design_patterns_gof_chunk_0557_b5077f2a", "text": "A n o t h e r s u b c l a s s , R e g i s t e r T r a n s f e r S e t , is a C o m p o s i t e c l a ss f or r e p r e s e n t i n g a s -\ns ig nment s that chang e severa l register s at o n c e . A n o t h e r e x a m p l e of t h is patter n o c c u r s in t he f i n a n c i a l d o m a i n , w h e r e a portfoli o\naggregate s individua l a s s e t s . You can suppor t comple x aggregation s of a s s e t s by\ni m p l e m e n t i n g a portfoli o as a C o m p o s i t e that conform s to the interfac e of an\nindividua l a s s et [ B E 9 3 ] . T he Comman d ( 2 3 3) patter n d e s c r i b e s h ow Comman d o b j e c t s c an be compose d\nand sequenced with a MacroCommand Composite class. Related Patterns\nOften the component-paren t link is u s ed for a Chain of Responsibilit y ( 2 2 3 ) . D e c o r a t o r ( 1 7 5) is often u s ed with C o m p o s i t e . W h en d e c o r a t o r s a nd c o m p o s i t e s\nare u s ed together , they will usuall y have a commo n paren t c l a s s.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 557, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_design_patterns_gof_chunk_0558_5258fb01", "text": "D e c o r a t o r ( 1 7 5) is often u s ed with C o m p o s i t e . W h en d e c o r a t o r s a nd c o m p o s i t e s\nare u s ed together , they will usuall y have a commo n paren t c l a s s. So decorator s\nw i ll have to s u p p o r t t he C o m p o n e n t i n t e r f a c e with o p e r a t i o n s l i ke A d d, R e m o v e ,\nand GetChild. F l y w e i g h t ( 1 9 5) l e ts y ou s h a re c o m p o n e n t s , b ut t h ey c an no l o n g e r refer to t h e ir\nparents. Iterato r ( 2 5 7) can be used to travers e composites. Visito r ( 3 3 1) localize s operation s and behavio r that woul d otherwis e be distribute d\na c r o s s Composite and L e a f c l a s s e s . ptg\nThis page intentionally left blank \n\nptgDECORATOR 175\nD E C O R A T O R O b j e c t Structural\nI n t e n t\nAttac h additiona l r e s p o n s i b i l i t i e s to an o b j e c t d y n a m i c a l l y . D e c o r a t o r s p r o v i d e a\nf l e x i b l e alternative to subclassing f o r extending functionality.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 558, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 990}}
{"id": "computer_science_design_patterns_gof_chunk_0559_2a70e39f", "text": "D e c o r a t o r s p r o v i d e a\nf l e x i b l e alternative to subclassing f o r extending functionality. A l s o Known As\nWrapper\nMotivation\nS o m e t i m e s we want to a dd r e s p o n s i b i l i t i e s to i n d i v i d u a l o b j e c t s , n ot to an e n t i re\nc l a s s. A graphica l u s er interfac e t o o l k i t , for e x a m p l e , s h o u l d let you add p r o p e r t i e s\nl i ke b o r d e r s or behavior s l i ke s c r o l l i n g to any u s er interfac e component. One way to add r e s p o n s i b i l i t i e s is with inheritance . Inheritin g a borde r from\nanothe r c l a ss puts a b o r d e r aroun d e v e ry s u b c l a s s i n s t a n c e . T h is is i n f l e x i b l e ,\nh o w e v e r , b e c a u s e t he c h o i c e of b o r d e r is m a de s t a t i c a l l y . A c l i e nt can't c o n t r o l\nhow and when to decorat e the componen t with a b o r d e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 559, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_design_patterns_gof_chunk_0560_c8286c11", "text": "A c l i e nt can't c o n t r o l\nhow and when to decorat e the componen t with a b o r d e r . A m o re f l e x i b l e a p p r o a c h is to e n c l o s e t he c o m p o n e n t in a n o t h e r o b j e c t that a d ds\nt he b o r d e r . T he e n c l o s i n g o b j e c t is c a l l ed a d e c o r a t o r . T he decorato r conform s to \nt he interfac e of t he componen t it decorate s so that i ts p r e s e n c e is transparen t to t he\ncomponent' s c l i e n t s . The d e c o r a t o r forward s r e q u e s t s to the componen t and may \nperfor m additiona l a c t i o n s (such as drawin g a border ) befor e or a f t er forwarding . T r a n s p a r e n c y l e ts y ou n e st d e c o r a t o r s r e c u r s i v e l y , thereb y a l l o w i n g an unlimite d\nnumber of added responsibilities. ptg1 7 6 STRUCTURAL PATTERNS CHAPTER 4\nFor e x a m p l e , suppos e we have a T e xt V i ew o b j e c t that display s text in a w i n d o w .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 560, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_design_patterns_gof_chunk_0561_7e672edf", "text": "ptg1 7 6 STRUCTURAL PATTERNS CHAPTER 4\nFor e x a m p l e , suppos e we have a T e xt V i ew o b j e c t that display s text in a w i n d o w . T e xt V i ew has no s c r o ll bars by default , b e c a u s e we migh t not alway s n e ed them . Whe n we do, we can use a S c r o l l D e c o r a t o r to add them . S u p p o s e we a l so want to\nadd a thick b l a ck b o r d e r aroun d the T e xt V i e w . We can use a BorderDecorato r to\na dd this as w e l l. We s i m p l y c o m p o s e t he d e c o r a t o r s with t he T e xt V i ew to produc e \nthe d e s i r e d result. The followin g o b j e c t diagra m show s how to c o m p o s e a T e xt V i ew o b j e c t with \nBorderDecorato r and S c r o l l D e c o r a t o r object s to produc e a b o r d e r e d , s c r o l l a b l e\ntext view:\nT he S c r o l l D e c o r a t o r a nd BorderDecorato r c l a s s e s a re s u b c l a s s e s of Decorator , an\nabstract class for visual components that decorate other visual components.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 561, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_design_patterns_gof_chunk_0562_a63bef9c", "text": "V i s u a l C o m p o n e n t is t he abstrac t c l a ss f or v i s u a l o b j e c t s . It define s t h e ir drawin g\nand event handlin g interface . Note how the D e c o r a t o r c l a ss s i m p l y forward s\ndraw request s to its component , and how Decorato r s u b c l a s s e s can e x t e n d this\noperation. Decorato r s u b c l a s s e s are free to add operation s for s p e c i f i c functionality . For ex-\na m p l e , S c r o l l D e c o r a t o r ' s S c r o l l T o operatio n l e ts other object s s c r o ll t he interfac e\nif they know the re happen s to be a S c r o l l D e c o r a t o r o b j e c t in the interface . The\nimportant aspect of this pattern is that it lets decorators appear anywhere a Vi-\nsualComponent can. That way clients generally can't tell the difference b e t w e e n\n\nptgDECORATOR 1 7 7\na decorate d componen t and an undecorate d o n e, and so they don't depen d at all\no n the d e c o r a t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 562, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_design_patterns_gof_chunk_0563_f4f193a9", "text": "That way clients generally can't tell the difference b e t w e e n\n\nptgDECORATOR 1 7 7\na decorate d componen t and an undecorate d o n e, and so they don't depen d at all\no n the d e c o r a t i o n . Applicability\nU se D e c o r a t o r\n• to add r e s p o n s i b i l i t i e s to i n d i v i d u a l o b j e c t s dynamicall y and transparently ,\nthat is, withou t affectin g other objects. • for r e s p o n s i b i l i t i e s that can be withdrawn. • when e x t e n s i o n by s u b c l a s s i n g is i m p r a c t i c a l . S o m e t i m e s a l a r ge numbe r\nof independen t extension s are possibl e and woul d produc e an e x p l o s i o n of\ns u b c l a s s e s to suppor t every combination . Or a c l a ss definitio n m a y b e h i d d e n\nor otherwise unavailable for subclassing. S t r u c t u r e\nP a r t i c i p a n t s\n• Componen t ( V i s u a l C o m p o n e n t )\n- define s the interfac e for object s that can have responsibilitie s adde d to\nthem dynamically.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 563, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_design_patterns_gof_chunk_0564_fa13061b", "text": "S t r u c t u r e\nP a r t i c i p a n t s\n• Componen t ( V i s u a l C o m p o n e n t )\n- define s the interfac e for object s that can have responsibilitie s adde d to\nthem dynamically. • C o n c r e t e C o m p o n e n t (TextView)\n- d e f i n e s an o b j e c t to w h i ch a d d i t i o n a l r e s p o n s i b i l i t i e s c an be attached. • Decorator\n- maintain s a referenc e to a Componen t objec t and define s an interfac e that\nconforms to Component's i n t e r f a c e . ptg1 7 8 STRUCTURAL P A T T E R N S CHAPTER 4\n• ConcreteDecorator ( B o r d e r D e c o r a t o r , ScrollDecorator)\n- adds responsibilities to the c o m p o n e n t . C o l l a b o r a t i o n s\n• Decorator forwards requests to its Component object. It may optionally per-\nf o r m additional operations before and a f t e r forwarding t h e request. C o n s e q u e n c e s\nThe Decorato r patter n has at l e a st two key benefit s and two l i a b i l i t i e s :\n1. More flexibility than static inheritance.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 564, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_design_patterns_gof_chunk_0565_17afa771", "text": "C o n s e q u e n c e s\nThe Decorato r patter n has at l e a st two key benefit s and two l i a b i l i t i e s :\n1. More flexibility than static inheritance. T he Decorato r patter n p r o v i d e s a more\nflexibl e way to add r e s p o n s i b i l i t i e s to object s than can be had with static\n( m u l t i p l e ) i n h e r i t a n c e . W i th d e c o r a t o r s , r e s p o n s i b i l i t i e s c an be a d d e d a nd\nremove d at run-tim e s i m p l y by attachin g and d e t a c h i n g them . In contrast ,\ni n h e r i t a n c e r e q u i r e s c r e a t i n g a n ew c l a ss f or e a ch a d d i t i o n a l r e s p o n s i b i l -\ni ty ( e . g ., B o r d e r e d S c r o l l a b l e T e x t V i e w , BorderedTextView) . T h is g i v es r i se to\nmany c l a s s e s a nd i n c r e a s e s t he c o m p l e x i t y of a s y s t e m .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 565, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 846}}
{"id": "computer_science_design_patterns_gof_chunk_0566_0628e3e8", "text": "g ., B o r d e r e d S c r o l l a b l e T e x t V i e w , BorderedTextView) . T h is g i v es r i se to\nmany c l a s s e s a nd i n c r e a s e s t he c o m p l e x i t y of a s y s t e m . Furthermore , p r o v i d -\ning differen t Decorato r c l a s s e s for a s p e c i f i c Componen t c l a ss l e ts you mix\nand matc h r e s p o n s i b i l i t i e s . Decorator s also make it e a sy to add a propert y twice . For example , to g i ve\na T e xt V i ew a doubl e border , s i m p l y attac h two BorderDecorators . I n h e r i t i n g \nf r om a B o r d e r c l a ss twice is error-pron e at best. 2. Avoids feature-laden classes high up in the hierarchy. D e c o r a t o r offer s a p a y -\na s - y o u - g o approac h to addin g r e s p o n s i b i l i t i e s . Instea d of tryin g to suppor t\na ll f o r e s e e a b l e feature s in a c o m p l e x , c u s t o m i z a b l e c l a s s, y ou c an d e f i n e\na s i m p l e c l a ss and add functionalit y incrementall y with Decorato r objects .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 566, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_design_patterns_gof_chunk_0567_ed25d4fb", "text": "Functionalit y c an be c o m p o s e d from s i m p l e p i e c e s . As a r e s u l t , an applicatio n\nneedn' t pay for feature s it doesn' t u s e. I t 's a l so easy to defin e new k i n ds of\nDecorator s independentl y f r om the c l a s s e s of object s they extend , e v en for\nunforesee n e x t e n s i o n s . Extendin g a c o m p l e x c l a ss tends to e x p o s e d e t a i l s\nunrelate d to the r e s p o n s i b i l i t i e s you'r e adding. 3. A decorator and its component aren't identical. A decorato r acts as a transparen t\ne n c l o s u r e . But from an objec t identit y point of v i e w , a decorate d c o m p o n e n t\nis not identica l to the componen t itself . H e n c e you shouldn' t r e ly on o b j e c t\nidentit y when you use decorators. 4.Lots of little objects. A d e s i g n that u s es Decorato r often result s in s y s t e m s\nc o m p o s e d of l o ts of l i t t le o b j e c t s that a ll l o ok a l i k e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 567, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_design_patterns_gof_chunk_0568_727d9d5c", "text": "4.Lots of little objects. A d e s i g n that u s es Decorato r often result s in s y s t e m s\nc o m p o s e d of l o ts of l i t t le o b j e c t s that a ll l o ok a l i k e. T he o b j e c t s differ o n ly\nin t he w ay they a re i n t e r c o n n e c t e d , n ot in their c l a ss or in t he value of\nt h e ir v a r i a b l e s . A l t h o u g h t h e se s y s t e m s a re e a sy to c u s t o m i z e by t h o se w ho\nunderstand them, they can be hard to learn and debug. ptgDECORATOR 179\nImplementation\nS e v e r a l i s s u e s s h o u l d be c o n s i d e r e d when applyin g the Decorato r pattern:\n1.Interface conformance. A d e c o r a t o r o b j e c t ' s interfac e must c o n f o r m to t he i n t e r -\nf a ce of the componen t it decorates . ConcreteDecorato r c l a s s e s must therefor e\ni n h e r i t from a c o m m o n c l a ss ( at l e a st in C++). 2. Omitting the abstract Decorator class.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 568, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_design_patterns_gof_chunk_0569_eb022363", "text": "ConcreteDecorato r c l a s s e s must therefor e\ni n h e r i t from a c o m m o n c l a ss ( at l e a st in C++). 2. Omitting the abstract Decorator class. T h e r e ' s no n e ed to defin e an abstrac t\nDecorato r c l a ss when you o n ly n e ed to add one r e s p o n s i b i l i t y . That' s often\nthe c a se when you'r e dealin g with an e x i s t i n g c l a ss hierarch y rathe r than\nd e s i g n i n g a new o n e. In that c a s e, you can m e r g e Decorator' s r e s p o n s i b i l i t y\nfor forwardin g request s to the componen t into the C o n c r e t e D e c o r a t o r . 3. Keeping Component classes lightweight. To ensur e a conformin g interface , c o m -\np o n e n t s a nd d e c o r a t o r s must d e s c e n d from a c o m m o n C o m p o n e n t c l a s s. It's importan t to keep this c o m m o n c l a ss lightweight ; that is, it s h o u l d fo-\nc us on d e f i n i n g an interface , n ot on s t o r i n g data .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 569, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_design_patterns_gof_chunk_0570_a02adc4a", "text": "It's importan t to keep this c o m m o n c l a ss lightweight ; that is, it s h o u l d fo-\nc us on d e f i n i n g an interface , n ot on s t o r i n g data . T he d e f i n i t i o n of t he data\nrepresentatio n shoul d be deferre d to s u b c l a s s e s ; o t h e r w i s e the c o m p l e x i t y\nof t he C o m p o n e n t c l a ss m i g h t make t he d e c o r a t o r s t oo h e a v y w e i g h t to u se\nin quantity . Puttin g a lot of functionalit y into Componen t a l so i n c r e a s e s the\np r o b a b i l i t y that c o n c r e t e s u b c l a s s e s w i ll p ay f or feature s t h ey d o n 't n e e d . 4. Changing the skin of an object versus changing its guts. We can think of a d e c o -\nrator as a s k in over an objec t that change s its behavior . An alternativ e is to\nchang e t he object' s guts. T he Strateg y ( 3 1 5) patter n is a g o od exampl e of a\npatter n for c h a n g i n g the guts.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 570, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 919}}
{"id": "computer_science_design_patterns_gof_chunk_0571_79c3eb5e", "text": "An alternativ e is to\nchang e t he object' s guts. T he Strateg y ( 3 1 5) patter n is a g o od exampl e of a\npatter n for c h a n g i n g the guts. S t r a t e g i e s are a bette r c h o i c e in situation s wher e the C o m p o n e n t c l a ss is\nintrinsicall y heavyweight , thereb y makin g the Decorato r patter n too c o s t ly\nto a p p l y . In the Strateg y pattern , the componen t forward s s o me of its b e h a v i o r\nto a separat e strateg y object . The Strateg y patter n l e ts us alter or exten d the\ncomponent' s functionalit y by replacin g the strateg y object. For e x a m p l e , we can suppor t differen t borde r s t y l es by h a v i n g the c o m p o n e n t\ndefer b o r d e r - d r a w i n g to a s e p a r a t e B o r d e r o b j e c t . T he B o r d e r o b j e c t is a\nStrateg y o b j e c t that encapsulate s a border-drawin g strategy .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 571, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 872}}
{"id": "computer_science_design_patterns_gof_chunk_0572_1f48ad44", "text": "T he B o r d e r o b j e c t is a\nStrateg y o b j e c t that encapsulate s a border-drawin g strategy . By e x t e n d i n g\nt he n u m b e r of s t r a t e g i e s from just o ne to an o p e n - e n d e d l i s t, we a c h i e v e t he\nsame effec t as nestin g decorator s r e c u r s i v e l y . In M a c A p p 3 .0 [ A p p 8 9 ] a nd B e d r o c k [ S y m 9 3 a ] , f or e x a m p l e , g r a p h i c a l c o m -\nponent s ( c a l l e d \" v i e w s \" ) maintai n a l i st of \"adorner \" o b j e c t s that can attac h\na d d i t i o n a l adornment s l i ke b o r d e r s to a v i ew c o m p o n e n t . If a v i ew h as a ny\nadorner s attached , then it g i v es them a c h a n c e to draw additiona l e m b e l l i s h -\nm e n t s . MacAp p a nd B e d r o c k must u se t h is a p p r o a c h b e c a u s e t he V i ew c l a ss\nis heavyweight . It woul d be too e x p e n s i v e to use a full-fledge d V i ew just to\nadd a b o r d e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 572, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_design_patterns_gof_chunk_0573_bbaaedc0", "text": "It woul d be too e x p e n s i v e to use a full-fledge d V i ew just to\nadd a b o r d e r . S i n ce the Decorato r patter n o n ly c h a n g e s a componen t f r om the o u t s i d e , the\ncomponen t d o e s n ' t have to know anythin g abou t its decorators ; that is, the\ndecorators are transparent to the component:\n\nptg1 8 0 STRUCTURAL P A T T E R N S CHAPTER 4\nWith strategies , t he componen t i t s e lf know s abou t p o s s i b l e e x t e n s i o n s . So it\nhas to reference and maintain the corresponding strategies:\nThe Strategy-base d approac h migh t r e q u i r e modifyin g the c o m p o n e n t to\naccommodat e new e x t e n s i o n s . On the other hand , a strateg y can have its\nown s p e c i a l i z e d interface , wherea s a decorator' s interfac e must confor m to\nthe component's . A strateg y for r e n d e r i n g a border , for example , n e ed o n ly\ndefin e the interfac e for renderin g a borde r (DrawBorder , GetWidth , e t c .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 573, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_design_patterns_gof_chunk_0574_5532a147", "text": "A strateg y for r e n d e r i n g a border , for example , n e ed o n ly\ndefin e the interfac e for renderin g a borde r (DrawBorder , GetWidth , e t c . ),\nwhic h mean s that the strateg y can be lightweigh t e v en if the C o m p o n e n t\nc l a ss is heavyweight. MacAp p and B e d r o c k use this approac h for more than j u st adornin g views . T h ey a l so u se it to a u g m e n t t he e v e n t - h a n d l i n g b e h a v i o r of o b j e c t s . In b o th\ns y s t e m s , a v i ew maintain s a l i st of \" b e h a v i o r \" o b j e c t s that can modif y and\nintercep t e v e n t s . T he v i ew g i v es e a ch of t he r e g i s t e r e d behavio r object s a\nc h a n c e to h a n d l e t he e v e nt befor e n o n r e g i s t e r e d b e h a v i o r s , e f f e c t i v e l y o v e r -\nriding them . You can decorat e a v i ew with specia l keyboard-handlin g s u p -\nport, for example , by registerin g a behavio r objec t that intercept s and h a n d l e s\nk e y events.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 574, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_design_patterns_gof_chunk_0575_3b354533", "text": "You can decorat e a v i ew with specia l keyboard-handlin g s u p -\nport, for example , by registerin g a behavio r objec t that intercept s and h a n d l e s\nk e y events. S a m p l e C o d e\nThe followin g c o de s h o w s how to implemen t user interfac e decorator s in C++. W e ' l l assume there's a Component class called VisualComponent. c l a ss VisualComponen t {\npublic:\nVisualComponent();\nvirtual void Draw();\nvirtual void Resize();\n// . . . } ;\n\nptgDECORATOR 181\nW e define a subclass of V i s u a l C o m p o n e n t called Decorator, which we'll sub-\nc l a s s to obtain different d e c o r a t i o n s . class Decorato r : public VisualComponen t {\npublic:\nDecorator(VisualComponent*);\nvirtual void Draw();\nvirtual void Resize();\n// . . -\nprivate:\nVisualComponent * _component ;\n} ;\nD e c o r a t o r decorate s the V i s u a l C o m p o n e n t reference d by the - c o m p o n e n t\ninstanc e variable , whic h is initialize d in t he constructor .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 575, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_design_patterns_gof_chunk_0576_bd97c5e4", "text": "F or e a ch operatio n in\nV i s u a l C o m p o n e n t ' s interface , D e c o r a t o r define s a d e f a u l t implementatio n\nthat passes the request on to -component:\nv o id D e c o r a t o r : : D r a w () {\n_component->Draw() ;\n}\nvoid Decorator::Resiz e () {\n_component->Resize() ;\n}\nS u b c l a s s e s of D e c o r a t o r d e f i n e s p e c i f i c d e c o r a t i o n s . F or e x a m p l e , t he c l a s s\nB o r d e r D e c o r a t o r a d ds a b o r d e r to its e n c l o s i n g c o m p o n e n t . B o r d e r -\nD e c o r a t o r is a s u b c l a s s of D e c o r a t o r t h at o v e r r i d e s t he Draw o p e r a t i o n to\nd r aw the b o r d e r . B o r d e r D e c o r a t o r a l so d e f i n e s a privat e D r a w B o r d e r h e l p e r\no p e r a t i o n that does the drawing. The subclass inherits all other operation imple -\nm e n t a t i o n s from Decorator.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 576, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_design_patterns_gof_chunk_0577_924afebb", "text": "The subclass inherits all other operation imple -\nm e n t a t i o n s from Decorator. c l a ss BorderDecorato r : public Decorato r {\npublic:\nBorderDecorator(VisualComponent* , int borderWidth);\nvirtual void D r a w ( );\np r i v a t e :\nvoid D r a w B o r d e r ( i n t ) ;\nprivate:\nint _width;\n} ;\nvoid BorderDecorator::Draw () {\nDecorator::Draw();\nDrawBorder(_width);\n}\n\nptg1 82 STRUCTURAL PATTERNS CHAPTER 4\nA s i m i l a r implementatio n woul d follow for S c r o l l D e c o r a t o r and D r o p -\nS h a d o w D e c o r a t o r , w h i c h woul d a dd s c r o l l i n g a nd d r op s h a d o w c a p a b i l i t i e s\nto a v i s u a l component. N ow we c an c o m p o s e i n s t a n c e s of t h e se c l a s s e s to p r o v i d e differen t d e c o r a t i o n s . T he followin g c o de illustrate s h ow we c an u se decorator s to c r e a t e a bordere d\ns c r o l l a b l e T e xt View. F i r s t, we n e ed a way to put a visua l c o m p o n e n t i n to a w i n d o w o b j e c t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 577, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_design_patterns_gof_chunk_0578_1850c77c", "text": "F i r s t, we n e ed a way to put a visua l c o m p o n e n t i n to a w i n d o w o b j e c t . W e ' ll a s s u m e\nour Window class provides a SetContents operation for this purpose:\nvoid W i n d o w : : S e t C o n t e n t s ( V i s u a l C o m p o n e n t * c o n t e n t s) {\n// . - . }\nN o w we can create the text view and a window to put it in:\nW i n d o w * window = new Window;\nT e x t V i e w * t e x t V i e w = new TextView;\nT e x t V i e w is a VisualComponent, w h i c h l e t s us put it into t h e w i n d o w :\nw i n d o w - > S e t C o n t e n t s ( t e x t V i e w ) ;\nB ut we want a b o r d e r e d a nd s c r o l l a b l e TextView . So we d e c o r a t e it a c c o r d i n g l y\nbefore putting it in the window.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 578, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 736}}
{"id": "computer_science_design_patterns_gof_chunk_0579_6f8bef22", "text": "So we d e c o r a t e it a c c o r d i n g l y\nbefore putting it in the window. w i n d o w - > S e t C o n t e n t s ( \nn e w BorderDecorator(\nnew ScrollDecorator(textView), 1\nB e c a u s e W i n d o w a c c e s s e s its c o n t e n t s t h r o u g h the V i s u a l C o m p o n e n t interface ,\ni t 's unawar e of t he decorator' s p r e s e n c e . Y o u, as t he c l i e n t , c an s t i ll k e ep track of\nt he text v i ew if y ou have to interac t with it d i r e c t l y , f or e x a m p l e , w h en y ou n e ed\nto i n v o k e o p e r a t i o n s that aren't part of the V i s u a l C o m p o n e n t interface . C l i e n t s\nthat rely on the component's identity should refer to it directly as well. K n o w n Uses\nM a ny o b j e c t - o r i e n t e d u s er interfac e t o o l k i t s use decorator s to add g r a p h i -\nc al e m b e l l i s h m e n t s to w i d g e t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 579, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_design_patterns_gof_chunk_0580_b6ed03ed", "text": "K n o w n Uses\nM a ny o b j e c t - o r i e n t e d u s er interfac e t o o l k i t s use decorator s to add g r a p h i -\nc al e m b e l l i s h m e n t s to w i d g e t s . E x a m p l e s i n c l u d e I n t e r v i e w s [ L V C 8 9 , L C I + 9 2 ] ,\nET++ [ W G M 8 8 ] , a nd t he O b j e c t W o r k s \\ S m a l l t a l k c l a ss librar y [ P a r 9 0 ] . M o re e x -\no t ic a p p l i c a t i o n s of D e c o r a t o r a re t he D e b u g g i n g G l y p h from I n t e r v i e w s a nd t he\nP a s s i v i t y W r a p p e r f r o m P a r c P l a c e S m a l l t a l k . A DebuggingGlyph prints o u t d e -\nb u g g i n g i n f o r m a t i o n b e f o r e and a f t e r i t forwards a layout request to its compo -\nn e n t . T h i s t r a c e i n f o r m a t i o n can be u s e d to analyze and debug the layout behavior\n\nptgDECORATOR 1 8 3\nof object s in a comple x composition . The Passivit y Wrappe r can enabl e or disabl e\nu s er i n t e r a c t i o n s with t he c o m p o n e n t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 580, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_design_patterns_gof_chunk_0581_ca8b0440", "text": "The Passivit y Wrappe r can enabl e or disabl e\nu s er i n t e r a c t i o n s with t he c o m p o n e n t . But the Decorato r patter n is by no mean s limite d to graphica l user interfaces , as the\nfollowin g exampl e ( b a s e d on t he ET++ streamin g c l a s s e s [ W G M 8 8 ] ) illustrates. Stream s are a f u n d a m e n t a l abstractio n in most I/O facilities . A strea m can provid e\nan interfac e for convertin g object s into a s e q u e n c e of bytes or characters . T h at\nl e ts us transcrib e an objec t to a file or to a string in memor y for retrieva l later. A\nstraightforwar d way to do this is to defin e an abstrac t Strea m c l a ss with s u b c l a s s e s\nMemoryStrea m and FileStream . But suppos e we also want to be able to do the\nfollowing:\n• C o m p r e s s t he s t r e am data u s i ng differen t c o m p r e s s i o n a l g o r i t h m s ( r u n -\nlengt h e n c o d i n g , Lempel-Ziv , etc.).", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 581, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 931}}
{"id": "computer_science_design_patterns_gof_chunk_0582_074e4280", "text": "• Reduc e the strea m data to 7 - b it A S C I I character s so that it can be transmitte d\nover an A S C I I communicatio n channel. The Decorato r p a t t e r n g i v es us an elegan t way to add t h e se r e s p o n s i b i l i t i e s to\nstreams. The diagram below shows one solution to the problem:\nThe Strea m abstrac t c l a ss maintain s an interna l b u f f e r and provide s operation s for\ns t o r i n g data o n to t he s t r e am ( P u t l n t , P u t S t r i n g ) . W h e n e v e r t he b u f f e r is full, S t r e a m\nc a l ls the abstrac t operatio n HandleBufferFull , whic h d o es the a c t u a l data transfer . T he F i l e S t r e a m v e r s i o n of t h is o p e r a t i o n o v e r r i d e s t h is o p e r a t i o n to transfe r t he\nb u f f e r to a file. T he key c l a ss h e re is StreamDecorator , w h i c h maintain s a referenc e to a c o m -\nponen t stream and forward s request s to it.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 582, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_design_patterns_gof_chunk_0583_da4f06c4", "text": "T he key c l a ss h e re is StreamDecorator , w h i c h maintain s a referenc e to a c o m -\nponen t stream and forward s request s to it. StreamDecorato r s u b c l a s s e s overrid e\nHandleBufferFull a n d p e r f o r m a d d i t i o n a l a c t i o n s b e f o r e c a l l i n g S t r e a m D e c o r a -\ntor's HandleBufferFull o p e r a t i o n . ptg1 84 STRUCTURAL PATTERNS CHAPTER 4\nF or e x a m p l e , t he C o m p r e s s i n g S t r e a m s u b c l a s s c o m p r e s s e s t he data, a nd t he\nA S C I I 7 S t r e a m c o n v e r t s t he data i n to 7 - b it A S C I I .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 583, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 584}}
{"id": "computer_science_design_patterns_gof_chunk_0584_137c1dd6", "text": "N o w , to creat e a F i l e S t r e a m\nthat c o m p r e s s e s i ts data a nd c o n v e r t s t he c o m p r e s s e d binar y data to 7 - b it A S C I I ,\nwe decorat e a F i l e S t r e a m with a C o m p r e s s i n g S t r e a m and an A S C I I 7 S t r e a m :\nS t r e a m* a S t r e am = n ew C o m p r e s s i n g S t r e a m (\nn ew A S C I I 7 S t r e a m (\nn ew FileStream(\"aFileName\" )\n)\n) ;\na S t r e a m - > P u t ! n t ( 1 2 ) ;\naStream->PutString(\"aString\");\nR e l a t e d P a t t e r n s\nAdapte r ( 1 3 9 ) : A decorato r is differen t from an adapte r in that a decorato r o n ly\nc h a n g e s an object' s r e s p o n s i b i l i t i e s , n ot i ts interface ; an adapte r w i ll g i ve an o b j e c t\na c o m p l e t e l y new interface. C o m p o s i t e ( 1 6 3 ) : A decorato r c an be v i e w e d as a degenerat e c o m p o s i t e with o n ly\none c o m p o n e n t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 584, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_design_patterns_gof_chunk_0585_18a36cc0", "text": "C o m p o s i t e ( 1 6 3 ) : A decorato r c an be v i e w e d as a degenerat e c o m p o s i t e with o n ly\none c o m p o n e n t . H o w e v e r , a decorato r adds additiona l r e s p o n s i b i l i t i e s — i t isn't\ni n t e n d e d for o b j e c t aggregation. Strateg y ( 3 1 5 ) : A decorato r l e ts y ou c h a n g e t he s k in of an o b j e c t ; a strateg y l e ts\ny o u change the guts. These are two alternative ways of c h a n g i n g an object. ptgFACADE 185\nF A C A D E O b j e c t Structural\nI n t e n t\nP r o v i d e a unifie d interfac e to a set of interface s in a s u b s y s t e m . Facad e define s a\nh i g h e r - l e v e l i n t e r f a c e t h a t m a k e s the subsystem easier to use. Motivation\nStructurin g a syste m i n to subsystem s h e l ps reduc e c o m p l e x i t y . A commo n d e s i g n\ng o al is to m i n i m i z e t he communicatio n a nd d e p e n d e n c i e s betwee n subsystems .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 585, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_design_patterns_gof_chunk_0586_e482ae13", "text": "A commo n d e s i g n\ng o al is to m i n i m i z e t he communicatio n a nd d e p e n d e n c i e s betwee n subsystems . One way to a c h i e v e t h is g o a l is to introduc e a facad e objec t that provide s a s i n g l e ,\ns i m p l i f i e d interface to the more general facilities of a subsystem. C o n s i d e r f or e x a m p l e a programmin g e n v i r o n m e n t that g i v es a p p l i c a t i o n s a c c e s s\nto i ts c o m p i l e r s u b s y s t e m . T h is subsyste m c o n t a i n s c l a s s e s s u ch as S c a n n e r , Parser ,\nProgramNode , B y t e c o d e S t r e a m , and ProgramNodeBuilde r that implemen t the\nc o m p i l e r . S o me s p e c i a l i z e d a p p l i c a t i o n s m i g h t n e ed to a c c e s s t h e se c l a s s e s d i r e c t l y . But m o st c l i e n t s of a compile r g e n e r a l l y don't c a re abou t detail s l i ke parsin g and\nc o de g e n e r a t i o n ; they m e r e l y want to c o m p i l e s o me c o d e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 586, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_design_patterns_gof_chunk_0587_6c277130", "text": "But m o st c l i e n t s of a compile r g e n e r a l l y don't c a re abou t detail s l i ke parsin g and\nc o de g e n e r a t i o n ; they m e r e l y want to c o m p i l e s o me c o d e. For t h e m , the p o w e r f u l\nbut l o w - l e v e l interface s in the c o m p i l e r s u b s y s t e m o n ly complicat e their task. To provid e a h i g h e r - l e v e l interfac e that c an s h i e ld c l i e n t s from t h e se c l a s s e s , t he\nc o m p i l e r subsyste m a l so i n c l u d e s a C o m p i l e r c l a s s . T h is c l a ss d e f i n e s a unifie d\ninterfac e to the compiler' s functionality . The C o m p i l e r c l a ss acts as a facade : It\noffer s c l i e n t s a s i n g l e , s i m p l e interfac e to the compile r subsystem . It g l u es togethe r\nthe c l a s s e s that implemen t c o m p i l e r functionalit y withou t h i d i n g them c o m p l e t e l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 587, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_design_patterns_gof_chunk_0588_d71b9c99", "text": "It g l u es togethe r\nthe c l a s s e s that implemen t c o m p i l e r functionalit y withou t h i d i n g them c o m p l e t e l y . The c o m p i l e r facad e make s life e a s i e r for most programmer s withou t h i d i n g the\nl o w e r - l e v e l f u n c t i o n a l i t y from the few that need it. ptg1 8 6 STRUCTURAL PATTERNS CHAPTER 4\nA p p l i c a b i l i t y\nUse the Facad e patter n when\n• you w a nt to provid e a s i m p l e interfac e to a comple x subsystem . S u b s y s t e m s\no f t en get more comple x as they e v o l v e . M o st patterns , when applied , r e s u l t\nin more and s m a l l e r c l a s s e s . T h is make s the subsyste m more reusabl e and\ne a s i e r to customize , but it also b e c o m e s harde r to use for c l i e n t s that don't\nn e ed to customiz e it. A facad e can provid e a s i m p l e defaul t view of the\nsubsyste m that is g o od enoug h for most c l i e n t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 588, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_design_patterns_gof_chunk_0589_7ed7aec9", "text": "A facad e can provid e a s i m p l e defaul t view of the\nsubsyste m that is g o od enoug h for most c l i e n t s . O n ly c l i e n t s needin g more\ncustomizabilit y will n e ed to l o ok beyon d the facade. • there are many d e p e n d e n c i e s betwee n c l i e n t s and the implementatio n c l a s s e s\nof an abstraction . Introduc e a facad e to d e c o u p l e the subsyste m from c l i e n t s\nand other subsystems , thereb y promotin g subsyste m i n d e p e n d e n c e and\nportability. • you want to layer your subsystems . Use a facad e to defin e an entry point to\neach s u b s y s t e m l e v e l . If subsystem s are dependent , then you can simplif y\nthe d e p e n d e n c i e s betwee n them by makin g them communicat e with e a ch \nother solely through their facades. ptgF A C A D E 187\nS t r u c t u r e\nP a r t i c i p a n t s\n• Facade ( C o m p i l e r )\n- knows which subsystem classes are r e s p o n s i b l e for a request.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 589, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_design_patterns_gof_chunk_0590_feb5a50f", "text": "ptgF A C A D E 187\nS t r u c t u r e\nP a r t i c i p a n t s\n• Facade ( C o m p i l e r )\n- knows which subsystem classes are r e s p o n s i b l e for a request. - delegates client requests to a p p r o p r i a t e s u b s y s t e m objects. • subsystem classes ( S c a n n e r , Parser, ProgramNode, etc.)\n-i m p l e m e n t s u b s y s t e m functionality. -handle w o r k assigned by the F a c a d e object. -have no knowledge of t h e facade; that is, t h e y k e e p no references to it. C o l l a b o r a t i o n s\n• C l i e n t s c o m m u n i c a t e with t he s u b s y s t e m by s e n d i n g r e q u e s t s to F a c a d e , w h i c h\nforward s them to the appropriat e s u b s y s t e m o b j e c t ( s ) . A l t h o u g h the s u b s y s t e m\no b j e c t s perfor m the actua l work , the facad e may have to do work of its own to\ntranslate its interface to subsystem interfaces. • Clients that use the facade don't have to access its subsystem objects d i r e c t l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 590, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_design_patterns_gof_chunk_0591_d5671ebc", "text": "• Clients that use the facade don't have to access its subsystem objects d i r e c t l y . C o n s e q u e n c e s\nThe F a c a d e patter n offer s the f o l l o w i n g benefits:\n1. It s h i e l d s c l i e n t s from s u b s y s t e m c o m p o n e n t s , thereb y r e d u c i n g t he numbe r\nof o b j e c t s that c l i e n t s d e al with a nd makin g t he s u b s y s t e m e a s i e r to u s e . 2. It p r o m o t e s weak c o u p l i n g b e t w e e n t he s u b s y s t e m a nd i ts c l i e n t s . Often t he\nc o m p o n e n t s in a s u b s y s t e m a re s t r o n g l y c o u p l e d . Weak c o u p l i n g l e ts y ou\nvary the components of the subsystem without affecting i t s clients. Facades\n\nptg1 88 STRUCTURAL PATTERNS CHAPTER 4\nh e lp layer a syste m and the d e p e n d e n c i e s betwee n objects . T h ey can e l i m i -\nnate c o m p l e x or circula r d e p e n d e n c i e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 591, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 905}}
{"id": "computer_science_design_patterns_gof_chunk_0592_5728fc1b", "text": "Facades\n\nptg1 88 STRUCTURAL PATTERNS CHAPTER 4\nh e lp layer a syste m and the d e p e n d e n c i e s betwee n objects . T h ey can e l i m i -\nnate c o m p l e x or circula r d e p e n d e n c i e s . T h is can be an importan t c o n s e q u e n c e\nwhen the c l i e n t and the subsyste m are implemente d i n d e p e n d e n t l y . Reducin g compilatio n d e p e n d e n c i e s is vital in large softwar e s y s t e m s . Y ou\nwant to s a ve time by minimizin g recompilatio n when subsyste m c l a s s e s\nc h a n g e . Reducin g compilatio n d e p e n d e n c i e s with facade s can l i m it the re-\ncompilatio n n e e d e d for a smal l c h a n g e in an importan t subsystem . A facad e\ncan a l so simplif y portin g system s to other platforms , becaus e it's l e ss l i k e ly\nthat buildin g one subsyste m r e q u i r e s buildin g all others. 3. It d o e s n ' t preven t application s f r om using subsyste m c l a s s e s if they n e ed t o.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 592, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 958}}
{"id": "computer_science_design_patterns_gof_chunk_0593_3eca0b7d", "text": "3. It d o e s n ' t preven t application s f r om using subsyste m c l a s s e s if they n e ed t o. T h u s you can choose between ease of use and generality. Implementation\nC o n s i d e r the followin g i s s u e s when implementin g a facade:\n1. Reducing client-subsystem coupling. T he couplin g betwee n c l i e n t s a nd t he s u b -\nsyste m can be r e d u c e d e v en f u r t h e r by makin g Facad e an abstrac t c l a ss\nwith c o n c r e t e s u b c l a s s e s for differen t implementation s of a subsystem . T h en\nc l i e n t s can communicat e with the subsyste m throug h the interfac e of the ab-\nstrac t Facad e c l a s s . T h is abstrac t c o u p l i n g keep s c l i e n t s f r om knowin g whic h\nimplementatio n of a subsyste m is u s e d . An alternativ e to s u b c l a s s i n g is to configur e a Facad e o b j e c t with differen t\nsubsyste m objects . To customiz e t he facade , s i m p l y r e p l a c e o ne or more of\nits s u b s y s t e m objects. 2.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 593, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_design_patterns_gof_chunk_0594_df05998f", "text": "To customiz e t he facade , s i m p l y r e p l a c e o ne or more of\nits s u b s y s t e m objects. 2. Public versus private subsystem classes. A subsyste m is a n a l o g o u s to a c l a ss in\nthat both have interfaces , and both encapsulat e something— a c l a ss e n c a p s u -\nlates state and operations , w h i le a subsyste m encapsulate s c l a s s e s . And just\nas it's usefu l to think of the publi c and privat e interfac e of a c l a s s, we can\nthink of the publi c and privat e interfac e of a subsystem. The p u b l i c interfac e to a subsyste m c o n s i s t s of c l a s s e s that all c l i e n t s can\na c c e s s ; the privat e interfac e is j u st for subsyste m extenders . The Facad e c l a ss\nis part of the publi c interface , of c o u r s e , but it's not the o n ly part. O t h e r \nsubsyste m c l a s s e s a re usuall y publi c as well. F or e x a m p l e , t he c l a s s e s Parse r\nand S c a n n e r in the c o m p i l e r subsyste m are part of the publi c interface.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 594, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_design_patterns_gof_chunk_0595_c949874a", "text": "O t h e r \nsubsyste m c l a s s e s a re usuall y publi c as well. F or e x a m p l e , t he c l a s s e s Parse r\nand S c a n n e r in the c o m p i l e r subsyste m are part of the publi c interface. Makin g subsyste m c l a s s e s privat e woul d be useful , but few o b j e c t - o r i e n t e d\nlanguage s suppor t it. B o th C++ and Smalltal k traditionall y have had a g l o b a l\nname space for c l a s s e s . Recently , h o w e v e r , the C++ standardizatio n c o m m i t -\ntee adde d name s p a c e s to the languag e [ S t r 9 4 ] , whic h will let you e x p o s e j u st\nthe public subsystem classes. S a m p l e Code\nL e t ' s t a k e a closer look at how to put a facade on a compiler subsystem. ptgFACADE 1 8 9\nThe c o m p i l e r subsyste m define s a B y t e c o d e S t r e a m c l a ss that implement s a strea m\nof B y t e c o d e objects . A B y t e c o d e objec t encapsulate s a bytecode , w h i c h can\nspecif y m a c h i n e instructions .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 595, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_design_patterns_gof_chunk_0596_0b88eac7", "text": "A B y t e c o d e objec t encapsulate s a bytecode , w h i c h can\nspecif y m a c h i n e instructions . The subsyste m a l so define s a T o k e n c l a ss for o b j e c t s\nthat encapsulat e token s in the programmin g language. The S c a n n e r c l a ss takes a stream of character s and produce s a stream of t o k e n s ,\none token at a time. class S c a n n er {\npublic:\nScanner(istream&) ;\nvirtual \"Scanner();\nvirtual T o k e n& Scan();\nprivate:\ni s t r e a m& _inputStream ;\n} ;\nThe c l a ss P a r s e r u s es a P r o g r a m N o d e B u i l d e r to construc t a parse tree f r om a\nS c a n n e r ' s tokens. class P a r s er {\np u b l i c :\nParser() ; \nvirtual \" P a r s e r ( ) ;\nvirtual void Parse(Scanners , ProgramNodeBuilder&) ;\n} ;\nP a r s e r calls back on ProgramNodeBuilder t o build t h e parse tree incremen -\nt a l l y . These classes interact according to the Builder (97) pattern.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 596, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 906}}
{"id": "computer_science_design_patterns_gof_chunk_0597_7f2e7a63", "text": "These classes interact according to the Builder (97) pattern. class ProgramNodeBuilde r {\npublic:\nProgramNodeBuilder();\nvirtual ProgramNode * NewVariable (\nc o n st char* variableName\n) const;\nv i r t u al P r o g r a m N o d e * N e w A s s i g n m e n t (\nProgramNode * variable , ProgramNode * expressio n\n) const;\nvirtual ProgramNode * NewReturnStatement(\nProgramNode * value\n) const;\nvirtual ProgramNode * NewCondition ( \nProgramNode * condition , \nProgramNode * truePart , ProgramNode * falsePart\n) const;\n// . . . ptg1 9 0 STRUCTURAL P A T T E R N S CHAPTER 4\nP r o g r a m N o d e * GetRootNode() ;\nprivate:\nP r o g r a m N o d e * _node;\n} ;\nThe parse tree is made up of i n s t a n c e s of P r o g r a m N o d e s u b c l a s s e s such as\nS t a t e m e n t Node , E x p r e s s i o n N o d e , and so forth . The P r o g r a m N o d e hierarch y\nis an exampl e of the Composit e ( 1 6 3) pattern .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 597, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_design_patterns_gof_chunk_0598_49451c20", "text": "The P r o g r a m N o d e hierarch y\nis an exampl e of the Composit e ( 1 6 3) pattern . P r o g r a m N o d e define s an interfac e\nfor m a n i p u l a t i n g t h e program node a n d i t s children, if a n y . c l a ss P r o g r a m N o d e {\npublic:\n// p r o g r am n o de manipulatio n \nvirtual void GetSourcePosition(int & line, i n t& i n d e x ); \n// . . . // child manipulatio n \nvirtual void Add(ProgramNode*) ;\nvirtual void Remove(ProgramNode*) ; \n// . . . virtual void T r a v e r s e ( C o d e G e n e r a t o r & ) ;\nprotected:\nP r o g r a m N o d e ( ) ;\n} ;\nThe T r a v e r s e operatio n takes a C o d e G e n e r a t o r object . P r o g r a m N o d e s u b -\nc l a s s e s use t h is objec t to generat e machin e c o de in the f o rm of B y t e c o d e o b j e c t s\non a BytecodeS t r e a m . T h e c l a s s CodeGenerator is a visitor (see Visitor ( 3 3 1 ) ) . c l a ss C o d e G e n e r a t o r {\npublic:\nvirtual void Visit(StatementNode*) ;\nvirtual void Visit(ExpressionNode*);\n// . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 598, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1012}}
{"id": "computer_science_design_patterns_gof_chunk_0599_f9d03f67", "text": "T h e c l a s s CodeGenerator is a visitor (see Visitor ( 3 3 1 ) ) . c l a ss C o d e G e n e r a t o r {\npublic:\nvirtual void Visit(StatementNode*) ;\nvirtual void Visit(ExpressionNode*);\n// . . . protected:\nC o d e G e n e r a t o r ( B y t e c o d e S t r e a m & ) ;\nprotected:\nBytecodeStream k _output;\n} ;\nC o d e G e n e r a t o r has s u b c l a s s e s , for example , S t a c k M a c h i n e C o d e G e n e r a t o r\nand R I S C C o d e G e n e r a t o r , that generat e m a c h i n e c o de for differen t hardwar e\na r c h i t e c t u r e s . E a ch s u b c l a s s of P r o g r a m N o d e implement s T r a v e r s e to c a ll T r a v e r s e on its\nc h i ld P r o g r a m N o d e o b j e c t s . In turn, e a ch c h i ld d o es the same for its c h i l d r e n , and\nso on recursively.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 599, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 802}}
{"id": "computer_science_design_patterns_gof_chunk_0600_92168fc7", "text": "In turn, e a ch c h i ld d o es the same for its c h i l d r e n , and\nso on recursively. For example, ExpressionNode defines Traverse as follows:\n\nptgF A C A D E 191\nvoid ExpressionNode::Travers e ( C o d e G e n e r a t o r & eg) {\neg.Visit(this);\nListIterator<PrograinNode* > i ( _ c h i l d r e n ) ;\nfor ( i. First ( ); ! i . I s D o ne () ; i.NextO) {\ni.Currentltem()->Traverse(eg) ;\n}\nThe c l a s s e s we've d i s c u s s e d so far make up the c o m p i l e r subsystem . Now we'll in-\ntroduc e a C o m p i l e r c l a s s, a facad e that p u ts all t h e se p i e c e s together . C o m p i l e r\np r o v i d e s a simple interface f o r compiling source and g e n e r a t i n g c o d e for a par-\nticular machine.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 600, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 724}}
{"id": "computer_science_design_patterns_gof_chunk_0601_3a5fceae", "text": "C o m p i l e r\np r o v i d e s a simple interface f o r compiling source and g e n e r a t i n g c o d e for a par-\nticular machine. class Compiler {\npublic:\nCompiler();\nvirtual void Compile(istream& , BytecodeStream&) ;\n} ;\nvoid Compiler::Compil e ( \ni s t r e a m& i n p u t, BytecodeStream k o u t p u t\n) { \nS c a n n er scanner(input);\nProgramNodeBuilde r builder;\nP a r s er parser;\nparser.Parse(scanner , builder);\nRISCCodeGenerato r generator(output) ;\nP r o g r a m N o d e * p a r s e T r e e = builder.GetRootNode() ;\nparseTree->Traverse(generator);\nT h is i m p l e m e n t a t i o n h a r d - c o d e s t he type of c o de generato r to u se so that program-\nmers aren' t require d to specif y the targe t architecture . That migh t be r e a s o n a b l e if\nthere' s o n ly e v er one targe t architecture . If that's not the c a s e, then we migh t want\nto c h a n g e the C o m p i l e r constructo r to take a C o d e G e n e r a t o r parameter .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 601, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_design_patterns_gof_chunk_0602_63900b55", "text": "If that's not the c a s e, then we migh t want\nto c h a n g e the C o m p i l e r constructo r to take a C o d e G e n e r a t o r parameter . T h en\nprogrammer s can specif y the generato r to use when they instantiat e C o m p i l e r . The compile r facad e can parameteriz e other participant s such as S c a n n e r and\nP r o g r a m N o d e B u i l d e r as w e l l, whic h adds flexibility , but it a l so detract s f r om\nthe Facad e pattern' s m i s s i o n , whic h is to simplif y the interfac e for the commo n\ncase. K n o w n Uses\nThe compiler example in the Sample Code section was i n s p i r e d b y t h e O b j e c t -\nWorks\\Smalltalk compiler system [Par90]. ptg1 9 2 STRUCTURAL PATTERNS CHAPTER 4\nIn the ET++ applicatio n f r a m e w o r k [ W G M 8 8 ] , an applicatio n can have built-i n\nbrowsin g t o o ls for i n s p e c t i n g its object s at run-time .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 602, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 879}}
{"id": "computer_science_design_patterns_gof_chunk_0603_49a46ec4", "text": "T h e se browsin g t o o ls are\nimplemente d in a separat e subsyste m that include s a Facad e c l a ss c a l l ed \" P r o -\ngrammingEnvironment. \" T h is f a c a d e define s operation s s u ch as I n s p e c t O b j e c t\nand InspectClas s for a c c e s s i n g the browsers. An ET++ applicatio n can a l so forgo built-i n browsin g support . In that c a s e, P r o -\ngrammingEnvironmen t implement s t h e se request s as null operations ; that i s, they \ndo nothing . O n ly t he ETProgrammingEnvironmen t subclas s implement s t h e se r e -\nq u e s t s with o p e r a t i o n s that d i s p l a y t he c o r r e s p o n d i n g b r o w s e r s . T he a p p l i c a t i o n\nhas no knowledg e of whethe r a browsin g environmen t is availabl e or not; t h e r e ' s\nabstrac t c o u p l i n g betwee n the applicatio n and the browsin g subsystem. The C h o i c e s operatin g syste m [ C I R M 9 3 ] uses facade s to compos e many frame-\nwork s into o n e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 603, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_design_patterns_gof_chunk_0604_edc9c41b", "text": "The C h o i c e s operatin g syste m [ C I R M 9 3 ] uses facade s to compos e many frame-\nwork s into o n e. The key abstraction s in C h o i c e s are p r o c e s s e s , storage , and ad-\nd r e ss s p a c e s . F or each of t h e se abstraction s t h e re is a c o r r e s p o n d i n g s u b s y s t e m ,\nimplemente d as a f r a m e w o r k , that support s portin g C h o i c e s to a variet y of dif-\nferen t hardwar e platforms . Two of these subsystem s have a \"representative \" ( i . e .,\nfacade). These representatives are FileSystemlnterface (storage) a n d Domain (ad -\ndress spaces). For example , the virtua l memor y f r a m e w o r k has Domai n as its facade . A Domai n\nrepresent s an addres s s p a c e . It provide s a mappin g betwee n virtua l a d d r e s s e s\na nd offset s i n to m e m o r y o b j e c t s , f i l e s, or b a c k i n g s t o r e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 604, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 872}}
{"id": "computer_science_design_patterns_gof_chunk_0605_31ac921a", "text": "A Domai n\nrepresent s an addres s s p a c e . It provide s a mappin g betwee n virtua l a d d r e s s e s\na nd offset s i n to m e m o r y o b j e c t s , f i l e s, or b a c k i n g s t o r e. T he m a in o p e r a t i o n s on\nDomai n suppor t addin g a memor y objec t at a particula r a d d r e s s , r e m o v i n g a \nmemory object, and handling a page f a u l t . As the preceding diagram shows, the virtual memory subsystem uses the follow -\ning components internally:\n\nptgF A C A D E 193\n• MemoryObjec t represent s a data store. • MemoryObjectCach e c a c h e s the data of MemoryObject s in physica l m e m o r y . MemoryObjectCach e is actuall y a Strateg y ( 3 1 5) that localize s the c a c h i n g\np o l i c y . • AddressTranslatio n encapsulate s the addres s translatio n hardware. The RepairFaul t operatio n is c a l l ed wheneve r a page f a u lt interrup t occurs .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 605, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_design_patterns_gof_chunk_0606_fe71fe91", "text": "• AddressTranslatio n encapsulate s the addres s translatio n hardware. The RepairFaul t operatio n is c a l l ed wheneve r a page f a u lt interrup t occurs . The\nDomai n finds the memor y objec t at the addres s causin g the f a u lt and delegate s the\nRepairFaul t operatio n to the c a c he a s s o c i a t e d with that memor y object . D o m a i n s\ncan be customized by changing their components. Related P a t t e r n s\nAbstrac t Factor y ( 8 7) can be u s ed with Facad e to provid e an interfac e for creatin g\nsubsyste m o b j e c t s in a subsystem-independen t way. Abstrac t Factor y can also be\nused as an alternativ e to Facad e to hide platform-specifi c c l a s s e s . Mediato r ( 2 7 3) is s i m i l a r to Facad e in that it abstract s functionalit y of e x i s t i n g\nc l a s s e s . H o w e v e r , Mediator' s purpos e is to abstrac t arbitrar y communicatio n be-\ntwee n colleagu e o b j e c t s , often centralizin g functionalit y that doesn' t belon g in\nany one of them .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 606, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_design_patterns_gof_chunk_0607_7a918f88", "text": "H o w e v e r , Mediator' s purpos e is to abstrac t arbitrar y communicatio n be-\ntwee n colleagu e o b j e c t s , often centralizin g functionalit y that doesn' t belon g in\nany one of them . A mediator' s c o l l e a g u e s are awar e of and communicat e with the\nmediato r instea d of communicatin g with e a ch other d i r e c t l y . In contrast , a facad e\nmerel y abstract s the interfac e to subsyste m object s to make them easie r to u s e; it\ndoesn't define new functionality, and subsystem classes don't know about it. Usually only one Facade object is required. Thus Facade objects are often Single -\ntons (127). ptg\nThis page intentionally left blank \n\nptgFLYWEIGHT 195\nF L Y W E I G H T Object S t r u c t u r a l\nIntent\nUse sharing to support large numbers of fine-grained objects e f f i c i e n t l y . Motivation\nS o me application s could benefi t f r om using object s throughou t their d e s i g n , but\na naive implementatio n woul d be prohibitivel y expensive.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 607, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_design_patterns_gof_chunk_0608_856d2807", "text": "Motivation\nS o me application s could benefi t f r om using object s throughou t their d e s i g n , but\na naive implementatio n woul d be prohibitivel y expensive. For example , most documen t edito r implementation s have text f o r m a t t i n g and\neditin g facilitie s t h at are modularize d to som e extent . Object-oriente d documen t\neditor s typicall y use object s to represen t embedde d element s like table s and fig-\nures. However , they usuall y stop short of using an objec t for each characte r in the\ndocument , even thoug h doing so woul d promot e flexibilit y at the fines t l e v e ls in\nthe application . Character s and embedde d element s c o u ld then be treate d uni-\nf o r m l y with r e s p e c t to how they are d r a w n and f o r m a t t e d . The applicatio n c o u ld\nbe extende d to suppor t new characte r s e ts withou t disturbin g other functionality . The application' s objec t structur e could mimi c the document' s physica l structure .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 608, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_design_patterns_gof_chunk_0609_37ab39cc", "text": "The application' s objec t structur e could mimi c the document' s physica l structure . The followin g diagra m s h o w s how a documen t edito r can use object s to represen t\ncharacters. The drawbac k of such a d e s i g n is its cost. Even moderate-size d document s may\nr e q u i r e hundred s of thousand s of characte r objects , whic h will consum e lots of\nmemor y and may incur unacceptabl e run-tim e overhead . The Flyweigh t p a t t e r n\nd e s c r i b e s how to share object s to allow their use at fine granularitie s withou t\nprohibitive cost. ptg1 96 STRUCTURAL PATTERNS CHAPTER 4\nA flyweigh t is a s h a r e d o b j e c t that c an be u s ed in multipl e context s s i m u l t a n e o u s l y . The flyweigh t a c ts as an independen t objec t in e a ch context—it' s i n d i s t i n g u i s h -\nable from an instanc e of the o b j e c t that's not shared . F l y w e i g h t s canno t make\nassumption s abou t the contex t in whic h they operate .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 609, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_design_patterns_gof_chunk_0610_40a7f646", "text": "F l y w e i g h t s canno t make\nassumption s abou t the contex t in whic h they operate . The key c o n c e p t h e re is the\nd i s t i n c t i o n betwee n i n t r i n s i c a nd e x t r i n s i c state. Intrinsi c state is s t o r e d in t he\nflyweight ; it c o n s i s t s of informatio n that's independen t of the flyweight' s context ,\nthereb y makin g it sharable . Extrinsi c state d e p e n d s on and v a r i e s with the fly-\nweight' s c o n t e x t and therefor e can't be s h a r e d . C l i e n t o b j e c t s are r e s p o n s i b l e for\npassin g e x t r i n s i c state to the flyweigh t when it n e e ds it. F l y w e i g h t s mode l c o n c e p t s or e n t i t i e s that are normall y too plentifu l to r e p r e s e n t\nwith objects . For e x a m p l e , a documen t edito r can creat e a flyweigh t for e a ch letter\nof the alphabet .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 610, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 860}}
{"id": "computer_science_design_patterns_gof_chunk_0611_b78878f2", "text": "For e x a m p l e , a documen t edito r can creat e a flyweigh t for e a ch letter\nof the alphabet . E a ch flyweigh t s t o r e s a characte r c o d e, but its coordinat e p o s i t i o n\nin the documen t and its typographi c s t y le can be determine d from the text layou t\nalgorithm s and formattin g command s in effec t whereve r the characte r appears . T h e character code is intrinsic state, while the other information i s extrinsic. L o g i c a l l y there is an object for every occurrence of a given character in the d o c u -\nment:\nP h y s i c a l l y , h o w e v e r , there is o ne s h a r e d f l y w e i g h t o b j e c t p er character , a nd it\nappear s in differen t context s in the documen t structure . E a ch o c c u r r e n c e of a par-\nticula r characte r o b j e c t refers to the same instanc e in the s h a r e d p o ol of flyweigh t\no b j e c t s :\n\nptgFLYWEIGHT 1 9 7\nThe c l a ss structur e for t h e se o b j e c t s is s h o w n next.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 611, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_design_patterns_gof_chunk_0612_1388f142", "text": "Glyp h is the abstrac t c l a ss for\ng r a p h i c a l o b j e c t s , s o me of w h i c h m ay be flyweights . O p e r a t i o n s that m ay d e p e n d\non extrinsi c state have it passe d to them as a parameter . For e x a m p l e , Draw and\nIntersects must know which context the glyph is in before they can do their job. A flyweigh t representin g the letter \"a\" o n ly s t o r e s the correspondin g characte r\nc o d e; it d o e s n ' t n e ed to s t o re i ts l o c a t i o n or font. C l i e n t s suppl y t he context-\ndependen t informatio n that the flyweigh t n e e ds to draw itself . For e x a m p l e , a\nR ow g l y ph k n o w s w h e r e i ts c h i l d r e n s h o u l d d r aw t h e m s e l v e s so that t h ey a re\nt i l ed horizontally . T h us it can pass each c h i ld its locatio n in the draw request.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 612, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 824}}
{"id": "computer_science_design_patterns_gof_chunk_0613_83c15f1b", "text": "T h us it can pass each c h i ld its locatio n in the draw request. B e c a u s e the numbe r of differen t characte r o b j e c t s is far l e ss than the numbe r of\ncharacter s in the document , the total numbe r of o b j e c t s is substantiall y l e ss than\nwhat a n a i ve implementatio n woul d u s e. A documen t in whic h all character s ap-\npear in t he same font a nd c o l or w i ll allocat e on t he ord er of 1 00 characte r o b j e c t s\n(roughl y t he s i ze of t he A S C I I characte r set) r e g a r d l e s s of t he document' s l e n g t h . A nd s i n ce m o st document s u se no more than 10 differen t font-colo r c o m b i n a -\nt i o n s , t h is numbe r won' t g r ow appreciabl y in practice . An objec t abstractio n thus\nb e c o m e s practical f o r individual characters. Applicability\nThe F l y w e i g h t pattern' s effectivenes s depend s heavil y on how and wher e it's\nused.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 613, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 912}}
{"id": "computer_science_design_patterns_gof_chunk_0614_59ef65f9", "text": "An objec t abstractio n thus\nb e c o m e s practical f o r individual characters. Applicability\nThe F l y w e i g h t pattern' s effectivenes s depend s heavil y on how and wher e it's\nused. Appl y the Flyweigh t patter n when all of the followin g are true:\n•An a p p l i c a t i o n u s es a l a r ge numbe r of o b j e c t s . •S t o r a g e c o s ts a re h i gh becaus e of t he s h e er quantit y of o b j e c t s . •M o st objec t state can be made e x t r i n s i c . •Many g r o u p s of o b j e c t s may be r e p l a c e d by r e l a t i v e l y few s h a r e d object s\no n ce e x t r i n s i c state is removed. •T he applicatio n d o e s n ' t d e p e n d on objec t identity . S i n ce flyweigh t o b j e c t s\nm a y be s h a r e d , i d e n t i t y tests w i l l r e t u r n t r u e for c o n c e p t u a l l y distinct objects.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 614, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 843}}
{"id": "computer_science_design_patterns_gof_chunk_0615_fad0d8ec", "text": "S i n ce flyweigh t o b j e c t s\nm a y be s h a r e d , i d e n t i t y tests w i l l r e t u r n t r u e for c o n c e p t u a l l y distinct objects. ptg1 9 8 STRUCTURAL PATTERNS\nS t r u c t u r eCHAPTER 4\nP a r t i c i p a n t s\nFlyweigh t (Glyph)\n- d e c l a r e s an interfac e throug h whic h f l y w e i g h t s c an r e c e i v e a nd a ct on\ne x t r i n s i c s t a t e . ptgF L Y W E I G H T 199\n• C o n c r e t e F l y w e i g h t ( C h a r a c t e r )\n- implement s the F l y w e i g h t interfac e and adds storag e for i n t r i n s i c state,\nif a n y. A C o n c r e t e F l y w e i g h t objec t must be sharable . A ny state it s t o r e s\nmust be i n t r i n s i c ; that i s, it must be i n d e p e n d e n t of t he C o n c r e t e F l y w e i g h t\nobject' s context. • U n s h a r e d C o n c r e t e F l y w e i g h t ( R o w , C o l u m n )\n- n ot a ll F l y w e i g h t s u b c l a s s e s n e ed to be shared .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 615, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 937}}
{"id": "computer_science_design_patterns_gof_chunk_0616_cb9ad1ae", "text": "• U n s h a r e d C o n c r e t e F l y w e i g h t ( R o w , C o l u m n )\n- n ot a ll F l y w e i g h t s u b c l a s s e s n e ed to be shared . T he F l y w e i g h t interfac e\nenables s h a r i n g ; it d o e s n ' t enforc e it. It's c o m m o n for UnsharedConcrete-\nF l y w e i g h t object s to have C o n c r e t e F l y w e i g h t o b j e c t s as c h i l d r e n at s o me\nl e v el in t he flyweigh t o b j e c t structur e ( as t he R ow a nd Colum n c l a s s e s\nh a v e ) . • FlyweightFactory\n- c r e a t e s and manage s flyweigh t objects. - e n s u r e s that flyweight s are s h a r e d p r o p e r l y . W h e n a c l i e nt r e q u e s t s a fly-\nw e i g h t , t he F l y w e i g h t F a c t o r y o b j e c t s u p p l i e s an e x i s t i n g i n s t a n c e or c r e a t e s\no n e , if none exists. • C l i e n t\n- maintains a reference to flyweight(s). - computes or s t o r e s the e x t r i n s i c s t a t e of flyweight(s).", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 616, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 955}}
{"id": "computer_science_design_patterns_gof_chunk_0617_05043866", "text": "• C l i e n t\n- maintains a reference to flyweight(s). - computes or s t o r e s the e x t r i n s i c s t a t e of flyweight(s). C o l l a b o r a t i o n s\n• State that a flyweigh t n e e ds to functio n must be characterize d as eithe r i n t r i n s i c\nor e x t r i n s i c . Intrinsi c state is s t o r e d in t he C o n c r e t e F l y w e i g h t o b j e c t ; e x t r i n s i c\nstate is s t o r e d or c o m p u t e d by C l i e n t o b j e c t s . C l i e n t s pass t h is state to t he\nflyweigh t w h en they i n v o k e its operations. • C l i e n t s s h o u l d not instantiat e C o n c r e t e F l y w e i g h t s d i r e c t l y . C l i e n t s must obtai n\nC o n c r e t e F l y w e i g h t o b j e c t s e x c l u s i v e l y f r om the FlyweightFactor y o b j e c t to\ne n s u r e t h e y are shared properly.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 617, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 829}}
{"id": "computer_science_design_patterns_gof_chunk_0618_884dac61", "text": "C l i e n t s must obtai n\nC o n c r e t e F l y w e i g h t o b j e c t s e x c l u s i v e l y f r om the FlyweightFactor y o b j e c t to\ne n s u r e t h e y are shared properly. C o n s e q u e n c e s\nF l y w e i g h t s m ay i n t r o d u c e r u n - t i m e c o s ts a s s o c i a t e d with transferring , f i n d i n g ,\na n d / o r computin g e x t r i n s i c s t a t e, e s p e c i a l l y if it was formerl y store d as i n t r i n s i c\nstate. H o w e v e r , s u ch c o s ts are o f f s e t by s p a ce s a v i n g s , whic h i n c r e a s e as m o re\nflyweights are shared. S t o r a g e savings are a function of several factors:\n• the reduction in the total number of i n s t a n c e s t h a t c o m e s from s h a r i n g\n• the amount of i n t r i n s i c s t a t e per object\n\nptg200 STRUCTURAL PATTERNS CHAPTER 4\n• whethe r extrinsi c state is compute d or stored. T he more f l y w e i g h t s a re shared , t he greate r t he storag e s a v i n g s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 618, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_design_patterns_gof_chunk_0619_dfa9741e", "text": "T he more f l y w e i g h t s a re shared , t he greate r t he storag e s a v i n g s . T he s a v i n g s\ni n c r e a s e with the amoun t of s h a r e d state. The greates t s a v i n g s o c c ur when the\nobject s use substantia l quantitie s of both i n t r i n s i c and e x t r i n s i c state, and the\nextrinsi c state can be compute d rathe r than stored . T h e n you s a ve on storag e in\ntwo ways : S h a r i n g reduce s the c o st of i n t r i n s i c state, and you trade e x t r i n s i c state\nfor computatio n time. The Flyweigh t patter n is often c o m b i n e d with the Composit e ( 1 6 3) patter n to\nrepresen t a hierarchica l structur e as a graph with s h a r e d leaf nodes . A c o n s e q u e n c e\nof s h a r i n g is that flyweigh t l e af n o d e s c a n n o t s t o re a p o i n t e r to t h e ir parent . R a t h e r ,\nthe paren t pointe r is passe d to the flyweigh t as part of its extrinsi c state.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 619, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_design_patterns_gof_chunk_0620_f2e94580", "text": "R a t h e r ,\nthe paren t pointe r is passe d to the flyweigh t as part of its extrinsi c state. T h is has\na major impact on how the objects in the hierarchy communicate with each other. Implementation\nC o n s i d e r the followin g i s s u e s when implementin g the F l y w e i g h t pattern:\n1. Removing extrinsic state. T he pattern' s applicabilit y is determine d l a r g e l y by\nhow e a sy it is to identif y e x t r i n s i c state and r e m o v e it f r om s h a r e d o b j e c t s . Removin g extrinsi c state won' t help reduc e storag e c o s ts if there are as many\ndifferen t kinds of e x t r i n s i c state as the re are o b j e c t s befor e s h a r i n g . I d e a l l y ,\ne x t r i n s i c state can be compute d from a separat e o b j e c t structure , one with far\ns m a l l e r storag e requirements.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 620, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 825}}
{"id": "computer_science_design_patterns_gof_chunk_0621_f0a8d122", "text": "I d e a l l y ,\ne x t r i n s i c state can be compute d from a separat e o b j e c t structure , one with far\ns m a l l e r storag e requirements. In our documen t e d i t o r , for example , we can s t o re a map of typographi c\ninformatio n in a separat e structur e rathe r than s t o re the font and type s t y le\nwith e a ch characte r object . The map k e e ps track of runs of character s with\nthe s a me typographi c attributes . W h en a characte r draw s itself , it r e c e i v e s\nits typographic attribute s as a side-effec t of the draw traversal . B e c a u s e d o c -\nument s normall y use j u st a few differen t fonts and s t y l e s , s t o r i n g t h is infor-\nmatio n externall y to e a ch characte r objec t is far more efficien t than storin g it \ninternally. 2. Managing shared objects. B e c a u s e object s are s h a r e d , c l i e n t s shouldn' t i n s t a n t i -\nate them d i r e c t l y . FlyweightFactor y lets c l i e n t s locat e a particula r flyweight .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 621, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_design_patterns_gof_chunk_0622_e9a61338", "text": "B e c a u s e object s are s h a r e d , c l i e n t s shouldn' t i n s t a n t i -\nate them d i r e c t l y . FlyweightFactor y lets c l i e n t s locat e a particula r flyweight . FlyweightFactor y o b j e c t s often use an associativ e s t o re to let c l i e n t s l o ok up\nflyweight s of interest . For e x a m p l e , the flyweigh t f a c t o r y in the documen t\nedito r exampl e can k e ep a table of flyweight s i n d e x e d by characte r c o d e s . The\nmanage r return s the prope r flyweigh t g i v en its c o d e, creatin g the flyweigh t \nif it d o es n ot alread y e x i s t . Sharabilit y a l so i m p l i e s s o me f o rm of referenc e countin g or garbag e c o l l e c t i o n\nto r e c l a i m a f l y w e i g h t ' s s t o r a g e w h en i t 's no l o n g e r n e e d e d . H o w e v e r , n e i t h e r\nis n e c e s s a r y if t he numbe r of f l y w e i g h t s is fixed a nd small ( e . g ., f l y w e i g h t s\nfor the A S C I I characte r set).", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 622, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_design_patterns_gof_chunk_0623_b879d75d", "text": "H o w e v e r , n e i t h e r\nis n e c e s s a r y if t he numbe r of f l y w e i g h t s is fixed a nd small ( e . g ., f l y w e i g h t s\nfor the A S C I I characte r set). In that c a s e, the flyweight s are wort h k e e p i n g\naround permanently. ptgFLYWEIGHT 201\nS a m p l e C o d e\nReturnin g to our documen t formatte r example , we can defin e a G l y p h base c l a ss\nfor flyweigh t graphica l o b j e c t s . L o g i c a l l y , g l y p h s are Composite s ( s ee C o m p o s -\nite ( 1 6 3 ) ) that have graphica l attribute s and can draw t h e m s e l v e s . H e re we focus on\nj u st the f o nt attribute , but the same approac h can be u s ed for any other graphica l\nattributes a glyph might have.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 623, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 717}}
{"id": "computer_science_design_patterns_gof_chunk_0624_eda05b36", "text": "H e re we focus on\nj u st the f o nt attribute , but the same approac h can be u s ed for any other graphica l\nattributes a glyph might have. c l a ss G l y ph {\npublic:\nvirtual ~ G l y p h ( ) ;\nvirtual void D r a w ( W i n d o w * , G l y p h C o n t e x t & ) ;\nv i r t u al void S e t F o n t ( F o n t * , G l y p h C o n t e x t k ) ;\nvirtual Font* GetFont(GlyphContext&);\nvirtual void First(GlyphContext&) ;\nvirtual void Next(GlyphContext&) ;\nvirtual bool I s D o n e ( G l y p h C o n t e x t & ) ;\nvirtual G l y p h* Current(GlyphContextk);\nvirtual void I n s e r t ( G l y p h * , G l y p h C o n t e x t & ) ;\nv i r t u al v o id R e m o v e ( G l y p h C o n t e x t k ) ;\nprotected:\nG l y p h ( );\n} ;\nThe Character subclass just stores a character code:\nc l a ss Characte r : public G l y ph {\npublic:\nCharacter(char);\nvirtual void Draw(Window* , GlyphContext&) ;\np r i v a t e :\nc h ar _charcode ;\n} ;\nTo keep f r om allocatin g s p a ce for a f o nt attribut e in every g l y p h , we'll s t o re\nthe attribut e extrinsicall y in a G l y p h C o n t e x t object .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 624, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1080}}
{"id": "computer_science_design_patterns_gof_chunk_0625_e8f9a0e0", "text": "G l y p h C o n t e x t acts as a\nrepositor y of extrinsi c state. It maintain s a compac t mappin g betwee n a g l y ph and\nits font (and any other graphica l attribute s it migh t have ) in differen t contexts . Any operatio n that n e e ds to know the g l y p h ' s font in a g i v en contex t will have\na G l y p h C o n t e x t instanc e passe d to it as a parameter . The operatio n can then\nquery the G l y p h C o n t e x t for the font in that context . The contex t depend s on\nthe glyph' s locatio n in the g l y ph structure . Therefor e G l y p h ' s c h i ld iteratio n\nand manipulatio n operation s must updat e the G l y p h C o n t e x t wheneve r they'r e\nused.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 625, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 679}}
{"id": "computer_science_design_patterns_gof_chunk_0626_e201b813", "text": "Therefor e G l y p h ' s c h i ld iteratio n\nand manipulatio n operation s must updat e the G l y p h C o n t e x t wheneve r they'r e\nused. ptg2 0 2 STRUCTURAL PATTERNS CHAPTER 4\nclass GlyphContex t {\npublic:\nGlyphContext() ; \nvirtual ~ G l y p h C o n t e x t ( ) ;\nvirtual void Next(int step = 1);\nvirtual void Insert(in t quantity = 1);\nvirtual Font* GetFont{) ; \nvirtual void SetFont(Font* , int s p an = 1 ) ;\nprivate: \nint _index; \nBTree* _fonts;\n} ;\nG l y p h C o n t e x t must be kept informe d of the c u r r e n t p o s i t i o n in the g l y ph s t r u c -\nture durin g traversal . G l y p h C o n t e x t : : N e xt i n c r e m e n t s .inde x as the traversa l\np r o c e e d s . Glyp h s u b c l a s s e s that h a ve c h i l d r e n ( e . g ., R ow a nd C o l u m n ) m u st i m -\nplemen t N e xt so that it c a l ls G l y p h C o n t e x t: : N e xt at e a ch point in the traversal.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 626, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 900}}
{"id": "computer_science_design_patterns_gof_chunk_0627_9fc4c648", "text": "g ., R ow a nd C o l u m n ) m u st i m -\nplemen t N e xt so that it c a l ls G l y p h C o n t e x t: : N e xt at e a ch point in the traversal. G l y p h C o n t e x t : : G e t F o n t u s es the i n d ex as a key into a B T r e e structur e that\ns t o r e s the glyph-to-fon t mapping . E a ch n o de in the tree is l a b e l e d with the lengt h\nof t he s t r i ng for w h i ch it g i v es font i n f o r m a t i o n . L e a v e s in t he t r ee p o i nt to a font,\nwhile interior nodes break the string into substrings, one for each child. C o n s i d e r the following excerpt from a glyph composition:\nThe BTree structure for font information might look like\n\nptgFLYWEIGHT 203\nI n t e r i o r n o d e s defin e r a n g e s of g l y ph i n d i c e s . BTr ee is update d in r e s p o n s e to font\nc h a n g e s and w h e n e v e r g l y p h s are adde d to or r e m o v e d from the g l y ph structure .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 627, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_design_patterns_gof_chunk_0628_5b419858", "text": "BTr ee is update d in r e s p o n s e to font\nc h a n g e s and w h e n e v e r g l y p h s are adde d to or r e m o v e d from the g l y ph structure . F or e x a m p l e , a s s u m i n g we're at i n d ex 1 02 in t he traversal , t he followin g c o de s e ts\nthe font of e a ch characte r in the word \" e x p e c t \" to that of the surroundin g text\n(that is, times 1 2 , a n instance of Font for 12-point Times Roman):\nG l y p h C o n t e x t gc;\nFont* t i m e s !2 = new Font(\"Times-Roman-12\");\nF o n t* t i m e s l t a l i c ! 2 = new Font(\"Times-Italic-12\") ;\n// - . . gc.SetFont(timesl2, 6);\nT h e new BTree structure (with changes shown in black) looks like\n\nptg204 STRUCTURAL PATTERNS CHAPTER 4\nS u p p o s e we add the word \" d o n ' t \" ( i n c l u d i n g a trailin g s p a c e ) in 1 2 - p o i n t T i m e s\nI t a l ic befor e \" e x p e c t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 628, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 857}}
{"id": "computer_science_design_patterns_gof_chunk_0629_31ead461", "text": "\" T he f o l l o w i n g c o de i n f o r m s t he gc of t h is e v e n t , a s s u m i n g\nit is s t i ll at i n d ex 1 0 2 :\ngc.Insert(6) ;\ngc.SetFont(timesltalic!2, 6);\nThe BTree structure becomes\nWhen the G l y p h C o n t e x t is q u e r i e d for the font of the curren t g l y p h , it d e s c e n d s\nthe BTree , addin g up i n d i c e s as it g o es until it finds the font for the curren t\ni n d e x . B e c a u s e t he frequenc y of f o nt c h a n g e s is r e l a t i v e l y l o w, t he t r ee stays s m a ll\nrelativ e to t he s i ze of t he g l y ph structure . T h is keeps storag e c o s ts down withou t\nan inordinat e i n c r e a s e in look-u p t i m e . 3\nT he last objec t we n e ed is a FlyweightFactor y that c r e a t e s g l y p h s a nd e n s u r e s\nthey'r e s h a r e d p r o p e r l y . C l a ss G l y p h F a c t o ry instantiate s C h a r a c t e r and other \nk i n ds of g l y p h s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 629, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_design_patterns_gof_chunk_0630_62fc04da", "text": "C l a ss G l y p h F a c t o ry instantiate s C h a r a c t e r and other \nk i n ds of g l y p h s . We o n ly s h a re C h a r a c t e r o b j e c t s ; c o m p o s i t e g l y p h s a re f ar l e ss\nplentiful , a nd t h e ir importan t stat e ( i . e ., t h e ir c h i l d r e n ) is i n t r i n s i c anyway. c o n st int NCHARCODE S = 128;\nc l a ss G l y p h F a c t o r y {\npublic:\nG l y p h F a c t o r y ( ) ; \nvirtual ~GlyphFactory ( ) ;\n3 L o o k - u p time in t h is s c h e m e is proportiona l to the font chang e frequency . W o r s t - c a s e performanc e occur s\nwhen a font change occurs on every character, but that's unusual in practice. ptgF L Y W E I G H T 205\nvirtual Character * CreateCharacter(char) ;\nvirtual Row* CreateRow() ; \nvirtual Column* CreateColumn();\n// . . . private:\nCharacter * _character[NCHARCODES] ;\n} ;\nThe .character array contains pointers to Character glyphs indexed by c h a r-\nacter code. The array is initialized to zero in the constructor.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 630, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_design_patterns_gof_chunk_0631_dd841242", "text": ". . private:\nCharacter * _character[NCHARCODES] ;\n} ;\nThe .character array contains pointers to Character glyphs indexed by c h a r-\nacter code. The array is initialized to zero in the constructor. G l y p h F a c t o r y : : G l y p h F a c t o r y () { \nfor ( i nt i = 0; i < NCHARCODES ; ++i) {\n_character[i ] = 0;\n}\n}\nC r e a t e C h a r a c t e r l o o ks up a characte r in the characte r glyph in the array , and it\nreturn s t he c o r r e s p o n d i n g g l y ph if it e x i s t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 631, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 491}}
{"id": "computer_science_design_patterns_gof_chunk_0632_e00bf178", "text": "If it d o e s n ' t , t h en C r e a t e C h a r a c t e r\ncreates the glyph, puts it in the array, and returns it:\nCharacter * GlyphFactory::CreateCharacte r ( c h ar c) {\nif (!_character[c] ) {\n_ c h a r a c t e r [ c ] = n ew C h a r a c t e r ( c ) ;\n}\nr e t u rn _character[c] ;\n}\nThe other operation s simpl y instantiat e a new objec t e a ch time they'r e c a l l e d ,\ns i n c e noncharacter glyphs won't be shared:\nRow* GlyphFactory::CreateRo w () {\nr e t u rn n ew Row;\n}\nColumn* G l y p h F a c t o r y : : C r e a t e C o l u m n () {\nr e t u r n new Column;\n}\nWe could o m it t h e se operation s a nd l et c l i e n t s instantiat e unshare d g l y p h s d i r e c t l y . H o w e v e r , if we d e c i d e to make t h e se g l y p h s s h a r a b l e l a t e r, w e ' ll h a ve to c h a n g e\nc l i e n t code that creates them.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 632, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 844}}
{"id": "computer_science_design_patterns_gof_chunk_0633_148190a6", "text": "H o w e v e r , if we d e c i d e to make t h e se g l y p h s s h a r a b l e l a t e r, w e ' ll h a ve to c h a n g e\nc l i e n t code that creates them. Known Uses\nT he c o n c e p t of f l y w e i g h t o b j e c t s w as first d e s c r i b e d a nd e x p l o r e d as a d e s i g n\ntechniqu e in I n t e r v i e w s 3 .0 [ C L 9 0 ] . I ts d e v e l o p e r s built a powerfu l documen t\neditor called Doc as a proof of concept [ C L 9 2 ] . Doc uses glyph objects to repre -\ns e n t e a c h c h a r a c t e r in the d o c u m e n t . The editor builds o n e Glyph instance for\n\nptg206 STRUCTURAL PATTERNS CHAPTER 4\neach characte r in a particula r style (whic h define s its graphica l attributes) ; h e n ce\na c h a r a c t e r ' s intrinsi c s t a te c o n s i s t s of the characte r c o de and its style informa-\nt i on ( an i n d ex i n to a s t y le t a b l e ) . 4 That m e a n s o n ly p o s i t i o n is e x t r i n s i c , makin g\nDoc f a s t.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 633, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_design_patterns_gof_chunk_0634_1a3f5b8f", "text": "4 That m e a n s o n ly p o s i t i o n is e x t r i n s i c , makin g\nDoc f a s t. Document s are represente d by a c l a ss Document , whic h a l so acts as the\nFlyweightFactory . Measurement s on Doc have show n that sharin g flyweigh t char-\nacter s is quite effective . In a typica l c a s e, a documen t containin g 1 8 0 , 0 0 0 character s\nrequire d allocatio n of only 480 characte r objects. ET++ [ W G M 8 8 ] uses flyweight s to suppor t look-and-fee l i n d e p e n d e n c e . 5 T he\nlook-and-fee l standar d a f f e c t s the layou t of user interfac e element s ( e . g ., s c r o ll\nbars, buttons , menus—know n c o l l e c t i v e l y as \" w i d g e t s \" ) and their d e c o r a t i o n s\n( e . g ., shadows , beveling) . A widge t delegate s all its layou t and drawin g behavio r\nto a separat e Layou t object . Changin g the Layou t objec t c h a n g e s the l o ok and feel,\ne v en at run-time. For each widge t c l a ss there is a correspondin g Layou t c l a ss ( e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 634, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_design_patterns_gof_chunk_0635_4e44c508", "text": "Changin g the Layou t objec t c h a n g e s the l o ok and feel,\ne v en at run-time. For each widge t c l a ss there is a correspondin g Layou t c l a ss ( e . g ., S c r o l l b a r L a y o u t ,\nMenubarLayout , e t c . ). An o b v i o u s p r o b l e m with t h is approac h is that using s e p -\narate layou t object s double s the numbe r of user interfac e o b j e c t s : For e a ch user\ninterfac e objec t there is an additiona l Layou t object . To avoid this overhead , L a y -\nout object s are implemente d as flyweights . T h ey make g o od flyweight s becaus e\nthey deal mostl y with definin g behavior , and it's easy to p a ss them what little\nextrinsi c state they need to lay out or draw an o b j e c t . The L a y o u t object s are create d and manage d by L o ok objects . The L o ok c l a ss is\nan Abstrac t F a c t o r y ( 8 7) that r e t r i e v e s a s p e c i f i c Layou t o b j e c t with o p e r a t i o n s \nlike GetButtonLayout , GetMenuBarLayout , and so f o r t h .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 635, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_design_patterns_gof_chunk_0636_19e67011", "text": "For each look-and-fee l\ns t a n d a r d there is a correspondin g Look s u b c l a s s ( e . g ., MotifLook , OpenLook ) that\nsupplie s the appropriat e Layou t objects. By the way, Layou t object s are essentiall y strategie s ( s ee Strateg y ( 3 1 5 ) ) . They are\nan example of a strategy object implemented a s a flyweight. Related Patterns\nThe Flyweigh t p a t t e r n is o f t en combine d with the Composit e ( 1 6 3) patter n to\ni m p l e m e n t a l o g i c a l l y h i e r a r c h i c a l structur e in terms of a d i r e c t e d - a c y c l i c g r a ph\nwith shared leaf n o d e s . It's often best to implement State (305) a n d Strategy (315) objects as flyweights. 4 In the Sampl e C o de given earlier , style informatio n is made extrinsic , leavin g the characte r c o de as the\nonly intrinsic state. 5 S e e A b s t r a c t F a c t o r y ( 8 7 ) for another approach t o look-and-feel independence.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 636, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_design_patterns_gof_chunk_0637_51b0f331", "text": "5 S e e A b s t r a c t F a c t o r y ( 8 7 ) for another approach t o look-and-feel independence. ptgPROXY 207\nP R O X Y Object Structural\nI n t e n t\nP r o v i d e a surrogate or placeholder for another object to control access to it. Also Known As\nS u r r o g a t e\nM o t i v a t i o n\nO ne r e a s o n f or c o n t r o l l i n g a c c e s s to an objec t is to defer t he full c o st of i ts c r e a t i o n\nand initializatio n until we actuall y n e ed to use it. C o n s i d e r a documen t edito r\nthat c an e m b e d g r a p h i c a l o b j e c t s in a document . S o me graphica l o b j e c t s , l i ke l a r ge\nraste r i m a g e s , can be e x p e n s i v e to c r e a t e . But o p e n i n g a documen t shoul d be fast,\nso we s h o u l d a v o id c r e a t i n g a ll t he e x p e n s i v e o b j e c t s at o n ce w h en t he d o c u m e n t\nis o p e n e d .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 637, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 873}}
{"id": "computer_science_design_patterns_gof_chunk_0638_54f55515", "text": "But o p e n i n g a documen t shoul d be fast,\nso we s h o u l d a v o id c r e a t i n g a ll t he e x p e n s i v e o b j e c t s at o n ce w h en t he d o c u m e n t\nis o p e n e d . T h is i s n 't n e c e s s a r y anyway , becaus e n ot a ll of t h e se o b j e c t s w i ll be\nv i s i b l e in t he documen t at t he same t i m e . T h e se constraint s woul d s u g g e s t creatin g e a ch e x p e n s i v e o b j e c t on demand, w h i c h\nin t h is c a se o c c u r s when an i m a g e b e c o m e s v i s i b l e . But what do we put in the\nd o c u m e n t in p l a ce of t he i m a g e ? A nd h ow c an we h i de t he fact that t he i m a g e is\ncreate d on deman d so that we don't complicat e the editor' s implementation ? T h is\noptimizatio n shouldn' t impac t the r e n d e r i n g and formattin g c o d e, for example. The s o l u t i o n is to use anothe r o b j e c t , an i m a g e p r o x y , that acts as a s t a n d - i n for\nthe real image .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 638, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_design_patterns_gof_chunk_0639_b11dc295", "text": "The s o l u t i o n is to use anothe r o b j e c t , an i m a g e p r o x y , that acts as a s t a n d - i n for\nthe real image . The proxy acts j u st l i ke the imag e and takes care of instantiatin g it\nw h e n it's required. T he i m a g e proxy c r e a t e s t he r e al i m a g e o n ly when t he documen t edito r asks it\nto d i s p l a y i t s e lf by i n v o k i n g its Draw operation . The proxy forward s s u b s e q u e n t\nrequest s d i r e c t l y to the image . It must therefor e keep a r e f e r e n c e to the i m a g e a f t er\ncreatin g i t . L e t 's a s s u m e t h at i m a g e s a re s t o r ed in s e p a r a t e f i l e s. In t h is c a se we c an u se t he\nfile name as the reference to the real object. The proxy also stores its extent, that\n\nptg2 0 8 STRUCTURAL PATTERNS CHAPTER 4\nis, its width and height . The exten t l e ts the proxy r e s p o n d to r e q u e s t s for its s i ze\nf r o m t h e formatter without actually instantiating the image.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 639, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_design_patterns_gof_chunk_0640_f5baedcc", "text": "The exten t l e ts the proxy r e s p o n d to r e q u e s t s for its s i ze\nf r o m t h e formatter without actually instantiating the image. The following class diagram illustrates this example in more detail. The documen t edito r a c c e s s e s e m b e d d e d i m a g e s throug h the interfac e define d by\nthe abstrac t Graphi c c l a s s. ImageProx y is a c l a ss for i m a g e s that are c rea te d on\ndemand . I m a g e P r o x y maintain s the file name as a referenc e to the i m a g e on d i s k. The file name is passe d as an argument to the ImageProx y constructor. ImageProx y a l so s t o r e s the boundin g box of the i m a g e and a referenc e to the\nreal Imag e i n s t a n c e . T h is referenc e won' t be valid until the proxy instantiate s\nt he r e al i m a g e . T he D r aw o p e r a t i o n m a k e s s u re t he i m a g e is i n s t a n t i a t e d befor e\nforwardin g it the request .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 640, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_design_patterns_gof_chunk_0641_04368010", "text": "T he D r aw o p e r a t i o n m a k e s s u re t he i m a g e is i n s t a n t i a t e d befor e\nforwardin g it the request . GetExten t forward s the r e q u e s t to the imag e o n ly if it's\ninstantiated; otherwise ImageProxy returns the extent it stores. Applicability\nProxy is applicabl e wheneve r there is a n e ed for a more versatil e or sophisticate d\nreferenc e to an objec t than a s i m p l e p o i n t e r . H e re are severa l commo n situation s\nin whic h t he Prox y patter n is applicable:\n1. A remot e proxy provide s a l o c al representativ e for an o b j e c t in a differen t\naddres s s p a c e . N E X T S T E P [ A d d 9 4 ] u s es the c l a ss NXProx y for t h is purpose . C o p l i e n [ C o p 9 2 ] c a l ls this kind of proxy an \" A m b a s s a d o r . \"\n2. A virtua l proxy create s e x p e n s i v e object s on demand . The ImageProx y de -\ns c r i b e d in t he Motivatio n is an exampl e of such a proxy. 3.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 641, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_design_patterns_gof_chunk_0642_94760de7", "text": "\"\n2. A virtua l proxy create s e x p e n s i v e object s on demand . The ImageProx y de -\ns c r i b e d in t he Motivatio n is an exampl e of such a proxy. 3. A protectio n proxy c o n t r o l s a c c e s s to the origina l object . P r o t e c t i o n p r o x i e s\nare u s e f u l w h e n o b j e c t s s h o u l d h a v e d i f f e r e n t a c c e s s r i g h t s . F o r example,\n\nptgPROXY 2 0 9\nK e r n e l P r o x i e s in the C h o i c e s operatin g syste m [ C I R M 9 3 ] provid e protecte d\na c c e s s to o p e r a t i n g s y s t e m o b j e c t s . 4. A s m a r t referenc e is a r e p l a c e m e n t for a bare p o i n t e r that perform s a d d i t i o n a l\naction s when an objec t is a c c e s s e d . T y p i c a l u s es include\n• countin g the numbe r of reference s to the r e al o b j e c t so t h at it can be\nf r e ed automaticall y w h en t h e re a re no m o re r e f e r e n c e s ( a l so c a l l ed s m a r t \npointer s [Ede92]).", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 642, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_design_patterns_gof_chunk_0643_386eb5f8", "text": "• loadin g a persisten t objec t into memor y when it's first referenced. • checkin g that the real objec t is l o c k e d befor e it's a c c e s s e d to ensur e that\nno other object can change it. S t r u c t u r e\nP a r t i c i p a n t s\n• Proxy (ImageProxy)\n-maintain s a r e f e r e n c e that l e ts t he p r o xy a c c e s s t he r e al s u b j e c t . P r o xy m ay\nrefer to a S u b j e c t if the RealSubjec t and S u b j e c t interface s are the same. -provide s an interfac e identica l to Subject' s so that a proxy can by substi-\ntuted for the r e al s u b j e c t . -control s a c c e s s to the real subjec t and may be r e s p o n s i b l e for creatin g and\ndeleting it. ptg210 STRUCTURAL PATTERNS CHAPTER 4\n- other r e s p o n s i b i l i t i e s depen d on the k i nd of proxy:\n• remote proxies are r e s p o n s i b l e for en codi n g a reques t and its argument s\nand for s e n d i n g the e n c o d e d reques t to the real subjec t in a differen t\naddres s s p a c e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 643, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_design_patterns_gof_chunk_0644_dc41fa57", "text": "• virtual proxies may c a c he a d d i t i o n a l informatio n a b o u t the r e al s u b j e c t\nso that they can postpon e a c c e s s i n g it. For example , the ImageProx y\nf r om the Motivatio n c a c h e s the real image' s extent. • protection proxies c h e ck that the c a l l er has the a c c e s s permission s re-\nq u i r e d to perfor m a r e q u e s t . • Subjec t (Graphic)\n- define s the commo n interfac e for RealSubjec t and Prox y so that a Proxy\nc a n be used anywhere a RealSubject is expected. • RealSubject ( I m a g e )\n- defines the r e a l object that the p r o x y r e p r e s e n t s . C o l l a b o r a t i o n s\n• P r o xy forward s r e q u e s t s to R e a l S u b j e c t w h en a p p r o p r i a t e , d e p e n d i n g on t he\nk i n d of p r o x y . C o n s e q u e n c e s\nT he Proxy patter n introduce s a l e v el of i n d i r e c t i o n when a c c e s s i n g an object . T he\nadditiona l indirectio n has many u s e s, dependin g on the k i nd of proxy:\n1.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 644, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 997}}
{"id": "computer_science_design_patterns_gof_chunk_0645_f49e65d4", "text": "T he\nadditiona l indirectio n has many u s e s, dependin g on the k i nd of proxy:\n1. A remot e proxy can h i de the f a ct that an objec t r e s i d e s in a differen t addres s\ns p a c e . 2. A virtua l proxy can p e r f o r m optimization s s u ch as creatin g an objec t on\nd e m a n d . 3. Both protectio n proxie s and smar t reference s a l l ow additiona l h o u s e k e e p i n g\ntasks w h en an o b j e c t is a c c e s s e d . T h e r e ' s anothe r optimizatio n that the Proxy patter n can hide f r om the c l i e n t . It's\nc a l l ed copy-on-write , and it's relate d to creatio n on demand . Copyin g a large and\nc o m p l i c a t e d objec t c an be an e x p e n s i v e operation . If t he c o py is never modified ,\nthen there' s no n e ed to incur this cost. By u s i ng a proxy to postpon e the c o p y i n g\np r o c e s s , we e n s u r e that we pay the price of c o p y i n g the objec t o n ly if it's modified. To make copy-on-writ e work , the subjec t must be referenc e counted .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 645, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1008}}
{"id": "computer_science_design_patterns_gof_chunk_0646_dfddf5e0", "text": "To make copy-on-writ e work , the subjec t must be referenc e counted . C o p y i n g the\nproxy w i ll do nothin g more than incremen t t h is referenc e count . O n ly when the\nc l i e nt request s an operatio n that modifie s the subjec t d o es the proxy actuall y c o py\nit. In that c a se the proxy must a l so d e c r e m e n t the subject' s referenc e count . W h en\nthe reference count goes to zero, the subject gets deleted. ptgPROXY 211\nC o p y - o n - w r i t e c a n reduce t h e cost of copying heavyweight subjects significantly. I m p l e m e n t a t i o n\nT he Proxy patter n c an e x p l o i t t he f o l l o w i n g languag e features:\n1. Overloading the member access operator in C++. C++ support s o v e r l o a d i n g\no p e r a t o r - > , t he m e m b e r a c c e s s o p e r a t o r . O v e r l o a d i n g t h is operato r l e ts\ny ou perfor m a d d i t i o n a l work w h e n e v e r an o b j e c t is d e r e f e r e n c e d .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 646, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_design_patterns_gof_chunk_0647_92daa3b5", "text": "O v e r l o a d i n g t h is operato r l e ts\ny ou perfor m a d d i t i o n a l work w h e n e v e r an o b j e c t is d e r e f e r e n c e d . T h is c an\nbe helpfu l f or i m p l e m e n t i n g s o me k i n ds of p r o x y ; t he p r o xy b e h a v e s just l i ke\na p o i n t e r . T he f o l l o w i n g e x a m p l e i l l u s t r a t e s h ow to u se t h is t e c h n i q u e to i m p l e m e n t a\nvirtua l proxy c a l l ed I m a g e P t r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 647, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 450}}
{"id": "computer_science_design_patterns_gof_chunk_0648_4218a705", "text": "T he f o l l o w i n g e x a m p l e i l l u s t r a t e s h ow to u se t h is t e c h n i q u e to i m p l e m e n t a\nvirtua l proxy c a l l ed I m a g e P t r . c l a ss I m a g e; \ne x t e rn I m a g e* L o a d A n l m a g e F i l e ( c o n s t c h a r * ) ;\n// e x t e r n al f u n c t i o n\nc l a ss I m a g e P tr {\npublic:\nI m a g e P t r ( c o n s t c h a r* i m a g e F i l e ) ;\nvirtual \" I m a g e P t r ( ) ;\nv i r t u al I m a g e* o p e r a t o r - > ( ) ;\nvirtual I m a g e& operator*();\np r i v a t e :\nI m a g e* L o a d l m a g e ( ) ;\nprivate:\nI m a ge * _image; \nc o n st c h a r* _imageFile;\n} ;\nI m a g e P t r : : I m a g e P t r ( c o n st c h a r* t h e l m a g e F i l e ) { \n_imageFil e = t h e l m a g e F i l e ;\n_image = 0 ;\n}\nI m a g e* I m a g e P t r : : L o a d l m a g e () {\nif ( _ i m a ge = =0) {\n_image = L o a d A n l m a g e F i l e ( _ i m a g e F i l e ) ;\n} \nr e t u rn _image;\n}\nThe o v e r l o a d e d -> and * o p e r a t o r s use L o a d l m a g e to retur n _ i m a g e to\nc a l l e r s ( l o a d i n g it if n e c e s s a r y ) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 648, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1081}}
{"id": "computer_science_design_patterns_gof_chunk_0649_1bc56e90", "text": "I m a g e* I m a g e P t r : : o p e r a t o r - > () {\nr e t u rn L o a d l m a g e ( ) ;\n}\nI m a g e& I m a g e P t r : : o p e r a t o r * () {\nr e t u r n *LoadImage();\n}\n\nptg212 STRUCTURAL PATTERNS CHAPTER 4\nT h is approac h lets you call I m a g e operation s throug h I m a g e P t r object s\nwithou t g o i ng to the troubl e of makin g the o p e r a t i o n s part of the I m a g e P t r\ninterface:\nImagePtr image = ImagePtr(\"anlmageFileName\") ;\nimage->Draw(Point(50, 100));\n/ / ( i m a g e . o p e r a t o r - > ( ) ) - > D r a w ( P o i n t ( 5 0 , 100))\nNotic e how the i m a g e prox y acts l i ke a pointer , but it's not declare d to be a\npointe r to an I m a g e . That mean s you can't use it exactl y like a real pointe r to\nan I m a g e . Henc e client s m u st treat I m a g e and I m a g e P t r object s differentl y\nin t h is approach. Overloadin g the membe r a c c e s s operato r isn't a g o od solutio n for every kind\nof proxy .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 649, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_design_patterns_gof_chunk_0650_c876e7e0", "text": "Henc e client s m u st treat I m a g e and I m a g e P t r object s differentl y\nin t h is approach. Overloadin g the membe r a c c e s s operato r isn't a g o od solutio n for every kind\nof proxy . S o me proxie s need to know precisel y which operatio n is called , and\noverloadin g the membe r a c c e s s operato r doesn' t work in those cases. Conside r the virtua l prox y example in the Motivation . The imag e s h o u l d\nbe loade d at a specifi c time—namel y when the Draw operatio n is called —\nand not wheneve r the imag e is referenced . Overloadin g the a c c e s s operato r\ndoesn' t a l l ow this distinction . In that c a se we must manuall y implemen t each\nproxy operatio n that f o r w a r d s the reques t to the subject. T h e s e operation s are usuall y very simila r to each other , as the S a m p l e C o de\ndemonstrates .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 650, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 848}}
{"id": "computer_science_design_patterns_gof_chunk_0651_d2daea28", "text": "T h e s e operation s are usuall y very simila r to each other , as the S a m p l e C o de\ndemonstrates . Typicall y all operation s verif y that the reques t is l e g a l , that\nthe origina l objec t e x i s t s , etc., befor e f o r w a r d i n g the reques t to the subject . I t 's tediou s to write t h is c o de again and again . So it's commo n to use a\npreprocesso r to generat e it automatically. 2. Using d o e s N o t U n d e r s t a n d in Smalltalk. Smalltal k provide s a hook that\nyou can use to suppor t a u t o m a t i c f o r w a r d i n g of requests . Smalltal k c a l ls\nd o e s N o t U n d e r s t a n d : a M e s s a g e when a c l i e n t s e n ds a messag e to a\nreceive r that has no correspondin g method . The Prox y c l a ss can redefin e\nd o e s N o t U n d e r s t a n d so that the m e s s a g e is forwarde d to its s u b j e c t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 651, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 864}}
{"id": "computer_science_design_patterns_gof_chunk_0652_a2294c62", "text": "The Prox y c l a ss can redefin e\nd o e s N o t U n d e r s t a n d so that the m e s s a g e is forwarde d to its s u b j e c t . To ensur e that a reques t is f o r w a r d e d to the subjec t and not j u st absorbe d\nby the prox y s i l e n t l y , you can defin e a Prox y c l a ss that doesn' t understan d\nany m e s s a g e s . Smalltal k lets you do this by definin g Proxy as a c l a ss with no\ns u p e r c l a s s . 6\nThe main disadvantag e of d o e s N o t U n d e r s t a n d : is that most Smalltal k\nsystem s have a few s p e c i a l message s that are h a n d l e d d i r e c t l y by the virtua l\nm a c h i n e , and these do not cause the usua l metho d look-up . The o n ly one\nthat's u s u a l l y i m p l e m e n t e d in O b j e c t (and so c an affec t p r o x i e s ) is t he i d e n t i t y\noperatio n = = . If you'r e g o i ng to use d o e s N o t U n d e r s t a n d : to implemen t P r o x y , t h en\nyou must d e s i g n aroun d this problem .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 652, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_design_patterns_gof_chunk_0653_09341bd1", "text": "If you'r e g o i ng to use d o e s N o t U n d e r s t a n d : to implemen t P r o x y , t h en\nyou must d e s i g n aroun d this problem . You can't e x p e c t identit y on prox-\ni es to m e an i d e n t i t y on t h e ir r e al s u b j e c t s . An adde d d i s a d v a n t a g e is that\n6 The implementatio n of distribute d object s in N E X T S T E P [Add94 ] (specifically , the class NXProxy ) u s es\nt h i s technique. T h e implementation redefines f o r w a r d , the equivalent hook in NEXTSTEP. ptgPROXY 2 1 3\nd o e s N o t U n d e r s t a n d : was develope d for error handling , not for buildin g\np r o x i e s , and so it's generall y not very f a s t . 3.Proxy doesn't always have to know the type of real subject. If a Prox y c l a ss can\ndeal with its subjec t s o l e ly throug h an abstrac t interface , then there' s no\nneed to make a Prox y c l a ss for e a ch RealSubjec t c l a s s ; the prox y can deal\nwith a ll R e a l S u b j e c t c l a s s e s u n i f o r m l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 653, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_design_patterns_gof_chunk_0654_60326d5c", "text": "B ut if P r o x i e s a re g o i ng to instantiat e\nRealSubject s (such as in a virtua l proxy) , then they have to know the c o n c r e t e\nc l a s s . A n o t h e r i m p l e m e n t a t i o n i s s ue i n v o l v e s h ow to refer to t he s u b j e c t befor e it's\ninstantiated . S o me proxie s have to refer to their subjec t whethe r it's on disk or\nin memory . That mean s they must use some f o rm of addres s space-independen t \nobject identifiers. W e u s e d a file name for this purpose in the Motivation. S a m p l e Code\nThe followin g c o de implement s two kinds of proxy : the virtua l prox y d e s c r i b e d in\nthe M o t i v a t i o n s e c t i o n , and a proxy i m p l e m e n t e d with d o e s N o t U n d e r s t a n d : 7\n1. A virtual proxy.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 654, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 768}}
{"id": "computer_science_design_patterns_gof_chunk_0655_faba6a66", "text": "A virtual proxy. The G r a p h i c c l a ss define s the interfac e for graphica l objects:\nc l a ss G r a p h ic {\npublic:\nvirtual \" G r a p h i c ( ) ;\nvirtual void D r a w ( c o n s t Point& at) = 0;\nv i r t u al void H a n d l e M o u s e ( E v e n t & e v e n t) = 0 ;\nvirtual c o n st Point& GetExtent( ) = 0;\nvirtual void Load(istream & from) = 0;\nvirtual void S a v e ( o s t r e a m & to) = 0;\nprotected:\nGraphic() ;\n} ;\nThe I m a g e c l a ss implement s the G r a p h i c interfac e to displa y imag e files. I m a g e override s H a n d l e M o u s e to let users r e s i z e the imag e interactively. c l a ss I m a ge : public Graphic {\np u b l i c :\nImage(cons t c h a r* file); // loads image f r om a file\nvirtual ~Image();\nvirtual void D r a w ( c o n s t Point& at);\nvirtual void H a n d l e M o u s e ( E v e n t & event);\nvirtual const P o i n t s GetExtent();\n7Iterator (257) describes another kind of proxy on page 266.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 655, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_design_patterns_gof_chunk_0656_0679efcf", "text": "ptg2 1 4 STRUCTURAL P A T T E R N S C H A P T E R 4\nv i r t u al v o id L o a d ( i s t r e a m & f r o m );\nv i r t u al void S a v e ( o s t r e a m & t o ) ;\nprivate:\n// . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 656, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 178}}
{"id": "computer_science_design_patterns_gof_chunk_0657_70553530", "text": "} ;\nI m a g e P r o x y has the s a me interfac e as Image:\nc l a ss I m a g e P r o x y : public G r a p h ic {\npublic:\nI m a g e P r o x y ( c o n s t c h a r* imageFile) ;\nvirtual ~ I m a g e P r o x y ( ) ;\nvirtual void D r a w ( c o n s t P o i n t& at);\nv i r t u al v o id H a n d l e M o u s e ( E v e n t & e v e n t ) ;\nv i r t u al c o n st P o i n t& GetExtent();\nvirtual void L o a d ( i s t r e a m & from);\nv i r t u al void S a v e ( o s t r e a m & to);\nprotected:\nI m a g e* G e t l m a g e ( ) ;\nprivate:\nI m a g e* _image;\nP o i nt _extent;\nc h a r* _fileName;\n} ;\nT he c o n s t r u c t o r s a v es a l o c al c o py of t he name of t he file that s t o r es t he\ni m a g e , and it i n i t i a l i z e s - e x t e n t and -image:\nI m a g e P r o x y : : I m a g e P r o x y ( c o n st c h a r* f i l e N a m e) { \n_fileNam e = s t r d u p ( f i l e N a m e ) ; \n_extent = P o i n t : : Z e r o ; // d o n 't k n ow e x t e nt yet\n_image = 0 ;\n}\nI m a g e* I m a g e P r o x y : : G e t l m a g e ( ) {\nif ( _ i m a ge = = 0) {\n_image - new Image(_fileName) ;\n}\nr e t u rn _image;\n}\nT he i m p l e m e n t a t i o n of G e t E x t e n t return s t he c a c h e d e x t e n t if p o s s i b l e ;\no t h e r w i s e t he i m a g e is l o a d e d from t he f i l e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 657, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1284}}
{"id": "computer_science_design_patterns_gof_chunk_0658_23c995a0", "text": "D r aw l o a ds t he i m a g e , a nd\nH a n d l e M o u s e forward s the e v e nt to the r e al i m a g e . c o n st P o i n t& I m a g e P r o x y : : G e t E x t e n t () {\nif ( _ e x t e nt == P o i n t : : Z e r o ) {\n_extent = Getlmage()->GetExtent() ;\n}\nr e t u rn _extent;\n}\n\nptgPROXY 215\nvoid ImageProxy::Dra w ( c o n st Point& at) {\nGetImage()->Draw(at) ;\n}\nvoid ImageProxy::HandleMous e ( E v e n t& event) {\nGetlmage()->HandleMouse(event) ;\n}\nT he Save o p e r a t i o n s a v es t he c a c h e d i m a g e e x t e n t a nd t he i m a g e f i le n a me\nto a s t r e a m . L o ad r e t r i e v e s t h is i n f o r m a t i o n a nd initialize s t he c o r r e s p o n d i n g\nm e m b e r s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 658, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 703}}
{"id": "computer_science_design_patterns_gof_chunk_0659_4f4ca307", "text": "L o ad r e t r i e v e s t h is i n f o r m a t i o n a nd initialize s t he c o r r e s p o n d i n g\nm e m b e r s . void ImageProxy::Sav e ( o s t r e a m & to) {\nto « _extent « _fileName;\n}\nvoid ImageProxy::Loa d ( i s t r e a m & from) {\nf r om » _extent » _fileName;\n}\nF i n a l l y , s u p p o s e we h a ve a c l a ss T e x t D o c u m e n t that can c o n t a i n G r a p h i c\no b j e c t s :\nclass TextDocumen t {\npublic:\nTextDocument();\nvoid Insert(Graphic*) ;\n// . . . } ;\nW e can insert an ImageProxy into a text document l i k e this:\nTextDocument * text = new TextDocument ;\n// . - . text->Insert(new ImageProxy(\"anlmageFileName\"));\n2. Proxies that use d o e s N o t U n d e r s t a n d . You can m a ke g e n e r i c p r o x i e s in\nS m a l l t a l k by d e f i n i n g c l a s s e s w h o s e s u p e r c l a s s is n i l8 a nd d e f i n i n g t he\nd o e s N o t U n d e r s t a n d : m e t h o d to h a n d l e m e s s a g e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 659, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_design_patterns_gof_chunk_0660_4c3dff56", "text": "T he followin g m e t h o d a s s u m e s t he p r o x y h as a r e al Sub j e ct m e t h o d t h at\nr e t u r n s i ts r e al s u b j e c t . In t he c a se of I m a g e P r o x y , t h is m e t h o d w o u l d c h e ck\nto s ee if t he t he I m a g e h ad b e en c r e a t e d , c r e a t e it if n e c e s s a r y , a nd f i n a l l y\nr e t u r n it. It u s es p e r f o r m : w i t h A r g u m e n t s : to p e r f o r m the m e s s a g e b e i ng\nt r a p p e d on the real subject. doesNotUnderstand : aMessage \n~ self realSubjec t \nperform: aMessage selector\nwithArguments: aMessage arguments\n8 Almos t a ll c l a s s e s ultimatel y h a ve O b j e c t as their s u p e r c l a s s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 660, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 688}}
{"id": "computer_science_design_patterns_gof_chunk_0661_207fd9b8", "text": "H e n c e this is t he s a me as s a y i n g \" d e f i n i n g\na class that doesn't have Object as its superclass.\"\n\nptg216 STRUCTURAL PATTERNS CHAPTER 4\nThe argumen t to d o e s N o t U n d e r s t a n d : is an i n s t a n c e of M e s s a g e that\nrepresent s t he m e s s a g e n ot understoo d by t he p r o x y . So t he proxy r e s p o n d s\nto all m e s s a g e s by makin g s u re that the r e al subjec t e x i s ts befor e forwardin g\nthe m e s s a g e to it. One of the advantage s of d o e s N o t U n d e r s t a n d : is it can perfor m arbitrar y\np r o c e s s i n g .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 661, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 584}}
{"id": "computer_science_design_patterns_gof_chunk_0662_cf6755b9", "text": "One of the advantage s of d o e s N o t U n d e r s t a n d : is it can perfor m arbitrar y\np r o c e s s i n g . For e x a m p l e , we c o u ld produc e a p r o t e c t i o n proxy by s p e c i f y i n g\na set l e g a l M e s s a g e s of m e s s a g e s to a c c e p t and then g i v i n g the proxy the\nf o l l o w i n g m e t h o d :\nd o e s N o t U n d e r s t a n d : a M e s s a ge \n( l e g a l M e s s a g e s i n c l u d e s: a M e s s a ge selector ) \ni f T r u e: [ s e lf r e a l S u b j e c t\np e r f o r m: a M e s s a ge s e l e c t or\nw i t h A r g u m e n t s : a M e s s a ge a r g u m e n t s ]\nifFalse: [ s e lf e r r o r: ' I l l e g al o p e r a t o r ' ]\nT h is metho d c h e c k s to s ee that a m e s s a g e is l e g al befor e forwardin g it to\nt he r e al s u b j e c t . If it i s n 't l e g a l, t h en it w i ll s e nd e r r o r : to t he p r o x y , w h i ch\nw i ll resul t in an i n f i n i t e l o op of error s u n l e s s the proxy define s e r r o r : .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 662, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_design_patterns_gof_chunk_0663_97729660", "text": "If it i s n 't l e g a l, t h en it w i ll s e nd e r r o r : to t he p r o x y , w h i ch\nw i ll resul t in an i n f i n i t e l o op of error s u n l e s s the proxy define s e r r o r : . C o n s e q u e n t l y , the d e f i n i t i o n of e r r o r : s h o u l d be c o p i e d from c l a ss O b j e c t\na l o n g w i t h any methods it uses. Known U s e s\nThe virtua l proxy exampl e in the Motivatio n s e c t i o n is f r om t he ET++ text buildin g\nb l o ck c l a s s e s . N E X T S T E P [ A d d 9 4 ] u s es p r o x i e s ( i n s t a n c e s of c l a ss N X P r o x y ) as l o c al r e p r e s e n -\nt a t i v e s for o b j e c t s that may be distributed . A s e r v e r c r e a t e s p r o x i e s for remot e\no b j e c t s when c l i e n t s r e q u e s t t h e m . On r e c e i v i n g a m e s s a g e , t he prox y e n c o d e s it\na l o ng with its argument s and then forward s the e n c o d e d m e s s a g e to the remot e\ns u b j e c t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 663, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_design_patterns_gof_chunk_0664_bb3eeda2", "text": "On r e c e i v i n g a m e s s a g e , t he prox y e n c o d e s it\na l o ng with its argument s and then forward s the e n c o d e d m e s s a g e to the remot e\ns u b j e c t . S i m i l a r l y , t he s u b j e c t e n c o d e s a ny return r e s u l t s a nd s e n ds t h em b a ck to\nthe NXProx y object. M c C u l l o u g h [ M c C 8 7 ] d i s c u s s e s using p r o x i e s in S m a l l t a l k to a c c e s s remot e o b -\njects. P a s c o e [ P a s 8 6 ] d e s c r i b e s h ow to p r o v i d e side-effect s on metho d c a l ls a nd\na c c e s s c o n t r o l w i t h \"Encapsulators.\"\nRelated Patterns\nAdapte r ( 1 3 9 ) : An adapte r p r o v i d e s a differen t interfac e to the o b j e c t it adapts . In contrast , a proxy p r o v i d e s the s a me interfac e as its s u b j e c t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 664, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 798}}
{"id": "computer_science_design_patterns_gof_chunk_0665_b2c1fa73", "text": "In contrast , a proxy p r o v i d e s the s a me interfac e as its s u b j e c t . H o w e v e r , a proxy\nu s ed for a c c e s s protectio n m i g h t refus e to perfor m an operatio n that the subjec t\nw i l l p e r f o r m , s o i t s interface m a y b e effectively a subset of the subject's. Decorator (175): Although decorators can have similar implementations as prox -\ni e s , d e c o r a t o r s h a v e a different p u r p o s e . A decorator adds one or more responsi -\nb i l i t i e s to an object, whereas a proxy controls access to an object. ptgPROXY 2 1 7\nP r o x i e s vary in the d e g r e e to w h i c h they are implemente d l i ke a d e c o r a t o r . A\nprotectio n proxy migh t be i m p l e m e n t e d e x a c t l y l i ke a decorator . On t he o t h er\nhand , a remot e proxy w i ll not contai n a d i r e c t referenc e to its r e al subjec t but o n ly\nan i n d i r e c t r e f e r e n c e , s u ch as \" h o st ID a nd l o c al addres s on h o s t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 665, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_design_patterns_gof_chunk_0666_da07ae8d", "text": "\" A virtua l proxy\nw i ll start off with an i n d i r e c t referenc e s u ch as a file name but will eventuall y\no b t a i n and use a direct reference. ptg\nThis page intentionally left blank \n\nptgDISCUSSION O F STRUCTURAL P A T T E R N S 219\nD i s c u s s i o n of Structural Patterns\nY ou m ay have n o t i c e d s i m i l a r i t i e s b et we e n t he structura l patterns , e s p e c i a l l y in t h e ir\nparticipant s a nd collaborations . T h is is so probabl y b e c a u s e structura l pattern s r e ly on\nt he same s m a ll s et of languag e m e c h a n i s m s f or structurin g c o de a nd o b j e c t s : s i n g le\nand multipl e i n h e r i t a n c e for c l a s s - b a s e d patterns , and o b j e c t c o m p o s i t i o n for o b j e c t\npatterns . But the s i m i l a r i t i e s b e l ie the differen t intent s amon g t h e se patterns .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 666, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 860}}
{"id": "computer_science_design_patterns_gof_chunk_0667_c42fef28", "text": "But the s i m i l a r i t i e s b e l ie the differen t intent s amon g t h e se patterns . In t h is\ns e c t i o n we c o m p a r e a nd c o n t r a s t g r o u p s of structura l p a t t e r n s to g i ve y ou a f e el f or\ntheir relativ e merits. Adapte r v e r s u s Bridge\nT he Adapte r ( 1 3 9) a nd B r i d g e ( 1 5 1) pattern s have s o me c o m m o n attributes . B o th p r o -\nmote f l e x i b i l i t y by providin g a l e v el of i n d i r e c t i o n to anothe r o b j e c t . B o th i n v o l v e\nforwardin g r e q u e s t s to t h is o b j e c t from an interfac e o t h er than its o w n . T he k ey differenc e b e t w e e n t h e se pattern s l i es in t h e ir i n t e n t s . Adapte r f o c u s e s on\nr e s o l v i n g i n c o m p a t i b i l i t i e s betwee n t wo e x i s t i n g interfaces . It d o e s n ' t focus on h ow\nt h o se interface s a re i m p l e m e n t e d , n or d o es it c o n s i d e r h ow they m i g h t e v o l v e i n d e -\np e n d e n t l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 667, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_design_patterns_gof_chunk_0668_a3008e88", "text": "It d o e s n ' t focus on h ow\nt h o se interface s a re i m p l e m e n t e d , n or d o es it c o n s i d e r h ow they m i g h t e v o l v e i n d e -\np e n d e n t l y . I t 's a w ay of makin g t wo i n d e p e n d e n t l y d e s i g n e d c l a s s e s work t o g e t h e r\nwithou t r e i m p l e m e n t i n g o ne or t he o t h e r . B r i d g e , on t he o t h er hand , b r i d g e s an a b -\ns tr ac ti o n and its ( p o t e n t i a l l y numerous ) i m p l e m e n t a t i o n s . It p r o v i d e s a s t a b le interfac e\nto c l i e n t s e v en as it l e ts y ou vary t he c l a s s e s that i m p l e m e n t i t. It a l so a c c o m m o d a t e s\nn ew implementation s as t he s y s t e m e v o l v e s . As a resul t of t h e se differences , Adapte r and B r i d g e are often u s ed at differen t p o i n t s\nin the softwar e l i f e c y c l e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 668, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 866}}
{"id": "computer_science_design_patterns_gof_chunk_0669_2cfea001", "text": "As a resul t of t h e se differences , Adapte r and B r i d g e are often u s ed at differen t p o i n t s\nin the softwar e l i f e c y c l e . An adapte r often b e c o m e s n e c e s s a r y when you d i s c o v e r that\nt wo incompatibl e c l a s s e s s h o u l d work t o g e t h e r , g e n e r a l l y to a v o id r e p l i c a t i n g c o d e. T he\nc o u p l i n g is u n f o r e s e e n . In contrast , t he u s er of a bridg e understand s up-fron t that an\nabstractio n mus t have s e v e r a l i m p l e m e n t a t i o n s , a nd both m ay e v o l v e i n d e p e n d e n t l y . T he A d a p t e r patter n m a k e s t h i n g s work after t h e y ' r e d e s i g n e d ; B r i d g e m a k e s t h em\nwork before they are. T h at d o e s n ' t mean Adapte r is s o m e h o w inferio r to B r i d g e ; e a ch\npatter n merel y a d d r e s s e s a differen t p r o b l e m . Y ou m i g h t think of a facad e ( s ee F a c a d e ( 1 8 5 ) ) as an adapte r to a s et of o t h er o b j e c t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 669, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_design_patterns_gof_chunk_0670_c57cd729", "text": "Y ou m i g h t think of a facad e ( s ee F a c a d e ( 1 8 5 ) ) as an adapte r to a s et of o t h er o b j e c t s . B ut\nthat interpretatio n o v e r l o o k s the fact that a facad e d e f i n e s a new interface , wherea s an\nadapte r r e u s e s an old interface . Remembe r that an adapte r make s two existing interface s\nwork togethe r as o p p o s e d to d e f i n i n g an entirel y n ew o n e . C o m p o s i t e v e r s u s D e c o r a t o r v e r s u s P r o x y\nC o m p o s i t e ( 1 6 3) a nd Decorato r ( 1 7 5) have s i m i l a r structur e d i a g r a m s , r e f l e c t i n g t he f a ct\nthat both r e ly on recursiv e c o m p o s i t i o n to o r g a n i z e an o p e n - e n d e d numbe r of o b j e c t s . T h i s c o m m o n a l i t y m i g h t t e m p t y o u t o t h i n k o f a d e c o r a t o r o b j e c t a s a d e g e n e r a t e\n\nptg220 STRUCTURAL PATTERNS CHAPTER 4\nc o m p o s i t e , but that m i s s e s the point of the Decorato r pattern .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 670, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_design_patterns_gof_chunk_0671_16b9ee93", "text": "The similarit y e n ds at\nr e c u r s i v e c o m p o s i t i o n , again becaus e of differin g intents. Decorato r is d e s i g n e d to let you add r e s p o n s i b i l i t i e s to o b j e c t s withou t s u b c l a s s i n g . It\navoid s the e x p l o s i o n of s u b c l a s s e s t h at can a r i se from tryin g to c o v e r e v e ry combinatio n\nof r e s p o n s i b i l i t i e s s t a t i c a l l y . Composit e has a differen t intent . It focuse s on structurin g\nc l a s s e s so t h at many relate d o b j e c t s can be treate d uniformly , and multipl e object s can\nbe treate d as o n e. Its focus is not on embellishmen t but on representation. T h e s e intent s are distinc t but complementary . Consequently , the C o m p o s i t e and D e c o -\nrator pattern s are o f t en u s ed in c o n c e r t . Both l e ad to the kind of d e s i g n in whic h you can \nbuild application s just by pluggin g object s togethe r withou t definin g any new c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 671, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_design_patterns_gof_chunk_0672_c25576f5", "text": "Both l e ad to the kind of d e s i g n in whic h you can \nbuild application s just by pluggin g object s togethe r withou t definin g any new c l a s s e s . T h e re w i ll be an abstrac t c l a ss with some s u b c l a s s e s that are c o m p o s i t e s , s o me that are\ndecorators , and s o me that implemen t the f u n d a m e n t a l buildin g b l o c k s of the system . In this c a s e, both c o m p o s i t e s and decorator s w i ll have a commo n interface . F r om the\npoint of v i ew of the Decorato r pattern , a composit e is a ConcreteComponent . F r om the \npoint of v i ew of the C o m p o s i t e pattern , a decorato r is a Leaf. Of c o u r s e , they don't have\nto be used togethe r and, as we have s e e n, their intent s are quite different. Anothe r patter n with a structur e s i m i l a r to Decorator' s is P r o x y ( 2 0 7 ) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 672, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 857}}
{"id": "computer_science_design_patterns_gof_chunk_0673_208cc507", "text": "Anothe r patter n with a structur e s i m i l a r to Decorator' s is P r o x y ( 2 0 7 ) . Both pattern s\nd e s c r i b e how to provid e a l e v el of indirectio n to an o b j e c t , and the implementation s of\nboth the prox y and decorato r o b j e c t keep a referenc e to anothe r o b j e c t to whic h they\nforwar d r e q u e s t s . O n ce a g a i n , however , they are intende d for differen t purposes. L i ke Decorator , the P r o x y patter n c o m p o s e s an objec t and p r o v i d e s an identica l in-\nterfac e to c l i e n t s . U n l i k e Decorator , the P r o x y patter n is not c o n c e r n e d with attachin g\nor detachin g propertie s dynamically , and i t 's not d e s i g n e d for r e c u r s i v e c o m p o s i t i o n . Its inten t is to provid e a stand-i n for a subjec t when it's inconvenien t or undesirabl e\nto a c c e s s the subjec t directl y because , for e x a m p l e , it l i v es on a remot e m a c h i n e , has\nrestricte d a c c e s s , or is persistent.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 673, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_design_patterns_gof_chunk_0674_2f5130e2", "text": "In the P r o x y pattern , the subjec t define s the key functionality , and the p r o xy p r o v i d e s (or\nrefuses ) a c c e s s to it. In Decorator , the componen t p r o v i d e s o n ly part of the functionality ,\nand one or more decorator s furnis h the r e s t. Decorato r a d d r e s s e s the situatio n wher e an\nobject' s total functionalit y can't be determine d at c o m p i l e t i m e, at l e a st not c o n v e n i e n t l y . That o p e n - e n d e d n e s s make s r e c u r s i v e compositio n an e s s e n t i a l part of D e c o r a t o r . That\nisn't the c a se in P r o x y , becaus e P r o x y focuse s on one relationship—betwee n the proxy\nand its subject—an d that r e l a t i o n s h i p can be e x p r e s s e d s t a t i c a l l y . T h e s e difference s are significan t becaus e they captur e s o l u t i o n s to s p e c i f i c r e c u r r i n g\np r o b l e m s in object-oriente d d e s i g n . But that doesn' t mean these pattern s can't be c o m -\nbined .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 674, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_design_patterns_gof_chunk_0675_1429015f", "text": "But that doesn' t mean these pattern s can't be c o m -\nbined . You migh t e n v i s i o n a proxy-decorato r that adds functionalit y to a p r o x y , or\na decorator-prox y that e m b e l l i s h e s a remot e object . Althoug h s u ch hybrid s might be\nusefu l (we don't have real example s handy) , they are d i v i s i b l e into pattern s that are\nuseful. ptgC h a p t e r 5\nB e h a v i o r a l P a t t e r n s\nBehaviora l pattern s are concerne d with algorithm s and the assignmen t of r e s p o n s i b i l i -\nties betwee n objects . Behaviora l pattern s describ e not j u st pattern s of object s or c l a s s e s\nbut also the pattern s of communicatio n betwee n them . T h e se pattern s characteriz e\ncomple x contro l flow that's d i f f i c u l t to follow at run-time . T h ey shift your f o c us a w ay\nf r om flow of contro l to let you concentrat e j u st on the way object s are interconnected.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 675, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 915}}
{"id": "computer_science_design_patterns_gof_chunk_0676_79e0d34f", "text": "T h ey shift your f o c us a w ay\nf r om flow of contro l to let you concentrat e j u st on the way object s are interconnected. Behaviora l c l a ss pattern s use inheritanc e to distribut e behavio r betwee n c l a s s e s . T h is\nchapte r include s two such patterns . Templat e Metho d ( 3 2 5) is the simple r and more\ncommo n of the two. A templat e metho d is an abstrac t definitio n of an algorithm . It\ndefine s the algorith m step by step. Each step invoke s eithe r an abstrac t operatio n or\na primitiv e operation . A subclas s fleshe s out the algorith m by definin g the abstrac t\noperations . The other behaviora l c l a ss p a t t e r n is Interprete r ( 2 4 3 ) , whic h represent s\na gramma r as a c l a ss hierarch y and implement s an interprete r as an operatio n on\ni n s t a n c e s of t h e se c l a s s e s . Behaviora l objec t p a t t e r n s use objec t compositio n rathe r than inheritance .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 676, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_design_patterns_gof_chunk_0677_e3899b30", "text": "Behaviora l objec t p a t t e r n s use objec t compositio n rathe r than inheritance . S o me de-\ns c r i be how a group of peer object s cooperat e to p e r f o r m a task that no s i n g le objec t\ncan carry out by itself . An importan t issue here is how peer object s know abou t each\no t h e r . P e e rs could maintai n explici t reference s to each other , but that woul d i n c r e a s e\ntheir coupling . In the extreme , every objec t woul d know abou t every other . The Me-\ndiato r ( 2 7 3) p a t t e r n avoid s this by introducin g a mediato r objec t betwee n peers . The\nmediato r provide s the indirectio n neede d for l o o se coupling. Chain of Responsibilit y ( 2 2 3) provide s e v en l o o s e r coupling . It lets you s e nd request s to\nan objec t implicitl y throug h a chain of candidat e objects . Any candidat e may f u l f i l l the\nreques t dependin g on run-tim e conditions .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 677, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_design_patterns_gof_chunk_0678_48fa1c05", "text": "It lets you s e nd request s to\nan objec t implicitl y throug h a chain of candidat e objects . Any candidat e may f u l f i l l the\nreques t dependin g on run-tim e conditions . The numbe r of candidate s is o p e n - e n d e d ,\nand you can s e l e c t whic h candidate s participat e in the chain at run-time. The Observe r ( 2 9 3) p a t t e r n define s and maintain s a dependenc y betwee n objects . The\nclassi c exampl e of Observe r is in Smalltal k Model/View/Controller , wher e all view s\nof the model are notified whenever the model's state changes. 2 2 1\n\nptg222 BEHAVIORAL PATTERNS CHAPTER 5\nO t h e r b e h a v i o r a l o b j e c t pattern s a re c o n c e r n e d with e n c a p s u l a t i n g b e h a v i o r in an o b j e c t\na nd d e l e g a t i n g r e q u e s t s to i t. T he S t r a t e g y ( 3 1 5) patter n e n c a p s u l a t e s an a l g o r i t h m in\nan o b j e c t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 678, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_design_patterns_gof_chunk_0679_090a695f", "text": "T he S t r a t e g y ( 3 1 5) patter n e n c a p s u l a t e s an a l g o r i t h m in\nan o b j e c t . S t r a t e g y m a k e s it e a sy to s p e c i f y a nd c h a n g e t he a l g o r i t h m an o b j e c t u s e s. T he C o m m a n d ( 2 3 3) patter n e n c a p s u l a t e s a r e q u e s t in an o b j e c t so that it c an be p a s s e d\nas a parameter , s t o r ed on a h i s t o r y l i s t, or manipulate d in o t h er ways . T he S t a te ( 3 0 5)\npatter n e n c a p s u l a t e s t he s t a t es of an o b j e c t so that t he o b j e c t c an c h a n g e i ts b e h a v i o r\nw h en i ts state o b j e c t c h a n g e s . V i s i t o r ( 3 3 1) e n c a p s u l a t e s b e h a v i o r that w o u l d o t h e r w i s e\nbe distribute d a c r o s s c l a s s e s , a nd Iterato r ( 2 5 7) abstract s t he w ay y ou a c c e s s a nd t r a v e r s e\no b j e c t s in an aggregate.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 679, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 890}}
{"id": "computer_science_design_patterns_gof_chunk_0680_acdb2632", "text": "ptgCHAIN O F RESPONSIBILITY 223\nCHAIN O F R E S P O N S I B I L I T Y object Behavioral\nIntent\nA v o i d c o u p l i n g the sende r of a reques t to its r e c e i v e r by g i v i n g more than one\no b j e c t a chanc e to handl e the request . Chai n the r e c e i v i n g object s and pass the\nrequest along the chain until an object handles it. Motivation\nConside r a context-sensitiv e help facilit y for a graphica l user interface . The user\ncan obtai n help informatio n on any part of the interfac e just by c l i c k i n g on it. The help that's provide d depend s on the part of the interfac e that's s e l e c t e d and\nits context ; for e x a m p l e , a b u t t o n widge t in a d i a l o g box migh t have differen t\nhelp informatio n than a s i m i l a r b u t t o n in the main window .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 680, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 803}}
{"id": "computer_science_design_patterns_gof_chunk_0681_e9300360", "text": "If no specifi c help\ninformatio n exist s for that part of the interface , then the help syste m s h o u l d\ndispla y a more genera l help messag e abou t the immediat e context—th e d i a l o g\nbox as a whole , for example. Henc e it's natura l to organiz e help informatio n accordin g to its generality—fro m\nthe most s p e c i f i c to the most g e n e r a l . Furthermore , it's c l e ar t h at a help r e q u e s t\nis handle d by one of s e v e r a l user interfac e o b j e c t s ; whic h one depend s on the\ncontex t and how s p e c i f i c the availabl e help is. The proble m here is that the o b j e c t that ultimatel y provides the help isn't know n\ne x p l i c i t l y to the objec t ( e . g ., the button ) t h at initiates the help request . Wha t we\nn e ed is a way to d e c o u p l e the butto n that initiate s the help reques t from the o b j e c t s\nthat migh t provid e help information . The Chai n of R e s p o n s i b i l i t y patter n define s\nhow that happens.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 681, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_design_patterns_gof_chunk_0682_8b8aca45", "text": "The Chai n of R e s p o n s i b i l i t y patter n define s\nhow that happens. The i d ea of this patter n is to decoupl e sender s and r e c e i v e r s by g i v i n g multipl e\nobject s a chanc e to handl e a request . The reques t gets p a s s e d along a chain of\nobjects until one of them handles it. specific general\n\nptg2 2 4 BEHAVIORAL PATTERNS CHAPTER 5\nThe f i r st objec t in the c h a in r e c e i v e s the r e q u e s t and eithe r handle s it or forward s\nit to t he n e xt c a n d i d a t e on t he c h a i n , w h i ch d o es l i k e w i s e . T he o b j e c t that made\nthe reques t has no explici t knowledg e of who will handl e it—w e say the reques t\nhas an implici t receiver. Let's assum e the user clicks for help on a butto n widge t marke d \" P r i n t . \" The\nbutto n is c o n t a i n e d in an i n s t a n c e of P r i n t D i a l o g , w h i ch k n o w s t he a p p l i c a t i o n\no b j e c t it b e l o n g s to ( s ee precedin g objec t diagram) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 682, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_design_patterns_gof_chunk_0683_cb8d5f6a", "text": "\" The\nbutto n is c o n t a i n e d in an i n s t a n c e of P r i n t D i a l o g , w h i ch k n o w s t he a p p l i c a t i o n\no b j e c t it b e l o n g s to ( s ee precedin g objec t diagram) . The followin g interactio n\ndiagram illustrates how the help request gets forwarded along the chain:\nIn this c a s e, neithe r aPrintButto n nor aPrintDialog handle s the r e q u e s t ; it stops at\nanApplication , whic h can handl e it or i g n o r e it. The c l i e n t that issue d the reques t\nhas no d i r e c t referenc e to the objec t that ultimatel y fulfill s it. To forwar d the reques t a l o ng the c h a i n , and to ensur e r e c e i v e r s remai n i m p l i c i t ,\neach o b j e c t on the c h a in s h a r e s a commo n interfac e for handlin g r e q u e s t s and for\na c c e s s i n g i ts s u c c e s s o r on t he c h a i n . F or e x a m p l e , t he help s y s t e m migh t defin e\na HelpHandle r c l a ss with a correspondin g HandleHel p operation .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 683, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_design_patterns_gof_chunk_0684_6a0b7a4d", "text": "F or e x a m p l e , t he help s y s t e m migh t defin e\na HelpHandle r c l a ss with a correspondin g HandleHel p operation . HelpHandle r\ncan be the paren t c l a ss for candidat e objec t c l a s s e s , or it can be define d as a mixin\nc l a s s. T h en c l a s s e s that want to handl e help r e q u e s t s can make HelpHandle r a\nparent:\n\nptgCHAIN OF RESPONSIBILITY 225\nThe Button , D i a l o g , and Applicatio n c l a s s e s use HelpHandle r operation s to handl e\nhelp r e q u e s t s . HelpHandler' s HandleHel p operatio n forward s the reques t to the\ns u c c e s s o r by default . S u b c l a s s e s can overrid e t h is operatio n to provid e help unde r\nthe right c i r c u m s t a n c e s ; otherwis e they can use the defaul t implementatio n to\nf o r w a r d the request. Applicability\nU se C h a in of Responsibilit y when\n• m o re than o ne o b j e c t m ay h a n d l e a r e q u e s t , a nd t he h a n d l e r i s n 't k n o w n a\npriori.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 684, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_design_patterns_gof_chunk_0685_b451b943", "text": "Applicability\nU se C h a in of Responsibilit y when\n• m o re than o ne o b j e c t m ay h a n d l e a r e q u e s t , a nd t he h a n d l e r i s n 't k n o w n a\npriori. The handle r s h o u l d be ascertaine d automatically. • you want to i s s ue a reques t to one of s e v e r a l o b j e c t s withou t specifyin g the\nr e c e i v e r explicitly. • the set of objects that can handle a request should be specified dynamically. S t r u c t u r e\nA typical object structure might look like this:\nParticipants\n• Handler ( H e l p H a n d l e r )\n- defines an i n t e r f a c e for h a n d l i n g r e q u e s t s . - (optional) implements the s u c c e s s o r l i n k . ptg226 BEHAVIORAL PATTERNS CHAPTER 5\n• ConcreteHandle r (PrintButton , PrintDialog)\n-handle s request s it is responsibl e for. -c an a c c e s s i ts s u c c e s s o r . -if the ConcreteHandle r can handl e the r e q u e s t , it d o es so; otherwis e it\nforwards the request to its successor.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 685, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_design_patterns_gof_chunk_0686_d775e4d1", "text": "-c an a c c e s s i ts s u c c e s s o r . -if the ConcreteHandle r can handl e the r e q u e s t , it d o es so; otherwis e it\nforwards the request to its successor. • C l i e n t\n- initiates the request to a ConcreteHandler object on the chain. C o l l a b o r a t i o n s\n• Whe n a c l i e n t i s s u e s a request , the reques t propagate s a l o ng the c h a in until a\nConcreteHandler object takes responsibility for handling it. C o n s e q u e n c e s\nC h a i n of Responsibilit y has the followin g benefit s and l i a b i l i t i e s :\n1. Reduced coupling. The patter n frees an o b j e c t f r om knowin g whic h other\no b j e c t handle s a request . An objec t o n ly has to know that a reques t w i ll be\nhandle d \"appropriately. \" B o th the r e c e i v e r and the s e n d e r have no e x p l i c i t\nknowledg e of e a ch o t h e r , and an o b j e c t in the c h a in doesn' t have to know\nabou t the c h a i n ' s structure.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 686, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 943}}
{"id": "computer_science_design_patterns_gof_chunk_0687_a7eb5cec", "text": "\" B o th the r e c e i v e r and the s e n d e r have no e x p l i c i t\nknowledg e of e a ch o t h e r , and an o b j e c t in the c h a in doesn' t have to know\nabou t the c h a i n ' s structure. As a result , C h a in of Responsibilit y can simplif y objec t interconnections . Instea d of object s maintainin g reference s to all candidat e r e c e i v e r s , they\nkeep a s i n g l e referenc e to their s u c c e s s o r . 2. Added flexibility in assigning responsibilities to objects. C h a i n of R e s p o n s i b i l i t y \ng i v es you adde d flexibilit y in distributin g r e s p o n s i b i l i t i e s amon g objects . You can add or c h a n g e responsibilitie s for handlin g a reques t by addin g\nto or otherwis e changin g the chain at run-time . You can c o m b i n e t h is with\ns u b c l a s s i n g to s p e c i a l i z e handler s statically. 3. Receipt isn't guaranteed.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 687, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_design_patterns_gof_chunk_0688_1581761c", "text": "You can c o m b i n e t h is with\ns u b c l a s s i n g to s p e c i a l i z e handler s statically. 3. Receipt isn't guaranteed. S i n ce a reques t has no e x p l i c i t r e c e i v e r , there' s no\nguarantee it'll be handled—th e reques t can f a ll off the end of the c h a in withou t\ne v er being handled . A reques t can also go unhandle d when the chain is not\nconfigured properly. Implementation\nHere are implementatio n i s s u e s to c o n s i d e r in C h a i n of R e s p o n s i b i l i t y :\n1. Implementing the successor chain. T h e r e are two p o s s i b l e ways to implemen t\nt he s u c c e s s o r c h a i n :\n(a) Defin e new links (usuall y in the Handler , but ConcreteHandler s c o u ld\ndefine them instead). ptgCHAIN O F RESPONSIBILITY 227\n( b) U se e x i s t i n g l i n k s . O ur e x a m p l e s so f ar d e f i n e n ew l i n k s, b ut o f t en y ou c an u se e x i s t i n g o b j e c t\nr e f e r e n c e s to form t he s u c c e s s o r c h a i n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 688, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_design_patterns_gof_chunk_0689_063fb1fe", "text": "O ur e x a m p l e s so f ar d e f i n e n ew l i n k s, b ut o f t en y ou c an u se e x i s t i n g o b j e c t\nr e f e r e n c e s to form t he s u c c e s s o r c h a i n . F or e x a m p l e , paren t r e f e r e n c e s in a\npart-whol e h i e r a r c h y can defin e a part's s u c c e s s o r . A widge t structur e migh t\na l r e a d y have s u ch l i n k s. C o m p o s i t e ( 1 6 3) d i s c u s s e s paren t r e f e r e n c e s in more\nd e t a i l . U s i ng e x i s t i n g l i n ks work s w e ll when t he l i n ks suppor t t he c h a in y ou n e e d. It s a v es y ou from d e f i n i n g l i n ks e x p l i c i t l y , a nd it s a v es s p a c e . B ut if t he\ns t r u c t u r e d o e s n ' t r e f l e c t t he c h a in of r e s p o n s i b i l i t y your a p p l i c a t i o n r e q u i r e s ,\nt h en y o u ' l l have to defin e redundan t l i n k s . 2. Connecting successors.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 689, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 896}}
{"id": "computer_science_design_patterns_gof_chunk_0690_9eb74551", "text": "2. Connecting successors. If t h e re are no p r e e x i s t i n g r e f e r e n c e s for definin g a\nc h a i n , t h en you'l l h a ve to i n t r o d u c e them yourself . In that c a s e, t he Handle r\nn ot o n ly d e f i n e s t he i n t e r f a c e f or t he r e q u e s t s b ut u s u a l l y m a i n t a i n s t he\ns u c c e s s o r as w e l l. T h at l e ts the handle r provid e a defaul t implementatio n \nof H a n d l e R e q u e s t that forward s t he r e q u e s t to t he s u c c e s s o r ( if a n y ). If a\nC o n c r e t e H a n d l e r s u b c l a s s i s n 't i n t e r e s t e d in t he r e q u e s t , it d o e s n ' t have to\no v e r r i d e the forwardin g o p e r a t i o n , s i n ce its defaul t implementatio n forward s\nu n c o n d i t i o n a l l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 690, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 779}}
{"id": "computer_science_design_patterns_gof_chunk_0691_3ab575c5", "text": "H e r e ' s a HelpHandle r b ase c l a ss that maintain s a s u c c e s s o r l i n k :\nc l a ss H e l p H a n d l e r {\npublic:\nH e l p H a n d l e r ( H e l p H a n d l e r * s) : _successor(s ) { }\nvirtual void H a n d l e H e l p ( ) ;\np r i v a t e :\nH e l p H a n d l e r * _successor ;\n} ;\nvoid H e l p H a n d l e r : : H a n d l e H e l p () {\nif ( _ s u c c e s s o r ) {\n_ s u c c e s s o r - > H a n d l e H e l p ( ) ;\n}\n}\n3. Representing requests. Differen t option s are availabl e for r e p r e s e n t i n g r e q u e s t s . In t he s i m p l e s t form , t he r e q u e s t is a h a r d - c o d e d operatio n i n v o c a t i o n , as in\nt he c a se of HandleHelp . T h is is c o n v e n i e n t a nd safe, b ut y ou c an forwar d\no n ly t he f i x ed s et of r e q u e s t s that t he Handle r c l a ss defines. An alternativ e is to use a s i n g le handle r functio n that takes a reques t c o de\n( e . g ., an i n t e g e r constan t or a string ) as parameter .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 691, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_design_patterns_gof_chunk_0692_6c8a24dd", "text": "An alternativ e is to use a s i n g le handle r functio n that takes a reques t c o de\n( e . g ., an i n t e g e r constan t or a string ) as parameter . T h is support s an o p e n -\ne n d ed s et of r e q u e s t s . T he o n ly r e q u i r e m e n t is that t he s e n d e r a nd r e c e i v e r\na g r ee on h ow t he r e q u e s t s h o u l d be e n c o d e d . T h is approac h is more f l e x i b l e , b ut it r e q u i r e s c o n d i t i o n a l statement s f or\nd i s p a t c h i n g t he r e q u e s t b a s ed on i ts c o d e. M o r e o v e r , there' s no type-saf e\nw ay to p a ss p a r a m e t e r s , so t h ey must be p a c k e d a nd u n p a c k e d m a n u a l l y . O b v i o u s l y this is less safe than invoking an operation directly. ptg228 BEHAVIORAL PATTERNS CHAPTERS\nTo a d d r e s s t he parameter-passin g problem , we c an u se separat e r e q u e s t\nobjects that bundl e r e q u e s t parameters .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 692, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_design_patterns_gof_chunk_0693_cabf4e3e", "text": "ptg228 BEHAVIORAL PATTERNS CHAPTERS\nTo a d d r e s s t he parameter-passin g problem , we c an u se separat e r e q u e s t\nobjects that bundl e r e q u e s t parameters . A R e q u e s t c l a ss can r e p r e s e n t re-\nquest s e x p l i c i t l y , a nd n ew k i n ds of request s c an be define d by s u b c l a s s i n g . S u b c l a s s e s can defin e differen t parameters . Handler s must know the k i nd\nof r e q u e s t (that i s, w h i c h R e q u e s t s u b c l a s s they'r e u s i n g ) to a c c e s s t h e se\nparameters. To identif y the r e q u e s t , R e q u e s t can defin e an a c c e s s o r functio n that return s\nan identifie r for the c l a s s. Alternatively , the r e c e i v e r can use run-tim e type\ninformatio n if the implementatio n language s support s it. H e re is a s k e t c h of a dispatc h functio n that u s es r e q u e s t object s to identif y\nrequests .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 693, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 904}}
{"id": "computer_science_design_patterns_gof_chunk_0694_1c894044", "text": "H e re is a s k e t c h of a dispatc h functio n that u s es r e q u e s t object s to identif y\nrequests . A G e t K i n d operatio n define d in the base R e q u e s t c l a ss identifie s\nt h e kind of request:\nvoid H a n d l e r : : H a n d l e R e q u e s t ( R e q u e s t* theRequest ) {\ns w i t ch ( t h e R e q u e s t - > G e t K i n d ( ) ) { \nc a se Help:\n// c a st a r g u m e nt to appropriat e t y pe\nHandleHelp((HelpRequest* ) theRequest) ;\nb r e a k ;\nc a se P r i n t: \nHandlePrint((PrintRequest* ) theRequest) ;\n// . . . b r e a k ;\ndefault: \n// . . . b r e a k ;\n}\n}\nS u b c l a s s e s can exten d the dispatc h by o v e r r i d i n g H a n d l e R e q u e s t . The\ns u b c l a s s h a n d l e s o n ly t he request s in w h i c h i t 's i n t e r e s t e d ; o t h er request s\na re forwarde d to t he paren t c l a s s. In t h is way, s u b c l a s s e s effectivel y e x -\ntend (rathe r than override ) the H a n d l e R e q u e s t operation .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 694, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_design_patterns_gof_chunk_0695_f16ac9ef", "text": "In t h is way, s u b c l a s s e s effectivel y e x -\ntend (rathe r than override ) the H a n d l e R e q u e s t operation . For e x a m p l e , \nh e r e ' s how an E x t e n d e d H a n d l e r s u b c l a s s extend s H a n d l e r ' s v e r s i o n of\nH a n d l e R e q u e s t :\nc l a ss E x t e n d e d H a n d l e r : public H a n d l er {\npublic:\nvirtual void H a n d l e R e q u e s t ( R e q u e s t * theRequest) ;\n// . . . } ;\nvoid E x t e n d e d H a n d l e r : : H a n d l e R e q u e s t ( R e q u e s t* theRequest ) {\ns w i t ch ( t h e R e q u e s t - > G e t K i n d ( ) ) { \nc a se P r e v i e w :\n// h a n d le t he P r e v i ew r e q u e st\nb r e a k ;\n\nptgC H A I N OF RESPONSIBILITY 229\ndefault:\n// l et Handler h a n d le o t h er r e q u e s ts\nHandler::HandleRequest(theRequest);\n}\n4. Automatic forwarding in Smalltalk. You can use the d o e s N o t U n d e r s t a n d\nm e c h a n i s m in Smalltal k to f o r w a r d r e q u e s t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 695, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_design_patterns_gof_chunk_0696_7336cff1", "text": "Automatic forwarding in Smalltalk. You can use the d o e s N o t U n d e r s t a n d\nm e c h a n i s m in Smalltal k to f o r w a r d r e q u e s t s . M e s s a g e s that have\nno c o r r e s p o n d i n g m e t h o d s a re t r a p p e d in t he i m p l e m e n t a t i o n of\nd o e s N o t U n d e r s t a n d , w h i c h can be overridde n to forwar d the messag e\nto an object' s s u c c e s s o r . T h us it i s n 't n e c e s s a r y to i m p l e m e n t forwardin g\nmanually ; t he c l a ss handle s o n ly t he r e q u e s t in whic h it's i n t e r e s t e d , a nd it\nr e l i e s on doesNotUnderstand t o forward all others. S a m p l e Code\nT he f o l l o w i n g e x a m p l e i l l u s t r a t e s h ow a c h a in of r e s p o n s i b i l i t y c an h a n d l e r e -\nquest s f or an o n - l i n e help s y s t e m l i ke t he o ne d e s c r i b e d e a r l i e r . T he h e lp reques t\nis an e x p l i c i t operation .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 696, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_design_patterns_gof_chunk_0697_c4774eca", "text": "T he h e lp reques t\nis an e x p l i c i t operation . W e ' ll u se e x i s t i n g paren t r e f e r e n c e s in t he widge t h i e r -\narchy to propagat e r e q u e s t s betwee n widget s in the c h a i n , and we'll defin e a\nreferenc e in the Handle r c l a ss to propagat e help r e q u e s t s betwee n nonwidget s in\nt he c h a i n . The H e l p H a n d l e r c l a ss define s the interfac e for handlin g help r e q u e s t s . It main-\nt a i ns a h e lp t o p ic ( w h i c h is e m p t y by default ) a nd k e e ps a r e f e r e n c e to i ts s u c c e s s o r\non t he c h a in of help handlers . T he k ey operatio n is H a n d l e H e l p , w h i c h s u b c l a s s e s\noverride . H a s H e l p is a c o n v e n i e n c e operatio n for c h e c k i n g whethe r there is an\na s s o c i a t e d help topic.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 697, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 821}}
{"id": "computer_science_design_patterns_gof_chunk_0698_28208d5d", "text": "H a s H e l p is a c o n v e n i e n c e operatio n for c h e c k i n g whethe r there is an\na s s o c i a t e d help topic. t y p e d ef i nt T o p i c; \nc o n st T o p ic NO_HELP_TOPI C = -1;\nclass HelpHandle r {\npublic:\nHelpHandler(HelpHandler * = 0, T o p ic = NO_HELP_TOPIC) ;\nvirtual bool HasHelp() ; \nvirtual void SetHandler(HelpHandler* , Topic);\nvirtual void HandleHelp();\nprivate:\nHelpHandler * _successor;\nTopic _topic;\n} ;\nHelpHandler::HelpHandle r (\nHelpHandler * h, Topic t \n) : _successor(h) , _topic(t ) { }\nb o ol H e l p H a n d l e r : : H a s H e l p () {\nreturn _ t o p i c ! = NO_HELP_TOPIC;\n}\n\nptg2 3 0 BEHAVIORAL P A T T E R N S CHAPTERS\nvoid HelpHandler::HandleHel p () {\nif ( _ s u c c e s s o r != 0) {\n_successor->HandleHelp() ;\n}\n}\nAll widget s are s u b c l a s s e s of the W i d g e t abstrac t c l a s s. W i d g e t is a s u b c l a s s of\nH e l p H a n d l e r , s i n ce all user interfac e e l e m e n t s can have h e lp a s s o c i a t e d with\nthem.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 698, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_design_patterns_gof_chunk_0699_685ea855", "text": "W i d g e t is a s u b c l a s s of\nH e l p H a n d l e r , s i n ce all user interfac e e l e m e n t s can have h e lp a s s o c i a t e d with\nthem. (We could have used a mixin-based implementation just as w e l l . )\nc l a ss Widget : public HelpHandle r {\nprotected:\nWidget(Widget * p a r e n t, T o p ic t = N O _ H E L P _ T O P I C ) ;\nprivate:\nWidget* _parent;\n} ;\nWidget::Widge t ( W i d g e t* w, Topic t) : H e l p H a n d l e r ( w , t) {\n_parent = w;\n}\nIn our example , a b u t t o n is the first handle r on the c h a i n . The B u t t o n c l a ss is a\ns u b c l a s s of W i d g e t . The B u t t o n constructo r takes two parameters : a referenc e\nto its enclosing widget and the help topic. c l a ss Button : public Widget {\npublic:\nButton(Widget * d, Topic t = NO_HELP_TOPIC);\nvirtual void HandleHelp() ; \n// Widget operations that Button overrides... } ;\nB u t t o n ' s versio n of H a n d l e H e l p first tests to see if there is a h e lp t o p ic for\nbuttons .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 699, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_design_patterns_gof_chunk_0700_79e3af6a", "text": "} ;\nB u t t o n ' s versio n of H a n d l e H e l p first tests to see if there is a h e lp t o p ic for\nbuttons . If the develope r hasn' t define d o n e, then the r e q u e s t g e ts forwarde d to\nthe s u c c e s s o r u s i ng the H a n d l e H e l p operatio n in H e l p H a n d l e r . If t h e re is a\nhelp topic, then the button displays it, and the search ends. Button::Butto n ( W i d g e t* h, T o p ic t) : Widgetfh , t) { }\nvoid Button::HandleHel p () {\nif (HasHelpO ) {\n// offer help on the button\n} else {\nHelpHandler::HandleHelp() ;\n}\n}\nD i a l o g implement s a s i m i l a r s c h e m e , e x c e p t that its s u c c e s s o r is not a widge t\nbut any h e lp h a n d l e r . In our applicatio n t h is s u c c e s s o r will be an i n s t a n c e of\nA p p l i c a t i o n . ptgCHAIN O F RESPONSIBILITY 231\nc l a ss Dialog : public Widget {\npublic:\nDialog(HelpHandler * h, Topic t = NO_HELP_TOPIC) ;\nvirtual void HandleHelp();\n// Widget operation s that D i a l og overrides.. . // . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 700, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1007}}
{"id": "computer_science_design_patterns_gof_chunk_0701_39ad934d", "text": ". // . . . } ;\nDialog::Dialo g ( H e l p H a n d l e r * h, Topic t) : Widget(O ) {\nSetHandler(h , t);\n}\nvoid Dialog::HandleHel p () {\nif ( H a s H e l p O ) {\n// offer help on the dialog\n} else {\nHelpHandler::HandleHelp() ;\n}\n}\nAt t he e nd of t he c h a in is an i n s t a n c e of A p p l i c a t i o n . T he a p p l i c a t i o n is n ot\na w i d g e t , so A p p l i c a t i o n is s u b c l a s s e d d i r e c t l y f r om H e l p H a n d l e r . W h e n a \nh e lp r e q u e s t p r o p a g a t e s to t h is l e v e l , t he a p p l i c a t i o n c an s u p p l y i n f o r m a t i o n on\nt he a p p l i c a t i o n in g e n e r a l , or it c an offer a list of differen t h e lp t o p i c s :\nc l a ss Applicatio n : public HelpHandle r {\npublic:\nApplication(Topi c t) : HelpHandler(0 , t) { }\nvirtual void HandleHelp() ; \n// application-specifi c operations...", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 701, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 870}}
{"id": "computer_science_design_patterns_gof_chunk_0702_9c39bd81", "text": "} ;\nvoid Application::HandleHel p () {\n// s h ow a list of h e lp topics\n}\nT he f o l l o w i n g c o de c r e a t e s a nd c o n n e c t s t h e se o b j e c t s . H e re t he d i a l o g c o n c e r n s\np r i n t i n g , a nd so t he o b j e c t s h a ve p r i n t i n g - r e l a t e d t o p i c s a s s i g n e d . c o n st T o p ic P R I N T _ T O P I C - 1 ; \nc o n st T o p ic PAPER_ORIENTATION_TOPI C = 2;\nconst T o p ic APPLICATION_TOPI C = 3;\nApplication * applicatio n = new Application(APPLICATION_TOPIC) ;\nDialog* dialog = new Dialog(application , PRINT_TOPIC) ;\nButton* button = new Button(dialog , PAPER_ORIENTATION_TOPIC);\nWe c an i n v o k e t he h e lp r e q u e s t by c a l l i n g Hand l e He Ip on a ny o b j e c t on t he c h a i n . T o start the search at the button object, just call HandleHelp on it:\n\nptg232 BEHAVIORAL P A T T E R N S CHAPTER 5\nbutton->HandleHelp();\nIn t h is c a s e, the butto n will handl e the reques t i m m e d i a t e l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 702, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_design_patterns_gof_chunk_0703_635e80ea", "text": "Note that any\nH e l p H a n d l e r c l a ss could be made the s u c c e s s o r of D i a l o g . M o r e o v e r , its s u c -\nc e s s o r could be c h a n g e d dynamically . So no matte r wher e a dialo g is u s e d, you'l l\nget the proper context-dependent help information f o r i t . Known Uses\nS e v e r a l c l a ss librarie s use the C h a in of R e s p o n s i b i l i t y patter n to handl e user\nevents . T h ey use differen t name s for the Handle r c l a s s, but the i d ea is the s a m e :\nWhen the user c l i c ks the mous e or p r e s s e s a k e y, an event g e ts generate d and\np a s s e d a l o ng t he c h a i n . M a c A p p [ A p p 8 9 ] a nd ET++ [ W G M 8 8 ] c a ll it \" E v e n t -\nH a n d l e r , \" Symantec' s T CL librar y [ S y m 9 3 b ] c a l ls it \"Bureaucrat, \" a nd NeXT' s\nAppKi t [Add94 ] u s es the name \" R e s p o n d e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 703, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 865}}
{"id": "computer_science_design_patterns_gof_chunk_0704_1daf256d", "text": "\"\nThe Unidra w f r a m e w o r k for graphica l editor s define s Comman d o b j e c t s that\nencapsulat e request s to Componen t and Componen t V i ew object s [ V L 9 0 ] . C o m -\nmand s are request s in the s e n se that a componen t or componen t v i ew may in-\nterpre t a comman d to p e r f o r m an operation . T h is correspond s to the \" r e q u e s t s\nas o b j e c t s \" approac h d e s c r i b e d in Implementation . Component s a nd componen t\nv i e w s may be structure d h i e r a r c h i c a l l y . A componen t or a componen t v i ew may\nf o r w a r d comman d interpretatio n to its parent , whic h may in turn f o r w a r d it to its\nparent , a nd so o n, thereb y formin g a c h a in of r e s p o n s i b i l i t y . ET++ uses C h a in of Responsibilit y to handl e graphica l update . A graphica l o b j e c t\nc a l ls the InvalidateRec t operatio n wheneve r it must updat e a part of its appear-\na n c e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 704, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 931}}
{"id": "computer_science_design_patterns_gof_chunk_0705_1450ac5a", "text": "ET++ uses C h a in of Responsibilit y to handl e graphica l update . A graphica l o b j e c t\nc a l ls the InvalidateRec t operatio n wheneve r it must updat e a part of its appear-\na n c e. A graphica l objec t can't handl e InvalidateRec t by i t s e l f , b e c a u s e it d o e s n ' t\nknow enoug h abou t its context . For example , a graphica l objec t can be e n c l o s e d\nin object s l i ke S c r o l l e r s or Zoomer s that t r a n s f o r m its coordinat e s y s t e m . T h at \nmean s the objec t migh t be s c r o l l e d or zoome d so that it's partiall y out of v i e w. Therefor e the d e f a u l t implementatio n of InvalidateRec t forward s the r e q u e s t to\nthe e n c l o s i n g containe r object . The l a st objec t in the forwardin g c h a in is a W i n d o w\ninstance . By t he time Windo w r e c e i v e s t he r e q u e s t , t he invalidatio n rectangl e is\nguarantee d to be transforme d properly .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 705, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 932}}
{"id": "computer_science_design_patterns_gof_chunk_0706_46448cfa", "text": "By t he time Windo w r e c e i v e s t he r e q u e s t , t he invalidatio n rectangl e is\nguarantee d to be transforme d properly . The W i n d o w h an dl e s InvalidateRec t by\nnotifying the window system interface and requesting an update. Related P a t t e r n s\nChain of Responsibilit y is often applie d in conjunctio n with Composit e ( 1 6 3 ) . T h e r e , a component's parent can act as its successor. ptgC O M M A N D 233\nC O M M A N D O b j e c t Behavioral\nIntent\nEncapsulate a r e q u e s t as an o b j e c t , thereb y lettin g you parameteriz e c l i e n t s with\ndifferent r e q u e s t s , queue or log requests, and support undoable operations. Also Known As\nAction, T r a n s a c t i o n\nMotivation\nS o m e t i m e s it's n e c e s s a r y to i s s ue r e q u e s t s to object s withou t knowin g anythin g\nabou t the operatio n bein g requeste d or the r e c e i v e r of the request .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 706, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_design_patterns_gof_chunk_0707_b5330e40", "text": "For example ,\nuser interfac e toolkit s includ e object s l i ke button s and menu s that carry out a\nr e q u e s t in r e s p o n s e to u s er input . B ut t he t o o l k i t c a n 't i m p l e m e n t t he r e q u e s t\ne x p l i c i t l y in the butto n or menu , b e c a u s e o n ly application s that use the toolki t\nknow what shoul d be done on whic h object . As toolki t d e s i g n e r s we have no way\nof knowin g the r e c e i v e r of the r e q u e s t or the operation s that will carry it out. The Comman d patter n l e ts toolki t object s make r e q u e s t s of unspecifie d applica-\ntion object s by turnin g the reques t i t s e lf into an o b j e c t . T h is o b j e c t can be s t o r e d\nand p a s s e d aroun d like other o b j e c t s . The key to this patter n is an abstrac t C o m -\nmand c l a s s, w h i c h d e c l a r e s an interfac e for executin g operations . In the s i m p l e s t\nf o rm this interfac e include s an abstrac t Execut e operation .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 707, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_design_patterns_gof_chunk_0708_e995c979", "text": "In the s i m p l e s t\nf o rm this interfac e include s an abstrac t Execut e operation . C o n c r e t e Comman d\ns u b c l a s s e s specif y a r e c e i v e r - a c t i o n pair by storin g the r e c e i v e r as an instanc e\nv a r i a b l e a nd by i m p l e m e n t i n g E x e c u t e to i n v o k e t he r e q u e s t . T he r e c e i v e r h as t he\nknowledge required to carry out the request. Menu s can be implemente d e a s i ly with Comman d objects . Each c h o i c e in a Menu\nis an instance of a Menultem class. An Application class creates these menus and\n\nptg2 3 4 BEHAVIORAL PATTERNS CHAPTER 5\ntheir menu i t e ms a l o ng with t he r e st of t he u s er interface . T he A p p l i c a t i o n c l a ss\na l so k e e ps track of D o c u m e n t o b j e c t s that a user has o p e n e d . T he applicatio n configure s e a ch Menulte m with an i n s t a n c e of a c o n c r e t e C o m -\nmand s u b c l a s s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 708, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 929}}
{"id": "computer_science_design_patterns_gof_chunk_0709_bc932159", "text": "T he applicatio n configure s e a ch Menulte m with an i n s t a n c e of a c o n c r e t e C o m -\nmand s u b c l a s s . W h en t he u s er s e l e c t s a M e n u l t e m , t he Menulte m c a l ls Execut e\non i ts command , a nd Execut e c a r r i e s o ut t he operation . M e n u l t e m s don't k n ow\nw h i c h s u b c l a s s of Comman d they u s e. Comman d s u b c l a s s e s s t o re t he r e c e i v e r of\nt he r e q u e s t a nd i n v o k e o ne or more operation s on t he r e c e i v e r . For example , PasteComman d support s pastin g text from the c l i p b o a r d i n to a\nDocument . PasteCommand' s r e c e i v e r is t he D o c u m e n t objec t it is s u p p l i e d upon\ninstantiation. The Execute operation invokes Paste on the receiving Document.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 709, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 774}}
{"id": "computer_science_design_patterns_gof_chunk_0710_60f844aa", "text": "PasteCommand' s r e c e i v e r is t he D o c u m e n t objec t it is s u p p l i e d upon\ninstantiation. The Execute operation invokes Paste on the receiving Document. OpenCommand' s Execut e o p e r a t i o n is different : it prompt s the u s er for a d o c u -\nment n a m e , c r e a t e s a c o r r e s p o n d i n g D o c u m e n t o b j e c t , adds the documen t to the\nr e c e i v i n g application, and opens the document. S o m e t i m e s a Menulte m n e e ds to e x e c u t e a sequence of c o m m a n d s . For e x a m p l e , a\nMenulte m for c e n t e r i n g a page at norma l s i ze c o u ld be constructe d f r om a C e n -\nterDocumentComman d o b j e c t a nd a N o r m a l S i z e C o m m a n d o b j e c t . B e c a u s e i t 's\nc o m m o n to string commands together in this way, we can define a M a c r o C o m -\nmand class to allow a M e n u l t e m to execute a n open-ended number of c o m m a n d s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 710, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_design_patterns_gof_chunk_0711_1f3ddad0", "text": "B e c a u s e i t 's\nc o m m o n to string commands together in this way, we can define a M a c r o C o m -\nmand class to allow a M e n u l t e m to execute a n open-ended number of c o m m a n d s . ptgC O M M A N D 2 3 5\nMacroComman d is a c o n c r e t e Comman d s u b c l a s s that s i m p l y e x e c u t e s a s e q u e n c e\nof C o m m a n d s . MacroComman d h as no e x p l i c i t r e c e i v e r , b e c a u s e t he command s\ni t sequences define their own receiver. In e a ch of t h e se e x a m p l e s , n o t i ce h ow t he C o m m a n d patter n d e c o u p l e s t he o b j e c t\nthat i n v o k e s the operatio n from the one h a v i n g the knowledg e to perfor m it. T h is\ng i v es us a l ot of f l e x i b i l i t y in d e s i g n i n g o ur u ser interface . An applicatio n c an\nprovid e both a menu and a push butto n interfac e to a featur e just by makin g\nthe men u and the push butto n s h a re an i n s t a n c e of the s a me c o n c r e t e Comman d\ns u b c l a s s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 711, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_design_patterns_gof_chunk_0712_71651b46", "text": "We can r e p l a c e command s d y n a m i c a l l y , whic h woul d be usefu l for\ni m p l e m e n t i n g c o n t e x t - s e n s i t i v e m e n u s . We c an a l so s u p p o r t c o m m a n d s c r i p t i n g\nby c o m p o s i n g command s into large r o n e s. A ll of t h is is p o s s i b l e b e c a u s e t he o b j e c t\nthat i s s u e s a r e q u e s t o n ly n e e ds to know how to i s s ue it; it doesn' t n e ed to know\nhow the request will be carried out. A p p l i c a b i l i t y\nUse the Comman d patter n when you want to\n• parameteriz e object s by an actio n to perform , as Menulte m object s did a b o v e . You can e x p r e s s s u ch parameterizatio n in a procedura l languag e with a\ncallbac k function , that is, a functio n that's r e g i s t e r e d s o m e w h e r e to be c a l l ed\nat a later point . Command s are an o b j e c t - o r i e n t e d replacemen t for c a l l b a c k s . • s p e c i f y , q u e u e , and execut e request s at differen t t i m e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 712, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_design_patterns_gof_chunk_0713_84d9cebd", "text": "Command s are an o b j e c t - o r i e n t e d replacemen t for c a l l b a c k s . • s p e c i f y , q u e u e , and execut e request s at differen t t i m e s . A Comman d objec t\ncan have a lifetim e independen t of the o r i g i n a l request . If the r e c e i v e r of a\nr e q u e s t can be r e p r e s e n t e d in an addres s space-independen t way, then you\ncan transfe r a comman d objec t for the r e q u e s t to a differen t p r o c e s s and fulfil l\nthe r e q u e s t t h e r e . • suppor t undo . The Command' s Execut e operatio n can s t o re state for r e v e r s -\ning its e f f e c t s in the comman d itself . The Comman d interfac e must have an\nadded Unexecute operation that reverses the effects o f a previous call to Ex-\n\nptg2 3 6 BEHAVIORAL PATTERNS CHAPTER 5\necute . Execute d command s are store d in a histor y l i s t.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 713, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 851}}
{"id": "computer_science_design_patterns_gof_chunk_0714_40504409", "text": "Execute d command s are store d in a histor y l i s t. U n l i m i t e d - l e v e l undo\nand r e do is a c h i e v e d by traversin g this l i st backward s and forward s c a l l i n g\nUnexecut e and Execute , r e s p e c t i v e l y . • suppor t l o g g i n g c h a n g e s so that they can be r e a p p l i e d in c a se of a s y s t e m\nc r a s h . By augmentin g the Comman d interfac e with l o ad and s t o re opera-\nt i o n s , you can k e ep a persisten t log of c h a n g e s . R e c o v e r i n g from a crash\ni n v o l v e s r e l o a d i n g l o g g e d command s f r om d i sk and r e e x e c u t i n g them with\nthe Execut e operation. • structur e a s y s t e m aroun d h i g h - l e v e l operation s built on primitive s opera-\nt i o n s . S u ch a structur e is c o m m o n in informatio n s y s t e m s that suppor t t r a n s -\na c t i o n s . A transactio n encapsulate s a s et of c h a n g e s to data. T he Comman d\npatter n o f f e r s a way to m o d e l transactions .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 714, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_design_patterns_gof_chunk_0715_27fe1a42", "text": "A transactio n encapsulate s a s et of c h a n g e s to data. T he Comman d\npatter n o f f e r s a way to m o d e l transactions . Command s have a commo n in-\nterface , lettin g you i n v o k e all transaction s the same way. The patter n also\nmakes it easy to extend the system with new transactions. S t r u c t u r e\nParticipants\n• C o m m a n d\n- declares an interface for e x e c u t i n g an operation. • ConcreteCommand ( P a s t e C o m m a n d , OpenCommand)\n- defines a b i n d i n g b e t w e e n a Receiver object and an a c t i o n . - implements E x e c u t e by invoking the corresponding operation(s) on Re -\nc e i v e r . • Client (Application)\n- creates a ConcreteCommand o b j e c t and s e t s its receiver. • Invoker (Menultem)\n- asks the c o m m a n d to c a r r y out the request. ptgC O M M A N D 237\n• Receiver ( D o c u m e n t , A p p l i c a t i o n )\n- knows how to perform t h e operations associated with carrying out a re -\nquest. Any class may serve as a Receiver.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 715, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_design_patterns_gof_chunk_0716_865aef21", "text": "ptgC O M M A N D 237\n• Receiver ( D o c u m e n t , A p p l i c a t i o n )\n- knows how to perform t h e operations associated with carrying out a re -\nquest. Any class may serve as a Receiver. C o l l a b o r a t i o n s\n• T he c l i e nt create s a ConcreteComman d o b j e c t a nd s p e c i f i e s i ts r e c e i v e r . • An Invoke r objec t s t o r e s the ConcreteComman d object. • The invoke r i s s u e s a reques t by c a l l i n g Execut e on the command . Whe n c o m -\nmand s are u n d o a b l e , ConcreteComman d s t o r e s state for u n d o i n g the c o m -\nmand prior to invokin g Execute. • The ConcreteComman d o b j e c t i n v o k e s operation s on its r e c e i v e r to carry out\nthe request. T he f o l l o w i n g d i a g r a m s h o w s t he i n t e r a c t i o n s b e t w e e n t h e se o b j e c t s . It i l l u s t r a t e s\nhow Comman d d e c o u p l e s the i n v o k e r from the r e c e i v e r (and the reques t it carrie s\nout).", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 716, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_design_patterns_gof_chunk_0717_b791a839", "text": "It i l l u s t r a t e s\nhow Comman d d e c o u p l e s the i n v o k e r from the r e c e i v e r (and the reques t it carrie s\nout). C o n s e q u e n c e s\nThe Comman d patter n has the followin g c o n s e q u e n c e s :\n1. Comman d d e c o u p l e s the objec t that invoke s the operatio n from t he o ne that\nk n o w s h ow to perfor m i t . 2. Command s are first-clas s objects . T h ey can be manipulate d and extende d\nl i ke any other object. 3. Y ou c an a s s e m b l e command s into a c o m p o s i t e command . An exampl e is t he\nM a c r o C o m m a n d c l a ss d e s c r i b e d e a r l i e r . In g e n e r a l , c o m p o s i t e c o m m a n d s \na re an i n s t a n c e of t he Composit e ( 1 6 3) pattern. 4. It's easy to add new Commands , becaus e you don't have to c h a n g e e x i s t i n g\nc l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 717, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 837}}
{"id": "computer_science_design_patterns_gof_chunk_0718_b40bfc67", "text": "4. It's easy to add new Commands , becaus e you don't have to c h a n g e e x i s t i n g\nc l a s s e s . ptg2 3 8 BEHAVIORAL P A T T E R N S CHAPTERS\nI m p l e m e n t a t i o n\nC o n s i d e r t he f o l l o w i n g i s s u e s w h en i m p l e m e n t i n g t he C o m m a n d p a t t e r n :\n1. H ow intelligent should a command b e? A comman d c an h a ve a wide r a n ge of\na b i l i t i e s . At o ne extrem e it merel y define s a b i n d i n g b e t w e e n a r e c e i v e r a nd\nthe a c t i o n s that carry out the r e q u e s t . At the o t h er e x t r e m e it i m p l e m e n t s\ne v e r y t h i n g i t s e lf withou t d e l e g a t i n g to a r e c e i v e r at a l l. T he latter e x t r e m e is\nusefu l when you want to defin e c o m m a n d s that are i n d e p e n d e n t of e x i s t i n g\nc l a s s e s , when no suitabl e r e c e i v e r e x i s t s , or w h en a comman d k n o w s i ts\nr e c e i v e r i m p l i c i t l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 718, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_design_patterns_gof_chunk_0719_93828ec0", "text": "F or e x a m p l e , a c o m m a n d that c r e a t e s a n o t h e r a p p l i c a t i o n\nwindo w may be j u st as c a p a b l e of creatin g the w i n d o w as any o t h er o b j e c t . S o m e w h e r e in b e t w e e n t h e se e x t r e m e s a re c o m m a n d s t h at h a ve e n o u g h\nk n o w l e d g e to find t h e ir r e c e i v e r d y n a m i c a l l y . 2.Supporting undo and redo. Command s can suppor t undo and r e do c a p a b i l i t i e s\nif they provid e a way to r e v e r s e their e x e c u t i o n ( e . g ., an U n e x e c u t e or Undo\noperation) . A C o n c r e t e C o m m a n d c l a ss migh t n e ed to s t o re a d d i t i o n a l s t a te\nto do s o.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 719, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 686}}
{"id": "computer_science_design_patterns_gof_chunk_0720_b46e787c", "text": "g ., an U n e x e c u t e or Undo\noperation) . A C o n c r e t e C o m m a n d c l a ss migh t n e ed to s t o re a d d i t i o n a l s t a te\nto do s o. T h is state c an i n c l u d e\n• t he R e c e i v e r o b j e c t , w h i c h actuall y c a r r i e s o ut o p e r a t i o n s in r e s p o n s e to\nthe r e q u e s t ,\n• the arguments to the operatio n performe d on the r e c e i v e r , and\n• any origina l value s in the r e c e i v e r that can c h a n g e as a r e s u l t of h a n d l i n g\nt he r e q u e s t . T he r e c e i v e r must p r o v i d e o p e r a t i o n s that l et t he comman d\nretur n the r e c e i v e r to its prior state. To suppor t o ne l e v el of undo , an applicatio n n e e ds to s t o re o n ly t he c o m -\nmand that was execute d l a s t.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 720, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 780}}
{"id": "computer_science_design_patterns_gof_chunk_0721_3a89fe2b", "text": "To suppor t o ne l e v el of undo , an applicatio n n e e ds to s t o re o n ly t he c o m -\nmand that was execute d l a s t. For m u l t i p l e - l e v e l undo and r e d o, the a p p l i c a -\nt i on n e e ds a histor y list of command s that h a ve b e en e x e c u t e d , w h e r e the\nmaximu m lengt h of t he l i st determine s t he numbe r of undo/red o l e v e l s . T he\nhistor y l i st s t o r e s s e q u e n c e s of command s that have b e en e x e c u t e d . T r a v e r s -\ni ng backwar d throug h t he l i st a nd r e v e r s e - e x e c u t i n g c o m m a n d s c a n c e l s t h e ir\neffect ; traversin g forwar d and e x e c u t i n g command s r e e x e c u t e s them. An undoabl e comman d m i g h t have to be c o p i e d befor e it c an be p l a c e d\non t he histor y l i s t. That' s becaus e t he comman d o b j e c t that c a r r i e d o ut t he\no r i g i n a l r e q u e s t , s a y, from a Menultem , will perfor m o t h er r e q u e s t s at later\nt i m e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 721, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_design_patterns_gof_chunk_0722_bc81ce8c", "text": "That' s becaus e t he comman d o b j e c t that c a r r i e d o ut t he\no r i g i n a l r e q u e s t , s a y, from a Menultem , will perfor m o t h er r e q u e s t s at later\nt i m e s . C o p y i n g is require d to d i s t i n g u i s h differen t i n v o c a t i o n s of t he s a me\ncomman d if its state can vary a c r o s s i n v o c a t i o n s . For example , a DeleteComman d that d e l e t e s s e l e c t e d o b j e c t s must s t o re dif-\nferen t s e ts of o b j e c t s e a ch time i t 's e x e c u t e d . T h e r e f o r e t he D e l e t e C o m m a n d\nobjec t must be c o p i e d followin g e x e c u t i o n , a nd t he c o py is p l a c e d on t he h i s -\ntory l i s t. If t he c o m m a n d ' s s t a te n e v er c h a n g e s on e x e c u t i o n , t h en c o p y i n g is\nn ot required—onl y a referenc e to t he comman d n e ed be p l a c e d on t he h i s t o r y\nlist.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 722, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 898}}
{"id": "computer_science_design_patterns_gof_chunk_0723_7c51ba46", "text": "Command s that must be c o p i e d befor e b e i ng p l a c e d on t he h i s t o r y l i st\na c t as prototypes (see Prototype (117)). ptgCOMMAND 2 3 9\n3. Avoiding error accumulation in the undo process. H y s t e r e s i s can be a proble m in\nensurin g a r e l i a b l e , semantics-preservin g u n d o / r e d o mechanism . Error s can\naccumulat e as c o m m a n d s a re e x e c u t e d , u n e x e c u t e d , a nd r e e x e c u t e d r e p e a t -\ne d ly so that an application' s state eventuall y d i v e r g e s from origina l values . It may be necessar y therefor e to s t o re more informatio n in the comman d to\nensur e that object s are restore d to their origina l state . The Mement o ( 2 8 3) pat-\ntern c an be a p p l i e d to g i ve t he c o m m a n d a c c e s s to t h is informatio n withou t\nexposin g the internal s of other objects. 4. Using C++ templates.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 723, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 883}}
{"id": "computer_science_design_patterns_gof_chunk_0724_4f6c2235", "text": "The Mement o ( 2 8 3) pat-\ntern c an be a p p l i e d to g i ve t he c o m m a n d a c c e s s to t h is informatio n withou t\nexposin g the internal s of other objects. 4. Using C++ templates. For command s t h at (1) aren' t undoabl e and (2) don't\nr e q u i r e a r g u m e n t s , we c an u se C ++ t e m p l a t e s to a v o id c r e a t i n g a C o m m a n d\ns u b c l a s s for every kind of actio n and r e c e i v e r . We show how to do this in the\nS a m p l e C o d e s e c t i o n . S a m p l e Code\nThe C++ code show n h e re s k e t c h e s the implementatio n of the Comman d c l a s s e s\nin the Motivatio n s e c t i o n . W e ' ll defin e O p e n C o m m a n d , P a s t e C o m m a n d , and\nMacroCommand. First the abstract Command class:\nclass Command {\npublic:\nv i r t u al \" C o m m a n d ( ) ;\nvirtual void Execute( ) = 0;\nprotected:\nCommand() ;\n} ;\nO p e n C o m m a n d o p e n s a documen t w h o s e name is supplie d by the u s e r.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 724, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_design_patterns_gof_chunk_0725_80530217", "text": "An\nOpenComman d must be p a s s e d an A p p l i c a t i o n objec t in its constructor . A s k U s e r is an implementatio n routin e that prompt s the user for the name of\nthe document to open. class O p e n C o m m a n d : public Command {\npublic:\nOpenCommand(Application*);\nvirtual void Execute() ;\nprotected:\nvirtual const c h a r* AskUser() ;\nprivate:\nApplication * _application ;\nchar* _response;\n} ;\nOpenCommand::OpenComman d (Application * a) {\n_applicatio n = a;\n}\n\nptg240 BEHAVIORAL P A T T E R N S CHAPTERS\nvoid OpenCommand::Execut e () {\nc o n st c h a r* n a me = AskUser();\nif ( n a me != 0) { \nDocument * document = new Document(name) ;\n_application->Add(document) ;\ndocument->0pen();\n}\nA Pas teCoiranan d must be p a s s e d a D o c u m e n t o b j e c t as its r e c e i v e r . The r e c e i v e r\nis given as a parameter t o PasteCommand's c o n s t r u c t o r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 725, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 883}}
{"id": "computer_science_design_patterns_gof_chunk_0726_5b56c2db", "text": "The r e c e i v e r\nis given as a parameter t o PasteCommand's c o n s t r u c t o r . c l a ss P a s t e C o m m a n d : public C o m m a nd {\npublic:\nP as t e C o m m a n d ( D o c u m e n t *);\nvirtual void Execute() ;\nprivate:\nDocument * _document ;\n} ;\nPasteCommand::PasteComman d ( D o c u m e n t * doc) {\n_documen t = doc;\n}\nvoid PasteCommand::Execut e () {\n_document->Paste() ;\n}\nFor s i m p l e command s that aren' t undoabl e and don't requir e arguments , we\ncan use a c l a ss templat e to parameteriz e the command' s r e c e i v e r . W e ' ll defin e\na templat e s u b c l a s s S i m p l e C o m m a n d for s u ch commands . S i m p l e C o m m a n d is\nparameterize d by the R e c e i v e r type and maintain s a b i n d i n g betwee n a r e c e i v e r\no b j e c t and an action stored as a pointer to a member function.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 726, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 841}}
{"id": "computer_science_design_patterns_gof_chunk_0727_e6a34338", "text": "S i m p l e C o m m a n d is\nparameterize d by the R e c e i v e r type and maintain s a b i n d i n g betwee n a r e c e i v e r\no b j e c t and an action stored as a pointer to a member function. template <class Receiver > \nc l a ss SimpleComman d : public C o m m a nd { \npublic:\nt y p e d ef void ( R e c e i v e r : : * Action)();\nSimpleCommand(Receiver * r, Action a) :\n_receiver(r) , _action(a ) { }\nvirtual void Execute() ;\nprivate:\nAction _action;\nReceiver* _receiver;\n} ;\nT he constructo r s t o r e s t he r e c e i v e r a nd t he a c t i o n in t he c o r r e s p o n d i n g i n s t a n c e\nv a r i a b l e s . Execute simply applies the action t o t h e r e c e i v e r . ptgCOMMAND 241\ntemplate <class Receiver > \nvoid SimpleCommand<Receiver>::Execut e () {\n(_receiver->*_action)() ;\n}\nTo c r e a t e a c o m m a n d t h at calls A c t i o n on an i n s t a n c e of c l a ss M y C l a s s , a c l i e n t\ns i m p l y w r i t e s\nMyClass* receiver = new MyClass;\n// . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 727, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_design_patterns_gof_chunk_0728_e48a6379", "text": ". . Command* aCommand =\nn ew SimpleCommand<MyClass>(receiver , &MyClass::Action) ;\n// . . . aCommand->Execute() ;\nK e ep in m i nd t h at t h is s o l u t i o n o n ly w o r k s f or s i m p l e c o m m a n d s . M o re c o m p l e x\nc o m m a n d s t h at k e ep t r a ck of n ot o n ly t h e ir r e c e i v e r s b ut a l so a r g u m e n t s a n d / o r\nu n do s t a te r e q u i r e a C o m m a n d s u b c l a s s . A MacroCommandmanage s a s e q u e n c e of s u b c o m m a n d s a nd p r o v i d e s o p e r a t i o n s\nf or a d d i n g a nd r e m o v i n g s u b c o m m a n d s . No explici t r e c e i v e r is r e q u i r e d , b e c a u s e\nt h e subcommands already define their receiver.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 728, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 702}}
{"id": "computer_science_design_patterns_gof_chunk_0729_871b892a", "text": "No explici t r e c e i v e r is r e q u i r e d , b e c a u s e\nt h e subcommands already define their receiver. c l a ss M a c r o C o m m a n d : p u b l ic C o m m a nd {\npublic:\nMacroCommand() ; \nvirtual \"MacroCommand();\nvirtual v o id A d d ( C o m m a n d * ) ;\nvirtual void Remove(Command*);\nvirtual void Execute() ;\nprivate:\nL i s t < C o m m a n d * > * _cmds;\n} ;\nT he k ey to t he MacroComman d is i ts E x e c u t e m e m b e r f u n c t i o n . T h is t r a v e r s e s\na l l the subcommands and performs E x e c u t e on each of them. void MacroCommand::Execut e () {\nL i s t I t e r a t o r < C o m m a n d * > i(_cmds);\nfor ( i. First ( ); ! i . I s D o ne () ; i.NextO ) {\nCommand* c = i.Currentltem() ;\nc->Execute();\n}\nN o te t h at s h o u l d t he MacroComman d i m p l e m e n t an U n e x e c u t e o p e r a t i o n , t h en\ni ts s u b c o m m a n d s m u st be u n e x e c u t e d in reverse o r d er relativ e to E x e c u t e ' s i m -\np l e m e n t a t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 729, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_design_patterns_gof_chunk_0730_d09d6bb4", "text": "F i n a l l y , MacroComman d m u st p r o v i d e o p e r a t i o n s to m a n a g e i ts s u b c o m m a n d s . T h e MacroCommand is also responsible for deleting its s u b c o m m a n d s . ptg242 BEHAVIORAL P A T T E R N S CHAPTER 5\nvoid M a c r o C o m m a n d : : A d d ( C o m m a n d* c) {\n_cmds->Append(c ) ;\n}\nvoid M a c r o C o m m a n d : : R e m o v e ( C o m m a n d* c) {\n_cmds->Remove(c) ;\n}\nKnown Uses\nP e r h a p s the first e x a m p l e of the Comman d patter n appear s in a pape r by\nLieberma n [ L i e 8 5 ] . MacAp p [ A p p 8 9 ] popularize d the notio n of command s for\nimplementin g undoabl e operations . ET++ [ W G M 8 8 ] , I n t e r v i e w s [LCI+92] , and\nUnidra w [ V L 9 0 ] a l so d e f i n e c l a s s e s that f o l l ow t he C o m m a n d pattern . I n t e r v i e w s\ndefine s an A c t i o n abstrac t c l a ss that provide s comman d functionality .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 730, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 893}}
{"id": "computer_science_design_patterns_gof_chunk_0731_738ffaf3", "text": "I n t e r v i e w s\ndefine s an A c t i o n abstrac t c l a ss that provide s comman d functionality . It also de-\nfines an ActionCallbac k template , parameterize d by actio n method , that can in-\ns t a n t i a t e c o m m a n d s u b c l a s s e s a u t o m a t i c a l l y . The THIN K c l a ss librar y [ S y m 9 3 b ] also uses command s to suppor t undoabl e\nactions . Command s in T H I N K are calle d \" T a s k s . \" T a sk object s are p a s s e d a l o ng a\nC h a in of R e s p o n s i b i l i t y ( 2 2 3) f or c o n s u m p t i o n . Unidraw' s comman d object s are uniqu e in that they can behav e like messages . A\nUnidra w comman d may be s e nt to anothe r o b j e c t for interpretation , and the resul t\nof the interpratio n varie s with the receivin g object . M o r e o v e r , the r e c e i v e r may\ndelegat e the interpretatio n to anothe r object , typicall y the receiver' s paren t in a \nlarge r structur e as in a Chai n of R e s p o n s i b i l i t y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 731, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_design_patterns_gof_chunk_0732_48d0ec73", "text": "M o r e o v e r , the r e c e i v e r may\ndelegat e the interpretatio n to anothe r object , typicall y the receiver' s paren t in a \nlarge r structur e as in a Chai n of R e s p o n s i b i l i t y . T he r e c e i v e r of a Unidra w c o m -\nmand is thus compute d rathe r than stored . Unidraw' s interpretatio n m e c h a n i s m\ndepend s on run-tim e type information. C o p l i e n d e s c r i b e s h ow to i m p l e m e n t f u n c t o r s , o b j e c t s that a re f u n c t i o n s , in\nC++ [ C o p 9 2 ] . He a c h i e v e s a d e g r e e of transparenc y in their use by overload-\ning the functio n call operato r ( o p e r a t o r ( )) . The Comman d patter n is different ;\ni ts focus is on m a i n t a i n i n g a binding between a r e c e i v e r a nd a functio n ( i . e ., a c t i o n ) ,\nnot just maintaining a f u n c t i o n . Related P a t t e r n s\nA Composit e ( 1 6 3) can be used to implemen t MacroCommands.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 732, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 934}}
{"id": "computer_science_design_patterns_gof_chunk_0733_2d1a9f23", "text": "e ., a c t i o n ) ,\nnot just maintaining a f u n c t i o n . Related P a t t e r n s\nA Composit e ( 1 6 3) can be used to implemen t MacroCommands. A M e m e n t o ( 2 8 3) c an k e ep state t he c o m m a n d r e q u i r e s to undo i ts effect. A comman d that must be copie d befor e being place d on the histor y l i st acts as a\nPrototype (117). ptgINTERPRETER 243\nI N T E R P R E T E R ciass Behavioral\nI n t e n t\nG i v e n a language , defin e a r e p r e s e n t i o n for its gramma r a l o ng with an interprete r\nthat uses the representation to interpret sentences in the language. M o t i v a t i o n\nIf a particula r k i nd of proble m o c c u r s often e n o u g h , then it migh t be worthwhil e\nto e x p r e s s i n s t a n c e s of t he p r o b l e m as s e n t e n c e s in a s i m p l e l a n g u a g e . T h en y ou\ncan build an interprete r that s o l v e s the proble m by interpretin g t h e se s e n t e n c e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 733, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_design_patterns_gof_chunk_0734_341c4920", "text": "T h en y ou\ncan build an interprete r that s o l v e s the proble m by interpretin g t h e se s e n t e n c e s . For e x a m p l e , s e a r c h i n g for s t r i n g s that matc h a patter n is a c o m m o n p r o b l e m . R e g u l a r e x p r e s s i o n s a re a s t a n d a r d l a n g u a g e f or s p e c i f y i n g pattern s of s t r i n g s . Rathe r than buildin g c u s t o m algorithm s to matc h e a ch patter n agains t s t r i n g s ,\ns e a r c h algorithm s c o u ld interpre t a regula r e x p r e s s i o n that s p e c i f i e s a s et of s t r i n g s\nto m a t c h . The Interprete r patter n d e s c r i b e s how to defin e a gramma r for s i m p l e l a n g u a g e s ,\nr e p r e s e n t s e n t e n c e s in t he language , a nd interpre t t h e se s e n t e n c e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 734, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 795}}
{"id": "computer_science_design_patterns_gof_chunk_0735_964b5205", "text": "In this e x a m p l e ,\nthe patter n d e s c r i b e s how to defin e a gramma r for regula r e x p r e s s i o n s , r e p r e s e n t\na particular regular expression, and how to interpret that regular expression. S u p p o s e the following grammar defines the regular expressions:\ne x p r e s s i o n ::= literal | alternatio n | s e q u e n ce | repetitio n |\n' (' e x p r e s s i o n ' )' \na l t e r n a t i o n ::- e x p r e s s i o n ' |' e x p r e s s i o n \ns e q u e n ce ::- e x p r e s s i o n ' &' e x p r e s s i o n \nrepetitio n : := e x p r e s s i o n ' *' \nliteral ::- ' a ' \\ ' b ' | ' c ' | . . . { 'a' | 'b' | 'c' | . . . } *\nThe s y m b o l e x p r e s s i o n is the start s y m b o l , and l i t e r a l is a termina l symbo l\ndefinin g s i m p l e words\nT he I n t e r p r e t e r patter n u s es a c l a ss to r e p r e s e n t e a ch gramma r r u l e. S y m b o l s on\nt he r i g h t - h a n d s i de of t he rule a re i n s t a n c e variable s of t h e se c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 735, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1000}}
{"id": "computer_science_design_patterns_gof_chunk_0736_36b346d7", "text": "S y m b o l s on\nt he r i g h t - h a n d s i de of t he rule a re i n s t a n c e variable s of t h e se c l a s s e s . T he gramma r\na b o ve is r e p r e s e n t e d by f i ve c l a s s e s : an abstrac t c l a ss RegularExpressio n a nd i ts\nf o ur s u b c l a s s e s L i t e r a l E x p r e s s i o n , A l t e r n a t i o n E x p r e s s i o n , S e q u e n c e E x p r e s s i o n ,\nand RepetitionExpression. The l a s t t h r e e c l a s s e s define variables that hold subex -\np r e s s i o n s . ptg2 4 4 BEHAVIORAL PATTERNS CHAPTER 5\nEvery regula r e x p r e s s i o n define d by t h is gramma r is r e p r e s e n t e d by an abstrac t\nsynta x tree made up of i n s t a n c e s of t h e se c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 736, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 721}}
{"id": "computer_science_design_patterns_gof_chunk_0737_7d6f4f36", "text": "For e x a m p l e , the abstrac t synta x\ntree\nrepresent s the regula r e x p r e s s i o n\nr a i n i ng & ( d o gs | cats) *\nWe can creat e an interprete r for t h e se regula r e x p r e s s i o n s by definin g the Interpre t\noperatio n on e a ch s u b c l a s s of RegularExpression . Interpre t takes as an argumen t\nt he c o n t e x t in w h i c h to interpre t t he e x p r e s s i o n . T he contex t contain s t he input\ns t r i ng a nd informatio n on h ow much of it h as b e en matche d so far. E a ch s u b c l a s s\nof RegularExpressio n implement s Interpre t to matc h the next part of the input\ns t r i n g b a s e d on the current context.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 737, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 657}}
{"id": "computer_science_design_patterns_gof_chunk_0738_b7940a58", "text": "E a ch s u b c l a s s\nof RegularExpressio n implement s Interpre t to matc h the next part of the input\ns t r i n g b a s e d on the current context. F o r example,\n\nptgINTERPRETER 2 4 5\n• LiteralExpressio n will c h e ck if the input matche s the litera l it d e f i n e s ,\n•A l t e r n a t i o n E x p r e s s i o n w i ll c h e ck if t he input m a t c h e s a ny of i ts a l t e r n a t i v e s ,\n•RepetitionExpressio n w i ll c h e ck if t he input h as multipl e c o p i e s of e x p r e s s i o n\ni t repeats,\na n d s o o n . A p p l i c a b i l i t y\nUse the Interprete r patter n when there is a languag e to interpret , and you can\nr e p r e s e n t statement s in the languag e as abstrac t synta x tr ees. The Interprete r\npatter n work s b e st when\n• t he gramma r is s i m p l e . F or c o m p l e x g r a m m a r s , t he c l a ss h i e r a r c h y f or t he\ngramma r b e c o m e s l a r ge and unmanageable .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 738, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_design_patterns_gof_chunk_0739_ab00ead3", "text": "F or c o m p l e x g r a m m a r s , t he c l a ss h i e r a r c h y f or t he\ngramma r b e c o m e s l a r ge and unmanageable . T o o ls s u ch as parse r generator s\nare a bette r alternativ e in s u ch c a s e s . T h ey can interpre t e x p r e s s i o n s withou t\nbuildin g abstrac t synta x t r e e s, whic h can save s p a ce and p o s s i b l y time. • efficienc y is not a critica l c o n c e r n . The m o st efficien t interpreter s are usuall y\nnot implemente d by interpretin g parse t r e es d i r e c t l y but by first translatin g\nthem into anothe r form . For example , regula r e x p r e s s i o n s are often trans-\nforme d i n to state m a c h i n e s . But e v en t h e n, the translator can be implemente d\nby the Interpreter pattern, so the pattern is still applicable.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 739, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 795}}
{"id": "computer_science_design_patterns_gof_chunk_0740_399c52ef", "text": "But e v en t h e n, the translator can be implemente d\nby the Interpreter pattern, so the pattern is still applicable. S t r u c t u r e\nParticipants\n• A b s t r a c t E x p r e s s i o n ( R e g u l a r E x p r e s s i o n )\n- d e c l a r e s an abstrac t Interpre t operatio n that is commo n to all n o d e s in the\nabstract syntax tree. ptg246 BEHAVIORAL PATTERNS CHAPTER 5\n• T e r m i n a l E x p r e s s i o n ( L i t e r a l E x p r e s s i o n )\n-implement s an Interpre t operatio n associate d with termina l s y m b o l s in the\ngrammar. -an i n s t a n c e is r e q u i r e d f or every termina l s y m b o l in a s e n t e n c e . • N o n t e r m i n a l E x p r e s s i o n ( A l t e r n a t i o n E x p r e s s i o n , R e p e t i t i o n E x p r e s s i o n , S e -\nq u e n c e E x p r e s s i o n s )\n- one s u ch c l a ss is require d for every rule R ::= R\\R^ • •. Rn in the grammar.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 740, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_design_patterns_gof_chunk_0741_ff7d91fb", "text": "Rn in the grammar. - maintain s i n s t a n c e variable s of type AbstractExpressio n for e a ch of the\ns y m b o l s RI t h r o u g h Rn. -i m p l e m e n t s an Interpre t operatio n for nontermina l s y m b o l s in the gram-\nmar. Interpre t typicall y c a l ls i t s e lf r e c u r s i v e l y on t he v a r i a b l e s representin g\nRI throug h Jin. • C o n t e x t\n- c o n t a i n s i n f o r m a t i o n that's g l o b a l to t he i n t e r p r e t e r . • C l i e n t\n-build s (or is g i v e n ) an abstrac t synta x t r ee r e p r e s e n t i n g a particula r s e n -\nt e n ce in the languag e that the gramma r defines . The abstrac t synta x tree is\na s s e m b l e d from instances of the NonterminalExpression and T e r m i n a l E x -\np r e s s i o n c l a s s e s . -i n v o k e s the Interpret operation.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 741, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 822}}
{"id": "computer_science_design_patterns_gof_chunk_0742_a8aa3992", "text": "The abstrac t synta x tree is\na s s e m b l e d from instances of the NonterminalExpression and T e r m i n a l E x -\np r e s s i o n c l a s s e s . -i n v o k e s the Interpret operation. C o l l a b o r a t i o n s\n• T he c l i e nt build s ( or is g i v e n ) t he s e n t e n c e as an abstrac t synta x tree of Nonter-\nm i n a l E x p r e s s i o n a nd T e r m i n a l E x p r e s s i o n i n s t a n c e s . T h en t he c l i e n t i n i t i a l i z e s\nthe contex t and i n v o k e s the Interpre t operation. • E a ch NonterminalExpressio n n o de define s Interpre t in term s of Interpre t on\ne a ch s u b e x p r e s s i o n . T he Interpre t operatio n of e a ch T e r m i n a l E x p r e s s i o n d e -\nfines t he base c a se in t he r e c u r s i o n . • The Interpre t operation s at e a ch n o de use the contex t to s t o re and a c c e s s the\nstate of the i n t e r p r e t e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 742, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_design_patterns_gof_chunk_0743_a8d555d2", "text": "• The Interpre t operation s at e a ch n o de use the contex t to s t o re and a c c e s s the\nstate of the i n t e r p r e t e r . C o n s e q u e n c e s\nThe Interprete r patter n has the followin g benefit s and l i a b i l i t i e s :\n1. It's easy to change a nd extend t he grammar. B e c a u s e t he patter n u s es c l a s s e s \nto r e p r e s e n t gramma r r u l e s , you can use inheritanc e to c h a n g e or exten d\nt he grammar . E x i s t i n g e x p r e s s i o n s c an be modifie d i n c r e m e n t a l l y , a nd n ew \ne x p r e s s i o n s can be defined as variations on old ones. ptgINTERPRETER 247\n2. Implementing the grammar is easy, too. C l a s s e s definin g n o d e s in the abstrac t\nsynta x tree have simila r implementations . T h e s e c l a s s e s are easy to write , and\noften t h e ir generatio n can be automate d with a compile r or parse r generator. 3. Complex grammars are hard to maintain.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 743, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_design_patterns_gof_chunk_0744_053fa2b4", "text": "T h e s e c l a s s e s are easy to write , and\noften t h e ir generatio n can be automate d with a compile r or parse r generator. 3. Complex grammars are hard to maintain. The Interprete r patter n define s at least\none c l a ss for every rule in the gramma r (gramma r rules define d using BNF\nmay requir e multipl e c l a s s e s ) . H e n c e grammar s containin g many rules can\nbe hard to manag e and maintain . Othe r d e s i g n pattern s can be applie d to\nmitigat e the proble m ( s ee Implementation) . But when the gramma r is very\nc o m p l e x , other technique s such as parse r or compile r generator s are more\nappropriate. 4. Adding new ways to interpret expressions. The Interprete r patter n make s it\ne a s i e r to evaluat e an e x p r e s s i o n in a new way. For e x a m p l e , you can suppor t\np r e t t y printin g or type-checkin g an expressio n by definin g a new operatio n\non t he e x p r e s s i o n c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 744, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_design_patterns_gof_chunk_0745_eb0645d8", "text": "For e x a m p l e , you can suppor t\np r e t t y printin g or type-checkin g an expressio n by definin g a new operatio n\non t he e x p r e s s i o n c l a s s e s . If y ou k e ep c r e a t i n g n ew ways of i n t e r p r e t i n g an\ne x p r e s s i o n , then conside r using the Visito r ( 3 3 1) p a t t e r n to avoid changin g\nthe grammar classes. Implementation\nThe Interprete r and Composit e ( 1 6 3) pattern s share many implementatio n i s s u e s . The followin g i s s u e s are specifi c to Interpreter:\n1.Creating the abstract syntax tree. The Interprete r patter n doesn' t explai n how to\ncreate an abstrac t synta x tree. In other words , it doesn' t addres s parsing . The\nabstrac t synta x tree can be create d by a table-drive n parser , by a hand-crafte d\n(usuall y recursiv e descent ) parser , or directl y by the client. 2.Defining the Interpret operation. You don't have to defin e the Interpre t o p e r -\nation in the e x p r e s s i o n c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 745, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_design_patterns_gof_chunk_0746_bd874664", "text": "2.Defining the Interpret operation. You don't have to defin e the Interpre t o p e r -\nation in the e x p r e s s i o n c l a s s e s . If it's commo n to creat e a new interpreter ,\nthen it's bette r to use the Visito r ( 3 3 1) patter n to put Interpre t in a separat e\n\"visitor \" object . For example , a gramma r for a programmin g languag e will\nhave many operation s on abstrac t synta x t r e e s, such as as t y p e - c h e c k i n g , op-\nt i m i z a t i o n , c o de g e n e r a t i o n , a nd so o n. It will be m o re l i k e ly to u se a v i s i t o r\nto avoid definin g t h e se operation s on ever y gramma r c l a s s . 3.Sharing terminal symbols with the Flyweight pattern. Grammar s w h o s e s e n t e n c e s\ncontai n many occurrence s of a termina l symbo l migh t benefi t from sharin g\na s i n g le c o py of that s y m b o l . Grammar s for compute r program s are g o od\nexamples—eac h progra m variabl e will appea r in many place s throughou t the\nc o d e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 746, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_design_patterns_gof_chunk_0747_41a32145", "text": "Grammar s for compute r program s are g o od\nexamples—eac h progra m variabl e will appea r in many place s throughou t the\nc o d e. In the Motivatio n example , a s e n t e n c e can have the termina l symbo l\nd og ( m o d e l e d by t he L i t e r a l E x p r e s s i o n c l a s s) appearin g many t i m e s . Termina l n o d e s generall y don't store informatio n abou t their positio n in the\na b s t r a c t synta x t r e e. P a r e n t n o d e s p a ss them w h a t e v e r c o n t e x t t h ey n e ed\ndurin g interpretation . H e n c e there is a distinctio n betwee n share d (intrinsic )\nstate and passed-in ( e x t r i n s i c ) state, and the Flyweight (195) pattern applies. ptg248 BEHAVIORAL PATTERNS CHAPTERS\nFor e x a m p l e , e a ch i n s t a n c e of LiteralExpressio n for dog r e c e i v e s a contex t\nc o n t a i n i n g t he substrin g matche d so far.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 747, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_design_patterns_gof_chunk_0748_702d6c14", "text": "ptg248 BEHAVIORAL PATTERNS CHAPTERS\nFor e x a m p l e , e a ch i n s t a n c e of LiteralExpressio n for dog r e c e i v e s a contex t\nc o n t a i n i n g t he substrin g matche d so far. A nd e v e ry s u ch LiteralExpressio n\nd o es t he s a me thing in i ts Interpre t operation—i t c h e c k s whethe r t he n e xt\npart of the input c o n t a i n s a dog—n o matte r wher e the i n s t a n c e appear s in\nt h e tree. S a m p l e C o d e\nHere a re t wo e x a m p l e s . T he f i r st is a c o m p l e t e exampl e in S m a l l t a l k f or c h e c k i n g\nwhethe r a s e q u e n c e m a t c h e s a r e g u l a r e x p r e s s i o n . T he s e c o n d is a C ++ progra m\nfor evaluatin g B o o l e a n e x p r e s s i o n s . T he regula r e x p r e s s i o n matche r tests whethe r a s t r i ng is in t he l a n g u a g e define d\nby t he regula r e x p r e s s i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 748, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 876}}
{"id": "computer_science_design_patterns_gof_chunk_0749_afd4c739", "text": "T he regula r e x p r e s s i o n matche r tests whethe r a s t r i ng is in t he l a n g u a g e define d\nby t he regula r e x p r e s s i o n . T he regula r e x p r e s s i o n is define d by t he followin g\ngrammar:\ne x p r e s s i o n : := literal | alternatio n | s e q u e n ce | repetitio n |\n' (' e x p r e s s i o n ' )' \na l t e r n a t i o n : := e x p r e s s i o n ' ]' e x p r e s s i o n \ns e q u e n ce ::= e x p r e s s i o n ' &' e x p r e s s i o n \nrepetitio n ::- e x p r e s s i o n ' r e p e a t' \nliteral : : = ' a ' | 'b' | ' c ' | ... { ' a ' | 'b' | ' c ' | ... }*\nT h is gramma r is a s l i g ht modificatio n of t he Motivatio n example . We c h a n g e d\nt he c o n c r e t e synta x of r e g u l a r e x p r e s s i o n s a l i t t l e, b e c a u s e s y m b o l \" *\" can't be\na postfi x operatio n in Smalltalk . So we use r e p e a t i n s t e a d .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 749, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 883}}
{"id": "computer_science_design_patterns_gof_chunk_0750_ea5e4aa0", "text": "So we use r e p e a t i n s t e a d . For e x a m p l e , the\nregular expression\n( ( ' d o g ' | ' c a t ') r e p e a t & 'weather')\nmatche s the input s t r i ng \" d og dog cat w e a t h e r \" . To i m p l e m e n t t he matcher , we defin e t he f i ve c l a s s e s d e s c r i b e d on\np a ge 2 4 3. T he c l a ss SequenceExpressio n h as i n s t a n c e v a r i a b l e s expres-\nsion ! and e x p r e s s i o n 2 for its c h i l d r e n in the abstrac t synta x t r e e. A l t e r n a t i o n E x p r e s s i o n s t o r e s its a l t e r n a t i v e s in the i n s t a n c e v a r i a b l e s\na l t e r n a t i v e l and a l t e r n a t i v e 2 , w h i le R e p e t i t i o n E x p r e s s i o n h o l d s the\ne x p r e s s i o n it r e p e a t s in its r e p e t i t i o n i n s t a n c e v a r i a b l e . L i t e r a l E x p r e s s i o n has\na c o m p o n e n t s i n s t a n c e variabl e that h o l ds a l i st of o b j e c t s (probabl y characters) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 750, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_design_patterns_gof_chunk_0751_022756e6", "text": "L i t e r a l E x p r e s s i o n has\na c o m p o n e n t s i n s t a n c e variabl e that h o l ds a l i st of o b j e c t s (probabl y characters) . T h e se r e p r e s e n t the l i t e r a l s t r i ng that must matc h the input s e q u e n c e . T he m a t c h : o p e r a t i o n i m p l e m e n t s an i n t e r p r e t e r f or t he r e g u l a r e x p r e s s i o n . E a ch of t he c l a s s e s d e f i n i n g t he abstrac t synta x t r ee implement s t h is o p e r a t i o n . It\ntakes i n p u t S t a te as an argumen t r e p r e s e n t i n g the curren t state of the matchin g\np r o c e s s , havin g read part of t he input s t r i n g . T h is curren t state is characterize d by a s et of i n p ut stream s r e p r e s e n t i n g t he s et\nof input s that t he regula r e x p r e s s i o n c o u ld have a c c e p t e d so far.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 751, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 850}}
{"id": "computer_science_design_patterns_gof_chunk_0752_757feba1", "text": "T h is curren t state is characterize d by a s et of i n p ut stream s r e p r e s e n t i n g t he s et\nof input s that t he regula r e x p r e s s i o n c o u ld have a c c e p t e d so far. ( T h is is r o u g h l y\ne q u i v a l e n t to r e c o r d i n g all states that the e q u i v a l e n t finite state automat a woul d\nb e in, h a v i n g recognized t h e input stream to this point). ptgINTERPRETER 2 4 9\nT he c u r r e n t state is m o st i m p o r t a n t to t he r e p e a t o p e r a t i o n . F or e x a m p l e , if t he\nr e g u l a r e x p r e s s i o n w e r e\n' a' repeat\nt h en t he i n t e r p r e t e r c o u ld m a t c h \" a \", \" a a \" , \" a a a \" , a nd so o n. If it w e r e\n' a' r e p e a t & ' b e '\nt h en it c o u ld m a t c h \" a b c \" , \" a a b c \" , \" a a a b c \" , a nd so o n.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 752, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 812}}
{"id": "computer_science_design_patterns_gof_chunk_0753_9ac2e5ca", "text": "If it w e r e\n' a' r e p e a t & ' b e '\nt h en it c o u ld m a t c h \" a b c \" , \" a a b c \" , \" a a a b c \" , a nd so o n. B ut if t he r e g u l a r e x -\np r e s s i o n w e r e\n' a' r e p e a t & ' a b c '\nt h en m a t c h i n g t he i n p u t \" a a b c \" a g a i n s t t he s u b e x p r e s s i o n \"' a' r e p e a t \" w o u l d\ny i e ld t wo i n p u t s t r e a m s , o ne h a v i n g m a t c h e d o ne c h a r a c t e r of t he i n p u t , a nd t he\no t h er h a v i n g m a t c h e d t wo c h a r a c t e r s . O n ly t he s t r e a m that h as a c c e p t e d o ne\nc h a r a c t e r will m a t c h t he r e m a i n i n g \" a b c \" . N ow we c o n s i d e r t he d e f i n i t i o n s of m a t c h : f or e a ch c l a ss d e f i n i n g t he r e g u -\nl ar e x p r e s s i o n . T he d e f i n i t i o n f or SequenceExpressio n m a t c h e s e a ch of i ts\ns u b e x p r e s s i o n s in s e q u e n c e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 753, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_design_patterns_gof_chunk_0754_046b228e", "text": "T he d e f i n i t i o n f or SequenceExpressio n m a t c h e s e a ch of i ts\ns u b e x p r e s s i o n s in s e q u e n c e . U s u a l l y it will e l i m i n a t e i n p u t s t r e a m s f r om i ts\ni n p u t S t a t e . match: inputStat e \n\" e x p r e s s i o n 2 match: ( e x p r e s s i o n l match: i n p u t S t a t e ) . An A l t e r n a t i o n E x p r e s s i o n will r e t u r n a state that c o n s i s t s of the\nu n i on of state s f r om e i t h e r alternative . T he d e f i n i t i o n of m a t c h : f o r\nA l t e r n a t i o n E x p r e s s i o n is\nm a t c h : i n p u t S t a t e \nI f i n a l S t a t e I \nf i n a l S t a t e := a l t e r n a t i v e l m a t c h : i n p u t S t a t e . f i n a l S t a t e a d d A l l : ( a l t e r n a t i v e 2 m a t c h : i n p u t S t a t e ) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 754, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 808}}
{"id": "computer_science_design_patterns_gof_chunk_0755_9227d5f2", "text": "f i n a l S t a t e a d d A l l : ( a l t e r n a t i v e 2 m a t c h : i n p u t S t a t e ) . ~ f i n a l S t a t e\nThe mat c h: o p e r a t i o n for R e p e t i t i onExpr e s s i on t r i es to find as m a ny state s\nt h at c o u ld m a t c h as p o s s i b l e :\nmatch: inputStat e \nI aState finalStat e I \naState := inputState . finalStat e := inputStat e copy. [ a S t a te isEmpty]\nwhileFalse : \n[ a S t a te := repetitio n match: aState. finalState addAll: a S t a t e ] . \" f i n a l S t a t e\n\nptg250 BEHAVIORAL PATTERNS CHAPTER 5\nIts outpu t state usuall y contain s more states than its input s t a t e, b e c a u s e\na R e p e t i t i o n E x p r e s s i o n can matc h o n e, two, or many o c c u r r e n c e s of\nr e p e t i t i o n on the input state. The outpu t states represen t all t h e se p o s s i b i l -\ni t i e s, a l l o w i n g subsequen t e l e m e n t s of t he regula r e x p r e s s i o n to d e c i d e w h i c h\nstate is t he correc t o n e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 755, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_design_patterns_gof_chunk_0756_9b67f021", "text": "F i n a l l y , the definitio n of m a t c h : for L i t e r a l E x p r e s s i o n tries to matc h its\ncomponent s a g a i n s t e a ch p o s s i b l e input stream . It keeps o n ly t h o se input stream s \nthat have a match:\nmatch: inputStat e \n| finalStat e t S t r e am | \nfinalStat e := S et n e w. inputState\ndo: \n[ : s t r e am | tStream := s t r e am c o p y . ( t S t r e am n e x t A v a i l a b l e :\nc o m p o n e n t s s i z e\n) = c o m p o n e n t s \ni f T r u e: [ f i n a l S t a t e a d d: tStream]\n] . \" finalState\nT he n e x t A v a i l a b l e : m e s s a g e advance s t he input stream . T h is is t he o n ly\nm a t c h : operatio n that advance s the stream . N o t i c e how the state that's returne d\nc o n t a i n s a copy of the input stream , thereb y e n s u r i n g that matchin g a litera l\nnever c h a n g e s t he input stream .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 756, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 863}}
{"id": "computer_science_design_patterns_gof_chunk_0757_07c9e7af", "text": "N o t i c e how the state that's returne d\nc o n t a i n s a copy of the input stream , thereb y e n s u r i n g that matchin g a litera l\nnever c h a n g e s t he input stream . T h is is importan t becaus e e a ch alternativ e of an \nA l t e r n a t i o n E x p r e s s i o n s h o u l d see identica l c o p i e s of the input stream. Now that we've define d the c l a s s e s that make up an abstrac t synta x t r e e, we can\nd e s c r i b e how to build it. Rathe r than write a parse r for regula r e x p r e s s i o n s , w e ' ll\ndefin e s o me operation s on the R e g u l a r E x p r e s s i o n c l a s s e s so that evaluatin g\na Smalltal k e x p r e s s i o n will produc e an abstrac t synta x tree for the c o r r e s p o n d i n g\nregula r e x p r e s s i o n . That l e ts us u se t he b u i l t - i n S m a l l t a l k c o m p i l e r as if it were a\nparse r for regula r e x p r e s s i o n s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 757, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 913}}
{"id": "computer_science_design_patterns_gof_chunk_0758_cc1e76e5", "text": "That l e ts us u se t he b u i l t - i n S m a l l t a l k c o m p i l e r as if it were a\nparse r for regula r e x p r e s s i o n s . To build t he abstrac t synta x t r e e, we'll n e ed to defin e \" | \", \"repeat\" , a nd \"&\"\nas operation s on R e g u l a r E x p r e s s i o n . T h e se operation s a re define d in c l a ss\nR e g u l a r E x p r e s s i o n like this:\n& aNode\n\" S e q u e n c e E x p r e s s i o n new \ne x p r e s s i o n l : s e l f expression2: aNode asRExp\nr e p e a t\nRepetitionExpression new repetition: self\n\nptgINTERPRETER 251\n| aNode\nA l t e r n a t i o n E x p r e s s i o n n ew \nalternativel : s e lf alternative2 : a N o de a s R E x p\na s R E xp \n~ self\nThe a s R E x p operatio n w i ll conver t literal s i n to R e g u l a r E x p r e s s i o n s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 758, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 787}}
{"id": "computer_science_design_patterns_gof_chunk_0759_ffd36e6c", "text": "T h e se\noperations are defined in class String:\n& aNode\nS e q u e n c e E x p r e s s i o n n ew \ne x p r e s s i o n l : s e l f a s R E x p expression2: aNode asRExp\nr e p e a t\nRepetitionExpressio n n ew repetition : s e l f\n| a N o d e\nA l t e r n a t i o n E x p r e s s i o n n ew \nalternativel: self asRExp alternative2: aNode asRExp\na s R E x p\nL i t e r a l E x p r e s s i o n n e w components: self\nIf we define d t h e se operation s h i g h e r up in the c l a ss h i e r a r c h y ( S e q u e n c e a b l e -\nC o l l e c t i o n in S m a l l t a l k - 8 0 , I n d e x e d C o l l e c t i o n in Smalltalk/V) , then they\nwoul d a l so be define d f or c l a s s e s s u ch as A r r a y a nd O r d e r edCo 11 a ct ion. T h is\nwoul d l et regula r e x p r e s s i o n s matc h s e q u e n c e s of a ny k i nd of o b j e c t . T he s e c o n d exampl e is a s y s t e m for manipulatin g a nd evaluatin g B o o l e a n e x p r e s -\ns i o ns i m p l e m e n t e d in C++.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 759, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_design_patterns_gof_chunk_0760_8e2df655", "text": "T he s e c o n d exampl e is a s y s t e m for manipulatin g a nd evaluatin g B o o l e a n e x p r e s -\ns i o ns i m p l e m e n t e d in C++. T he t e r m i n a l s y m b o l s in t h is l a n g u a g e a re B o o l e a n\nv a r i a b l e s , that is, the c o n s t a n t s t r ue and f a l s e . N o n t e r m i n a l s y m b o l s r e p r e s e n t\ne x p r e s s i o n s c o n t a i n i n g the operator s and, or, and n o t. The gramma r is d e f i n e d\na s follows 1:\nB o o l e a n E x p : := VariableEx p | C o n s t a nt | O r E xp | A n d E xp | NotExp |\n' (' B o o l e a n E x p ' ) '\nA n d E xp ::- B o o l e a n E x p ' a n d' B o o l e a n E x p \nO r E xp : := B o o l e a n E x p ' o r' B o o l e a n E x p \nN o t E xp : := ' n o t' B o o l e a n E x p \nC o n s t a n t : : = ' t r u e ' | ' f a l s e '\nVariableExp : : = ' A ' j ' B ' | . . . | ' X ' | 'Y' | 'Z'\nWe defin e two operation s on B o o l e a n e x p r e s s i o n s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 760, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_design_patterns_gof_chunk_0761_db1d21c6", "text": ". . | ' X ' | 'Y' | 'Z'\nWe defin e two operation s on B o o l e a n e x p r e s s i o n s . The first, E v a l u a t e , evaluate s\na B o o l e a n e x p r e s s i o n in a c o n t e x t that a s s i g n s a true or false v a l ue to e a ch v a r i a b l e . T he s e c o n d operation , R e p l a c e , p r o d u c e s a n ew B o o l e a n e x p r e s s i o n by r e p l a c i n g\na variabl e with an e x p r e s s i o n . R e p l a c e s h o w s how the Interprete r patter n can\nbe u s ed for more than j u st e v a l u a t i n g e x p r e s s i o n s . In t h is c a s e, it manipulate s the\ne x p r e s s i o n itself. 1 F or s i m p l i c i t y , we i g n o r e operato r p r e c e d e n c e a nd a s s u m e it's t he r e s p o n s i b i l i t y of w h i c h e v e r o b j e c t\nconstructs the syntax tree. ptg2 52 B E H A V I O R A L PATTERNS CHAPTER 5\nWe g i ve d e t a i l s of just the B o o l e a n E x p , V a r i a b l e E x p , and AndEx p c l a s s e s\nh e r e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 761, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_design_patterns_gof_chunk_0762_eb455518", "text": "ptg2 52 B E H A V I O R A L PATTERNS CHAPTER 5\nWe g i ve d e t a i l s of just the B o o l e a n E x p , V a r i a b l e E x p , and AndEx p c l a s s e s\nh e r e. C l a s s e s O r E x p and N o t E x p are simila r to AndExp . The C o n s t a n t c l a ss\nr e p r e s e n t s the Boolean c o n s t a n t s . B o o l e a n E x p defines the interface for all c l a s s e s t h a t d e f i n e a Boolean expression:\nc l a ss B o o l e a n E x p {\npublic:\nB o o l e a n E x p ( ) ; \nvirtual \" B o o l e a n E x p ( ) ;\nvirtual bool Evaluate(Contexts ) = 0; \nvirtual B o o l e a n E x p * Replace(cons t char*, BooleanExpS ) - 0;\nv i r t u a l B o o l e a n E x p * CopyO c o n s t = 0;\n} ;\nThe c l a ss C o n t e x t d e f i n e s a mappin g from variable s to B o o l e a n values , whic h we\nr e p r e s e n t with the C++ constant s t r ue and f a l s e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 762, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 857}}
{"id": "computer_science_design_patterns_gof_chunk_0763_93426b3f", "text": "C o n t e x t has the followin g\ni n t e r f a c e :\nclass C o n t e xt {\npublic:\nbool Lookup(cons t char*) const;\nv o i d Assign(VariableExp*, b o o l ) ;\n} ;\nA VariableExp represents a named v a r i a b l e :\nc l a ss VariableEx p : public B o o l e a n E x p {\npublic:\nV a r i a b l e E x p ( c o n s t char*);\nvirtual \" V a r i a b l e E x p ( ) ;\nvirtual bool E v a l u a t e ( C o n t e x t s ) ; \nvirtual BooleanExp * Replace(cons t c h a r *, B o o l e a n E x p S ) ;\nvirtual BooleanExp * C o p y () const;\nprivate: \nc h a r * _ n a m e ;\n} ;\nThe constructor takes t h e variable's name a s a n a r g u m e n t :\nV a r i a b l e E x p : : V a r i a b l e E x p ( c o n st c h a r* name) {\n_name = strdup(name) ;\n}\nEvaluating a variable returns i t s value i n t h e current c o n t e x t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 763, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 798}}
{"id": "computer_science_design_patterns_gof_chunk_0764_2a0b2a56", "text": "bool VariableExp::Evaluat e ( C o n t e x ts aContext ) {\nr e t u r n aContext.Lookup(_name);\n}\n\nptgINTERPRETER 2 53\nC o p y i n g a v a r i a b l e r e t u r n s a new V a r i a b l e E x p :\nBooleanExp * VariableExp::Cop y () c o n st {\nr e t u r n new VariableExp(_name);\n}\nTo r e p l a c e a variabl e with an e x p r e s s i o n , we c h e ck to s ee if t he variabl e h as t he\nsame name as the one it is passed as an argument:\nBooleanExp * VariableExp::Replac e (\nconst char* name, B o o l e a n E x p & exp\n) {\nif ( s t r c m p ( n a m e , _name) = =0) {\nreturn exp.Copy();\n} else { \nr e t u rn n ew VariableExp(_name);\n}\n}\nAn A n d E x p represent s an e x p r e s s i o n made by A N D i n g two B o o l e a n e x p r e s s i o n s\ntogether.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 764, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 751}}
{"id": "computer_science_design_patterns_gof_chunk_0765_e75958c5", "text": "class A n d E xp : public BooleanEx p {\npublic:\nAndExp(BooleanExp* , BooleanExp*) ;\nvirtual ~AndExp();\nvirtual bool Evaluate(Contexts) ; \nvirtual BooleanExp * Replace(cons t char*, B o o l e a n E x p & ) ;\nvirtual B o o l e a n E x p * CopyO const;\nprivate:\nBooleanExp * _operandl;\nBooleanExp * _operand2;\n} ;\nAndExp::AndEx p ( B o o l e a n E x p * opl, B o o l e a n E x p * op2) {\n_operand l = opl;\n_operand2 = op2;\n}\nEvaluatin g an A n d E x p evaluate s its operand s and return s the l o g i c a l \" a n d \" of the\nr e s u l t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 765, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 537}}
{"id": "computer_science_design_patterns_gof_chunk_0766_58f63164", "text": "bool AndExp::Evaluat e ( C o n t e x ts aContext ) {\nr e t u r n\n_operandl->Evaluate(aContext ) &&\n_operand2->Evaluate(aContext);\n}\nAn AndEx p implement s Copy and R e p l a c e by makin g r e c u r s i v e c a l ls on its\noperands:\n\nptg254 BEHAVIORAL P A T T E R N S CHAPTERS\nB o o l e a n E x p * A n d E x p : : C o p y () c o n st {\nr e t u r n\nn ew A n d E x p ( _ o p e r a n d l - > C o p y ( ) , _ o p e r a n d 2 - > C o p y ( ) ) ;\n}\nB o o l e a n E x p * AndExp::Replac e ( c o n st c h a r* n a m e, B o o l e a n E x p & e x p) {\nr e t u r n\nn ew A n d E x p( \n_operandl->Replace(name , e x p ),\n_operand2->Replace(name , e x p )\n) ;\n}\nN o w w e c a n define t h e Boolean expression\n( t r u e a n d x ) o r ( y a n d ( n o t x ))\nand evaluat e it for a g i v en a s s i g n m e n t of t r ue or f a l se to the v a r i a b l e s x and\ny :\nB o o l e a n E x p * e x p r e s s i o n ;\nC o n t e xt context;\nVariableExp * x = new VariableExp(\"X\") ;\nVariableExp * y - new VariableExp(\"Y\");\ne x p r e s s i o n = new O r E x p( \nn ew A n d E x p ( n e w Constant(true) , x), \nn ew A n d E x p ( y , n ew N o t E x p ( x ) )\n) ;\ncontext.Assign(x , false);\nc o n t e x t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 766, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1179}}
{"id": "computer_science_design_patterns_gof_chunk_0767_201a6ee9", "text": "A s s i g n ( y , t r u e ) ;\nbool r e s u lt = expression->Evaluate(context);\nThe e x p r e s s i o n evaluate s to t r ue for t h is a s s i g n m e n t to x and y. We can evaluat e\nthe e x p r e s s i o n with a differen t a s s i g n m e n t to the v a r i a b l e s s i m p l y by c h a n g i n g\nt he c o n t e x t . F i n a l l y , we can r e p l a c e the variabl e y with a new e x p r e s s i o n and then reevaluat e\ni t :\nV a r i a b l e E x p * z = new VariableExp(\"Z\") ;\nNotExp not_z(z);\nB o o l e a n E x p * replacemen t = expression->Replace(\"Y\" , not_z);\ncontext.Assign(z , true);\nr e s u lt = replacement->Evaluate(context);\nT h is e x a m p l e i l l u s t r a t e s an i m p o r t a n t p o i nt a b o u t t he I n t e r p r e t e r p a t t e r n : m a ny\nk i n d s o f operations c a n \"interpret\" a sentence.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 767, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 831}}
{"id": "computer_science_design_patterns_gof_chunk_0768_ad2d9775", "text": "O f t h e t h r e e o p e r a t i o n s d e f i n e d\n\nptgINTERPRETER 2 5 5\nfor BooleanExp , E v a l u a t e fits our i d ea of what an interprete r s h o u l d do m o st\nclosely—tha t i s, it interpret s a progra m or e x p r e s s i o n and return s a simpl e result. However , R e p l a c e can be viewe d as an interprete r as well. It's an interprete r\nwhos e contex t is the name of the variabl e being replace d along with the e x p r e s s i o n\nthat r e p l a c e s it, and whos e resul t is a new e x p r e s s i o n . E v en Copy can be though t\nof as an interprete r with an empt y context . It may s e em a little strang e to conside r\nR e p l a c e and Copy to be interpreters , becaus e t h e se are j u st basic operation s\non t r e e s. T he e x a m p l e s in V i s i t o r ( 3 3 1) illustrat e h ow a ll t h r ee o p e r a t i o n s c an be\nrefactore d into a separat e \"interpreter \" visitor , thus showin g that the similarit y is\ndeep.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 768, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 957}}
{"id": "computer_science_design_patterns_gof_chunk_0769_0315213d", "text": "The Interprete r patter n is more than j u st an operatio n distribute d o v er a c l a ss\nhierarch y that u s es the Composit e ( 1 6 3) pattern . We c o n s i d e r E v a l u a t e an in-\nterprete r becaus e we think of the B o o l e a n E x p c l a ss hierarch y as representin g a\nlanguage . G i v e n a simila r c l a ss hierarch y for representin g automotiv e p a rt assem-\nb l i e s, i t 's u n l i k e l y we'd c o n s i d e r o p e r a t i o n s l i ke W e i g h t a nd Copy as i n t e r p r e t e r s \ne v en thoug h they are distribute d o v er a c l a ss hierarch y that uses the C o m p o s -\nite pattern—w e j u st don't think of automotiv e parts as a language . It's a matte r\nof perspective ; if we starte d publishin g grammar s of automotiv e parts , then we\nc o u l d c o n s i d e r o p e r a t i o n s on those parts to be ways of i n t e r p r e t i n g the language.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 769, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 891}}
{"id": "computer_science_design_patterns_gof_chunk_0770_1bb19e6f", "text": "K n o w n U s e s\nT he I n t e r p r e t e r patter n is w i d e l y u s ed in c o m p i l e r s i m p l e m e n t e d with o b j e c t -\no r i e n t e d languages , as the Smalltal k c o m p i l e r s are. S P E C T a l k u s es the patter n to\ninterpre t description s of input file f o r m a t s [ S z a 9 2 ] . The Q O C A constraint-solvin g\ntoolki t u s es it to evaluat e constraint s [ H H M V 9 2 ] . C o n s i d e r e d in its most genera l f o rm ( i . e ., an operatio n distribute d over a c l a ss\nhierarch y based on the C o m p o s i t e pattern) , nearl y every use of the Composit e\npatter n w i ll also contai n the Interprete r pattern . But the Interprete r patter n s h o u l d\nbe r e s e r v e d f or t h o se c a s es in w h i c h y ou want to think of t he c l a ss h i e r a r c h y as\ndefining a language. Related Patterns\nC o m p o s i t e ( 1 6 3 ) : The abstrac t synta x tree is an instanc e of the Composit e pattern.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 770, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_design_patterns_gof_chunk_0771_40316a78", "text": "Related Patterns\nC o m p o s i t e ( 1 6 3 ) : The abstrac t synta x tree is an instanc e of the Composit e pattern. Flyweigh t ( 1 9 5) s h o w s how to share termina l symbol s withi n the abstrac t synta x\ntree. Iterato r ( 2 5 7 ) : The interprete r can use an Iterato r to travers e the structure. Visito r ( 3 3 1) can be u s ed to maintai n the behavio r in e a ch node in the abstrac t\nsyntax tree in one class. ptg\nThis page intentionally left blank \n\nptgITERATOR 257\nI T E R A T O R O b j e c t Behavioral\nI n t e n t\nP r o v i d e a w ay to a c c e s s t he e l e m e n t s of an a g g r e g a t e o b j e c t s e q u e n t i a l l y w i t h o u t\ne x p o s i n g its underlying representation. A l s o Known As\nC u r s o r\nMotivation\nAn a g g r e g a t e o b j e c t s u ch as a l i st s h o u l d g i ve y ou a w ay to a c c e s s i ts e l e m e n t s\nwithou t e x p o s i n g its i n t e r n a l structure .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 771, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_design_patterns_gof_chunk_0772_afb1b2fc", "text": "M o r e o v e r , you m i g h t want to travers e the\nl i st in differen t w a y s , d e p e n d i n g on what you want to a c c o m p l i s h . But you p r o b -\na b ly don't want to b l o at the L i st interfac e with operation s for differen t traversals ,\ne v en if y ou c o u ld anticipat e t he o n es y ou w i ll n e e d. Y ou m i g h t a l so n e ed to have\nm o re than o ne t r a v e r s a l p e n d i n g on t he s a me l i s t . T he Iterato r patter n l e ts y ou do a ll t h i s. T he k ey i d ea in t h is patter n is to take t he\nr e s p o n s i b i l i t y f or a c c e s s a nd traversa l o ut of t he l i st o b j e c t a nd p ut it into an i t e r a t o r\no b j e c t . T he Iterato r c l a ss define s an interfac e f or a c c e s s i n g t he l i s t 's e l e m e n t s . An\ni t e r a t o r o b j e c t is r e s p o n s i b l e f or k e e p i n g t r a ck of t he c u r r e n t e l e m e n t ; that i s, it\nknows which elements have been traversed already.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 772, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_design_patterns_gof_chunk_0773_dd99a950", "text": "An\ni t e r a t o r o b j e c t is r e s p o n s i b l e f or k e e p i n g t r a ck of t he c u r r e n t e l e m e n t ; that i s, it\nknows which elements have been traversed already. For example, a List class would call for a Listlterator with the following relation -\ns h i p b e t w e e n t h e m :\nBefor e y ou c an i n s t a n t i a t e L i s t l t e r a t o r , y ou must suppl y t he L i st to traverse . O n ce\ny ou have t he Listlterato r i n s t a n c e , y ou c an a c c e s s t he l i s t 's e l e m e n t s s e q u e n t i a l l y . T he Currentlte m operatio n return s t he curren t e l e m e n t in t he l i s t, F i r st i n i t i a l i z e s\nthe curren t e l e m e n t to the first e l e m e n t , Next advance s the curren t e l e m e n t to\nt he n e xt e l e m e n t , a nd I s D o n e t e s ts w h e t h e r w e ' ve a d v a n c e d b e y o n d t he l a st\nelement—that is, we're finished with the traversal.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 773, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_design_patterns_gof_chunk_0774_5a6d5c65", "text": "ptg2 5 8 BEHAVIORAL PATTERNS CHAPTER 5\nS e p a r a t i n g t he t r a v e r s a l m e c h a n i s m from t he L i st o b j e c t l e ts us d e f i n e i t e r a t o r s\nf or differen t traversa l p o l i c i e s withou t enumeratin g them in the L i st interface . For\ne x a m p l e , FilteringListlterato r migh t p r o v i d e a c c e s s only to those e l e m e n t s that\ns a t i s f y s p e c i f i c f i l t e r i n g c o n s t r a i n t s . Not ic e that the iterato r and the l i st are c o u p l e d , and the c l i e nt must know that\nit is a list that's t r a v e r s e d as o p p o s e d to s o me o t h er a g g r e g a t e s t r u c t u r e . H e n c e\nthe c l i e nt commit s to a particula r aggregat e structure . It woul d be bette r if we\nc o u ld chang e t he aggregat e c l a ss withou t changin g c l i e nt c o d e. We c an do this by\ng e n e r a l i z i n g t he i t e r a t o r c o n c e p t to s u p p o r t p o l y m o r p h i c i t e r a t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 774, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_design_patterns_gof_chunk_0775_5bd2f550", "text": "We c an do this by\ng e n e r a l i z i n g t he i t e r a t o r c o n c e p t to s u p p o r t p o l y m o r p h i c i t e r a t i o n . As an e x a m p l e , l e t 's assum e that we a l so have a S k i p L i s t implementatio n of a\nl i s t. A s k i p l i s t [ P u g 9 0 ] is a p r o b a b i l i s t i c data structur e with c h a r a c t e r i s t i c s s i m i l a r\nto balance d t r e e s. We want to be a b le to write c o d e that work s for both L i st and\nS k i p L i s t objects. We defin e an AbstractLis t c l a ss that p r o v i d e s a c o m m o n interfac e for manipulatin g\nl i s t s. S i m i l a r l y , we n e ed an abstrac t Iterato r c l a ss that define s a commo n iteratio n\ninterface . T h en we can defin e c o n c r e t e Iterato r s u b c l a s s e s for the differen t l i st\nimplementations . As a r e s u l t , the iteratio n mechanis m b e c o m e s independen t of\nc o n c r e t e aggregate classes. The remainin g p r o b l e m is how to creat e the iterator .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 775, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_design_patterns_gof_chunk_0776_cd2a9c38", "text": "As a r e s u l t , the iteratio n mechanis m b e c o m e s independen t of\nc o n c r e t e aggregate classes. The remainin g p r o b l e m is how to creat e the iterator . S i n ce we want to write c o d e\nthat's i n d e p e n d e n t of t he c o n c r e t e L i st s u b c l a s s e s , we c a n n o t s i m p l y instantiat e\na s p e c i f i c c l a s s. Instead , we make the l i st o b j e c t s r e s p o n s i b l e for creatin g their\ncorrespondin g iterator . T h is r e q u i r e s an operatio n l i ke Createlterato r throug h\nw h i c h c l i e n t s r e q u e s t an iterato r o b j e c t . Createlterato r is an exampl e of a f a c t o r y metho d ( s ee Factor y Metho d ( 1 0 7 ) ) . We\nu se it h e re to l et a c l i e nt a sk a l i st o b j e c t f or t he a p p r o p r i a t e i t e r a t o r . T he F a c t o r y\nMetho d approac h g i ve rise to two c l a ss h i e r a r c h i e s , one f or l i s ts and anothe r f or\niterators.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 776, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_design_patterns_gof_chunk_0777_2467cdbe", "text": "T he F a c t o r y\nMetho d approac h g i ve rise to two c l a ss h i e r a r c h i e s , one f or l i s ts and anothe r f or\niterators. The Createlterator factory method \"connects\" t h e t w o hierarchies. ptgITERATOR 259\nApplicability\nUse the Iterato r pattern\n• to a c c e s s an agg re ga t e o b j e c t ' s con t ent s withou t e x p o s i n g its interna l r e p r e -\ns e n t a t i o n . •to suppor t multipl e traversal s of aggregat e o b j e c t s . •to provid e a unifor m interfac e for traversin g differen t aggregat e structure s\n(that is, to support polymorphic iteration). S t r u c t u r e\nP a r t i c i p a n t s\n• Iterator\n- d e f i n e s an interfac e for a c c e s s i n g and traversin g e l e m e n t s . • C o n c r e t e l t e r a t o r\n- i m p l e m e n t s the Iterato r interface. - k e e ps track of the curren t positio n in the traversa l of the aggregate. • A g g r e g a t e\n- d e f i n e s an interfac e for c r e a t i n g an Iterato r object.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 777, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_design_patterns_gof_chunk_0778_e9688670", "text": "- k e e ps track of the curren t positio n in the traversa l of the aggregate. • A g g r e g a t e\n- d e f i n e s an interfac e for c r e a t i n g an Iterato r object. • C o n c r e t e A g g r e g a t e\n- i m p l e m e n t s the Iterato r c r e a t i o n interfac e to retur n an i n s t a n c e of the\np r o p e r Concretelterator. ptg260 BEHAVIORAL P A T T E R N S CHAPTERS\nC o l l a b o r a t i o n s\n• A Concretelterato r keep s track of the curren t objec t in the aggregat e and can\ncompute the succeeding object in the traversal. C o n s e q u e n c e s\nThe Iterato r patter n has three importan t c o n s e q u e n c e s :\n1. It supports variations in the traversal of an aggregate. Comple x aggregate s may\nbe traverse d in many ways . For e x a m p l e , c o de generatio n and semanti c\nc h e c k i n g i n v o l v e traversin g parse trees. C o de generatio n may travers e the\nparse t r ee i n o r d e r or p r e o r d e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 778, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_design_patterns_gof_chunk_0779_7b599235", "text": "For e x a m p l e , c o de generatio n and semanti c\nc h e c k i n g i n v o l v e traversin g parse trees. C o de generatio n may travers e the\nparse t r ee i n o r d e r or p r e o r d e r . I t e r a t o r s make it e a sy to c h a n g e t he t r a v e r s a l\nalgorithm : Just r e p l a c e the iterato r i n s t a n c e with a differen t o n e. You can a l so\ndefin e Iterato r s u b c l a s s e s to suppor t new traversals. 2. Iterators simplify the Aggregate interface. Iterator' s traversa l interfac e o b v i a t e s\nthe n e ed for a s i m i l a r interfac e in Aggregate , thereb y simplifyin g the a g g r e -\ngate' s interface. 3. More than one traversal can be pending on an aggregate. An iterato r keep s track\nof its own traversa l state. Therefor e you can have more than one traversa l in\np r o g r e s s at once. Implementation\nIterato r has many implementatio n variant s and alternatives . S o me importan t o n es\nfollow .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 779, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_design_patterns_gof_chunk_0780_49d307cd", "text": "Therefor e you can have more than one traversa l in\np r o g r e s s at once. Implementation\nIterato r has many implementatio n variant s and alternatives . S o me importan t o n es\nfollow . The trade-off s often depen d on the contro l structures your languag e pro-\nv i d e s . S o me language s ( C LU [ L G 8 6 ] , for example ) e v en suppor t t h is patter n di-\nr e c t l y . 1. W ho controls t he iteration? A fundamenta l i s s ue is d e c i d i n g w h i c h party c o n -\nt r o ls the iteration , the iterato r or the c l i e n t that u s es the iterator . Whe n the\nc l i e n t control s the iteration , the iterato r is c a l l ed an externa l iterator , and\nwhen the iterato r control s it, the iterato r is an interna l iterator. 2 C l i e n t s that\nuse an externa l iterato r must advanc e the traversa l and reques t the next el-\nemen t explicitl y f r om the iterator .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 780, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 887}}
{"id": "computer_science_design_patterns_gof_chunk_0781_ac540a5f", "text": "2 C l i e n t s that\nuse an externa l iterato r must advanc e the traversa l and reques t the next el-\nemen t explicitl y f r om the iterator . In contrast , the c l i e n t hand s an interna l\niterato r an operatio n to perform , and the iterato r applie s that operatio n to\nevery e l e m e n t in the aggregate. Externa l iterator s are more flexibl e than interna l iterators . I t 's e a sy to compar e\ntwo c o l l e c t i o n s for equalit y with an externa l iterator , for e x a m p l e , but it's\npracticall y i m p o s s i b l e with interna l iterators . Interna l iterator s are e s p e c i a l l y\nweak in a languag e like C++ that d o es not provid e anonymou s functions ,\nc l o s u r e s , or continuation s l i ke Smalltal k a nd C L O S . B ut on t he other hand,\n2Booc h refer s to externa l and interna l iterator s as activ e and passiv e iterators , respectivel y [ B o o 9 4 ] .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 781, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_design_patterns_gof_chunk_0782_2f14fe38", "text": "B ut on t he other hand,\n2Booc h refer s to externa l and interna l iterator s as activ e and passiv e iterators , respectivel y [ B o o 9 4 ] . The\nterms \"active\" and \"passive\" describe the role of the client, not the level of activity in the iterator. ptgITERATOR 2 6 1\ni n t e r n a l i t e r a t o r s a re e a s i er to u s e, b e c a u s e t h ey defin e t he i t e r a t i o n l o g ic f or\nyou. 2. Who defines the traversal algorithm? The iterato r is not the o n ly place wher e the\ntraversa l algorith m can be defined . The aggregat e migh t defin e the traversa l\nalgorith m and use the iterato r to s t o re just the state of the iteration . We c a ll\nthis k i nd of iterato r a c u r s o r , s i n ce it m e r e l y point s to the curren t positio n in \nthe aggregate . A c l i e n t w i ll i n v o k e the Next operatio n on the aggregat e with\nt he c u r s o r as an a r g u m e n t , a nd t he N e xt o p e r a t i o n w i ll c h a n g e t he s t a te of\nthe c u r s o r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 782, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_design_patterns_gof_chunk_0783_a1ab206a", "text": "3\nIf the iterato r is r e s p o n s i b l e for the traversa l algorithm , then it's e a sy to use\ndifferen t iteratio n algorithm s on the same aggregate , and it can a l so be e a s i e r\nto r e u se the s a me algorith m on differen t a g g r e g a t e s . On the o t h er hand ,\nthe traversa l algorith m migh t n e ed to a c c e s s the privat e variable s of the\na g g r e g a t e . If so, puttin g the traversa l algorith m in the iterato r v i o l a t e s the\ne n c a p s u l a t i o n of t he a g g r e g a t e . 3. How robust is the iterator? It can be dangerou s to modif y an aggregat e while\nyou'r e traversin g it. If e l e m e n t s are adde d or delete d from the a g g r e g a t e ,\nyou migh t end up a c c e s s i n g an e l e m e n t t w i ce or m i s s i n g it c o m p l e t e l y . A\ns i m p l e solutio n is to c o py the aggregat e and travers e the c o p y, but that's too\ne x p e n s i v e to do in general.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 783, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_design_patterns_gof_chunk_0784_1ae45a73", "text": "A\ns i m p l e solutio n is to c o py the aggregat e and travers e the c o p y, but that's too\ne x p e n s i v e to do in general. A robus t iterato r e n s u r e s that i n s e r t i o n s and r e m o v a l s won' t interfer e with\nt r a v e r s a l , a nd it d o es it w i t h o u t c o p y i n g t he a g g r e g a t e . T h e re a re many ways\nto implemen t robus t iterators . M o st r e ly on r e g i s t e r i n g the iterato r with the\naggregate . On insertio n or r e m o v a l , the aggregat e eithe r adjust s the interna l\nstate of iterator s it has p r o d u c e d , or it maintain s informatio n internall y to\ne n s u r e prope r traversal. Kofle r p r o v i d e s a g o od d i s c u s s i o n of how robus t iterator s are implemente d\nin ET++ [ K o f 9 3 ] . Murra y d i s c u s s e s the implementatio n of robus t iterator s\nf or t he U SL StandardComponents ' L i st c l a ss [ M u r 9 3 ] . 4. Additional Iterator operations.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 784, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_design_patterns_gof_chunk_0785_f085cae4", "text": "Murra y d i s c u s s e s the implementatio n of robus t iterator s\nf or t he U SL StandardComponents ' L i st c l a ss [ M u r 9 3 ] . 4. Additional Iterator operations. The minima l interfac e to Iterato r c o n s i s t s of\nthe operation s F i r s t, Next , I s D o n e , and Currentltem. 4 S o me additiona l op-\neration s migh t prove useful . For e x a m p l e , o r d e r e d aggregate s can have a\nP r e v i o u s operatio n that p o s i t i o n s the iterato r to the p r e v i o u s element . A\nS k i p T o operatio n is usefu l f or sorte d or i n d e x e d c o l l e c t i o n s . S k i p T o p o s i t i o n s\nthe iterato r to an o b j e c t matchin g s p e c i f i c criteria. 5. Using polymorphic iterators in C++. P o l y m o r p h i c i t e r a t o r s have t h e ir c o s t. T h ey\nr e q u i r e the iterato r o b j e c t to be allocate d dynamicall y by a factor y method . H e n c e they s h o u l d be u s ed o n ly when there' s a n e ed for polymorphism .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 785, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_design_patterns_gof_chunk_0786_82648dd9", "text": "T h ey\nr e q u i r e the iterato r o b j e c t to be allocate d dynamicall y by a factor y method . H e n c e they s h o u l d be u s ed o n ly when there' s a n e ed for polymorphism . O t h e r w i s e use c o n c r e t e iterators , whic h can be allocate d on the stack. 3 Cursor s are a s i m p l e exampl e of the M e m e n t o ( 2 8 3) patter n and share many of its implementatio n i s s u e s . 4 We can make t h is interfac e e v en smaller by mergin g Next , I s D o n e , and Currentlte m into a s i n g l e operatio n\nthat advance s to the next o b j e c t and return s it. If the traversa l is finished , then this operatio n return s a s p e c i a l \nvalue (0, for instance) that marks the end of the i t e r a t i o n . ptg262 BEHAVIORAL PATTERNS CHAPTERS\nPolymorphi c iterator s have anothe r drawback : the c l i e n t is r e s p o n s i b l e for\nd e l e t i n g t h e m .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 786, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 891}}
{"id": "computer_science_design_patterns_gof_chunk_0787_f1b9423c", "text": "ptg262 BEHAVIORAL PATTERNS CHAPTERS\nPolymorphi c iterator s have anothe r drawback : the c l i e n t is r e s p o n s i b l e for\nd e l e t i n g t h e m . T h is is e r r o r - p r o n e , b e c a u s e i t 's e a sy to forge t to free a h e a p -\nallocate d iterato r o b j e c t when you'r e finishe d with it. Tha t' s e s p e c i a l l y l i k e ly\nw h en t h e re a re multipl e e x it p o i n t s in an o p e r a t i o n . A nd if an e x c e p t i o n is\ntriggered , the iterato r objec t will never be freed. T he P r o xy ( 2 0 7) patter n p r o v i d e s a r e m e d y . We c an u se a s t a c k - a l l o c a t e d\nproxy as a stand-i n for the real iterator . The proxy d e l e t e s the iterato r in\ni ts d e s t r u c t o r . T h us w h en t he p r o xy g o es o ut of s c o p e , t he r e al i t e r a t o r w i ll\nget deallocate d along with it. The proxy e n s u r e s prope r cleanup , e v en in\nt he face of e x c e p t i o n s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 787, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_design_patterns_gof_chunk_0788_94a645b8", "text": "The proxy e n s u r e s prope r cleanup , e v en in\nt he face of e x c e p t i o n s . T h is is an a p p l i c a t i o n of t he w e l l - k n o w n C ++ t e c h -\nnique \" r e s o u r c e allocatio n is initialization \" [ E S 9 0 ] . T he S a m p l e C o de g i v es\nan e x a m p l e . 6. Iterators may have privileged access. An iterato r can be v i e w e d as an e x t e n s i o n\nof the aggregat e that create d it. The iterato r and the aggregat e are tightl y cou-\npled. We can e x p r e s s this c l o se r e l a t i o n s h i p in C+ + by makin g the iterato r a\nf r i e n d of its aggregate . T h en you don't n e ed to defin e aggregat e operation s\nwhos e s o le purpos e is to let iterator s implemen t traversa l efficiently. However , s u ch privilege d a c c e s s can make definin g new traversal s difficult ,\ns i n ce it'll requir e c han gi n g the a g g r e g a t e interfac e to add anothe r friend .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 788, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_design_patterns_gof_chunk_0789_849989f9", "text": "However , s u ch privilege d a c c e s s can make definin g new traversal s difficult ,\ns i n ce it'll requir e c han gi n g the a g g r e g a t e interfac e to add anothe r friend . To avoid this problem , the Iterato r c l a ss can i n c l u d e p r o t e c t e d operation s\nfor accessin g importan t but publicl y unavailabl e member s of the a g g r e g a t e . Iterato r s u b c l a s s e s (and only Iterato r s u b c l a s s e s ) may use t h e se protecte d\noperation s to g a in p r i v i l e g e d a c c e s s to the a g g r e g a t e . 7. Iterators for composites. Externa l iterator s can be difficul t to implemen t o v er\nr e c u r s i v e a g g r e g a t e structure s l i ke t h o se in t he C o m p o s i t e ( 1 6 3) pattern , b e -\ncause a positio n in the structur e may span many l e v e ls of n e s t e d agg re ga te s . T h e r e f o r e an e x t e r n a l iterato r h as to s t o re a path t h r o u g h t he C o m p o s i t e to\nkeep track of the curren t object .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 789, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_design_patterns_gof_chunk_0790_f0b54bbd", "text": "T h e r e f o r e an e x t e r n a l iterato r h as to s t o re a path t h r o u g h t he C o m p o s i t e to\nkeep track of the curren t object . S o m e t i m e s it's e a s i e r j u st to use an interna l\ni t e r a t o r . It c an r e c o r d t he curren t p o s i t i o n s i m p l y by c a l l i n g i t s e lf r e c u r s i v e l y ,\nthereb y storin g the p a th implicitl y in the c a ll stack. If t he n o d e s in a C o m p o s i t e h a ve an interfac e f or m o v i n g from a n o de to\nits s i b l i n g s , parents , and c h i l d r e n , then a cursor-base d iterato r may o f f er a\nbette r a l t e r n a t i v e . T he c u r s o r o n ly n e e ds to k e ep track of t he c u r r e n t n o d e ; it\ncan rely on the node interfac e to travers e the Composite. C o m p o s i t e s often n e ed to be traverse d in m o re than one way. P r e o r d e r ,\npostorder , i n o r d e r , and breadth-firs t traversal s are common .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 790, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_design_patterns_gof_chunk_0791_793ed559", "text": "C o m p o s i t e s often n e ed to be traverse d in m o re than one way. P r e o r d e r ,\npostorder , i n o r d e r , and breadth-firs t traversal s are common . You can suppor t\ne a ch k i nd of traversa l with a differen t c l a ss of iterator. 8. Null iterators. A N u l l l t e r a t o r is a d e g e n e r a t e i t e r a t o r that's helpfu l for h a n -\nd l i ng boundar y conditions . By definition , a Nulllterator is always d o ne with\nt r a v e r s a l ; that i s, i ts I s D o n e o p e r a t i o n alway s evaluate s to true. Nulllterato r can make traversin g tree-structure d aggregate s (like C o m p o s -\ni t e s) e a s i e r . At e a ch p o i nt in t he t r a v e r s a l , we a sk t he c u r r e n t e l e m e n t f or\nan i t e r a t o r f o r i t s c h i l d r e n . A g g r e g a t e e l e m e n t s r e t u r n a c o n c r e t e i t e r a t o r\n\nptgITERATOR 2 6 3\nas usual . But l e af e l e m e n t s retur n an i n s t a n c e of Nulllterator .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 791, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_design_patterns_gof_chunk_0792_da66f99c", "text": "A g g r e g a t e e l e m e n t s r e t u r n a c o n c r e t e i t e r a t o r\n\nptgITERATOR 2 6 3\nas usual . But l e af e l e m e n t s retur n an i n s t a n c e of Nulllterator . That lets us\nimplement traversal over the entire structure in a uniform way. S a m p l e C o d e\nW e ' ll look at t he implementatio n of a s i m p l e L i st c l a s s, whic h is part of o ur\nfoundatio n librar y (Appendi x C). W e ' ll s h ow two Iterato r implementations , one\nfor traversin g the L i st in front-to-bac k o r d e r , and anothe r for traversin g back-to-\nfront (the foundatio n librar y support s o n ly the first o n e ). T h en we s h ow how to\nuse t h e se iterator s and how to a v o id committin g to a particula r implementation . After that, we c h a n g e the d e s i g n to make sure iterator s get d e l e t e d properly . The l a st exampl e illustrate s an interna l iterato r and compare s it to its externa l\ncounterpart. 1. List a nd Iterator interfaces.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 792, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_design_patterns_gof_chunk_0793_974ba400", "text": "The l a st exampl e illustrate s an interna l iterato r and compare s it to its externa l\ncounterpart. 1. List a nd Iterator interfaces. F i r st let's l o ok at t he part of t he L i st interfac e that's\nrelevan t to implementin g iterators . Refer to Appendi x C for the f u ll interface. template <class Item>\nc l a ss L i st { \npublic:\nList(lon g s i ze = D E F A U L T _ L I S T _ C A P A C I T Y ) ;\nl o ng C o u n t () const;\nI t e m& Get(long i n d e x) const;\n// . . . } ;\nT he L i st c l a ss p r o v i d e s a r e a s o n a b l y efficien t w ay to s u p p o r t i t e r a t i o n\nthroug h its publi c interface . I t 's sufficien t to implemen t both traversals . So\nthere' s no n e ed to g i ve iterator s p r i v i l e g e d a c c e s s to the underlyin g data\nstructure ; that is, the iterato r c l a s s e s are not friend s of L i s t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 793, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 853}}
{"id": "computer_science_design_patterns_gof_chunk_0794_b3d84fe1", "text": "So\nthere' s no n e ed to g i ve iterator s p r i v i l e g e d a c c e s s to the underlyin g data\nstructure ; that is, the iterato r c l a s s e s are not friend s of L i s t . To e n a b l e trans-\nparen t use of the differen t traversal s we defin e an abstrac t I t e r a t o r c l a s s,\nw h i c h define s the iterato r interface. template <class Item>\nc l a ss I t e r a t or { \npublic:\nvirtual void First() = 0; \nvirtual void Next() = 0; \nv i r t u al b o ol I s D o n eO c o n st = 0;\nvirtual I t em Currentltem( ) c o n st = 0;\nprotected:\nIterator() ;\n} ;\n2. I t e r a t o r s u b c l a s s i m p l e m e n t a t i o n s . Listlterator is a subclass of Iterator.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 794, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 672}}
{"id": "computer_science_design_patterns_gof_chunk_0795_fb4ec2b2", "text": "I t e r a t o r s u b c l a s s i m p l e m e n t a t i o n s . Listlterator is a subclass of Iterator. ptg264 BEHAVIORAL P A T T E R N S CHAPTER 5\ntemplate <class Item> \nc l a ss Listlterato r : public Iterator<Item > {\npublic:\nListlterator(cons t List<Item> * aList);\nvirtual void First(); \nvirtual void Next(); \nvirtual bool IsDoneO const; \nvirtual I t em Currentltem( ) const;\nprivate: \nc o n st List<Item> * _list;\nl o ng _current;\n} ;\nT he i m p l e m e n t a t i o n of Li s t Iterator is straightforward . It s t o r es t he L i st\nalong with an i n d ex .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 795, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 564}}
{"id": "computer_science_design_patterns_gof_chunk_0796_f28a6efa", "text": "It s t o r es t he L i st\nalong with an i n d ex . c u r r e n t into the l i s t :\ntemplate <class Item>\nListlterator<ltem>::Listlterato r (\nc o n st List<Item> * a L i st \n) : _list(aList) , _current(0 ) {\n}\nF i r s t position s the iterato r to the first e l e m e n t :\ntemplate <class Item> \nvoid Listlterator<ltem>::Firs t () {\n_current = 0;\n}\nN e xt advance s the curren t e l e m e n t :\ntemplate <class I t e m> \nvoid Listlterator<ltem>::Nex t () {\n_current++ ;\n}\nI s D o n e c h e c k s whethe r the i n d ex refers to an e l e m e n t withi n the L i s t :\ntemplate <class Item> \nbool Listlterator<ltem>::IsDon e () c o n st {\nr e t u rn _current >= _list->Count() ;\n}\nF i n a l l y , C u r r e n t I t e rn return s the item at the curren t i n d e x .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 796, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 764}}
{"id": "computer_science_design_patterns_gof_chunk_0797_5bdbe684", "text": "If the iteratio n\nhas alread y terminated , then we throw an I t e r a t o r O u t O f Bound s e x c e p -\nt i o n :\ntemplate <class Item>\nI t em Listlterator<ltem>::CurrentIte m () c o n st {\nif ( I s D o n e ( ) ) { \nt h r ow I t e r a t o r O u t O f B o u n d s ;\n} \nr e t u r n _list->Get(_current);\n}\n\nptgITERATOR 2 6 5\nT he i m p l e m e n t a t i o n of ReverseListlterato r is i d e n t i c a l , e x c e p t i ts F ir st o p -\ne r a t i o n p o s i t i o n s . c u r r e n t to the end of the l i s t, and N e xt d e c r e m e n t s\n. c u r r e n t t o w a r d the first item. 3. Using the iterators. L e t 's a s s u m e we h a ve a L i st of E m p l o y e e o b j e c t s ,\na nd we w o u l d l i ke to p r i nt a ll t he c o n t a i n e d e m p l o y e e s . T he E m p l o y e e\nc l a ss s u p p o r t s t h is with a P r i n t o p e r a t i o n . To p r i nt t he list, we defin e a\nP r i n t E m p l o y e e s o p e r a t i o n t h at takes an i t e r a t o r as an a r g u m e n t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 797, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_design_patterns_gof_chunk_0798_48000e31", "text": "To p r i nt t he list, we defin e a\nP r i n t E m p l o y e e s o p e r a t i o n t h at takes an i t e r a t o r as an a r g u m e n t . It u s es\nt he i t e r a t o r to t r a v e r s e a nd p r i nt t he list. void PrintEmployee s (Iterator<Employee*> & i) {\nfor ( i. First ( ); ! i . I s D o ne () ; i.NextO ) {\ni.Currentltem()->Print() ;\n}\n}\nS i n ce we h a ve i t e r a t o r s f or b o th back-to-fron t a nd f r o n t - t o - b a c k t r a v e r s a l s ,\nwe c an r e u se t h is o p e r a t i o n to p r i nt t he e m p l o y e e s in b o th o r d e r s . List<Employee*> * employees ;\n// . . . ListIterator<Employee* > forward(employees) ;\nReverseListIterator<Employee*> backward(employees);\nPrintEmployees(forward);\nPrintEmployees(backward);\n4. Avoiding commitment to a specific list implementation. L e t 's c o n s i d e r how a\ns k i p l i s t v a r i a t i o n of L i st w o u l d affec t our iteratio n c o d e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 798, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_design_patterns_gof_chunk_0799_8ad090c4", "text": "Avoiding commitment to a specific list implementation. L e t 's c o n s i d e r how a\ns k i p l i s t v a r i a t i o n of L i st w o u l d affec t our iteratio n c o d e . A S k i p L i s t\ns u b c l a s s of L i st m u st p r o v i d e a S k i p L i s t I t e r a t o r that i m p l e -\nm e n t s the I t e r a t o r interface . I n t e r n a l l y , the S k i p L i s t l t e r a t o r has \nto k e ep m o re t h an j u st an i n d ex to do t he iteratio n efficiently . B ut\ns i n ce S k i p L i s t l t e r a t o r c o n f o r m s to the I t e r a t o r i n t e r f a c e , the\nP r i n t Emp 1 oy e e s o p e r a t i o n c an a l so be u s ed w h en t he e m p l o y e e s a re s t o r e d\nin a S k i p L i s t o b j e c t . SkipList<Employee*> * employees ;\n// . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 799, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 771}}
{"id": "computer_science_design_patterns_gof_chunk_0800_9c8354f9", "text": "SkipList<Employee*> * employees ;\n// . . . SkipListIterator<Employee* > iterator(employees) ;\nPrintEmployees(iterator);\nA l t h o u g h t h is a p p r o a c h w o r k s , it woul d be b e t t e r if we d i d n ' t h a ve to c o m m i t\nto a s p e c i f i c L i st i m p l e m e n t a t i o n , n a m e l y S k i p L i s t . We can i n t r o d u c e an\nA b s t r a c t L i s t c l a ss to s t a n d a r d i z e the list interfac e for differen t l i st i m p l e -\nm e n t a t i o n s . L i st and S k i p L i s t b e c o m e s u b c l a s s e s of A b s t r a c t L i s t . To e n a b l e p o l y m o r p h i c i t e r a t i o n , A b s t r a c t L i s t d e f i n e s a f a c t o r y m e t h o d\nC r e a t e l t e r a t o r , w h i c h s u b c l a s s e s o v e r r i d e to r e t u r n t h e ir c o r r e s p o n d i n g\ni t e r a t o r :\n\nptg266 BEHAVIORAL PATTERNS CHAPTER 5\ntemplate <class Item>\nclass AbstractLis t { \npublic:\nvirtual Iterator<Item> * Createlterator( ) c o n st = 0;\n// . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 800, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 997}}
{"id": "computer_science_design_patterns_gof_chunk_0801_06ddeeb5", "text": ". . } ;\nAn a l t e r n a t i v e w o u l d be to d e f i n e a g e n e r a l m i x in c l a ss T r a v e r s a b l e that\ndefine s t he i n t e r f a c e f or c r e a t i n g an i t e r a t o r . A g g r e g a t e c l a s s e s c an m ix in\nT r a v e r s a b l e to s u p p o r t p o l y m o r p h i c i t e r a t i o n . L i st o v e r r i d e s C r e a t e l t e r a t o r to retur n a L i s t l t e r a t o r o b j e c t :\ntemplate <class Item>\nIterator<Item> * List<Item>::CreateIterato r () const {\nreturn new Listlterator<ltem>(this) ;\n}\nN ow w e ' re in a p o s i t i o n to write t he c o de f or p r i n t i n g t he e m p l o y e e s i n d e -\np e n d e n t of a c o n c r e t e r e p r e s e n t a t i o n . / / we k n ow o n ly that we have an AbstractLis t\nAbstractList<Employee*> * employees ; \n// . . . Iterator<Employee*> * iterator = employees->Create!terator() ;\nPrintEmployees(*iterator) ; \ndelete iterator;\n5. Making sure iterators get deleted.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 801, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_design_patterns_gof_chunk_0802_471a25d4", "text": ". . Iterator<Employee*> * iterator = employees->Create!terator() ;\nPrintEmployees(*iterator) ; \ndelete iterator;\n5. Making sure iterators get deleted. N o t i c e t h at C r e a t e l t e r a t o r r e t u r n s a\nn e w l y a l l o c a t e d i t e r a t o r o b j e c t . W e ' r e r e s p o n s i b l e f or d e l e t i n g i t. If we f o r g e t ,\nt h en w e ' v e c r e a t e d a s t o r a g e leak. To m a ke life e a s i e r for c l i e n t s , w e ' ll p r o v i d e\nan 11 e r a t o r P t r t h at a c ts as a p r o x y f or an i t e r a t o r . It takes c a re of c l e a n i n g\nup t he I t e r a t o r o b j e c t w h en it g o es o ut of s c o p e . i t e r a t o r P t r is alway s a l l o c a t e d on the stack. 5 C++ a u t o m a t i c a l l y t a k es\nc a re of c a l l i n g i ts d e s t r u c t o r , w h i c h d e l e t e s t he r e al i t e r a t o r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 802, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 870}}
{"id": "computer_science_design_patterns_gof_chunk_0803_43e3de28", "text": "5 C++ a u t o m a t i c a l l y t a k es\nc a re of c a l l i n g i ts d e s t r u c t o r , w h i c h d e l e t e s t he r e al i t e r a t o r . I t e r a t o r P t r\no v e r l o a d s b o th o p e r a t o r - > and o p e r a t o r * in s u ch a way t h at an \nI t e r a t o r P t r c an be t r e a t e d j u st l i ke a p o i n t e r to an i t e r a t o r . T he m e m -\nb e rs of I t e r a t o r P t r a re a ll i m p l e m e n t e d i n l i n e ; t h us t h ey c an i n c ur no\no v e r h e a d . t e m p l a t e < c l a s s I t e m >\nc l a s s I t e r a t o r P t r {\np u b l i c :\nI t e r a t o r P t r ( I t e r a t o r < I t e m > * i ): _ i (i) { }\n\" I t e r a t o r P t r ( ) { delete _ i ; }\n5 You c a n ensure this at compile-time just by declaring private n e w and delete operators. An accompa -\nn y i n g implementation isn't needed.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 803, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 847}}
{"id": "computer_science_design_patterns_gof_chunk_0804_93295f8b", "text": "An accompa -\nn y i n g implementation isn't needed. ptgITERATOR 267\nIterator<Item> * operator->( ) { return _i; }\nIterator<Item> & operator*( ) { r e t u rn *_i; }\nprivate: \n// disallow c o py and a s s i g n m e n t to avoid\n// multiple deletion s of _i:\nIteratorPtr(cons t IteratorPtr&);\nIteratorPtr & operator=(cons t IteratorPtr&);\nprivate:\nIterator<Item> * _i;\n} ;\nI t e r a t o r P t r lets us simplif y our p r i n t i n g c o d e :\nAbstractList<Employee*> * employees ;\n// . . . IteratorPtr<Employee* > iterator(employees->Create!terator()) ;\nPrintEmployees(*iterator);\n6. An internal Listlterator. As a final example , let's l o ok at a p o s s i b l e implementa-\ntion of an interna l or p a s s i v e L i s t l t e r a t o r c l a s s. H e re the iterato r c o n t r o l s\nthe iteration , and it applie s an operatio n to each e l e m e n t . The i s s ue in this c a se is how to parameteriz e the iterato r with the operatio n\nwe want to p e r f o r m on e a ch element .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 804, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_design_patterns_gof_chunk_0805_87408b48", "text": "The i s s ue in this c a se is how to parameteriz e the iterato r with the operatio n\nwe want to p e r f o r m on e a ch element . C++ d o es not suppor t anonymou s\nfunction s or c l o s u r e s that other language s provid e for t h is task. T h e re are at \nleast two o p t i o n s : (1) Pass in a pointe r to a functio n (globa l or static) , or (2)\nr e ly on s u b c l a s s i n g . In the first c a s e, the iterato r c a l ls the operatio n passe d\nto it at each point in the iteration . In the s e c o n d c a s e, the iterato r c a l ls an\noperatio n that a s u b c l a s s override s to e n a ct specifi c b e h a v i o r . Neithe r optio n is perfect . Often you want to accumulat e state durin g the\niteration , and function s aren't well-suite d to that; we woul d have to use\nstatic variable s to remembe r the state. An I t e r a t o r s u b c l a s s provide s us\nwith a c o n v e n i e n t place to store the accumulate d state, l i ke in an i n s t a n c e\nvariable .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 805, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_design_patterns_gof_chunk_0806_c0c23e6e", "text": "An I t e r a t o r s u b c l a s s provide s us\nwith a c o n v e n i e n t place to store the accumulate d state, l i ke in an i n s t a n c e\nvariable . But creatin g a s u b c l a s s for every d i f f e r e n t traversa l is more work. Here' s a s k e t c h of t he s e c o n d option , whic h uses subclassing . We c a ll t he\ninternal iterator a ListTraverser. template <class Item>\nclass ListTraverse r {\npublic:\nListTraverser(List<Item> * aList) ;\nbool Traverse();\nprotected : \nvirtual bool Processltem(cons t Item&) = 0;\nprivate:\nListlterator<ltem > _iterator ;\n} ;\nL i s t T r a v e r s e r takes a L i st instanc e as a parameter . Internall y it uses an\nexternal Listlterator t o d o t h e traversal. Traverse s t a r t s the traversal\n\nptg268 BEHAVIORAL PATTERNS CHAPTER 5\nand calls P r o c e s s I tern for e a ch item . The i n t e r n a l i t e r a t o r can c h o o s e to\nt e r m i n a t e a t r a v e r s a l by r e t u r n i n g f a l s e f r om P r o c e s s l t e m .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 806, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_design_patterns_gof_chunk_0807_879879ba", "text": "The i n t e r n a l i t e r a t o r can c h o o s e to\nt e r m i n a t e a t r a v e r s a l by r e t u r n i n g f a l s e f r om P r o c e s s l t e m . T r a v e r s e\nr e t u r n s w h e t h e r t he t r a v e r s a l t e r m i n a t e d p r e m a t u r e l y . template <class Item>\nListTraverser<Item>::ListTraverse r (\nList<Item> * a L i st \n) : _iterator(aList ) { }\ntemplate <class Item> \nbool ListTraverser<Item>::Travers e () {\nbool result = false;\nfor ( \n_iterator.First();\n!_iterator.IsDone() ;\n_iterator.Next()\n) {\nresult = Processltem(_iterator.Currentltem());\nif ( r e s u lt == false) {\nb r e a k ;\n}\n}\nr e t u r n r e s u l t ;\nL e t 's u se a L i s t T r a v e r s e r to p r i nt t he first 10 e m p l o y e e s f r om o ur e m -\np l o y e e l i s t. To do it we h a ve to s u b c l a s s L i s t T r a v e r s e r a nd o v e r r i d e\nP r o c e s s l t e m . We c o u n t t he n u m b e r of p r i n t e d e m p l o y e e s in a _ c o u n t\ni n s t a n c e v a r i a b l e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 807, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_design_patterns_gof_chunk_0808_381445e7", "text": "We c o u n t t he n u m b e r of p r i n t e d e m p l o y e e s in a _ c o u n t\ni n s t a n c e v a r i a b l e . class PrintNEmployee s : public ListTraverser<Employee* > {\npublic:\nPrintNEmployees(List<Employee*> * aList, int n) : \nListTraverser<Employee*>(aList) ,\n_total(n) , _count(0 ) { }\nprotected : \nbool Processltem(Employee * const&);\nprivate: \nint _total;\nint _count;\n} ;\nbool PrintNEmployees::Processlte m ( E m p l o y e e * c o n s t& e) { \n_count++ ; \ne->Print() ; \nreturn _count < _ t o t a l ;\n}\nH e r e ' s h o w P r i n t N E m p l o y e e s prints the first 1 0 employees on the list:\n\nptgITERATOR 269\nList<Employee*> * employees ;\n// . . . PrintNEmployee s pa(employees , 10)\npa.Traverse();\nNote how the c l i e nt doesn' t specif y the iteratio n l o o p. The entire iteratio n\nl o g ic c an be r e u s e d . T h is is t he primar y benefi t of an i n t e r n a l i t e r a t o r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 808, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 904}}
{"id": "computer_science_design_patterns_gof_chunk_0809_fe0e859e", "text": "The entire iteratio n\nl o g ic c an be r e u s e d . T h is is t he primar y benefi t of an i n t e r n a l i t e r a t o r . I t 's a\nbit more work t h an an externa l iterator , though , becaus e we have to defin e a\nnew c l a s s. Contras t this with using an externa l iterator:\nListIterator<Employee* > i(employees) ;\nint count = 0;\nfor ( i. First ( ); ! i . I s D o ne () ; i.NextO) {\ncount++;\ni.Currentltem()->Print();\nif ( c o u nt >= 10) {\nbreak;\n}\n}\nInterna l iterator s can encapsulat e differen t kinds of iteration .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 809, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 529}}
{"id": "computer_science_design_patterns_gof_chunk_0810_09fba564", "text": "First ( ); ! i . I s D o ne () ; i.NextO) {\ncount++;\ni.Currentltem()->Print();\nif ( c o u nt >= 10) {\nbreak;\n}\n}\nInterna l iterator s can encapsulat e differen t kinds of iteration . For e x a m p l e ,\nF i l t e r i n g L i s t T r a v e r s e r e n c a p s u l a t e s an i t e r a t i o n that p r o c e s s e s o n ly \nitems that satisf y a test:\ntemplate <class Item> \nclass FilteringListTraverse r { \npublic:\nFilteringListTraverser(List<Item> * aList);\nbool Traverse();\nprotected : \nvirtual bool Processltem(cons t Item&) - 0; \nvirtual bool Testltem(cons t Item&) = 0;\nprivate:\nListlterator<ltem > _iterator ;\n} ;\nT h is i n t e r f a c e is t he s a me as L i s t T r a v e r s e r ' s e x c e p t f or an a d d e d\nT e st I t e rn membe r functio n that define s the test. S u b c l a s s e s overrid e \nTe s 1 11 em to specif y t he test.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 810, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 847}}
{"id": "computer_science_design_patterns_gof_chunk_0811_e4c8c905", "text": "S u b c l a s s e s overrid e \nTe s 1 11 em to specif y t he test. T r a v e r s e d e c i d e s to c o n t i n u e t he t r a v e r s a l b a s ed on t he o u t c o m e of t he t e s t :\ntemplate < c l a ss I t e m> \nvoid FilteringListTraverser<Item>::Travers e () {\nb o ol r e s u lt = false;\nfor ( \n_iterator.First();\n! _ i t e r a t o r . I s D o n e ( ) ;\n_iterator.Next()\n) {\nif (Testltem(_iterator.Currentltem()) ) { \nresult = Processltem(_iterator.Currentltem());\n\nptg270 BEHAVIORAL P A T T E R N S CHAPTER 5\nif ( r e s u lt == false) {\nbreak;\n}\n}\n} \nr e t u r n result;\n}\nA varian t of t h is c l a ss c o u ld defin e T r a v e r s e to retur n if at l e a st o ne i t em\ns a t i s f i e s the test. 6\nK n o w n Uses\nIterator s a re c o m m o n in o b j e c t - o r i e n t e d s y s t e m s . M o st c o l l e c t i o n c l a ss l i b r a r i e s\noffer i t e r a t o r s in o ne form or a n o t h e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 811, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 913}}
{"id": "computer_science_design_patterns_gof_chunk_0812_335cec56", "text": "M o st c o l l e c t i o n c l a ss l i b r a r i e s\noffer i t e r a t o r s in o ne form or a n o t h e r . H e r e ' s an e x a m p l e from t he B o o c h c o m p o n e n t s [ B o o 9 4 ] , a p o p u l a r c o l l e c t i o n\nc l a ss l i b r a r y . It p r o v i d e s both a f i x ed s i ze (bounded ) a nd d y n a m i c a l l y g r o w i n g\n( u n b o u n d e d ) i m p l e m e n t a t i o n of a q u e u e . T he q u e u e interfac e is d e f i n e d by an\nabstrac t Q u e u e c l a s s. To suppor t polymorphi c i t e r a t i o n o v er t he differen t q u e u e\nimplementations , t he q u e u e iterato r is i m p l e m e n t e d in t he terms of t he abstrac t\nQ u e u e c l a ss i n t e r f a c e . T h is v a r i a t i o n h as t he a d v a n t a g e that y ou d o n 't n e ed a\nfactor y metho d to ask the queu e i m p l e m e n t a t i o n s for their appropriat e iterator .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 812, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 891}}
{"id": "computer_science_design_patterns_gof_chunk_0813_64a887ef", "text": "T h is v a r i a t i o n h as t he a d v a n t a g e that y ou d o n 't n e ed a\nfactor y metho d to ask the queu e i m p l e m e n t a t i o n s for their appropriat e iterator . H o w e v e r , it r e q u i r e s t he i n t e r f a c e of t he a b s t r a c t Q u e u e c l a ss to be powerfu l\ne n o u g h to i m p l e m e n t the iterato r e f f i c i e n t l y . Iterator s don't have to be define d as e x p l i c i t l y in S m a l l t a l k . T he standar d c o l l e c t i o n\nc l a s s e s ( B a g, S e t, D i c t i o n a r y , O r d e r e d C o l l e c t i o n , S t r i n g , e t c .) defin e an i n t e r n a l\niterato r metho d d o :, w h i c h takes a b l o ck ( i . e ., c l o s u r e ) as an argument . E a ch\ne l e m e n t in t he c o l l e c t i o n is boun d to t he l o c al v a r i a b l e in t he b l o c k ; then t he b l o ck\nis e x e c u t e d .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 813, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 871}}
{"id": "computer_science_design_patterns_gof_chunk_0814_8f8d6a54", "text": "e ., c l o s u r e ) as an argument . E a ch\ne l e m e n t in t he c o l l e c t i o n is boun d to t he l o c al v a r i a b l e in t he b l o c k ; then t he b l o ck\nis e x e c u t e d . S m a l l t a l k a l so i n c l u d e s a s et of S t r e a m c l a s s e s t h at s u p p o r t an i t e r a t o r -\nl i ke interface . ReadStrea m is e s s e n t i a l l y an Iterator , a nd it c an a ct as an e x t e r n a l\niterato r f or a ll t he s e q u e n t i a l c o l l e c t i o n s . T h e re a re no s t a n d a r d e x t e r n a l i t e r a t o r s\nf or n o n s e q u e n t i a l c o l l e c t i o n s such as S et a nd D i c t i o n a r y . P o l y m o r p h i c iterator s a nd t he c l e a n u p P r o xy d e s c r i b e d e a r l i e r a re p r o v i d e d by\nt he ET++ c o n t a i n e r c l a s s e s [ W G M 8 8 ] . T he U n i d r a w g r a p h i c a l e d i t i n g framewor k\nc l a s s e s u se c u r s o r - b a s e d i t e r a t o r s [ V L 9 0 ] .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 814, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_design_patterns_gof_chunk_0815_1cd50f66", "text": "T he U n i d r a w g r a p h i c a l e d i t i n g framewor k\nc l a s s e s u se c u r s o r - b a s e d i t e r a t o r s [ V L 9 0 ] . O b j e c t W i n d o w s 2 .0 [ B o r 9 4 ] p r o v i d e s a c l a ss h i e r a r c h y of i t e r a t o r s f or c o n t a i n e r s . Y ou c an i t e r a t e o v er differen t c o n t a i n e r t y p es in t he s a me w a y. T he O b j e c t W i n d o w\niteratio n synta x r e l i es on o v e r l o a d i n g the p o s t i n c r e m e n t o p e r a t o r ++ to a d v a n c e\nthe iteration. Related P a t t e r n s\nC o m p o s i t e ( 1 6 3 ) : Iterator s a re often a p p l i e d to r e c u r s i v e structure s s u ch as C o m -\np o s i t e s . 6The T r a v e r s e o p e r a t i o n in t h e se e x a m p l e s is a T e m p l a t e M e t h o d ( 3 2 5) w i th p r i m i t i v e o p e r a t i o n s\nT e s t l t e m a n d Processltem.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 815, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 876}}
{"id": "computer_science_design_patterns_gof_chunk_0816_d2eeacd6", "text": "6The T r a v e r s e o p e r a t i o n in t h e se e x a m p l e s is a T e m p l a t e M e t h o d ( 3 2 5) w i th p r i m i t i v e o p e r a t i o n s\nT e s t l t e m a n d Processltem. ptgITERATOR 2 7 1\nFactor y Metho d ( 1 0 7 ) : Polymorphi c iterator s rely on f a c t o r y method s to instantiat e\nthe appropriat e Iterato r s u b c l a s s . Mement o ( 2 8 3) is often used in conjunction with the Iterato r pattern . An iterato r\ncan use a mement o to captur e the state of an iteration . The iterato r s t o r es the\nmemento internally. ptg\nThis page intentionally left blank \n\nptgMEDIATOR 273\nM E D I A T O R Object Behavioral\nI n t e n t\nDefin e an objec t that encapsulate s how a set of object s interact . Mediato r promote s\nl o o se c o u p l i n g by keepin g object s f r om referrin g to each other e x p l i c i t l y , and it\nlets you vary their interaction independently.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 816, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 896}}
{"id": "computer_science_design_patterns_gof_chunk_0817_dfeb9228", "text": "Mediato r promote s\nl o o se c o u p l i n g by keepin g object s f r om referrin g to each other e x p l i c i t l y , and it\nlets you vary their interaction independently. Motivation\nO b j e c t - o r i e n t e d d e s i g n e n c o u r a g e s t he d i s t r i b u t i o n of b e h a v i o r a m o n g o b j e c t s . S u ch distributio n can resul t in an objec t structur e with many c o n n e c t i o n s betwee n\no b j e c t s ; in t he wors t c a s e, e v e ry o b j e c t e n ds up k n o w i n g a b o u t e v e ry o t h e r . T h o u g h partitionin g a syste m into many object s g e n e r a l l y e n h a n c e s reusability ,\nproliferatin g interconnection s tend to reduc e it again . Lots of i n t e r c o n n e c t i o n s\nmake it l e ss l i k e ly that an o b j e c t c an work withou t t he s u p p o r t of o t h e r s — t h e\nsyste m acts as thoug h it were monolithic .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 817, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 890}}
{"id": "computer_science_design_patterns_gof_chunk_0818_ecd37574", "text": "Lots of i n t e r c o n n e c t i o n s\nmake it l e ss l i k e ly that an o b j e c t c an work withou t t he s u p p o r t of o t h e r s — t h e\nsyste m acts as thoug h it were monolithic . M o r e o v e r , it can be difficul t to c h a n g e\nt he s y s t e m ' s b e h a v i o r in a ny s i g n i f i c a n t way, s i n ce b e h a v i o r is d i s t r i b u t e d a m o n g\nmany objects . As a result , you may be force d to defin e many subclasse s to c u s -\ntomiz e the system' s behavior. As an e x a m p l e , c o n s i d e r t he i m p l e m e n t a t i o n of d i a l o g b o x es in a g r a p h i c a l u s er\ninterface . A d i a l o g box u s es a windo w to presen t a c o l l e c t i o n of widget s such as\nbuttons, menus, and entry fields, as shown here:\n\nptg2 7 4 BEHAVIORAL PATTERNS CHAPTER 5\nOften there are d e p e n d e n c i e s betwee n the widget s in the d i a l o g . For e x a m p l e ,\na butto n g e ts d i s a b l e d when a certai n entry field is e m p t y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 818, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 990}}
{"id": "computer_science_design_patterns_gof_chunk_0819_98201bfc", "text": "For e x a m p l e ,\na butto n g e ts d i s a b l e d when a certai n entry field is e m p t y . S e l e c t i n g an entry\nin a l i st of c h o i c e s called a list box migh t c h a n g e the content s of an entry field. C o n v e r s e l y typin g text into the entry field migh t automaticall y s e l e c t one or more\ncorrespondin g entrie s in the l i st box. O n ce text appear s in the entry field, other\nbutton s may b e c o m e e n a b l e d that let the user do somethin g with the text, s u ch as\nc h a n g i n g or d e l e t i n g t he t h i ng to w h i c h it refers. Differen t dialo g b o x e s will have differen t d e p e n d e n c i e s betwee n widgets . So e v en\nthoug h d i a l o g s d i s p l a y t he s a me k i n ds of w i d g e t s , t h ey c a n 't s i m p l y r e u se s t o ck\nwidget c l a s s e s ; they have to be customize d to reflec t dialog-specifi c d e p e n d e n c i e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 819, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_design_patterns_gof_chunk_0820_2a82c72c", "text": "Customizin g them individuall y by s u b c l a s s i n g will be tedious , s i n ce many c l a s s e s\nare involved. You can a v o id t h e se problem s by encapsulatin g c o l l e c t i v e behavio r in a separat e\nmediato r object . A mediato r is responsibl e for controllin g and coordinatin g the\ninteraction s of a group of objects . The mediato r s e r v e s as an intermediar y that\nk e e ps o b j e c t s in t he g r o up from referrin g to e a ch o t h er e x p l i c i t l y . T he o b j e c t s o n ly\nknow the mediator , thereb y reducin g the numbe r of i n t e r c o n n e c t i o n s . F or e x a m p l e , F o n t D i a l o g D i r e c t o r c an be t he m e d i a t o r b e t w e e n t he w i d g e t s in\na dialo g box. A F o n t D i a l o g D i r e c t o r objec t know s the widget s in a dialo g and\ncoordinates their interaction.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 820, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 852}}
{"id": "computer_science_design_patterns_gof_chunk_0821_efed65dd", "text": "A F o n t D i a l o g D i r e c t o r objec t know s the widget s in a dialo g and\ncoordinates their interaction. It acts as a hub of communication for widgets:\nThe followin g interactio n diagra m illustrate s how the object s cooperat e to handl e\na change in a list box's selection:\n\nptgMEDIATOR 275\nH e r e ' s t he s u c c e s s i o n of e v e n t s by w h i c h a l i st box's s e l e c t i o n p a s s e s to an entry\nfield:\n1. T he l i st b ox t e l ls i ts d i r e c t o r that it's c h a n g e d . 2. T he d i r e c t o r g e ts t he s e l e c t i o n from t he l i st b o x . 3. T he d i r e c t o r p a s s e s t he s e l e c t i o n to t he e n t ry f i e l d . 4. Now that the entry field c o n t a i n s s o me text, the d i r e c t o r e n a b l e s button(s )\nf or i n i t i a t i n g an a c t i o n ( e . g ., \" d e m i b o l d , \" \" o b l i q u e \" ) . Note h ow t he d i r e c t o r mediate s betwee n t he l i st b ox a nd t he entry f i e l d.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 821, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_design_patterns_gof_chunk_0822_584981b8", "text": "g ., \" d e m i b o l d , \" \" o b l i q u e \" ) . Note h ow t he d i r e c t o r mediate s betwee n t he l i st b ox a nd t he entry f i e l d. W i d g e t s\nc o m m u n i c a t e w i th e a ch o t h er o n ly i n d i r e c t l y , t h r o u g h t he d i r e c t o r . T h ey d o n 't\nh a ve to know abou t e a ch o t h e r ; a ll they know is t he d i r e c t o r . Furthermore , b e c a u s e\nt he b e h a v i o r is l o c a l i z e d in o ne c l a s s, it c an be c h a n g e d or r e p l a c e d by e x t e n d i n g\nor r e p l a c i n g that c l a s s . H e r e ' s h ow t he F o n t D i a l o g D i r e c t o r abstractio n c an be integrate d i n to a c l a ss\nl i b r a r y :\n\nptg2 7 6 B E H A V I O R A L P A T T E R N S CHAPTER 5\nD i a l o g D i r e c t o r is an abstrac t c l a ss that define s the overal l behavio r of a d i a -\nl o g. C l i e n t s c a ll the S h o w D i a l o g operatio n to displa y the d i a l o g on the s c r e e n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 822, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_design_patterns_gof_chunk_0823_c3581d7d", "text": "C l i e n t s c a ll the S h o w D i a l o g operatio n to displa y the d i a l o g on the s c r e e n . CreateWidget s is an abstrac t operatio n for creatin g the widget s of a d i a l o g . W i d -\ngetChange d is anothe r abstrac t operation ; widget s c a ll it to infor m t h e ir d i r e c t o r\nthat they have c h a n g e d . D i a l o g D i r e c t o r s u b c l a s s e s o v e r r i d e C r e a t e W i d g e t s to cre-\nate the proper widgets, and they override WidgetChanged to handle the changes. Applicability\nUse the Mediato r patter n when\n• a set of object s communicat e in well-define d but c o m p l e x ways . The r e s u l t i n g\ninterdependencie s are unstructure d and difficul t to understand. • r e u s i n g an objec t is difficul t becaus e it refers to and communicate s with many\nother o b j e c t s . • a behavio r that's distribute d betwee n s e v e r a l c l a s s e s s h o u l d be customizabl e\nwithout a lot of subclassing.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 823, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_design_patterns_gof_chunk_0824_a43555f0", "text": "• a behavio r that's distribute d betwee n s e v e r a l c l a s s e s s h o u l d be customizabl e\nwithout a lot of subclassing. S t r u c t u r e\nA typical object structure might look like this:\n\nptgMEDIATOR 277\nP a r t i c i p a n t s\n• Mediato r ( D i a l o g D i r e c t o r )\n- d e f i n e s an i n t e r f a c e for c o m m u n i c a t i n g with C o l l e a g u e o b j e c t s . • C o n c r e t e M e d i a t o r ( F o n t D i a l o g D i r e c t o r )\n- i m p l e m e n t s c o o p e r a t i v e b e h a v i o r by c o o r d i n a t i n g C o l l e a g u e o b j e c t s . - know s and maintain s its c o l l e a g u e s . • Colleagu e c l a s s e s ( L i s t B o x , EntryField)\n- e a ch C o l l e a g u e c l a ss know s its Mediato r object. - e a ch c o l l e a g u e communicate s with its mediato r wheneve r it woul d have\no t h e r w i s e communicated with another colleague.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 824, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 894}}
{"id": "computer_science_design_patterns_gof_chunk_0825_4b31a434", "text": "- e a ch c o l l e a g u e communicate s with its mediato r wheneve r it woul d have\no t h e r w i s e communicated with another colleague. C o l l a b o r a t i o n s\n• C o l l e a g u e s s e nd and r e c e i v e request s f r om a Mediato r o b j e c t . The mediato r\ni m p l e m e n t s t h e cooperative behavior by routing requests between the appro -\npriate colleague(s). C o n s e q u e n c e s\nThe Mediato r patter n has the followin g benefit s and drawbacks:\n1. It limits subclassing. A mediato r l o c a l i z e s behavio r t h at otherwis e woul d be\ndistribute d amon g severa l objects . Changin g this behavio r r e q u i r e s s u b c l a s s -\ni ng Mediato r o n l y; C o l l e a g u e c l a s s e s c an be r e u s e d as i s . 2. It decouples colleagues. A mediato r promote s l o o se couplin g betwee n c o l -\nl e a g u e s . You can vary and reuse C o l l e a g u e and Mediato r c l a s s e s indepen-\nd e n t l y . 3. It simplifies object protocols.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 825, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_design_patterns_gof_chunk_0826_08364946", "text": "A mediato r promote s l o o se couplin g betwee n c o l -\nl e a g u e s . You can vary and reuse C o l l e a g u e and Mediato r c l a s s e s indepen-\nd e n t l y . 3. It simplifies object protocols. A mediato r r e p l a c e s many-to-man y interaction s\nwith one-to-man y interaction s betwee n the mediato r and its c o l l e a g u e s . O n e -\nto-man y r e l a t i o n s h i p s a re e a s i e r to understand , m a i n t a i n , a nd e x t e n d . 4. It abstracts how objects cooperate. M a k i n g m e d i a t i o n an i n d e p e n d e n t c o n c e p t\nand encapsulatin g it in an objec t l e ts you focus on how o b j e c t s interac t apart\nfrom their individua l b e h a v i o r . That can help clarif y how o b j e c t s interac t in\na system. 5. It centralizes control. The Mediato r patter n trade s complexit y of interactio n\nfor c o m p l e x i t y in the m e d i a t o r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 826, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_design_patterns_gof_chunk_0827_b1e1bf67", "text": "That can help clarif y how o b j e c t s interac t in\na system. 5. It centralizes control. The Mediato r patter n trade s complexit y of interactio n\nfor c o m p l e x i t y in the m e d i a t o r . B e c a u s e a mediato r encapsulate s p r o t o c o l s ,\nit can b e c o m e m o re c o m p l e x than any individua l c o l l e a g u e . T h is can make\nthe mediator itself a monolith that's hard to maintain. ptg278 BEHAVIORAL P A T T E R N S CHAPTER 5\nI m p l e m e n t a t i o n\nThe followin g implementatio n i s s u e s are r e l e v a n t to the Mediato r pattern:\n1. Omitting t he abstract Mediator class. T h e r e ' s no n e ed to defin e an abstrac t\nM e d i a t o r c l a ss w h en c o l l e a g u e s w o rk w i th o n ly o ne m e d i a t o r . T he a b s t r a c t\nc o u p l i n g that the M e d i a t o r c l a ss p r o v i d e s l e ts c o l l e a g u e s work with differen t\nM e d i a t o r s u b c l a s s e s , a nd v i ce versa. 2.Colleague-Mediator communication.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 827, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_design_patterns_gof_chunk_0828_897ef684", "text": "2.Colleague-Mediator communication. C o l l e a g u e s have to c o m m u n i c a t e with\nt h e ir mediato r when an e v e nt of i n t e r e s t o c c u r s . O ne a p p r o a c h is to i m -\np l e m e n t t he Mediato r as an O b s e r v e r using t he O b s e r v e r ( 2 9 3) pattern . C o l -\nl e a g u e c l a s s e s a ct as S u b j e c t s , s e n d i n g notification s to t he mediato r wheneve r\nthey c h a n g e state. T he med ia to r r e s p o n d s by propagatin g t he effect s of t he\nc h a n g e to o t h er c o l l e a g u e s . Anothe r approac h define s a s p e c i a l i z e d n o t i f i c a t i o n interfac e in M e d i a t o r\nthat l e ts c o l l e a g u e s be m o re d i r e c t in their communication . Smalltalk/ V for\nW i n d o w s u s es a form of d e l e g a t i o n : W h en c o m m u n i c a t i n g w i th t he m e d i a -\nt o r, a c o l l e a g u e p a s s e s i t s e lf as an argument , a l l o w i n g the mediato r to identif y\nt h e sender.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 828, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_design_patterns_gof_chunk_0829_f9705ee5", "text": "The Sample Code uses this approach, and the Smalltalk/V im-\nplementation is discussed f u r t h e r in the Known Uses. S a m p l e Code\nW e ' ll use a D i a l o g D i r e c t o r to i m p l e m e n t the font d i a l o g box show n in the M o t i -\nvation . The abstrac t c l a ss D i a l o g D i r e c t o r define s the interfac e for d i r e c t o r s . c l a ss D i a l o g D i r e c t o r {\npublic:\nvirtual \"DialogDirector();\nvirtual void ShowDialog() ; \nvirtual void WidgetChanged(Widget* ) = 0;\nprotected:\nDialogDirector() ; \nvirtual void CreateWidgets( ) = 0 ;\n} ;\nW i d g e t is the abstrac t b a se c l a ss for w i d g e t s . A w i d g e t know s its d i r e c t o r . c l a ss W i d g et {\npublic:\nWidget(DialogDirector*) ;\nvirtual v o id C h a n g e d ( ) ;\nvirtual void HandleMouse(MouseEvent & event);\n// . . . private:\nDialogDirector * _director ;\n} ;\n\nptgMEDIATOR 2 7 9\nC h a n g e d c a l ls the director' s W i d g e t C h a n g e d operation .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 829, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_design_patterns_gof_chunk_0830_3012fcf9", "text": ". . private:\nDialogDirector * _director ;\n} ;\n\nptgMEDIATOR 2 7 9\nC h a n g e d c a l ls the director' s W i d g e t C h a n g e d operation . W i d g e t s c a ll\nW i d g e t C h a n g e d on their director to inform it of a significant event. void Widget::Change d () {\n_director->WidgetChanged(this) ;\n}\nS u b c l a s s e s of D i a l o g D i r e c t o r o v e r r i d e W i d g e t C h a n g e d to affec t the ap-\np r o p r i a t e w i d g e t s . T he w i d g e t p a s s e s a r e f e r e n c e to i t s e lf as an argumen t\nto W i d g e t C h a n g e d to let the d i r e c t o r identif y the w i d g e t that c h a n g e d . D i a l o g D i r e c t o r s u b c l a s s e s redefin e the C r e a t e W i d g e t s pure virtua l to c o n -\nstruc t the w i d g e t s in the d i a l o g . The L i s t B o x , E n t r y F i e l d , and B u t t o n are s u b c l a s s e s of W i d g e t for s p e c i a l -\ni z ed u s er interfac e e l e m e n t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 830, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_design_patterns_gof_chunk_0831_d86a6217", "text": "The L i s t B o x , E n t r y F i e l d , and B u t t o n are s u b c l a s s e s of W i d g e t for s p e c i a l -\ni z ed u s er interfac e e l e m e n t s . L i s t B o x p r o v i d e s a G e t S e l e c t i o n o p e r a t i o n to\nget the c u r r e n t s e l e c t i o n , and E n t r y F ie Id's Set T e xt o p e r a t i o n puts new t e xt\ni n t o the field. c l a ss ListBox : public Widget {\npublic:\nListBox(DialogDirector*);\nvirtual c o n st c h a r* GetSelection() ; \nvirtual void SetList(List<char*> * listltems) ; \nvirtual void HandleMouse(MouseEvent & event);\n// . . . } ;\nc l a ss EntryFiel d : public Widget {\npublic:\nEntryField(DialogDirector*);\nvirtual void S e t T e x t ( c o n s t c h a r* text);\nvirtual const char* GetText() ; \nvirtual void HandleMouse(MouseEvent& event);\nB u t t o n is a s i m p l e w i d g e t that c a l ls Change d w h e n e v e r i t 's p r e s s e d .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 831, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_design_patterns_gof_chunk_0832_9a7990c2", "text": "T h is g e ts\nd o n e in its implementation of HandleMouse:\nc l a ss Button : public Widget {\npublic:\nButton(DialogDirector* ) ;\nvirtual void S e t T e x t ( c o n s t c h a r* text);\nvirtual void HandleMouse(MouseEvent & event);\n// . . . } ;\n\nptg2 80 B E H A V I O R A L PATTERNS CHAPTER 5\nvoid Button::HandleMous e ( M o u s e E v e n t k event) { \n// . . . Changed();\n}\nT he F o n t D i a l o g D i r e c t o r c l a ss m e d i a t e s b e t w e e n w i d g e t s in t he d i a l o g b o x.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 832, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 493}}
{"id": "computer_science_design_patterns_gof_chunk_0833_7e0ac1fc", "text": ". . Changed();\n}\nT he F o n t D i a l o g D i r e c t o r c l a ss m e d i a t e s b e t w e e n w i d g e t s in t he d i a l o g b o x. F o n t D i a l o g D i r e c t o r is a s u b c l a s s of D i a l o g D i r e c t o r :\nc l a ss F o n t D i a l o g D i r e c t o r : public D i a l o g D i r e c t o r {\npublic:\nFontDialogDirector() ; \nvirtual \"FontDialogDirector() ; \nvirtual void WidgetChanged(Widget*);\np r o t e c t e d : \nvirtual void CreateWidgets();\np r i v a t e: \nButton* _ok;\nButton* _cancel;\nListBox* _fontList ; \nEntryField * _fontName;\n} ;\nF o n t D i a l o g D i r e c t o r k e e p s t r a ck of t he w i d g e t s it d i s p l a y s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 833, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 658}}
{"id": "computer_science_design_patterns_gof_chunk_0834_2cfe9398", "text": "It r e d e f i n e s\nC r e a t e W i d g e t s to c r e a t e t he w i d g e t s a nd i n i t i a l i z e i ts r e f e r e n c e s to t h e m :\nvoid FontDialogDirector::CreateWidget s () { \n_ ok = n ew B u t t o n ( t h i s ) ; \n_cancel = new Button(this) ;\n_fontLis t = new ListBox(this) ;\n_fontNam e = new EntryField(this);\n// fill t he l i s t B ox with t he a v a i l a b le f o nt n a m e s\n// a s s e m b le t he w i d g e ts in t he d i a l og\n}\nWidgetChange d e n s u r e s t h at t he w i d g e t s w o rk t o g e t h e r p r o p e r l y :\nvoid FontDialogDirector::WidgetChange d (\nWidget* t h e C h a n g e d W i d g e t\n) {\nif ( t h e C h a n g e d W i d g e t == _fontList ) { \n_ f o n t N a m e - > S e t T e x t ( _ f o n t L i s t - > G e t S e l e c t i o n ( ) ) ;\n} else if ( t h e C h a n g e d W i d g e t == _ok) { \n// a p p ly f o nt c h a n ge a nd d i s m i ss d i a l og\n// . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 834, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 904}}
{"id": "computer_science_design_patterns_gof_chunk_0835_22b5ba7c", "text": ". . ptgMEDIATOR 281\n} else if ( t h e C h a n g e d W i d g e t == _cancel) { \n// dismiss dialog\nT he c o m p l e x i t y of W i d g e t Change d i n c r e a s e s p r o p o r t i o n a l l y w i th t he c o m p l e x i t y\nof t he d i a l o g . L a r ge d i a l o g s a re u n d e s i r a b l e f or other r e a s o n s , of c o u r s e , b ut\nmediator complexity might mitigate the pattern's benefits in other applications. K n o w n Uses\nBoth ET++ [ W G M 8 8 ] a nd t he T H I N K C c l a ss librar y [ S y m 9 3 b ] u se d i r e c t o r - l i k e\no b j e c t s in d i a l o g s as m e d i a t o r s b e t w e e n w i d g e t s . T he a p p l i c a t i o n architectur e of Smalltalk/ V f or W i n d o w s is b a s ed on a m e d i a -\nt or s t r u c t u r e [ L a L 9 4 ] . In that e n v i r o n m e n t , an a p p l i c a t i o n c o n s i s t s of a W i n d o w\nc o n t a i n i n g a s et of p a n e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 835, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_design_patterns_gof_chunk_0836_24982e33", "text": "In that e n v i r o n m e n t , an a p p l i c a t i o n c o n s i s t s of a W i n d o w\nc o n t a i n i n g a s et of p a n e s . T he librar y c o n t a i n s s e v e r a l predefine d Pane o b j e c t s ;\ne x a m p l e s i n c l u d e T e x t P a n e , L i s t B o x , Button , a nd so o n. T h e se p a n es c an be u s ed\nwithou t s u b c l a s s i n g . An a p p l i c a t i o n d e v e l o p e r o n ly s u b c l a s s e s from V i e w M a n -\na g e r, a c l a ss that's r e s p o n s i b l e f or doing inter-pan e c o o r d i n a t i o n . V i e w M a n a g e r is\nt he M e d i a t o r , a nd e a ch pane o n ly know s i ts v i ew manager , w h i c h is c o n s i d e r e d\nthe \"owner\" o f t h e pane. Panes don't r e f e r to each other directly. The following o b j e c t diagram shows a snapshot of an application at run-time:\nSmalltalk/ V u s es an e v e nt m e c h a n i s m for P a n e - V i e w M a n a g e r communication .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 836, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 941}}
{"id": "computer_science_design_patterns_gof_chunk_0837_1c1fe4df", "text": "The following o b j e c t diagram shows a snapshot of an application at run-time:\nSmalltalk/ V u s es an e v e nt m e c h a n i s m for P a n e - V i e w M a n a g e r communication . A\npane g e n e r a t e s an e v e nt when it want s to get informatio n from the m edia to r or \nwhen it want s to infor m the mediato r that s o m e t h i n g s ig nif i can t happened . An\ne v e nt d e f i n e s a s y m b o l ( e . g ., # s e l e c t ) that i d e n t i f i e s t he e v e n t . To h a n d l e t he\ne v e n t , the v i ew manage r r e g i s t e r s a metho d s e l e c t o r with the pane . T h is s e l e c t o r\ni s t h e event's handler; it will be invoked whenever the event occurs.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 837, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 688}}
{"id": "computer_science_design_patterns_gof_chunk_0838_c54f7939", "text": "T h is s e l e c t o r\ni s t h e event's handler; it will be invoked whenever the event occurs. ptg2 82 B E H A V I O R A L PATTERNS CHAPTER 5\nThe followin g c o de excerp t show s how a ListPan e objec t g e ts create d i n s i d e a\nV i e w M a n a g e r s u b c l a s s a nd h ow V i e w M a n a g e r r e g i s t e r s an e v e nt h a n d l e r f or t he\n# s e l e c t event:\nself addSubpane : ( L i s t P a ne new \npaneName : 'myListPane' ; \no w n e r: self; \nw h e n : # s e l e c t p e r f o r m : t t l i s t S e l e c t : ) . Anothe r applicatio n of the Mediato r patter n is in coordinatin g c o m p l e x updates . An exampl e is t he ChangeManage r c l a ss mentione d in O b s e r v e r ( 2 9 3 ) . C h a n g e -\nManage r mediate s betwee n subject s and o b s e r v e r s to a v o id redundan t updates . When an o b j e c t c h a n g e s , it n o t i f i e s t he C h a n g e M a n a g e r , w h i c h in turn c o o r d i n a t e s\nthe updat e by notifyin g the object' s dependents.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 838, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_design_patterns_gof_chunk_0839_0fc0df54", "text": "When an o b j e c t c h a n g e s , it n o t i f i e s t he C h a n g e M a n a g e r , w h i c h in turn c o o r d i n a t e s\nthe updat e by notifyin g the object' s dependents. A s i m i l a r applicatio n appear s in the Unidra w drawin g f r a m e w o r k [ V L 9 0 ] and u s es\na c l a ss c a l l ed C S o l v e r to enforc e connectivit y constraint s betwee n \" c o n n e c t o r s . \"\nObject s in graphica l editor s can appea r to s t i ck to one anothe r in differen t w a y s . Connector s are usefu l in application s t h at maintai n c o n n e c t i v i t y automatically ,\nl i ke diagra m editor s a nd c i r c u i t d e s i g n s y s t e m s . C S o l v e r is a mediato r b etw ee n\nc o n n e c t o r s . It s o l v e s the connectivit y constraint s and update s the c o n n e c t o r s '\np o s i t i o n s to reflect them.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 839, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 841}}
{"id": "computer_science_design_patterns_gof_chunk_0840_1ec30b4f", "text": "C S o l v e r is a mediato r b etw ee n\nc o n n e c t o r s . It s o l v e s the connectivit y constraint s and update s the c o n n e c t o r s '\np o s i t i o n s to reflect them. Related P a t t e r n s\nFacad e ( 1 8 5) d i f f e r s from Mediato r in t h at it abstract s a subsyste m of o b j e c t s\nto provid e a more c o n v e n i e n t interface . Its protoco l is u n i d i r e c t i o n a l ; that is,\nFacad e o b j e c t s make request s of the s u b s y s t e m c l a s s e s but not v i ce versa . In\ncontrast , Mediato r e n a b l e s c o o p e r a t i v e behavio r that c o l l e a g u e object s don't or\ncan't provide, and the protocol is multidirectional. C o l l e a g u e s can communicate with the mediator using the Observer (293) pattern. ptgMEMENTO 283\nM E M E N T O O b j e c t Behavioral\nI n t e n t\nWithou t v i o l a t i n g encapsulation , captur e and e x t e r n a l i z e an o b j e c t ' s interna l state\nso that the object can be restored to this state later.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 840, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_design_patterns_gof_chunk_0841_84b1dd8d", "text": "Also Known As\nT o k e n\nMotivation\nS o m e t i m e s i t 's n e c e s s a r y to r e c o r d t he interna l state of an o b j e c t . T h is is r e q u i r e d\nwhen implementin g c h e c k p o i n t s and undo m e c h a n i s m s that let u s e rs b a ck out of\ntentativ e operation s or r e c o v e r from e r r o r s . Y ou must s a ve state informatio n s o m e -\nwher e so that y ou c an r e s t o r e o b j e c t s to their p r e v i o u s s t a t e s . B ut o b j e c t s n o r m a l l y\nencapsulat e s o me or a ll of their s t a t e, makin g it i n a c c e s s i b l e to other o b j e c t s a nd\ni m p o s s i b l e to s a ve e x t e r n a l l y . Exposin g this state woul d v i o l a t e e n c a p s u l a t i o n ,\nwhic h c an c o m p r o m i s e t he application' s r e l i a b i l i t y a nd e x t e n s i b i l i t y . C o n s i d e r for exampl e a graphica l e d i t o r t h at support s con ne ct ivi t y b e t w e e n ob-\njects.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 841, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_design_patterns_gof_chunk_0842_87283f8d", "text": "C o n s i d e r for exampl e a graphica l e d i t o r t h at support s con ne ct ivi t y b e t w e e n ob-\njects. A u s er can c o n n e c t two r e c t a n g l e s with a l i n e, and the r e c t a n g l e s stay c o n -\nn e c t e d when the user m o v e s eithe r of them . The edito r e n s u r e s that the l i ne\nstretches to maintain the connection. A w e l l - k n o w n way to maintai n c o n n e c t i v i t y r e l a t i o n s h i p s betwee n o b j e c t s is with\na c o n s t r a i n t - s o l v i n g s y s t e m . We can encapsulat e this functionalit y in a Constraint-\nS o l v e r o b j e c t . C o n s t r a i n t S o l v e r r e c o r d s c o n n e c t i o n s as they a re made a nd g e n e r -\nates mathematica l equation s that d e s c r i b e them . It s o l v e s t h e se equation s when-\ne v er the u s er make s a c o n n e c t i o n or oth e rw is e modifie s the diagram .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 842, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 900}}
{"id": "computer_science_design_patterns_gof_chunk_0843_0f0a1c59", "text": "It s o l v e s t h e se equation s when-\ne v er the u s er make s a c o n n e c t i o n or oth e rw is e modifie s the diagram . C o n s t r a i n t -\nS o l v e r u s es t he r e s u l t s of i ts c a l c u l a t i o n s to rearrang e t he graphic s so that they\nmaintai n the p r o p e r c o n n e c t i o n s . Supportin g undo in this applicatio n i s n 't as e a sy as it may s e e m . An o b v i o u s way\nto undo a move operation is to store the original distance moved and move the\n\nptg2 8 4 BEHAVIORAL PATTERNS CHAPTER 5\nobjec t back an e q u i v a l e n t distance . However , t h is d o es not guarante e all o b j e c t s\nw i ll appea r wher e they d id before . S u p p o s e there is s o me s l a ck in t he c o n n e c -\ntion. In that c a s e, simpl y movin g the rectangl e back to its origina l l o c a t i o n won' t\nn e c e s s a r i l y a c h i e v e the desired e f f e c t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 843, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_design_patterns_gof_chunk_0844_a450037d", "text": "In that c a s e, simpl y movin g the rectangl e back to its origina l l o c a t i o n won' t\nn e c e s s a r i l y a c h i e v e the desired e f f e c t . In general , the ConstraintSolver' s publi c interfac e migh t be insufficien t to a l l ow\np r e c i s e reversa l of its effect s on other o b j e c t s . The undo mechanis m must work\nmore c l o s e l y with ConstraintSolve r to r e e s t a b l i s h p r e v i o u s state, but we s h o u l d\na l so a v o id e x p o s i n g the ConstraintSolver' s internal s to the undo mechanism. We can s o l ve this p r o b l e m with the Mement o pattern . A m e m e n t o is an o b j e c t\nthat s t o r e s a snapsho t of the interna l state of anothe r object—th e memento' s\no r i g i n a t o r . The undo mechanis m w i ll r e q u e s t a mement o f r om the originato r\nwhen it n e e ds to c h e c k p o i n t the originator' s state. The originato r i n i t i a l i z e s the\nmement o with informatio n that c h a r a c t e r i z e s its curren t state.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 844, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_design_patterns_gof_chunk_0845_f34afe7f", "text": "The originato r i n i t i a l i z e s the\nmement o with informatio n that c h a r a c t e r i z e s its curren t state. O n ly the originato r\ncan s t o re and r e t r i e v e informatio n from the memento—th e mement o is \" o p a q u e \" \nto other o b j e c t s . In the graphica l e d i t o r exampl e just d i s c u s s e d , the ConstraintSolve r can act as an\noriginator . T he followin g s e q u e n c e of e v e n t s characterize s t he undo p r o c e s s :\n1. T he edito r r e q u e s t s a mement o f r om t he ConstraintSolve r as a side-effec t of\nthe m o ve operation. 2. The C o n s t r a i n t S o l v e r create s and return s a memento , an instanc e of a c l a ss\nS o l v e r S t a t e in t h is c a s e. A S o l v e r S t a t e mement o contain s data structure s that\nd e s c r i b e the curren t state of the ConstraintSolver' s interna l equation s and\nv a r i a b l e s . 3.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 845, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 897}}
{"id": "computer_science_design_patterns_gof_chunk_0846_c3cad0cb", "text": "A S o l v e r S t a t e mement o contain s data structure s that\nd e s c r i b e the curren t state of the ConstraintSolver' s interna l equation s and\nv a r i a b l e s . 3. Later when the u s er undoe s the move operation , the edito r g i v es the S o l v e r -\nState back to the ConstraintSolver. 4. B a s e d on the informatio n in the S o l v e r S t a t e , the ConstraintSolve r change s\nits interna l structure s to retur n its equation s and v a r i a b l e s to their e x a ct\np r e v i o u s state. T h is arrangemen t l e ts the C o n s t r a i n t S o l v e r entrus t other object s with the infor-\nmatio n it needs to rever t to a p r e v i o u s state withou t e x p o s i n g its interna l structur e\nand representations.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 846, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 739}}
{"id": "computer_science_design_patterns_gof_chunk_0847_525b0fff", "text": "ptgMEMENTO 285\nApplicability\nUse the Mement o patter n when\n• a snapsho t of ( s o m e portio n of) an object' s state must be s a v ed so t h at it can\nbe restore d to t h at state l a t e r, and\n• a d i r e c t interfac e to obtainin g the state woul d e x p o s e implementatio n detail s\nand break the object's encapsulation. S t r u c t u r e\nParticipants\n• Mement o ( S o l v e r S t a t e )\n- s t o r e s interna l state of the Originato r object . The mement o may s t o re as\nmuch or as l i t t le of the originator' s interna l state as necessar y at its o r i g i -\nnator' s discretion. - protect s agains t a c c e s s by object s other than the originator . Memento s\nhave effectivel y two interfaces . Caretake r s e es a narrow interfac e to the\nMemento—i t can only p a ss the mement o to other objects . O r i g i n a t o r , in\ncontrast , s e es a wide interface , one t h at l e ts it a c c e s s all the data n e c e s s a r y to\nrestor e i t s e lf to its p r e v i o u s state.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 847, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_design_patterns_gof_chunk_0848_483aeab9", "text": "O r i g i n a t o r , in\ncontrast , s e es a wide interface , one t h at l e ts it a c c e s s all the data n e c e s s a r y to\nrestor e i t s e lf to its p r e v i o u s state. I d e a l l y , o n ly the originato r that produce d\nthe memento would be permitted to access the memento's internal state. • Originator ( C o n s t r a i n t S o l v e r )\n- creates a memento containing a snapshot of its current internal state. - uses the m e m e n t o to r e s t o r e its i n t e r n a l s t a t e . • Caretaker (undo mechanism)\n- is r e s p o n s i b l e for t h e m e m e n t o ' s s a f e k e e p i n g . - never operates on or examines the contents of a memento.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 848, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 666}}
{"id": "computer_science_design_patterns_gof_chunk_0849_2d1b0d15", "text": "• Caretaker (undo mechanism)\n- is r e s p o n s i b l e for t h e m e m e n t o ' s s a f e k e e p i n g . - never operates on or examines the contents of a memento. ptg2 8 6 BEHAVIORAL PATTERNS CHAPTERS\nC o l l a b o r a t i o n s\n• A caretake r r e q u e s t s a mement o from an o r i g i n a t o r , h o l ds it for a t i m e, and\np a s s e s i t b a c k to the originator, a s t h e following interaction diagram illustrates:\nS o m e t i m e s t he c a r e t a k e r w o n ' t p a ss t he m e m e n t o b a ck to t he o r i g i n a t o r , b e -\nc a u se t he o r i g i n a t o r migh t n e v er n e ed to r e v e r t to an e a r l i e r state. • Memento s are p a s s i v e . O n ly the o r i g i n a t o r that c r e a t e d a mement o w i ll a s s i g n\no r retrieve its state. C o n s e q u e n c e s\nT he M e m e n t o patter n h as s e v e r a l c o n s e q u e n c e s :\n1. Preserving encapsulation boundaries.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 849, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_design_patterns_gof_chunk_0850_44f1d700", "text": "C o n s e q u e n c e s\nT he M e m e n t o patter n h as s e v e r a l c o n s e q u e n c e s :\n1. Preserving encapsulation boundaries. Mement o a v o i d s e x p o s i n g informatio n\nthat o n ly an o r i g i n a t o r s h o u l d manag e but that must be s t o r ed n e v e r t h e l e s s\no u t s i d e t he o r i g i n a t o r . T he patter n s h i e l d s o t h er o b j e c t s from p o t e n t i a l l y\nc o m p l e x O r i g i n a t o r i n t e r n a l s , t h e r e b y p r e s e r v i n g e n c a p s u l a t i o n b o u n d a r i e s . 2. It simplifies Originator. In other e n c a p s u l a t i o n - p r e s e r v i n g d e s i g n s , O r i g i n a t o r\nk e e ps the v e r s i o n s of interna l state that c l i e n t s have r e q u e s t e d . T h at puts\na ll t he s t o r a g e m a n a g e m e n t b u r d e n on O r i g i n a t o r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 850, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 855}}
{"id": "computer_science_design_patterns_gof_chunk_0851_5b35d7b8", "text": "T h at puts\na ll t he s t o r a g e m a n a g e m e n t b u r d e n on O r i g i n a t o r . H a v i n g c l i e n t s m a n a g e\nthe state they ask for s i m p l i f i e s O r i g i n a t o r and k e e ps c l i e n t s from h a v i n g to\nnotify o r i g i n a t o r s when they'r e d o n e . 3. Using mementos might be expensive. Memento s m i g h t i n c ur c o n s i d e r a b l e o v e r -\nh e ad if O r i g i n a t o r must c o py l a r ge amount s of informatio n to s t o re in t he\nmement o or if c l i e n t s c r e a t e a nd retur n memento s to t he o r i g i n a t o r often\ne n o u g h . U n l e s s encapsulatin g a nd r e s t o r i n g O r i g i n a t o r state is c h e a p , t he\npatter n migh t n ot be appropriate . S ee t he d i s c u s s i o n of i n c r e m e n t a l i t y in t he\nImplementatio n s e c t i o n . 4. Defining narrow and wide interfaces. It may be difficul t in s o me l a n g u a g e s to\ne n s u r e that o n ly the originato r can a c c e s s the memento' s state. 5.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 851, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1010}}
{"id": "computer_science_design_patterns_gof_chunk_0852_6592cb16", "text": "4. Defining narrow and wide interfaces. It may be difficul t in s o me l a n g u a g e s to\ne n s u r e that o n ly the originato r can a c c e s s the memento' s state. 5. Hidden costs in caring for mementos. A caretake r is r e s p o n s i b l e for d e l e t i n g the\nmementos it cares for. However, the caretaker h a s n o idea how much state is\n\nptgMEMENTO 2 8 7\nin the memento . H e n c e an otherwis e lightweigh t caretake r migh t incur l a r ge\nstorage costs when it stores mementos. Implementation\nHere are two i s s u e s to conside r when implementin g the Mement o pattern:\n1.Language support. Memento s have two interfaces : a wide one for originator s\nand a narro w one for other o b j e c t s . I d e a l l y the implementatio n languag e\nw i ll suppor t two l e v e ls of static protection . C++ lets you do this by makin g \nthe Originato r a friend of Mement o and makin g Memento' s wide interfac e\nprivate. Only the narrow interface should be declared public.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 852, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_design_patterns_gof_chunk_0853_0054b1aa", "text": "C++ lets you do this by makin g \nthe Originato r a friend of Mement o and makin g Memento' s wide interfac e\nprivate. Only the narrow interface should be declared public. For example:\nclass State;\nclass Originato r {\npublic:\nMemento* CreateMemento() ; \nvoid SetMemento(cons t Memento*) ;\n// . . . private:\nState* _state; // internal data structure s\n// . . . } ;\nclass Memento {\npublic:\n// narrow public interfac e\nvirtual ~Memento();\nprivate:\n// private members accessibl e o n ly to Originato r\nfriend class Originator;\nMemento();\nvoid SetState(State*);\nState* GetState O ; \n// . . . private:\nState* _state;\n// . - . } ;\n2. Storing incremental changes. Whe n memento s get create d and p a s s e d back to\ntheir originato r in a predictabl e s e q u e n c e , then Mement o can save just the\nincremental change to the originator' s interna l state.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 853, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 850}}
{"id": "computer_science_design_patterns_gof_chunk_0854_a12f33cb", "text": "Whe n memento s get create d and p a s s e d back to\ntheir originato r in a predictabl e s e q u e n c e , then Mement o can save just the\nincremental change to the originator' s interna l state. For e x a m p l e , undoabl e command s in a histor y l i st can use memento s to en-\nsure t h at command s are restore d to their exact state when they'r e undon e\n( s ee Comman d ( 2 3 3 ) ) . T he histor y l i st define s a s p e c i f i c o rd er in whic h c o m -\nmand s can be undon e and r e d o n e . That mean s memento s can store just the\nincrementa l chang e that a comman d make s rathe r than the f u ll state of every\no b j e c t they a f f e c t . In the Motivatio n exampl e g i v en e a r l i e r , the constrain t\ns o l v e r c a n store only those internal structures that change to keep t h e l i n e\n\nptg288 BEHAVIORAL PATTERNS CHAPTER 5\nc o n n e c t i n g t he r e c t a n g l e s , as o p p o s e d to s t o r i n g t he a b s o l u t e p o s i t i o n s of\nt h e s e objects.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 854, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 997}}
{"id": "computer_science_design_patterns_gof_chunk_0855_a1a46dbe", "text": "Sample Code\nT he C ++ c o de g i v en h e re i l l u s t r a t e s t he C o n s t r a i n t S o l v e r e x a m p l e d i s c u s s e d e a r -\nl i e r. We u se M o v e C o m m a n d o b j e c t s ( s ee C o m m a n d (233) ) to ( u n ) d o t he t r a n s l a t i o n\nof a g r a p h i c a l o b j e c t f r om o ne positio n to a n o t h e r . T he g r a p h i c a l edito r c a l ls t he\nc o m m a n d ' s E x e c u t e o p e r a t i o n to m o ve a g r a p h i c a l o b j e c t and U n e x e c u t e to\nu n do t he move . T he c o m m a n d s t o r e s i ts t a r g e t , t he d i s t a n c e m o v e d , a nd an i n -\ns t a n c e of C o n s t r a i n t S o l v e r M e m e n t o , a m e m e n t o c o n t a i n i n g state f r om the\nc o n s t r a i n t s o l v e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 855, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 771}}
{"id": "computer_science_design_patterns_gof_chunk_0856_2f4aa0b0", "text": "class Graphic; \n// base class for graphica l objects in the graphica l editor\nclass MoveComman d {\npublic:\nMoveCommand(Graphic * target, const Point& delta);\nvoid Execute() ; \nvoid Unexecute();\nprivate: \nConstraintSolverMemento * _state;\nP o i nt _delta;\nGraphic* _target;\n} ;\nT he c o n n e c t i o n c o n s t r a i n t s a re e s t a b l i s h e d by t he c l a ss C o n s t r a i n t S o l v e r . I ts k ey m e m b e r functio n is Solve , w h i c h s o l v e s t he c o n s t r a i n t s r e g i s t e r e d with\nthe A d d C o n s t r a i n t operation . To s u p p o r t u n d o , C o n s t r a i n t S o l v e r ' s s t a te\ncan be externalize d with C r e a t e M e m e n t o into a C o n s t r a i n t S o l v e r M e m e n t o\ni n s t a n c e . T he c o n s t r a i n t s o l v e r c an be r e t u r n e d to a p r e v i o u s state by c a l l i n g\nS e t M e m e n t o . C o n s t r a i n t S o l v e r is a S i n g l e t o n (127).", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 856, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_design_patterns_gof_chunk_0857_fd58b1b4", "text": "T he c o n s t r a i n t s o l v e r c an be r e t u r n e d to a p r e v i o u s state by c a l l i n g\nS e t M e m e n t o . C o n s t r a i n t S o l v e r is a S i n g l e t o n (127). class ConstraintSolve r {\npublic:\nstatic ConstraintSolver * Instance();\nvoid Solve(); \nvoid AddConstraint(\nGraphic* startConnection , Graphic* endConnectio n\n) ; \nvoid RemoveConstraint(\nGraphic* startConnection , Graphic* endConnectio n\n) ;\n\nptgMEMENTO 289\nConstraintSolverMemento * CreateMemento() ;\nvoid SetMemento(ConstraintSolverMemento*);\nprivate: \n// nontrivia l state and operation s for enforcin g\n// connectivit y semantics\n} ;\nclass ConstraintSolverMement o {\npublic:\nvirtual \"ConstraintSolverMemento() ;\nprivate:\nfriend class ConstraintSolver;\nConstraintSolverMemento();\n// private constrain t solver state\n} ;\nG i v en t h e se interfaces , we can i m p l e m e n t M o v e C o n u n a n d m e m b e r s E x e c u t e and\nU n e x e c u t e as follows:\nvoid MoveCommand::Execut e () { \nConstraintSolver * solver = ConstraintSolver::Instance() ;\n_state = solver->CreateMemento() ; // create a memento\n_target->Move(_delta) ; \nsolver->Solve();\n}\nvoid MoveCommand::Unexecut e () { \nConstraintSolver * solver = ConstraintSolver::Instance() ;\n_target->Move(-_delta) ; \nsolver->SetMemento(_state) ; // restore s o l v er state \nsolver->Solve();\n}\nE x e c u t e a c q u i r e s a C o n s t r a i n t S o l v e r M e m e n t o mement o befor e it m o v e s the\ng r a p h i c .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 857, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1468}}
{"id": "computer_science_design_patterns_gof_chunk_0858_101d53ba", "text": "U n e x e c u t e m o v e s the g r a p h i c b a c k, s e ts the c o n s t r a i n t s o l v e r ' s state to\nt h e previous state, and finally tells the constraint solver to solve the constraints. K n o w n Uses\nT he p r e c e d i n g sampl e c o de is b a s ed on Unidraw' s suppor t f or c o n n e c t i v i t y\nthroug h i ts C S o l v e r c l a ss [ V L 9 0 1 . C o l l e c t i o n s in D y l a n [ A p p 9 2 ] p r o v i d e an iteratio n interfac e that reflect s t he M e -\nment o pattern . Dylan' s c o l l e c t i o n s have t he n o t i o n of a \" s t a t e \" o b j e c t , w h i c h is a\nmement o that r e p r e s e n t s t he state of t he iteration . E a ch c o l l e c t i o n c an r e p r e s e n t\nt he curren t state of t he iteratio n in a ny w ay it c h o o s e s ; t he representatio n is c o m -\np l e t e l y hidde n from c l i e n t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 858, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 859}}
{"id": "computer_science_design_patterns_gof_chunk_0859_cafe775f", "text": "E a ch c o l l e c t i o n c an r e p r e s e n t\nt he curren t state of t he iteratio n in a ny w ay it c h o o s e s ; t he representatio n is c o m -\np l e t e l y hidde n from c l i e n t s . The D y l a n iteratio n approac h migh t be translate d to\nC++ as follows:\n\nptg290 BEHAVIORAL PATTERNS CHAPTER 5\ntemplate <class Item>\nclass Collectio n {\npublic:\nCollection();\nIterationState * CreatelnitialState() ; \nvoid Next(IterationState*) ; \nbool I s D o n e ( c o n s t IterationState* ) const;\nItem Currentltem(cons t IterationState* ) const;\nI t e r a t i o n S t a t e * C o p y ( c o n s t I t e r a t i o n S t a t e * ) c o n s t ;\nvoid Append(cons t Item&);\nvoid Remove(cons t Item&);\n// . . . } ;\nC r e a t e l n i t i a l S t a t e r e t u r n s an initialize d I t e r a t i o n S t a t e o b j e c t for the\ncollection .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 859, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 835}}
{"id": "computer_science_design_patterns_gof_chunk_0860_062ca1d5", "text": ". . } ;\nC r e a t e l n i t i a l S t a t e r e t u r n s an initialize d I t e r a t i o n S t a t e o b j e c t for the\ncollection . Next a d v a n c e s t he state o b j e c t to t he n e xt p o s i t i o n in t he i t e r a t i o n ;\nit effectivel y i n c r e m e n t s the i t e r a t i o n i n d e x . Is Done r e t u r n s t r ue if N e xt has\na d v a n c e d b e y o n d t he last e l e m e n t in t he c o l l e c t i o n . C u r r e n t l t e m d e r e f e r e n c e s\nt he s t a te o b j e c t a nd r e t u r n s t he e l e m e n t in t he c o l l e c t i o n to w h i c h it refers . C o py\nr e t u r n s a c o py of t he g i v en state o b j e c t . T h is is u s e f u l f or m a r k i n g a p o i nt in an\niteration. Give n a c l a ss I t e m T y p e , we can iterat e o v er a c o l l e c t i o n of its i n s t a n c e s as\nfollows 7:\nclass ItemType {\npublic:\nvoid Process() ;\n// . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 860, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_design_patterns_gof_chunk_0861_d679e05a", "text": "Give n a c l a ss I t e m T y p e , we can iterat e o v er a c o l l e c t i o n of its i n s t a n c e s as\nfollows 7:\nclass ItemType {\npublic:\nvoid Process() ;\n// . . . } ;\nCollection<ItemType* > aCollection ;\nIterationState * state;\nstate - aCollection.CreatelnitialState();\nwhile (laCollection.IsDone(state) ) {\naCollection.CurrentItern(state)->Process() ;\naCollection.Next(state);\n} \ndelete state;\nT he m e m e n t o - b a s e d i t e r a t i o n interfac e h as t wo i n t e r e s t i n g b e n e f i t s :\n1. M o re t h an o ne state c an w o rk on t he s a me c o l l e c t i o n . ( T he s a me is t r ue of t he\nI t e r a t o r (257) pattern.)\n7Note that o ur e x a m p l e d e l e t e s t he state o b j e c t at t he e nd of t he i t e r a t i o n . B ut d e l e t e w o n ' t g et c a l l e d if\nP r o c e s s l t e m t h r o w s an e x c e p t i o n , t h us c r e a t i n g g a r b a g e . T h is is a p r o b l e m in C++ but not in D y l a n , whic h \nh a s garbage collection.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 861, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_design_patterns_gof_chunk_0862_8b327b47", "text": "T h is is a p r o b l e m in C++ but not in D y l a n , whic h \nh a s garbage collection. We d i s c u s s a solution to this problem on page 266. ptgMEMENTO 2 9 1\n2. It d o e s n ' t r e q u i r e b r e a k i n g a c o l l e c t i o n ' s e n c a p s u l a t i o n to suppor t i t e r a t i o n . T he mement o is o n ly i n t e r p r e t e d by t he c o l l e c t i o n i t s e l f ; no o ne e l se h as a c c e s s\nto i t. O t h e r a p p r o a c h e s to i t e r a t i o n r e q u i r e b r e a k i n g e n c a p s u l a t i o n by makin g\niterato r c l a s s e s M e n d s of t h e ir c o l l e c t i o n c l a s s e s ( s ee Iterato r ( 2 5 7 ) ) . T he\ns i t u a t i o n is r e v e r s e d in the m e m e n t o - b a s e d i m p l e m e n t a t i o n : C o l l e c t i o n\nis a friend of the i t e r a t o r S t a t e . T he Q O C A c o n s t r a i n t - s o l v i n g t o o l k i t s t o r es i n c r e m e n t a l informatio n in m e m e n -\nt os [ H H M V 9 2 ] .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 862, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_design_patterns_gof_chunk_0863_aeda0b0e", "text": "T he Q O C A c o n s t r a i n t - s o l v i n g t o o l k i t s t o r es i n c r e m e n t a l informatio n in m e m e n -\nt os [ H H M V 9 2 ] . C l i e n t s c an o b t a i n a m e m e n t o that c h a r a c t e r i z e s t he c u r r e n t s o -\nl u t i on to a s y s t e m of c o n s t r a i n t s . T he mement o c o n t a i n s o n ly t h o se constrain t\nv a r i a b l e s that h a ve c h a n g e d s i n ce t he l a st s o l u t i o n . U s u a l l y o n ly a s m a ll s u b s e t\nof t he s o l v e r ' s v a r i a b l e s c h a n g e s f or e a ch n ew s o l u t i o n . T h is s u b s e t is e n o u g h\nto r e t u rn t he s o l v e r to t he p r e c e d i n g s o l u t i o n ; r e v e r t i n g to e a r l i e r s o l u t i o n s r e -\nq u i r e s r e s t o r i n g m e m e n t o s from t he i n t e r v e n i n g s o l u t i o n s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 863, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 846}}
{"id": "computer_science_design_patterns_gof_chunk_0864_27428f45", "text": "H e n c e y ou can't s et\nm e m e n t o s in a ny o r d e r ; Q O C A r e l i es on a h i s t o r y m e c h a n i s m to r e v e r t to e a r l i e r\ns o l u t i o n s . R e l a t e d Patterns\nC o m m a n d ( 2 3 3 ) : C o m m a n d s c an u se m e m e n t o s to maintai n state f or u n d o a b l e\no p e r a t i o n s . Iterator (257): M e m e n t o s can be used for iteration as described earlier. ptg\nThis page intentionally left blank \n\nptgOBSERVER 293\nO B S E R V E R O b j e c t Behavioral\nIntent\nDefin e a one-to-man y dependenc y betwee n o b j e c t s so that when one o b j e c t\nchanges state, all its dependents are notified a n d updated automatically. Also Known A s\nDependents, Publish-Subscribe\nMotivation\nA commo n side-effec t of partitionin g a syste m into a c o l l e c t i o n of cooperatin g\nc l a s s e s is the n e ed to maintai n c o n s i s t e n c y betwee n relate d o b j e c t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 864, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_design_patterns_gof_chunk_0865_ddd36f47", "text": "You don't\nwant to a c h i e v e c o n s i s t e n c y by makin g the c l a s s e s tightl y c o u p l e d , b e c a u s e that\nr e d u c e s their reusability. For example , many graphica l user interfac e toolkit s separat e the presentationa l\na s p e c t s of t he u s er interfac e from t he u n d e r l y i n g a p p l i c a t i o n data [ K P 8 8 , L V C 8 9 ,\nP+ 8 8, W G M 8 8 ] . C l a s s e s definin g applicatio n data a nd presentation s can be r e u s e d\ni n d e p e n d e n t l y . T h ey c an work t o g e t h e r , t o o. B o th a s p r e a d s h e e t o b j e c t a nd b ar\nchart objec t can depic t informatio n in the same applicatio n data objec t using\ndifferen t p r e s e n t a t i o n s . T he s p r e a d s h e e t a nd t he b ar c h a rt d o n 't know a b o u t e a ch \nother , thereb y lettin g you r e u se only the one you need. But they behave as thoug h\nthey do.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 865, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_design_patterns_gof_chunk_0866_74e0ca11", "text": "T he s p r e a d s h e e t a nd t he b ar c h a rt d o n 't know a b o u t e a ch \nother , thereb y lettin g you r e u se only the one you need. But they behave as thoug h\nthey do. Whe n the u s er c h a n g e s the informatio n in the s p r e a d s h e e t , the bar c h a rt\nreflects the changes immediately, a n d vice versa. ptg2 9 4 B E H A V I O R A L P A T T E R N S CHAPTER 5\nT h is behavio r i m p l i e s that t he s p r e a d s h e e t a nd b ar chart a re d e p e n d e n t on t he\ndata o b j e c t a nd therefor e s h o u l d be notifie d of a ny c h a n g e in i ts state. A nd t h e r e ' s\nno reaso n to l i m it the numbe r of d e p e n d e n t object s to two; there may be any\nnumbe r of differen t user interface s to the s a me data. T he O b s e r v e r patter n d e s c r i b e s h ow to e s t a b l i s h t h e se r e l a t i o n s h i p s . T he k ey\no b j e c t s in t h is patter n are subjec t and observer . A s u b j e c t may have any numbe r\nof dependen t observers .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 866, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_design_patterns_gof_chunk_0867_c1b804c3", "text": "T he k ey\no b j e c t s in t h is patter n are subjec t and observer . A s u b j e c t may have any numbe r\nof dependen t observers . All o b s e r v e r s are notifie d w h e n e v e r the subjec t u n d e r g o e s\na c h a n g e in state. In r e s p o n s e , e a ch o b s e r v e r w i ll query t he subjec t to s y n c h r o n i z e\nits state with the subject' s state. T h is k i nd of interactio n is a l so know n as publish-subscribe . T he subjec t is t he\npublishe r of notifications . It s e n ds out t h e se notification s withou t havin g to know\nwho its observers are. Any number of observers can subscribe to receive notifica -\nt i o n s . Applicability\nUse the O b s e r v e r patter n in any of the followin g situations:\n• Whe n an abstractio n has two aspects , one dependen t on the o t h e r . Encapsu-\nlating t h e se aspect s in separat e o b j e c t s l e ts you vary and r e u se them i n d e -\np e n d e n t l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 867, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_design_patterns_gof_chunk_0868_69ba5ba0", "text": "Encapsu-\nlating t h e se aspect s in separat e o b j e c t s l e ts you vary and r e u se them i n d e -\np e n d e n t l y . • Whe n a chang e to one objec t require s c h a n g i n g o t h e r s , and you don't k n ow\nhow many object s n e ed to be changed. • Whe n an o b j e c t s h o u l d be a b le to notif y other object s withou t makin g as-\nsumption s abou t who t h e se object s a r e. In o t h er w o r d s , you d o n 't want t h e se \no b j e c t s tightly coupled. S t r u c t u r e\n\nptgOBSERVER 295\nP a r t i c i p a n t s\n• Subject\n- know s its o b s e r v e r s . Any numbe r of O b s e r v e r o b j e c t s may o b s e r v e a s u b -\nject. - p r o v i d e s an interfac e for attachin g and detachin g O b s e r v e r objects. • O b s e r v e r\n- define s an updatin g interfac e f or o b j e c t s that s h o u l d be notifie d of c h a n g e s\nin a s u b j e c t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 868, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_design_patterns_gof_chunk_0869_5325439a", "text": "• O b s e r v e r\n- define s an updatin g interfac e f or o b j e c t s that s h o u l d be notifie d of c h a n g e s\nin a s u b j e c t . • C o n c r e t e S u b j e c t\n- s t o r es s t a te of i n t e r e s t to C o n c r e t e O b s e r v e r o b j e c t s . - s e n ds a notificatio n to its o b s e r v e r s when its state c h a n g e s . • C o n c r e t e O b s e r v e r\n- maintain s a referenc e to a C o n c r e t e S u b j e c t o b j e c t . - s t o r es state that s h o u l d stay c o n s i s t e n t with the s u b j e c t ' s . - implement s the O b s e r v e r updatin g interfac e to k e ep its state c o n s i s t e n t\nwith the subject's. C o l l a b o r a t i o n s\n• C o n c r e t e S u b j e c t notifie s its o b s e r v e r s wheneve r a chang e o c c u r s that c o u ld\nmake its o b s e r v e r s ' state i n c o n s i s t e n t with its o w n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 869, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 874}}
{"id": "computer_science_design_patterns_gof_chunk_0870_033a8848", "text": "• After b e i ng informe d of a c h a n g e in t he c o n c r e t e s u b j e c t , a C o n c r e t e O b s e r v e r\no b j e c t may query the s u b j e c t for information . C o n c r e t e O b s e r v e r u s es this in-\nformatio n to r e c o n c i l e its state with that of the subject. T he f o l l o w i n g i n t e r a c t i o n d i a g r a m i l l u s t r a t e s t he c o l l a b o r a t i o n s b e t w e e n a\nsubject and two observers:\n\nptg296 BEHAVIORAL PATTERNS CHAPTERS\nNote how the Observe r o b j e c t that initiate s the c h a n g e reques t p o s t p o n e s its\nupdat e until it g e ts a notificatio n f r om the subject . Notif y is not alway s c a l l ed\nby t he subject . It c an be c a l l ed by an o b s e r v e r or by anothe r k i nd of o b j e c t\ne n t i r e l y . The Implementation section discusses some common variations. C o n s e q u e n c e s\nThe Observe r patter n lets you vary subject s and o b s e r v e r s i n d e p e n d e n t l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 870, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_design_patterns_gof_chunk_0871_22933bb6", "text": "The Implementation section discusses some common variations. C o n s e q u e n c e s\nThe Observe r patter n lets you vary subject s and o b s e r v e r s i n d e p e n d e n t l y . You\ncan reuse subject s withou t r e u s i n g their o b s e r v e r s , and v i ce versa . It l e ts you add\nobserver s withou t modifyin g the subjec t or o t h er o b s e r v e r s . Furthe r benefit s and l i a b i l i t i e s of the O b s e r v e r patter n includ e the f o l l o w i n g :\n1. Abstract coupling between Subject a nd Observer. A ll a subjec t know s is that it\nh as a l i st of o b s e r v e r s , e a ch c o n f o r m i n g to t he s i m p l e i n t e r f a c e of t he a b s t r a c t\nO b s e r v e r c l a s s . T he subjec t d o e s n ' t know t he c o n c r e t e c l a ss of a ny o b s e r v e r . T h us the c o u p l i n g betwee n subject s and o b s e r v e r s is abstrac t and m i n i m a l .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 871, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_design_patterns_gof_chunk_0872_2b89812b", "text": "T he subjec t d o e s n ' t know t he c o n c r e t e c l a ss of a ny o b s e r v e r . T h us the c o u p l i n g betwee n subject s and o b s e r v e r s is abstrac t and m i n i m a l . Becaus e Subjec t and O b s e r v e r aren' t tightl y c o u p l e d , they can b e l o n g to\ndifferen t layer s of abstractio n in a s y s t e m . A l o w e r - l e v e l s u b j e c t can c o m -\nmunicat e and infor m a h i g h e r - l e v e l o b s e r v e r , thereb y k e e p i n g the s y s t e m ' s\nlayerin g intact . If S u b j e c t and O b s e r v e r are lumpe d t o g e t h e r , then the result-\ning objec t must eithe r span two l a y e r s (and violat e the l a y e r i n g ) , or it must be\nforce d to l i ve in one layer or the other ( w h i c h migh t compromis e the layerin g\nabstraction). 2. Support for broadcast communication. Unlik e an ordinar y r e q u e s t , the notifi-\nc a t i o n that a subjec t s e n ds n e e d n ' t specif y i ts r e c e i v e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 872, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_design_patterns_gof_chunk_0873_1740ed26", "text": "2. Support for broadcast communication. Unlik e an ordinar y r e q u e s t , the notifi-\nc a t i o n that a subjec t s e n ds n e e d n ' t specif y i ts r e c e i v e r . T he notificatio n is\nbroadcas t automaticall y to all i n t e r e s t e d o b j e c t s that s u b s c r i b e d to it. The\nsubjec t doesn' t c a re how many intereste d object s e x i s t; its o n ly r e s p o n s i b i l -\nity is to notif y its o b s e r v e r s . T h is g i v es you the freedo m to add and r e m o v e \no b s e r v e r s at any time. It's up to the o b s e r v e r to handl e or i g n o r e a notification. 3. Unexpected updates. B e c a u s e o b s e r v e r s have no k n o w l e d g e of e a ch other' s\np r e s e n c e , they can be blind to the ultimat e c o st of c h a n g i n g the s u b j e c t . A\ns e e m i n g l y innocuou s operatio n on the subjec t may c a u se a c a s c a d e of update s \nto o b s e r v e r s and t h e ir dependen t objects .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 873, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_design_patterns_gof_chunk_0874_23516f3f", "text": "A\ns e e m i n g l y innocuou s operatio n on the subjec t may c a u se a c a s c a d e of update s \nto o b s e r v e r s and t h e ir dependen t objects . M o r e o v e r , d e p e n d e n c y c r i t e r i a that\naren' t well-define d or maintaine d usuall y l e ad to spuriou s updates , w h i c h\ncan be hard to track down. T h is proble m is aggravate d by the f a ct that the s i m p l e updat e protoco l pro-\nvides no d e t a i l s on what c h a n g e d in the subject . Withou t additiona l protoco l\nto h e lp o b s e r v e r s d i s c o v e r what changed , they may be force d to work hard\nt o deduce the changes. I m p l e m e n t a t i o n\nS e v e r a l i s s u e s r e l a t e d to t he i m p l e m e n t a t i o n of t he d e p e n d e n c y m e c h a n i s m a re\nd i s c u s s e d in this section. ptgOBSERVER 297\n1. Mapping subjects to their observers.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 874, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 870}}
{"id": "computer_science_design_patterns_gof_chunk_0875_55145d26", "text": "ptgOBSERVER 297\n1. Mapping subjects to their observers. The s i m p l e s t way for a subjec t to keep\ntrack of the observer s it s h o u l d notif y is to store reference s to them explicitl y\nin t he s u b j e c t . H o w e v e r , s u ch s t o r a g e m ay be t oo e x p e n s i v e w h en t h e re a re\nmany subject s and few observers . One solutio n is to trade space for time by\nusing an a s s o c i a t i v e look-u p ( e . g ., a hash table ) to maintai n the subject-to-\no b s e r v e r mapping . T h us a subjec t with no o b s e r v e r s d o es not incur storag e\noverhead . On the other hand , t h is approac h increase s the c o st of a c c e s s i n g\nthe observers. 2.Observing more than one subject. It migh t make s e n se in some situation s for\nan o b s e r v e r to depen d on more than one subject . For example , a spreadshee t\nmay d e p e n d on more than one data s o u r c e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 875, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 903}}
{"id": "computer_science_design_patterns_gof_chunk_0876_8aa2ea2d", "text": "It migh t make s e n se in some situation s for\nan o b s e r v e r to depen d on more than one subject . For example , a spreadshee t\nmay d e p e n d on more than one data s o u r c e . I t 's necessar y to e x t e n d the\nUpdat e interfac e in s u ch c a s es to let the o b s e r v e r know which subjec t is\ns e n d i n g the notification . The subjec t can simpl y p a ss i t s e lf as a paramete r\nin the Updat e operation , thereb y lettin g the o b s e r v e r know whic h subjec t to\nexamine. 3. Who triggers the update? The subjec t and its o b s e r v e r s r e ly on the notificatio n\nmechanis m to stay c o n s i s t e n t . But what o b j e c t actuall y c a l ls N o t i f y to trigge r\nthe update ? H e re are two o p t i o n s :\n(a)Have state-settin g operation s on S u b j e c t c a ll N o t i f y a f t er they c h a n g e\nthe subject' s state. The advantag e of this approac h is that c l i e n t s don't \nhave to remembe r to c a ll Notif y on the subject .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 876, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_design_patterns_gof_chunk_0877_7465ae47", "text": "The advantag e of this approac h is that c l i e n t s don't \nhave to remembe r to c a ll Notif y on the subject . The disadvantag e is that\ns e v e r a l consecutiv e operation s will c a u se severa l consecutiv e updates ,\nwhic h may be inefficient. (b)Make c l i e n t s r e s p o n s i b l e for c a l l i n g Notif y at the right time. The advan-\ntage h e re is that the c l i e n t can wait to trigge r the u p d a t e until a f t er a s e r i es\nof state c h a n g e s has b e en made , thereb y avoidin g n e e d l e s s intermediat e\nupdates . The disadvantag e is that c l i e n t s have an adde d r e s p o n s i b i l i t y\nto t r i g g e r t he u p d a t e . T h at m a k e s e r r o r s m o re l i k e l y , s i n ce c l i e n t s m i g h t\nforge t to c a ll Notify. 4. Dangling references to deleted subjects. D e l e t i n g a subjec t s h o u l d not produc e\ndanglin g r e f e r e n c e s in its o b s e r v e r s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 877, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 934}}
{"id": "computer_science_design_patterns_gof_chunk_0878_e0c71653", "text": "4. Dangling references to deleted subjects. D e l e t i n g a subjec t s h o u l d not produc e\ndanglin g r e f e r e n c e s in its o b s e r v e r s . One way to a v o id danglin g reference s\nis to make the subjec t notif y its observer s as it is delete d so that they can\nr e s et t h e ir r e f e r e n c e to i t. In g e n e r a l , s i m p l y d e l e t i n g t he o b s e r v e r s is n ot an\no p t i o n , becaus e other o b j e c t s may referenc e them , or they may be observin g\nother subject s as well. 5. Making sure Subject state is self-consistent before notification. It's importan t to\nmake sure S u b j e c t state is s e l f - c o n s i s t e n t befor e c a l l i n g Notify , becaus e ob-\ns e r v e r s q u e ry t he s u b j e c t f or i ts c u r r e n t s t a te in t he c o u r s e of updatin g t h e ir\nown state. T h is s e l f - c o n s i s t e n c y rule is easy to violat e unintentionall y when S u b j e c t\ns u b c l a s s o p e r a t i o n s call inherited operations.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 878, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_design_patterns_gof_chunk_0879_6e6f0c2c", "text": "T h is s e l f - c o n s i s t e n c y rule is easy to violat e unintentionall y when S u b j e c t\ns u b c l a s s o p e r a t i o n s call inherited operations. For e x a m p l e , the notification in\n\nptg2 98 B E H A V I O R A L PATTERNS CHAPTER 5\nt he followin g c o de s e q u e n c e is t r i g g e d when t he subjec t is in an i n c o n s i s t e n t\nstate:\nvoid M y S u b j e c t : : O p e r a t i o n ( i nt n e w V a l u e ) {\nB a s e C l a s s S u b j e c t : : O p e r a t i o n ( n e w V a l u e ) ;\n// t r i g g er notification\n_ m y ! n s t V a r += n e w V a l u e ;\n// u p d a te s u b c l a ss state ( t oo late!)\n}\nYou can a v o id t h is pitfal l by s e n d i n g notification s from templat e method s\n( T e m p l a t e M e t h o d ( 3 2 5 ) ) in abstrac t S u b j e c t c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 879, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 808}}
{"id": "computer_science_design_patterns_gof_chunk_0880_d6b22e44", "text": "D e f i n e a primitiv e o p -\neratio n f or s u b c l a s s e s to o v e r r i d e , a nd make Notif y t he l a st o p e r a t i o n in t he\ntemplat e method , whic h w i ll e n s u r e that t he o b j e c t is s e l f - c o n s i s t e n t when\ns u b c l a s s e s overrid e S u b j e c t o p e r a t i o n s . void T e x t : : C ut ( T e x t R a n g e r) { \nReplaceRange(r) ; // r e d e f i n ed in s u b c l a s s e s\nNotify();\n}\nBy the way, it's alway s a g o od i d ea to documen t w h i c h S u b j e c t operation s\nt r i g g e r notifications. 6. Avoiding observer-specific update protocols: the push and pull models. I m p l e m e n -\ntation s of the O b s e r v e r patter n often have the subjec t broadcas t a d d i t i o n a l\ninformatio n abou t t he c h a n g e . T he s u b j e c t p a s s e s t h is informatio n as an\nargumen t to Update . The amoun t of informatio n may vary w i d e l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 880, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_design_patterns_gof_chunk_0881_a5745d8e", "text": "T he s u b j e c t p a s s e s t h is informatio n as an\nargumen t to Update . The amoun t of informatio n may vary w i d e l y . At o ne e x t r e m e , w h i c h we c a ll t he p u sh m o d e l , t he subjec t s e n ds o b s e r v e r s\ndetaile d informatio n abou t the c h a n g e , whethe r they want it or not. At the\no t h er extrem e is t he pull m o d e l ; t he s u b j e c t s e n ds n o t h i n g b ut t he most\nm i n i m a l notification , and o b s e r v e r s ask for d e t a i l s e x p l i c i t l y thereafter. T he pull mode l e m p h a s i z e s t he subject' s i g n o r a n c e of i ts o b s e r v e r s , w h e r e a s\nthe push mode l a s s u m e s s u b j e c t s k n ow s o m e t h i n g abou t t h e ir o b s e r v e r s '\nn e e d s . T he push m o d e l migh t make o b s e r v e r s l e ss r e u s a b l e , b e c a u s e S u b j e c t\nc l a s s e s make assumption s abou t O b s e r v e r c l a s s e s that m i g h t n ot alway s be\ntrue.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 881, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_design_patterns_gof_chunk_0882_7d670b6f", "text": "On the o t h er h a n d , the pull m o d e l may be inefficient , b e c a u s e O b s e r v e r\nc l a s s e s must a s c e r t a i n what c h a n g e d withou t h e lp from the S u b j e c t . 7. Specifying modifications of interest explicitly. You can improv e updat e efficienc y\nby e x t e n d i n g the s u b j e c t ' s registratio n interfac e to a l l ow r e g i s t e r i n g o b s e r v e r s\no n ly f or s p e c i f i c e v e n t s of i n t e r e s t . W h e n s u ch an e v e nt o c c u r s , t he s u b j e c t\ninform s o n ly t h o se o b s e r v e r s that have r e g i s t e r e d i n t e r e s t in that e v e n t . O ne\nw ay to suppor t t h is u s es t he notio n of a s p e c t s f or S u b j e c t o b j e c t s . To r e g i s t e r\ni n t e r e s t in particular events, observers are attached to their subjects using\nvoid Subject::Attach(Observer*, Aspects interest);\n\nptgOBSERVER 2 9 9\nwher e i n t e r e s t specifie s the even t of i n t e r e s t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 882, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_design_patterns_gof_chunk_0883_a9e42ec3", "text": "At notificatio n t i m e, the\nsubjec t supplie s the c h a n g e d a s p e c t to its observer s as a paramete r to the\nUpdate operation. For e x a m p l e :\nvoid Observer::Update(Subject*, Aspect& interest);\nEncapsulating complex update semantics. Whe n the dependenc y r e l a t i o n s h i p\nbetwee n subject s and o b s e r v e r s is particularl y complex , an o b j e c t that main-\ntains t h e se r e l a t i o n s h i p s migh t be r e q u i r e d . We c a ll s u ch an objec t a C h a n g e -\nM a n a g e r . Its purpos e is to m i n i m i z e the work r e q u i r e d to make o b s e r v e r s\nreflec t a c h a n g e in t h e ir subject . F or e x a m p l e , if an operatio n i n v o l v e s c h a n g e s\nto s e v e r a l interdependen t subjects , you migh t have to ensur e that their ob-\ns e r v e r s are notifie d o n ly a f t er all the subject s have been modifie d to a v o id\nnotifying o b s e r v e r s more than o n c e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 883, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_design_patterns_gof_chunk_0884_29aea4ae", "text": "ChangeManage r has three r e s p o n s i b i l i t i e s :\n(a)It maps a subjec t to its o b s e r v e r s and provide s an interfac e to maintai n\nthis mapping . T h is eliminate s the n e ed for subject s to maintai n reference s\nto their o b s e r v e r s and v i ce versa. (b)It define s a particula r updat e strategy. (c)It update s all dependen t observer s at the reques t of a subject. The followin g diagra m depict s a s i m p l e ChangeManager-base d implemen-\ntation of the O b s e r v e r pattern . T h e re are two s p e c i a l i z e d ChangeManagers . S i m p l e C h a n g e M a n a g e r is naive in that it alway s update s a ll o b s e r v e r s of e a ch\nsubject . In contrast , DAGChangeManage r handle s d i r e c t e d - a c y c l i c graph s of\ndependencie s betwee n subject s and their o b s e r v e r s . A DAGChangeManage r\nis preferabl e to a SimpleChangeManage r when an o b s e r v e r o b s e r v e s more\nthan one subject .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 884, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 957}}
{"id": "computer_science_design_patterns_gof_chunk_0885_a63506e6", "text": "A DAGChangeManage r\nis preferabl e to a SimpleChangeManage r when an o b s e r v e r o b s e r v e s more\nthan one subject . In that c a s e, a c h a n g e in two or more subject s migh t c a u se\nredundan t updates . T he DAGChangeManage r e n s u r e s t he o b s e r v e r r e c e i v e s\nj u st one update . S i m p l e C h a n g e M a n a g e r is fine when multipl e update s aren' t\nan issue. ptg3 0 0 BEHAVIORAL PATTERNS CHAPTER 5\nC h a n g e M a n a g e r is an i n s t a n c e of t he Mediato r ( 2 7 3) pattern . In g e n e r a l t h e re\nis o n ly o ne C h a n g e M a n a g e r , a nd it is know n g l o b a l l y . T he S i n g l e t o n ( 1 2 7)\npatter n woul d be usefu l h e r e . 9.Combining t he Subject a nd Observer classes. C l a ss l i b r a r i e s writte n in l a n g u a g e s \nthat lack multipl e i n h e r i t a n c e (like Smalltalk ) generall y don't defin e separat e\nS u b j e c t a nd O b s e r v e r c l a s s e s b ut c o m b i n e their interface s in o ne c l a s s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 885, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_design_patterns_gof_chunk_0886_7d55ca3e", "text": "That\nl e ts you defin e an o b j e c t that acts as both a subjec t and an o b s e r v e r withou t\nm u l t i p l e i n h e r i t a n c e . In S m a l l t a l k , f or e x a m p l e , t he S u b j e c t a nd O b s e r v e r\ninterface s are define d in the root c l a ss O b j e c t , makin g them a v a i l a b l e to all\nc l a s s e s . S a m p l e C o d e\nAn abstrac t c l a ss define s the O b s e r v e r interface:\nc l a ss S u b j e c t ;\nc l a ss O b s e r v er {\npublic:\nvirtual \" O b s e r v e r ( ) ; \nv i r t u a l void U p d a t e ( S u b j e c t * theChangedSubject) = 0;\nprotected:\nO b s e r v e r ( ) ;\nT h is i m p l e m e n t a t i o n s u p p o r t s m u l t i p l e s u b j e c t s f or e a ch o b s e r v e r . T he s u b -\nject passe d to the U p d a t e operatio n l e ts the o b s e r v e r determin e w h i c h subjec t\nc h a n g e d w h e n it observes more than one.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 886, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_design_patterns_gof_chunk_0887_9799dd6f", "text": "T he s u b -\nject passe d to the U p d a t e operatio n l e ts the o b s e r v e r determin e w h i c h subjec t\nc h a n g e d w h e n it observes more than one. S i m i l a r l y , an abstract class defines the Subject i n t e r f a c e :\n\nptgOBSERVER 301\nc l a ss S u b j e ct {\npublic:\nvirtual ~Subject();\nvirtual void Attach(Observer*) ;\nvirtual void Detach(Observer*) ;\nvirtual void Notify();\nprotected:\nSubject() ;\nprivate:\nL i s t < O b s e r v e r * > * _ o b s e r v e r s ;\n} ;\nvoid Subject:-.Attac h ( O b s e r v e r * o) {\n_observers->Append(o) ;\n}\nvoid Subject::Detac h ( O b s e r v e r * o) {\n_observers->Remove(o) ;\n}\nvoid Subject::Notif y () { \nListIterator<Observer* > i ( _ o b s e r v e r s ) ;\nfor ( i. First ( ); ! i . I s D o ne () ; i.NextO) {\ni.Currentltem()->Update(this) ;\n}\n}\nC l o c k T i m e r is a c o n c r e t e s u b j e c t f or s t o r i n g a nd m a i n t a i n i n g t he t i me of d a y. It n o t i f i e s i ts o b s e r v e r s e v e ry s e c o n d .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 887, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_design_patterns_gof_chunk_0888_45cad987", "text": "It n o t i f i e s i ts o b s e r v e r s e v e ry s e c o n d . C l o c k T i m e r p r o v i d e s t he i n t e r f a c e f or\nr e t r i e v i n g i n d i v i d u a l t i me u n i ts s u ch as t he h o u r , m i n u t e , a nd s e c o n d . class C l o c k T i m e r : public S u b j e ct {\npublic:\nClockTimer();\nvirtual int GetHour() ;\nvirtual int GetMinute() ;\nvirtual int GetSecond();\nvoid Tick();\n} ;\nT he T i ck o p e r a t i o n g e ts c a l l ed by an i n t e r n a l t i m er at r e g u l a r i n t e r v a l s to p r o v i d e\nan a c c u r a t e t i me b a s e. T i ck u p d a t e s t he C l o c k T i m e r ' s i n t e r n a l state a nd c a l ls \nNot i fy to i n f o r m o b s e r v e r s of the c h a n g e :\nvoid ClockTimer::Tic k () { \n// update i n t e r n al time-keepin g state\n// . . . Notify();\n}\n\nptg302 BEHAVIORAL PATTERNS CHAPTERS\nN ow we c an d e f i n e a c l a ss D i g i t a l C l o c k t h at d i s p l a y s t he t i m e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 888, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_design_patterns_gof_chunk_0889_2f7152d6", "text": ". . Notify();\n}\n\nptg302 BEHAVIORAL PATTERNS CHAPTERS\nN ow we c an d e f i n e a c l a ss D i g i t a l C l o c k t h at d i s p l a y s t he t i m e. It i n h e r i t s i ts\ng r a p h i c a l f u n c t i o n a l i t y f r om a W i d g e t c l a ss p r o v i d e d by a u s er i n t e r f a c e t o o l k i t . T he O b s e r v e r i n t e r f a c e is m i x e d i n to t he D i g i t a l C l o c k i n t e r f a c e by i n h e r i t i n g\nf r om O b s e r v e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 889, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 463}}
{"id": "computer_science_design_patterns_gof_chunk_0890_638d9c9d", "text": "T he O b s e r v e r i n t e r f a c e is m i x e d i n to t he D i g i t a l C l o c k i n t e r f a c e by i n h e r i t i n g\nf r om O b s e r v e r . class DigitalClock : public Widget, public O b s e r v er {\npublic:\nDigitalClock(ClockTimer*) ;\nvirtual \"DigitalClock();\nvirtual v o id U p d a t e ( S u b j e c t * ) ; \n// o v e r r i d es O b s e r v er o p e r a t i o n\nvirtual void D r a w ( ); \n// o v e r r i d es Widget operation ; \n// defines h ow to d r aw t he digital c l o c k\nprivate:\nC l o c k T i m e r * _subject ;\n} ;\nDigitalClock::DigitalCloc k ( C l o c k T i m e r * s) { \n_subject = s;\n_subject->Attach(this);\n}\nDigitalClock::~DigitalCloc k () {\n_subject->Detach(this) ;\n}\nB e f o r e t he Updat e o p e r a t i o n d r a w s t he c l o ck f a c e, it c h e c k s to m a ke s u re t he\nn o t i f y i n g s u b j e c t is t he c l o c k ' s s u b j e c t :\nvoid DigitalClock::Updat e ( S u b j e c t* t h e C h a n g e d S u b j e c t ) {\nif ( t h e C h a n g e d S u b j e c t == _subject) {\nD r a w ( );\n}\n}\nvoid DigitalClock::Dra w () { \n// g et t he n ew values f r om t he s u b j e c t\nint h o ur = _subject->GetHour() ; \nint minute = _subject->GetMinute() ;\n// etc.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 890, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1197}}
{"id": "computer_science_design_patterns_gof_chunk_0891_732e2a7e", "text": "// d r aw the digital c l o ck\n}\nA n AnalogClock class can be defined in the same way. ptgOBSERVER 303\nclass AnalogCloc k : public Widget, public Observer {\npublic:\nAnalogClock(ClockTimer*) ;\nvirtual void Update(Subject*) ; \nvirtual void Draw();\n// . . . The followin g c o de c r e a t e s an A n a l o g C l o c k and a D i g i t a l C l o c k t h at alway s\ns h o w the same time:\nClockTimer * timer = new ClockTimer;\nAnalogClock * analogCloc k = new AnalogClock(timer) ;\nDigitalClock* digitalClock = n e w DigitalClock(timer);\nWheneve r the t i m e r t i c k s, the two c l o c k s w i ll be update d and w i ll redispla y\nthemselves appropriately. K n o w n Uses\nThe f i r st and perhap s best-know n exampl e of the O b s e r v e r patter n appear s in\nS m a l l t a l k Model/View/Controlle r ( M V C ) , the u s er interface framewor k in the\nS m a l l t a l k environmen t [ K P 8 8 ] .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 891, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_design_patterns_gof_chunk_0892_914e358d", "text": "MVC s M o d e l c l a ss plays t he r o le of S u b j e c t , w h i le\nV i ew is t he b a se c l a ss f or o b s e r v e r s . S m a l l t a l k , ET++ [ W G M 8 8 1 , a nd t he T H I N K\nc l a ss librar y [ S y m 9 3 b ] provid e a genera l dependenc y mechanis m by puttin g S u b -\nject and O b s e r v e r interface s in the paren t c l a ss for all other c l a s s e s in the s y s t e m . Othe r user interfac e toolkit s that e m p l o y this patter n are I n t e r v i e w s [ L V C 8 9 ] ,\nthe Andre w T o o l k i t [ P+8 8 ], and Unidra w [ V L 9 0 ] . I n t e r v i e w s define s O b s e r v e r \na nd O b s e r v a b l e (for s u b j e c t s ) c l a s s e s e x p l i c i t l y . Andre w c a l ls them \" v i e w \" a nd\n\"data o b j e c t , \" r e s p e c t i v e l y . Unidra w s p l i ts graphica l edito r object s into V i ew ( f or\no b s e r v e r s ) and Subject p a r t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 892, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 890}}
{"id": "computer_science_design_patterns_gof_chunk_0893_ee3553bc", "text": "Andre w c a l ls them \" v i e w \" a nd\n\"data o b j e c t , \" r e s p e c t i v e l y . Unidra w s p l i ts graphica l edito r object s into V i ew ( f or\no b s e r v e r s ) and Subject p a r t s . Related Patterns\nMediato r ( 2 7 3 ) : By encapsulatin g c o m p l e x updat e semantics , the ChangeManage r\nacts as mediato r betwee n subject s and o b s e r v e r s . S i n g l e t o n ( 1 2 7 ) : The ChangeManage r may use the S i n g l e t o n patter n to make it\nunique and globally accessible. ptg\nThis page intentionally left blank \n\nptgS T A T E 305\nS T A T E O b j e c t B e h a v i o r a l\nI n t e n t\nA l l ow an o b j e c t to a l t er i ts b e h a v i o r w h en i ts i n t e r n a l state c h a n g e s . T he o b j e c t\nwill appear to change its class. Also Known As\nObjects for States\nM o t i v a t i o n\nC o n s i d e r a c l a ss T C P C o n n e c t i o n that represent s a networ k connection .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 893, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 915}}
{"id": "computer_science_design_patterns_gof_chunk_0894_2cc6a77b", "text": "T he o b j e c t\nwill appear to change its class. Also Known As\nObjects for States\nM o t i v a t i o n\nC o n s i d e r a c l a ss T C P C o n n e c t i o n that represent s a networ k connection . A T C P -\nConnectio n o b j e c t can be in one of severa l differen t states : Established , L i s t e n i n g ,\nC l o s e d . W h en a T C P C o n n e c t i o n o b j e c t r e c e i v e s r e q u e s t s from o t h er o b j e c t s , it\nrespond s differentl y dependin g on its curren t state. For example , the effec t of an\nO p en reques t depend s on whethe r t he connectio n is in i ts C l o s e d state or i ts E s t a b -\nl i s h ed state. The State patter n d e s c r i b e s how T C P C o n n e c t i o n can exhibi t differen t\nbehavio r in each state. T he k ey idea in t h is patter n is to introduc e an abstrac t c l a ss c a l l ed T C P S t a t e\nto r e p r e s e n t the states of the networ k c o n n e c t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 894, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 932}}
{"id": "computer_science_design_patterns_gof_chunk_0895_0e206f47", "text": "T he k ey idea in t h is patter n is to introduc e an abstrac t c l a ss c a l l ed T C P S t a t e\nto r e p r e s e n t the states of the networ k c o n n e c t i o n . The T C P S t a t e c l a ss d e c l a r e s\nan interfac e commo n to all c l a s s e s that represen t differen t operationa l states . S u b c l a s s e s of TCPStat e implemen t state-specifi c b e h a v i o r . For example , the c l a s s e s\nTCPEstablishe d and T C P C l o s e d implemen t behavio r particula r to the Establishe d\na n d Closed states of T C P C o n n e c t i o n . The c l a ss T C P C o n n e c t i o n maintain s a state objec t (an instanc e of a s u b c l a s s of\nT C P S t a t e ) t h a t represents the current s t a t e of the TCP c o n n e c t i o n . T h e class \n\nptg3 0 6 BEHAVIORAL PATTERNS CHAPTER 5\nConnectio n delegate s all state-specifi c request s to t h is state object .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 895, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 885}}
{"id": "computer_science_design_patterns_gof_chunk_0896_dd4ef349", "text": "T h e class \n\nptg3 0 6 BEHAVIORAL PATTERNS CHAPTER 5\nConnectio n delegate s all state-specifi c request s to t h is state object . T C P C o n n e c t i o n\nu s es its T C P S t a t e s u b c l a s s instanc e to p e r f o r m operation s particula r to the state\nof t he c o n n e c t i o n . Wheneve r the connectio n change s state, the T C P C o n n e c t i o n objec t c h a n g e s the\ns t a te o b j e c t it u s e s. When t he c o n n e c t i o n g o es from e s t a b l i s h e d to c l o s e d , f or e x a m -\np l e, T C P C o n n e c t i o n will replac e its T C P E s t a b l i s h e d instanc e with a T C P C l o s e d\ninstance. Applicability\nU se t he S t a te patter n in e i t h er of t he followin g c a s e s :\n• An object' s behavio r d e p e n d s on its state, and it must chang e its behavio r at\nrun-tim e d ep endi n g on that state. • Operation s have l a r g e , multipar t conditiona l statement s that depen d on the\no b j e c t ' s state.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 896, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_design_patterns_gof_chunk_0897_5553ce41", "text": "• Operation s have l a r g e , multipar t conditiona l statement s that depen d on the\no b j e c t ' s state. T h is state is usuall y represente d by o ne or m o re enumerate d\nconstants . Often , severa l operation s w i ll contai n this same conditiona l s t r u c -\nture. The State patter n puts e a ch branc h of the conditiona l in a separat e c l a s s. T h is l e ts you treat the object' s state as an o b j e c t in its own right that can vary\nindependently f r o m o t h e r objects. S t r u c t u r e\nParticipants\n• Contex t ( T C P C o n n e c t i o n )\n-define s the interfac e of interes t to c l i e n t s . -maintain s an instanc e of a ConcreteStat e s u b c l a s s that define s the curren t\nstate. • State ( T C P S t a t e )\n- defines an interface for encapsulating the behavior associated with a par-\nticular state of the Context.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 897, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 853}}
{"id": "computer_science_design_patterns_gof_chunk_0898_6dee0124", "text": "• State ( T C P S t a t e )\n- defines an interface for encapsulating the behavior associated with a par-\nticular state of the Context. ptgS T A T E 307\n• ConcreteState subclasses ( T C P E s t a b l i s h e d , T C P L i s t e n , T C P C l o s e d )\n- each subclass implements a b e h a v i o r a s s o c i a t e d w i t h a state o f t h e C o n t e x t . C o l l a b o r a t i o n s\n• Contex t delegate s state-specifi c request s to the curren t C o n c r e t e S t a t e o b j e c t . • A c o n t e x t m ay p a ss i t s e lf as an argumen t to t he S t a te o b j e c t h a n d l i n g t he\nrequest . T h is l e ts t he State objec t a c c e s s t he contex t if n e c e s s a r y . • C o n t e x t is t he primar y i n t e r f a c e f or c l i e n t s . C l i e n t s c an c o n f i g u r e a c o n t e x t w i th\nState objects . O n ce a contex t is configured , its c l i e n t s don't have to deal with\nthe State object s d i r e c t l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 898, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_design_patterns_gof_chunk_0899_b395fca7", "text": "C l i e n t s c an c o n f i g u r e a c o n t e x t w i th\nState objects . O n ce a contex t is configured , its c l i e n t s don't have to deal with\nthe State object s d i r e c t l y . • Eithe r Contex t or the C o n c r e t e S t a t e s u b c l a s s e s can d e c i d e whic h state s u c c e e d s\nanother and under what circumstances. C o n s e q u e n c e s\nThe State patter n has the followin g c o n s e q u e n c e s :\n1. It localizes state-specific behavior and partitions behavior for different states. The\nState patter n puts all behavio r a s s o c i a t e d with a particula r state into one\no b j e c t . B e c a u s e a ll s t a t e - s p e c i f i c c o de l i v es in a S t a te s u b c l a s s , n ew s t a t es a nd\ntransition s can be adde d e a s i ly by definin g new s u b c l a s s e s . An alternativ e is to u se data v a l u e s to d e f i n e i n t e r n a l s t a t es a nd h a ve C o n -\ntext operation s c h e ck the data e x p l i c i t l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 899, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_design_patterns_gof_chunk_0900_0bf6f10e", "text": "An alternativ e is to u se data v a l u e s to d e f i n e i n t e r n a l s t a t es a nd h a ve C o n -\ntext operation s c h e ck the data e x p l i c i t l y . But then we'd have l o o k - a l i k e c o n -\nditiona l or c a se statement s scattere d throughou t Context' s implementation . Addin g a new state could requir e changin g s e v e r a l operations , whic h c o m -\nplicate s maintenance. The State patter n a v o i d s t h is p r o b l e m but migh t introduc e another , b e c a u s e\nthe patter n distribute s behavio r for differen t states a c r o s s s e v e r a l State s u b -\nc l a s s e s . T h is i n c r e a s e s t he numbe r of c l a s s e s a nd is l e ss c o m p a c t than a s i n g le\nc l a s s. But s u ch distributio n is actuall y g o od if there are many s t a t e s , whic h\nwoul d otherwis e necessitat e l a r ge conditiona l statements. Like long p r o c e d u r e s , l a r ge conditiona l statement s are u n d e s i r a b l e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 900, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_design_patterns_gof_chunk_0901_e51b45e3", "text": "Like long p r o c e d u r e s , l a r ge conditiona l statement s are u n d e s i r a b l e . T h e y ' r e\nmonolithi c and tend to make the c o de l e ss e x p l i c i t , whic h in turn make s \nthem difficul t to modif y and extend . The State patter n offer s a bette r way to\nstructur e state-specifi c c o d e. The l o g ic that determine s the state transition s\ndoesn' t r e s i d e in m o n o l i t h i c if or s w i t c h statement s but instea d is parti-\ntione d betwee n the State s u b c l a s s e s . Encapsulatin g e a ch state transitio n and\na c t i o n in a c l a ss e l e v a t e s t he i d ea of an e x e c u t i o n s t a te to full o b j e c t s t a t u s . That i m p o s e s structur e on the c o de and make s its inten t c l e a r e r . 2. It makes state transitions explicit.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 901, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 802}}
{"id": "computer_science_design_patterns_gof_chunk_0902_3e0d21b9", "text": "That i m p o s e s structur e on the c o de and make s its inten t c l e a r e r . 2. It makes state transitions explicit. Whe n an o b j e c t d e f i n e s i ts c u r r e n t state s o l e ly\nin terms of internal data values, its state transitions have no explicit repre -\ns e n t a t i o n ; they only show u p a s assignments t o some variables. Introduc -\ning separate objects for different s t a t e s m a k e s the t r a n s i t i o n s m o r e e x p l i c i t . ptg308 BEHAVIORAL PATTERNS CHAPTER 5\nA l s o , State object s can protec t the Contex t from inconsisten t interna l states ,\nbecaus e state transition s are atomi c f r om the Context' s perspective—the y\nhappe n by rebindin g one variabl e (the Context' s State objec t variable) , not\nsevera l [ d C L F 9 3 ] . 3.State objects c an be shared. If S t a te object s have no instanc e variables—tha t i s,\nthe state they represen t is encode d entirel y in their type—the n context s can\nshare a State object .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 902, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_design_patterns_gof_chunk_0903_f28c9e4f", "text": "3.State objects c an be shared. If S t a te object s have no instanc e variables—tha t i s,\nthe state they represen t is encode d entirel y in their type—the n context s can\nshare a State object . Whe n state s are share d in this way, they are essentiall y\nflyweights (see Flyweight (195)) with no intrinsic state, only behavior. Implementation\nThe State patter n raise s a variet y of implementatio n i s s u e s :\n1. Who defines the state transitions? The State patter n d o es not specif y whic h\nparticipan t define s the criteri a for state transitions . If the criteri a are fixed ,\nthen they can be implemente d entirel y in the Context . It is g e n e r a l l y more\nflexibl e and appropriate , however , to let the State s u b c l a s s e s themselve s\nspecif y t h e ir s u c c e s s o r state and when to make the transition . T h is r e q u i r e s\naddin g an interfac e to the Contex t that l e ts State object s set the Context' s\ncurren t state e x p l i c i t l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 903, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_design_patterns_gof_chunk_0904_1a50a660", "text": "T h is r e q u i r e s\naddin g an interfac e to the Contex t that l e ts State object s set the Context' s\ncurren t state e x p l i c i t l y . Decentralizin g the transitio n l o g ic in this way make s it easy to m o d i f y or\nexten d the l o g ic by definin g new State s u b c l a s s e s . A disadvantag e of de-\ncentralizatio n is that one State s u b c l a s s will have knowledg e of at least one \nother , whic h introduce s implementatio n dependencie s betwee n s u b c l a s s e s . 2. A table-based alternative. In C++ Programming Style [ C a r 9 2 1 , C a r g i l l d e s c r i b e s\nanothe r way to impos e structur e on state-drive n c o d e: He uses table s to map\ninput s to state transitions . For each state, a table maps every p o s s i b l e input\nto a succeedin g state . In effect , this approac h convert s conditiona l c o de (and\nvirtua l f u n c t i o n s , in t he c a se of t he S t a te pattern ) into a t a b le l o o k - u p .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 904, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_design_patterns_gof_chunk_0905_4cb7b983", "text": "In effect , this approac h convert s conditiona l c o de (and\nvirtua l f u n c t i o n s , in t he c a se of t he S t a te pattern ) into a t a b le l o o k - u p . The main advantag e of table s is their regularity : You can chang e the transitio n\ncriteri a by modifyin g data instea d of changin g progra m c o d e . T h e r e are s o me\ndisadvantages , however:\n• A table look-u p is o f t en l e ss efficien t t h an a (virtual ) functio n c a l l . • Puttin g transitio n l o g ic into a uniform , tabula r f o r m a t make s the transi-\ntion criteri a l e ss e x p l i c i t and therefor e harde r to understand. • It's usuall y difficul t to add action s to accompan y the state transitions . The table-drive n approac h capture s the state s and their transitions , but it \nmust be augmente d to p e r f o r m arbitrar y computatio n on e a ch transition.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 905, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 864}}
{"id": "computer_science_design_patterns_gof_chunk_0906_332ce3b9", "text": "The table-drive n approac h capture s the state s and their transitions , but it \nmust be augmente d to p e r f o r m arbitrar y computatio n on e a ch transition. The key differenc e betwee n table-drive n state machine s and the State patter n\ncan be summe d up like this: The State p a t t e r n model s state-specifi c behavior ,\nwhereas the table-driven approach focuses on defining state transitions. ptgS T A T E 3 0 9\n3.Creating and destroying State objects. A commo n implementatio n trade-of f\nwort h c o n s i d e r i n g is whethe r ( 1) to c r e a t e S t a te o b j e c t s o n ly when they a re\nneede d and destro y them thereafte r versu s (2) creatin g them ahea d of time\nand neve r destroyin g them. The first c h o i c e is preferabl e when the states t h at w i ll be entere d aren' t\nknow n at run-time , and context s chang e state infrequently .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 906, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 869}}
{"id": "computer_science_design_patterns_gof_chunk_0907_9502c1a5", "text": "The first c h o i c e is preferabl e when the states t h at w i ll be entere d aren' t\nknow n at run-time , and context s chang e state infrequently . T h is approac h\navoid s creatin g object s t h at won' t be u s e d , whic h is importan t if the State\nobject s store a lot of information . The s e c o n d approac h is bette r when state\nchange s o c c u r rapidly , in whic h c a se you want to avoid destroyin g states ,\nbecaus e they may be n e e d e d again shortly . Instantiatio n c o s ts are paid once\nup-front , and there are no destructio n c o s ts at a l l. T h is approac h migh t be\ninconvenient , though , becaus e the Contex t must keep reference s to all states\nthat migh t be entered. 4. Using dynamic inheritance. Changin g the behavio r for a particula r reques t\nc o u ld be accomplishe d by changin g the object' s c l a ss at run-time , but this\nis not p o s s i b l e in most object-oriente d programmin g languages .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 907, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_design_patterns_gof_chunk_0908_8f92b01b", "text": "Exception s\ninclud e S e lf [ U S 8 7 ] and other delegation-base d language s that provid e such\na mechanis m and henc e suppor t the State p a t t e r n d i r e c t l y . O b j e c t s in S e lf\ncan delegat e operation s to other o b j e c t s to a c h i e v e a f o rm of dynami c inher-\nitance . Changin g the delegatio n targe t at run-tim e effectivel y change s the\ninheritanc e structure . T h is mechanis m l e ts o b j e c t s chang e their behavio r and\namounts to changing their class. Sample Code\nThe followin g exampl e g i v es the C++ c o de for the TCP connectio n exampl e de-\ns c r i b e d in the Motivatio n s e c t i o n . T h is exampl e is a simplifie d versio n of the\nTCP p r o t o c o l ; it doesn' t describ e the complet e protoco l or all the state s of TCP\nconnections. 8\nF i r s t, we defin e the c l a ss T C P C o n n e c t i o n, whic h provide s an interfac e for trans-\nmittin g d a ta and handle s request s to chang e state.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 908, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_design_patterns_gof_chunk_0909_3531c904", "text": "8\nF i r s t, we defin e the c l a ss T C P C o n n e c t i o n, whic h provide s an interfac e for trans-\nmittin g d a ta and handle s request s to chang e state. class TCPOctetStream ;\nclass TCPState;\nclass TCPConnectio n {\npublic:\nTCPConnection O ;\nvoid ActiveOpen() ;\nvoid PassiveOpen() ;\nvoid Close();\n8 T h i s example is based on the TCP c o n n e c t i o n protocol described by Lynch and Rose [LR93]. ptg310 BEHAVIORAL PATTERNS CHAPTER 5\nvoid S e n d ( ); \nvoid Acknowledge() ; \nvoid S y n c h r o n i z e ( ) ;\nvoid ProcessOctet(TCPOctetStream*) ;\nprivate:\nf r i e nd c l a ss T C P S t a t e ; \nvoid ChangeState(TCPState*);\nprivate:\nTCPState * _state;\n} ;\nT C P C o n n e c t i o n k e e p s an i n s t a n c e of the T C P S t a t e c l a ss in the _ s t a t e m e m -\nb er v a r i a b l e . T he c l a ss T C P S t a t e d u p l i c a t e s t he s t a t e - c h a n g i n g i n t e r f a c e of\nT C P C o n n e c t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 909, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 934}}
{"id": "computer_science_design_patterns_gof_chunk_0910_c71bb83f", "text": "T he c l a ss T C P S t a t e d u p l i c a t e s t he s t a t e - c h a n g i n g i n t e r f a c e of\nT C P C o n n e c t i o n . E a ch T C P S t a t e o p e r a t i o n t a k es a T C P C o n n e c t i o n i n s t a n c e\nas a p a r a m e t e r , l e t t i n g T C P S t a t e a c c e s s d a ta f r om T C P C o n n e c t i o n a nd c h a n g e\nt h e connection's state. class T C P S t a te {\npublic:\nvirtual void Transmit(TCPConnection* , TCPOctetStream*) ;\nvirtual void ActiveOpen(TCPConnection*) ; \nvirtual void PassiveOpen(TCPConnection*) ; \nvirtual void Close(TCPConnection*) ; \nvirtual void Synchronize(TCPConnection*) ; \nvirtual void A c k n o w l e d g e ( T C P C o n n e c t i o n * ) ; \nvirtual void Send(TCPConnection*);\nprotected : \nvoid ChangeState(TCPConnection*, TCPState*);\n} ;\nT C P C o n n e c t i o n d e l e g a t e s a ll s t a t e - s p e c i f i c r e q u e s t s to i ts T C P S t a t e i n s t a n c e\n_ s t a t e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 910, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_design_patterns_gof_chunk_0911_4e15435c", "text": "T C P C o n n e c t i o n a l so p r o v i d e s an o p e r a t i o n for c h a n g i n g t h is v a r i a b l e\nto a new T C P S t a t e . The c o n s t r u c t o r for T C P C o n n e c t ion i n i t i a l i z e s the o b j e c t to\nt h e TCPClosed state (defined later). TCPConnection::TCPConnectio n () {\n_state = T C P C l o s e d : : I n s t a n c e ( ) ;\n}\nvoid T C P C o n n e c t i o n : : C h a n g e S t a t e ( T C P S t a t e * s) {\n_state = s;\n}\nvoid TCPConnection::ActiveOpe n () {\n_state->ActiveOpen(this) ;\n}\nvoid TCPConnection::PassiveOpe n () {\n_ s t a t e - > P a s s i v e O p e n ( t h i s ) ;\n}\n\nptgS T A T E 311\nv o id T C P C o n n e c t i o n : : C l o s e () {\n_state->Close(this) ; • \n}\nvoid TCPConnection::Acknowledg e () {\n_s tate->Acknowledge(this) ;\n}\nvoid TCPConnection::Synchroniz e () {\n_state->Synchronize(this) ;\n}\nT O P S t ate i m p l e m e n t s defaul t b e h a v i o r for all r e q u e s t s d e l e g a t e d to it.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 911, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_design_patterns_gof_chunk_0912_6e811e1c", "text": "It can\na l so c h a n g e the s t a te of a T C P C o n n e c t i o n with the C h a n g e S t a t e o p e r a t i o n . T C P S t a t e is d e c l a r e d a f r i e n d of T C P C o n n e c t i o n to g i ve it p r i v i l e g e d a c c e s s to\nt h is o p e r a t i o n . void TCPState::Transmi t ( T C P C o n n e c t i o n * , TCPOctetStream* ) { }\nv o id T C P S t a t e : : A c t i v e O p e n ( T C P C o n n e c t i o n * ) { } \nvoid TCPState::PassiveOpe n ( T C P C o n n e c t i o n * ) { } \nvoid TCPState::Clos e ( T C P C o n n e c t i o n * ) { } \nvoid TCPState::Synchroniz e ( T C P C o n n e c t i o n * ) { }\nvoid TCPState::ChangeStat e ( T C P C o n n e c t i o n * t, TCPState * s) {\nt - > C h a n g e S t a t e ( s ) ;\n}\nS u b c l a s s e s of T C P S t a t e i m p l e m e n t s t a t e - s p e c i f i c b e h a v i o r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 912, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 842}}
{"id": "computer_science_design_patterns_gof_chunk_0913_4299bc3f", "text": "A T CP c o n n e c -\nt i on c an be in m a ny s t a t e s : E s t a b l i s h e d , L i s t e n i n g , C l o s e d , e t c ., a nd t h e r e ' s a\ns u b c l a s s of T C P S t a t e f or e a ch state . W e ' l l d i s c u s s t h r ee s u b c l a s s e s in d e t a i l :\nT C P E s t a b l i s h e d , T C P L i s t e n , a nd T C P C l o s e d . class TCPEstablishe d : public TCPState {\npublic:\nstatic TCPState * Instance();\nvirtual void Transmit(TCPConnection* , TCPOctetStream*) ;\nvirtual void Close(TCPConnection*);\n} ;\nclass TCPListen : public TCPState {\npublic:\nstatic TCPState * Instance();\nvirtual void Send(TCPConnection*) ;\n// . . . } ;\n\nptg312 BEHAVIORAL PATTERNS CHAPTERS\nclass TCPClose d : public TCPState {\npublic:\nstatic TCPState * Instance();\nvirtual void ActiveOpen(TCPConnection*) ;\nvirtual void PassiveOpen(TCPConnection*) ;\n// . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 913, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 854}}
{"id": "computer_science_design_patterns_gof_chunk_0914_ece66a3d", "text": ". . } ;\nT C P S t a t e s u b c l a s s e s m a i n t a i n no l o c al state , so t h ey c an be s h a r e d , a nd o n ly o ne\ni n s t a n c e of e a ch is r e q u i r e d . T he u n i q u e i n s t a n c e of e a ch T C P S t a t e s u b c l a s s is\no b t a i n e d by the static I n s t a n c e o p e r a t i o n . 9\nE a ch T C P S t a t e s u b c l a s s i m p l e m e n t s state-specifi c b e h a v i o r f or v a l id r e q u e s t s in\nt he state:\nvoid TCPClosed::ActiveOpe n ( T C P C o n n e c t i o n * t) { \n// s e nd S Y N, r e c e i ve S Y N, ACK, etc.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 914, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 568}}
{"id": "computer_science_design_patterns_gof_chunk_0915_337545d0", "text": "ChangeState(t , TCPEstablished::Instance( ) ) ;\n}\nv o id T C P C l o s e d : : P a s s i v e O p e n ( T C P C o n n e c t i o n * t) {\nChangeState(t , TCPListen::Instance()) ;\n}\nvoid TCPEstablished::Clos e ( T C P C o n n e c t i o n * t) { \n// s e nd P I N, r e c e i ve A CK of F I N\nChangeState(t , TCPListen::Instance()) ;\n}\nvoid T C P E s t a b l i s h e d : : T r a n s m i t (\nT C P C o n n e c t i o n * t, TCPOctetStream * o\n) {\nt->ProcessOctet(o) ;\n}\nvoid TCPListen::Sen d ( T C P C o n n e c t i o n * t) {\n// s e nd S Y N, receive SYN, ACK, etc. ChangeState(t , TCPEstablished::Instance()) ;\n}\nAfter p e r f o r m i n g s t a t e - s p e c i f i c w o r k , t h e se o p e r a t i o n s c a ll t he C h a n g e S t a t e\no p e r a t i o n to c h a n g e the state of the T C P C o n n e c t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 915, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 811}}
{"id": "computer_science_design_patterns_gof_chunk_0916_843b7c17", "text": "T C P C o n n e c t i o n i t s e lf\nd o e s n ' t k n ow a t h i ng a b o u t t he T CP c o n n e c t i o n p r o t o c o l ; i t 's t he T C P S t a t e\ns u b c l a s s e s that define each state transition and action in T C P . 9This makes each TCPState subclass a Singleton (see Singleton ( 1 2 7 ) ) . ptgS T A T E 313\nK n o w n Uses\nJ o h n s o n a nd Z w e i g [ J Z 9 1 ] characteriz e t he S t a te patter n a nd i ts applicatio n to T CP\nc o n n e c t i o n p r o t o c o l s . M o st popula r i n t e r a c t i v e drawin g program s provid e \" t o o l s \" for performin g op-\ne r a t i o n s by d i r e c t manipulation . For e x a m p l e , a l i n e - d r a w i n g tool l e ts a u ser c l i ck\na nd drag to creat e a n ew l i n e. A s e l e c t i o n t o ol l e ts t he us er s e l e c t s h a p e s . T h e r e ' s\nu s u a l l y a p a l e t t e of s u ch t o o ls to c h o o s e from .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 916, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_design_patterns_gof_chunk_0917_858110ab", "text": "A s e l e c t i o n t o ol l e ts t he us er s e l e c t s h a p e s . T h e r e ' s\nu s u a l l y a p a l e t t e of s u ch t o o ls to c h o o s e from . T he u s er t h i n k s of t h is a c t i v i t y as\np i c k i n g up a t o ol and w i e l d i n g i t, but in realit y the editor' s behavio r c h a n g e s \nwith t he curren t t o o l: W h e n a drawin g tool is a c t i v e we creat e s h a p e s ; when t he\ns e l e c t i o n t o ol is a c t i v e we s e l e ct s h a p e s ; a nd so forth . We c an u se t he State patter n\nto c h a n g e t he editor' s b e h a v i o r d e p e n d i n g on t he curren t t o o l . We c an defin e an abstrac t T o ol c l a ss from whic h to defin e s u b c l a s s e s that i m p l e -\nment t o o l - s p e c i f i c b e h a v i o r . T he drawin g e d i t o r m a i n t a i n s a curren t T o ol o b j e c t\na nd d e l e g a t e s r e q u e s t s to i t.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 917, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_design_patterns_gof_chunk_0918_4e35c269", "text": "T he drawin g e d i t o r m a i n t a i n s a curren t T o ol o b j e c t\na nd d e l e g a t e s r e q u e s t s to i t. It r e p l a c e s t h is o b j e c t when t he u s er c h o o s e s a n ew\nt o o l, c a u s i n g t he behavio r of t he drawin g e d i t o r to c h a n g e a c c o r d i n g l y . T h is t e c h n i q u e is u s ed in both t he HotDra w [ J o h 9 2 ] a nd Unidra w [ V L 9 0 ] drawin g\ne d i t o r frameworks . It a l l o w s c l i e n t s to defin e n ew k i n ds of t o o ls e a s i l y . In HotDraw , \nt he D r a w i n g C o n t r o l l e r c l a ss forward s t he r e q u e s t s to t he curren t T o ol object . In\nUnidraw , t he c o r r e s p o n d i n g c l a s s e s a re V i e w e r a nd T o o l. T he followin g c l a ss\ndiagram sketches the Tool and DrawingController interfaces:\nC o p l i e n ' s E n v e l o p e - L e t t e r i d i om [ C o p 9 2 ] is r e l a t e d to S t a t e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 918, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_design_patterns_gof_chunk_0919_ec8ceb82", "text": "T he followin g c l a ss\ndiagram sketches the Tool and DrawingController interfaces:\nC o p l i e n ' s E n v e l o p e - L e t t e r i d i om [ C o p 9 2 ] is r e l a t e d to S t a t e . E n v e l o p e - L e t t e r is\na t e c h n i q u e for c h a n g i n g an object' s c l a ss at run-time . The S t a te patter n is more\ns p e c i f i c , focusin g on h ow to d e al with an objec t whos e behavio r d e p e n d s on i ts\nstate. Related Patterns\nT h e Flyweight (195) pattern explains when and how State objects can be shared. State objects a r e often Singletons ( 1 2 7 ) . ptg\nThis page intentionally left blank \n\nptgSTRATEGY 315\nS T R A T E G Y O b j e c t Behavioral\nI n t e n t\nDefine a family of a l g o r i t h m s , encapsulate each one, and make them interchange -\na b l e . Strategy lets the algorithm vary independently f r o m clients that use it. Also Known As\nP o l i c y\nM o t i v a t i o n\nMany algorithm s e x i st f or breakin g a strea m of text into l i n e s.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 919, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_design_patterns_gof_chunk_0920_20040e2f", "text": "Strategy lets the algorithm vary independently f r o m clients that use it. Also Known As\nP o l i c y\nM o t i v a t i o n\nMany algorithm s e x i st f or breakin g a strea m of text into l i n e s. Hard-wirin g all s u ch\nalgorithm s into the c l a s s e s that r e q u i r e them i s n 't d e s i r a b l e for s e v e r a l r e a s o n s :\n• C l i e n t s that n e ed l i n e b r e a k i n g g et m o re c o m p l e x if t h ey i n c l u d e t he l i n e -\nbreakin g c o d e. T h at make s c l i e n t s b i g g e r a nd harde r to maintain , e s p e c i a l l y\nif they suppor t multipl e l i n e b r e a k i n g a l g o r i t h m s . • Differen t algorithm s w i ll be appropriat e at differen t t i m e s . We don't want to\ns u p p o r t m u l t i p l e l i n e b r e a k i n g a l g o r i t h m s if we d o n 't u se them a l l . • It's difficul t to add new a l g o r i t h m s and vary e x i s t i n g o n es when l i n e b r e a k i n g\nis an integra l part of a c l i e n t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 920, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_design_patterns_gof_chunk_0921_cc87efe1", "text": "• It's difficul t to add new a l g o r i t h m s and vary e x i s t i n g o n es when l i n e b r e a k i n g\nis an integra l part of a c l i e n t . We c an a v o id t h e se p r o b l e m s by d e f i n i n g c l a s s e s that e n c a p s u l a t e differen t l i n e -\nbreakin g a l g o r i t h m s . An algorith m that's en cap su la te d in this way is c a l l ed a\nstrategy. S u p p o s e a C o m p o s i t i o n c l a ss is r e s p o n s i b l e for maintainin g and updatin g the\nl i n e b r e a k s of text d i s p l a y e d in a text v i e w e r . L i n e b r e a k i n g s t r a t e g i e s aren' t i m -\np l e m e n t e d by the c l a ss C o m p o s i t i o n . Instead , they are implemente d separatel y\nby s u b c l a s s e s of t he abstrac t C o m p o s i t o r c l a s s.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 921, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 790}}
{"id": "computer_science_design_patterns_gof_chunk_0922_0a197522", "text": "Instead , they are implemente d separatel y\nby s u b c l a s s e s of t he abstrac t C o m p o s i t o r c l a s s. C o m p o s i t o r s u b c l a s s e s i m p l e m e n t\ndifferent s t r a t e g i e s :\n\nptg3 1 6 BEHAVIORAL PATTERNS CHAPTER 5\n• SimpleComposito r implement s a s i m p l e strateg y t h at determine s l i n e b r e a k s\none at a time. • TeXComposito r implement s the T gX algorithm for findin g linebreaks . T h is\nstrateg y tries to optimiz e linebreak s g l o b a l l y , that i s, one paragrap h at a time. • ArrayComposito r implement s a strateg y t h at s e l e c t s break s so that each row\nhas a fixed numbe r of items . It's u s e f u l for breakin g a c o l l e c t i o n of i c o ns into\nr o w s , for example. A C o m p o s i t i o n m a i n t a i n s a r e f e r e n c e to a C o m p o s i t o r o b j e c t . W h e n e v e r a C o m p o -\nsition reformat s its text, it forward s this r e s p o n s i b i l i t y to its Co mp osi to r object .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 922, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_design_patterns_gof_chunk_0923_f5aa2f6b", "text": "W h e n e v e r a C o m p o -\nsition reformat s its text, it forward s this r e s p o n s i b i l i t y to its Co mp osi to r object . The \nc l i e nt of Compositio n s p e c i f i e s whic h Composito r s h o u l d be u s ed by installin g\nthe Compositor it desires into the C o m p o s i t i o n . Applicability\nUse the Strateg y patter n when\n• many relate d c l a s s e s d i f f er only in their b e h a v i o r . Strategie s provid e a way\nto configur e a c l a ss with one of many behaviors. • you n e ed differen t variant s of an algorithm . For e x a m p l e , you migh t de-\nfine algorithm s reflectin g differen t space/tim e trade-offs . S t r a t e g i e s can be\nu s ed when t h e se variant s a re implemente d as a c l a ss hierarch y of a l g o -\nrithm s [ H O 8 7 ] . • an a l g o r i t h m u s es data that c l i e n t s shouldn' t know about . Use the Strateg y\npatter n to a v o id e x p o s i n g c o m p l e x , algorithm-specifi c data structures.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 923, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_design_patterns_gof_chunk_0924_06bc466f", "text": "• an a l g o r i t h m u s es data that c l i e n t s shouldn' t know about . Use the Strateg y\npatter n to a v o id e x p o s i n g c o m p l e x , algorithm-specifi c data structures. • a c l a ss d e f i n e s many b e h a v i o r s , a nd t h e se appea r as m u l t i p l e c o n d i t i o n a l\nstatement s in its operations . Instea d of many conditionals , move relate d\nconditional branches into their own Strategy class. S t r u c t u r e\n\nptgS T R A T E G Y 317\nParticipants\n• Strateg y (Compositor)\n- d e c l a r e s an i n t e r f a c e commo n to all supporte d algorithms . Contex t uses\nthis interface to call the algorithm defined by a C o n c r e t e S t r a t e g y . • ConcreteStrategy (SimpleCompositor, TeXCompositor, A r r a y C o m p o s i t o r )\n- implements the a l g o r i t h m u s i n g the S t r a t e g y interface. • Context (Composition)\n-is c o n f i g u r e d w i t h a ConcreteStrategy object. -maintains a reference to a Strategy object.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 924, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_design_patterns_gof_chunk_0925_9a346ead", "text": "• Context (Composition)\n-is c o n f i g u r e d w i t h a ConcreteStrategy object. -maintains a reference to a Strategy object. -may define an interface that lets Strategy access its data. C o l l a b o r a t i o n s\n• Strateg y and Contex t interac t to implemen t the c h o s e n algorithm . A contex t\nmay p a ss all data r e q u i r e d by the algorith m to the strateg y w h en the a l g o r i t h m\nis c a l l e d . Alternatively , the contex t can pass i t s e lf as an argumen t to Strateg y\noperations . That lets the strateg y c a ll back on the contex t as required. • A c o n t e x t forward s r e q u e s t s from i ts c l i e n t s to i ts s t r a t e g y . C l i e n t s usuall y\ncreat e and pass a ConcreteStrateg y objec t to the context ; thereafter , client s\ninterac t with the contex t e x c l u s i v e l y . T h e re is o f t en a f a m i l y of ConcreteStrateg y\nc l a s s e s for a client to choose from.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 925, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 929}}
{"id": "computer_science_design_patterns_gof_chunk_0926_949e5068", "text": "T h e re is o f t en a f a m i l y of ConcreteStrateg y\nc l a s s e s for a client to choose from. C o n s e q u e n c e s\nThe S t r a t e g y patter n has the followin g benefit s and d r a w b a c k s :\n1. Families of related algorithms. Hierarchie s of Strateg y c l a s s e s defin e a f a m i l y of\nalgorithm s or behavior s for context s to reuse . Inheritanc e can help f a c t o r out\nc o m m o n functionalit y of t he a l g o r i t h m s . 2. An alternative to subclassing. Inheritanc e o f f e r s anothe r way to suppor t a\nvariet y of algorithm s or behaviors . You can subclas s a Contex t c l a ss d i r e c t l y\nto g i ve it differen t behaviors . But this hard-wire s the behavio r into Context . It\nm i x e s the algorith m implementatio n with Context's , makin g Contex t harde r\nto understand , maintain , and extend . And you can't vary the algorith m\nd y n a m i c a l l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 926, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_design_patterns_gof_chunk_0927_fe30c4d6", "text": "It\nm i x e s the algorith m implementatio n with Context's , makin g Contex t harde r\nto understand , maintain , and extend . And you can't vary the algorith m\nd y n a m i c a l l y . Y ou w i nd up with many r e l a t e d c l a s s e s w h o s e o n ly differenc e\nis the algorith m or behavio r they e m p l o y . Encapsulatin g the algorith m in\nseparat e Strateg y c l a s s e s lets you vary the algorith m independentl y of its\ncontext, making it easier to switch, understand, a n d extend. 3.Strategies eliminate conditional statements. The Strategy pattern offers a n alter -\nnative to conditional statements for selecting desired behavior. When d i f f e r -\ne n t behaviors are lumped into one class, it's hard to avoid using conditional\n\nptg3 18 BEHAVIORAL PATTERNS CHAPTER 5\nstatement s to s e l e c t the right b e h a v i o r . Encapsulatin g the behavio r in s e p a -\nrate Strateg y c l a s s e s eliminate s these conditiona l statements.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 927, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 955}}
{"id": "computer_science_design_patterns_gof_chunk_0928_0406bf61", "text": "Encapsulatin g the behavio r in s e p a -\nrate Strateg y c l a s s e s eliminate s these conditiona l statements. For e x a m p l e , withou t strategies , the c o de for breakin g text into l i n es c o u ld\nl o o k l i k e\nvoid Composition::Repai r () {\ns w i t ch ( _ b r e a k i n g S t r a t e g y ) {\ncase SimpleStrategy:\nComposeWithSimpleCompositor() ;\nb r e a k ;\ncase TeXStrategy : \nComposeWithTeXCompositor() ;\nbreak;\n// . . . }\n// merge results with existing composition , if necessar y\n}\nThe Strategy pattern eliminates this case statement by d e l e g a t i n g t h e l i n e -\nbreaking task to a Strategy object:\nvoid Composition::Repai r () {\n_compositor->Compose() ; \n// merge results with existing composition, if n e c e s s a r y\n}\nC o de containin g many conditiona l statement s o f t en indicate s the need to\na p p ly t he S t r a t e g y pattern. 4. A choice of implementations. S t r a t e g i e s can provid e differen t implementation s\nof t he same b e h a v i o r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 928, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_design_patterns_gof_chunk_0929_ec771a83", "text": "4. A choice of implementations. S t r a t e g i e s can provid e differen t implementation s\nof t he same b e h a v i o r . T he c l i e nt c an c h o o s e a m o n g s t r a t e g i e s with differen t\ntime and s p a ce trade-offs. 5. Clients must be aware of different Strategies. The patter n has a potentia l draw-\nback in that a c l i e nt must understan d how S t r a t e g i e s d i f f e r befor e it can\ns e l e ct t he appropriat e o n e. C l i e n t s m i g h t be e x p o s e d to i m p l e m e n t a t i o n i s -\ns u e s. T h e r e f o r e you shoul d use the Strateg y patter n o n ly when the variatio n\nin b e h a v i o r is r e l e v a n t to c l i e n t s . 6. Communication overhead between Strategy and Context. The Strateg y interfac e\nis s h a r e d by a ll C o n c r e t e S t r a t e g y c l a s s e s whethe r t he algorithm s they i m p l e -\nment a re trivia l or c o m p l e x .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 929, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_design_patterns_gof_chunk_0930_065ae3dd", "text": "The Strateg y interfac e\nis s h a r e d by a ll C o n c r e t e S t r a t e g y c l a s s e s whethe r t he algorithm s they i m p l e -\nment a re trivia l or c o m p l e x . H e n c e i t 's l i k e ly that s o me ConcreteStrategie s\nwon' t u se a ll t he informatio n p a s s e d to them throug h t h is interface ; s i m p l e\nC o n c r e t e S t r a t e g i e s may use none of it! That mean s there w i ll be t i m es when\nt he c o n t e x t c r e a t e s a nd i n i t i a l i z e s p a r a m e t e r s that n e v er g et u s e d. If t h is is\nan i s s u e , then you'l l need tighte r c o u p l i n g betwee n Strateg y and Context. 7. Increased number of objects. S t r a t e g i e s i n c r e a s e the numbe r of object s in an\napplication . S o m e t i m e s you can r e d u c e t h is o v e r h e a d by implementin g\ns t r a t e g i e s as s t a t e l e s s o b j e c t s that context s can s h a r e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 930, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_design_patterns_gof_chunk_0931_bd54c6bb", "text": "S o m e t i m e s you can r e d u c e t h is o v e r h e a d by implementin g\ns t r a t e g i e s as s t a t e l e s s o b j e c t s that context s can s h a r e . Any r e s i d u a l state is\nmaintained b y t h e context, which passes i t i n each request t o t h e Strategy\n\nptgS T R A T E G Y 3 1 9\nobject . S h a r e d strategie s s h o u l d not maintai n state a c r o s s invocations . The\nF l y w e i g h t ( 1 9 5 ) p a t t e r n d e s c r i b e s t h i s a p p r o a c h in more detail. Implementation\nC o n s i d e r the followin g implementatio n i s s u e s :\n1.Defining t he Strategy a nd Context interfaces. T he S t r a t e g y a nd C o n t e x t i n t e r f a c e s\nmust g i ve a ConcreteStrateg y efficien t a c c e s s to any data it n e e ds from a\ncontext , a nd v i ce v e r s a . O ne a p p r o a c h is to h a ve C o n t e x t p a ss data in p a r a m e t e r s to S t r a t e g y\noperations—i n other w o r d s , take the data to the strategy .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 931, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_design_patterns_gof_chunk_0932_d1570444", "text": "O ne a p p r o a c h is to h a ve C o n t e x t p a ss data in p a r a m e t e r s to S t r a t e g y\noperations—i n other w o r d s , take the data to the strategy . T h is k e e ps Strateg y\nand Contex t decoupled . On the other hand , Contex t migh t pass data the\nS t r a t e g y d o e s n ' t n e e d . Anothe r techniqu e has a contex t p a ss itself as an argument , and the strateg y\nr e q u e s t s data from the contex t e x p l i c i t l y . Alternatively , the strateg y can s t o re\na referenc e to i ts context , e l i m i n a t i n g t he n e ed to p a ss anythin g at a l l. Eithe r\nway, the strateg y can reques t e x a c t l y what it n e e d s . But now Contex t must\ndefin e a m o re elaborat e interfac e to its data, whic h c o u p l e s Strateg y and \nContex t more c l o s e l y . The needs of the particula r algorith m and its data requirement s w i ll deter-\nmine the best technique. 2.Strategies as template parameters.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 932, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_design_patterns_gof_chunk_0933_114db35d", "text": "The needs of the particula r algorith m and its data requirement s w i ll deter-\nmine the best technique. 2.Strategies as template parameters. In C++ template s can be u s ed to configur e\na c l a ss with a strategy . T h is techniqu e is o n ly applicabl e if ( 1) t he Strateg y\nc an be s e l e c t e d at c o m p i l e - t i m e , a nd ( 2) it d o es n ot h a ve to be c h a n g e d at \nrun-time . In this c a s e, the c l a ss to be configure d ( e . g ., C o n t e x t ) is define d\nas a templat e c l a ss that has a S t r a t e g y c l a ss as a parameter:\ntemplate <class AStrategy >\nclass Context {\nvoid Operation( ) { theStrategy.DoAlgorithm() ; }\n// . . .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 933, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 666}}
{"id": "computer_science_design_patterns_gof_chunk_0934_9feab972", "text": ". . private:\nA S t r a t e g y t h e S t r a t e g y ;\n} ;\nThe c l a ss is then configure d with a S t r a t e g y c l a ss when it's instantiated:\nclass MyStrateg y {\npublic:\nvoid DoAlgorithm() ;\n} ;\nContext<MyStrategy> aContext;\nWith templates , there' s no n e ed to defin e an abstrac t c l a ss that define s the\ninterfac e to the S t r a t e g y . Usin g S t r a t e g y as a templat e paramete r a l so\nlets you b i nd a S t r a t e g y to its C o n t e x t s t a t i c a l l y , whic h can i n c r e a s e\nefficiency. ptg320 BEHAVIORAL PATTERNS CHAPTERS\n3. Making Strategy objects optional. The Contex t c l a ss may be simplifie d if it's\nmeaningfu l not to have a Strateg y object . Contex t c h e c k s to see if it has\na Strateg y objec t befor e a c c e s s i n g it. If there is o n e, then Contex t u s es it\nnormally . If there isn't a strategy , then Contex t carrie s out d e f a u l t behavior .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 934, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_design_patterns_gof_chunk_0935_78ef1970", "text": "If there is o n e, then Contex t u s es it\nnormally . If there isn't a strategy , then Contex t carrie s out d e f a u l t behavior . The benefi t of this approac h is t h at c l i e n t s don't have to deal with Strateg y \nobjects at all unless they don't like the default behavior. S a m p l e C o d e\nW e ' ll g i ve the h i g h - l e v e l c o de for the Motivatio n e x a m p l e , whic h is b a s ed on the\nimplementatio n of Compositio n and Composito r c l a s s e s in Interview s [LCI+92]. The C o m p o s i t i o n c l a ss maintain s a c o l l e c t i o n of C o m p o n e n t instances , whic h\nr e p r e s e n t t e xt a nd g r a p h i c a l e l e m e n t s in a document . A c o m p o s i t i o n a r r a n g e s \ncomponen t object s into l i n es using an instanc e of a C o m p o s i t o r s u b c l a s s , whic h\ne n c a p s u l a t e s a l i n e b r e a k i n g s t r a t e g y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 935, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_design_patterns_gof_chunk_0936_135d2d28", "text": "E a ch c o m p o n e n t h as an a s s o c i a t e d natura l\ns i z e, stretchability , and shrinkability . The stretchabilit y define s how much the\ncomponen t can g r ow beyon d its n a t u r a l s i z e; shrinkabilit y is how much it can\nshrink . The compositio n passe s these value s to a compositor , whic h uses them to\ndetermine the best location for linebreaks. c l a s s C o m p o s i t i o n {\np u b l i c :\nComposition(Compositor*) ;\nvoid Repair();\nprivate:\nCompositor * _compositor;\nComponent * _components ;// t he l i st of c o m p o n e n t s \nint _componentCount ; // the number of component s \nint _lineWidth ; // the Composition' s line width\ni n t* _lineBreaks ; // the position of l i n e b r e a k s\n// in component s \nint _lineCount; // the number o f lines\nW h en a n ew layou t is r e q u i r e d , t he c o m p o s i t i o n a s ks i ts c o m p o s i t o r to d e t e r m i n e\nwher e to p l a ce l i n e b r e a k s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 936, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_design_patterns_gof_chunk_0937_08a0cb72", "text": "The compositio n p a s s e s the composito r three array s\nthat defin e natura l s i z e s, s t r e t c h a b i l i t i e s , a nd s h r i n k a b i l i t i e s of t he c o m p o n e n t s . It\nalso p a s s e s the numbe r of components , how wide the line is, and an array that\nthe c o m p o s i t o r fills with the positio n of e a ch linebreak . The c o m p o s i t o r return s\nthe number of calculated breaks. T h e Compositor interface lets the composition p a s s the compositor a l l t h e infor -\nmation it needs. This is an example of \"taking the data to the strategy\":\n\nptgS T R A T E G Y 321\nclass Composito r {\npublic:\nvirtual int Compose( \nCoord natural[] , Coord stretch[] , Coord shrinkf] ,\nint componentCount , int lineWidth , int breaks[]\n) = 0;\nprotected:\nCompositor() ;\n} ;\nNote that C o m p o s i t o r is an abstrac t c l a s s. Concret e s u b c l a s s e s defin e s p e c i f i c\nlinebreakin g s t r a t e g i e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 937, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 941}}
{"id": "computer_science_design_patterns_gof_chunk_0938_7132f07f", "text": "Concret e s u b c l a s s e s defin e s p e c i f i c\nlinebreakin g s t r a t e g i e s . The c o m p o s i t i o n c a l ls its c o m p o s i t o r in its R e p a i r operation . R e p a i r first i n i t i a l -\ni z es array s with the natura l s i z e, stretchability , and shrinkabilit y of e a ch c o m p o -\nnent (the detail s of whic h we omit for brevity) . T h en it c a l ls on the composito r to\nobtai n the l i n e b r e a k s and finall y lays out the component s accordin g to the break s\n(also omitted):\nvoid Composition::Repai r () {\nCoord* natural;\nCoord* stretchability ; \nCoord* shrinkability ; \nint componentCount ;\nint* breaks;\n// prepare the arrays with the desired componen t sizes\n// . . . // determin e where the breaks are:\nint breakCount ; \nbreakCoun t - _compositor->Compose(\nnatural, stretchability , shrinkability ,\ncomponentCount , _lineWidth , breaks\n) ;\n// lay out component s accordin g to breaks\n// . . . Now let's l o ok at the C o m p o s i t o r s u b c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 938, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_design_patterns_gof_chunk_0939_e4526ddf", "text": ". . Now let's l o ok at the C o m p o s i t o r s u b c l a s s e s . S i m p l e C o m p o s i t o r e x a m i n e s\ncomponents a line at a time to determine where breaks should go:\nclass SimpleComposito r : public Composito r {\npublic:\nSimpleComposito r () , -\nvirtual int Compose(\nC o o rd n a t u r a l [ ] , C o o rd stretch[] , C o o rd s h r i n k [ ] ,\nint componentCount, int lineWidth, int breaks[]\n\nptg322 BEHAVIORAL PATTERNS CHAPTER 5\nT e X C o m p o s i t o r u s es a more g l o b a l strategy . It e x a m i n e s a paragraph at a t i m e,\ntakin g into accoun t the components ' s i ze and s t r e t c h a b i l i t y . It a l so t r i es to g i ve\nan even \" c o l o r \" to the paragrap h by minimizin g the whitespac e betwee n c o m p o -\nnents.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 939, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 762}}
{"id": "computer_science_design_patterns_gof_chunk_0940_34cef563", "text": "It a l so t r i es to g i ve\nan even \" c o l o r \" to the paragrap h by minimizin g the whitespac e betwee n c o m p o -\nnents. class TeXComposito r : public Composito r {\npublic:\nTeXCompositor();\nvirtual int Compose( \nC o o rd natural[] , C o o rd stretch[] , C o o rd shrinkf] ,\nint componentCount, int lineWidth, int breaks[]\nA r r a y C o m p o s i t o r break s the component s into l i n es at regula r intervals. class ArrayComposito r : public Composito r {\npublic:\nArrayCompositor(in t interval);\nvirtual int Compose( \nC o o rd natural[] , Coord stretchf] , C o o rd shrink[], \nint componentCount , int lineWidth , int breaks[]\n) ; \n// . . . T h e se c l a s s e s don't use all the informatio n p a s s e d in C o m p o s e . S i m p l e C o m -\np o s i t o r i g n o r e s the stretchabilit y of the components , takin g o n ly their nat-\nural width s into account .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 940, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_design_patterns_gof_chunk_0941_99fa7b93", "text": "S i m p l e C o m -\np o s i t o r i g n o r e s the stretchabilit y of the components , takin g o n ly their nat-\nural width s into account . T e X C o m p o s i t o r u s es all the informatio n p a s s e d to it,\nw h e r e a s A r r a y C o m p o s i t o r i g n o r e s e v e r y t h i n g . To instantiate C o m p o s it ion, you pass it the c o m p o s i t o r you w a nt to u s e :\nComposition * quick = new Composition(ne w SimpleCompositor) ;\nComposition * slick - new Composition(ne w TeXCompositor) ;\nComposition* iconic = new Composition(new ArrayCompositor(100));\nC o m p o s i t o r ' s interfac e is carefull y d e s i g n e d to suppor t all layou t a l g o r i t h m s\nt h at s u b c l a s s e s migh t implement . You don't want to have to chang e this interfac e\nwith every new s u b c l a s s , b e c a u s e that w i ll r e q u i r e changin g existin g s u b c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 941, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_design_patterns_gof_chunk_0942_56624796", "text": "You don't want to have to chang e this interfac e\nwith every new s u b c l a s s , b e c a u s e that w i ll r e q u i r e changin g existin g s u b c l a s s e s . In g e n e r a l , t he S t r a t e g y a nd C o n t e x t i n t e r f a c e s d e t e r m i n e h ow w e ll t he patter n\na c h i e v e s its intent. K n o w n Uses\nBoth ET++ [ W G M 8 8 ] and I n t e r v i e w s u s e strategies to encapsulate different l i n e -\nbreaking algorithms as we've described. ptgS T R A T E G Y 3 2 3\nIn the RTL S y s t e m for compile r code optimizatio n [ J M L 9 2 ] , strategie s defin e d i f f e r -\ne nt registe r a l l o c a t i o n s c h e m e s (RegisterAllocator ) a nd instructio n s et s c h e d u l i n g\np o l i c i e s ( R I S C s c h e d u l e r , C I S C s c h e d u l e r ) . T h is provide s flexibilit y in targetin g the\noptimize r for differen t machin e architectures.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 942, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_design_patterns_gof_chunk_0943_97a9371e", "text": "T h is provide s flexibilit y in targetin g the\noptimize r for differen t machin e architectures. The ET++SwapsManage r calculatio n e n g i n e f r a m e w o r k compute s price s for dif-\nferen t financia l instrument s [EG92] . Its key abstraction s are Instrumen t and Y i e l d -\nCurve . Differen t instrument s are implemente d as s u b c l a s s e s of Instrument . Y i e l d -\nCurv e calculate s discoun t factors , whic h determin e the presen t value of f u t u r e\nc a sh flows . B o th of these c l a s s e s delegat e s o me behavio r to Strateg y objects . The\nf r a m e w o r k provide s a famil y of ConcreteStrateg y c l a s s e s for generatin g c a sh\nflows , valuin g swaps , and calculatin g discoun t factors . You can creat e new c a l -\nculatio n e n g i n e s by configurin g Instrumen t and YieldCurv e with the d i f f e r e n t\nConcreteStrateg y objects . T h is approac h support s mixin g and matchin g existin g\nStrateg y implementation s as well as definin g new o n e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 943, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_design_patterns_gof_chunk_0944_477aedda", "text": "T h is approac h support s mixin g and matchin g existin g\nStrateg y implementation s as well as definin g new o n e s . T he B o o c h component s [ B V 9 0 ] u se strategie s as templat e arguments . T he B o o c h\nc o l l e c t i o n c l a s s e s suppor t three differen t kinds of memor y allocatio n strategies :\nmanage d (allocatio n out of a pool) , controlle d (allocations/deallocation s are pro-\ntecte d by l o c k s ) , and unmanage d (the norma l memor y allocator) . T h e s e strategie s\nare p a s s e d as templat e arguments to a collectio n c l a ss when it's instantiated . For\ne x a m p l e , an UnboundedCollectio n that u s es the unmanage d strateg y is instanti-\nated as U n b o u n d e d C o l l e c t i o n < M y I t e m T y p e * , U n m a n a g e d > . RAp p is a s y s t e m for integrate d circui t layou t [ G A 8 9 , AG90] . RAp p must lay out\nand route wires that c o n n e c t subsystem s on the circuit .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 944, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_design_patterns_gof_chunk_0945_e1dce678", "text": "RAp p is a s y s t e m for integrate d circui t layou t [ G A 8 9 , AG90] . RAp p must lay out\nand route wires that c o n n e c t subsystem s on the circuit . Routin g algorithm s in\nRAp p are define d as s u b c l a s s e s of an abstrac t Route r c l a s s . Route r is a Strateg y\nc l a s s . Borland' s Objec t Window s [ B o r 9 4 ] u s es strategie s in d i a l o g s boxe s to ensur e that\nthe user enter s v a l id data. For example , number s migh t have to be in a certai n\nrange , and a numeri c entry field s h o u l d accep t o n ly digits . Validatin g that a string\nis correc t can requir e a table look-up. O b j e c t W i n d o w s u s es Validato r o b j e c t s to encapsulat e validatio n strategies . V a l -\nidator s are example s of Strateg y objects . Data entry fields delegat e the validatio n\nstrateg y to an optiona l Validato r object . The c l i e n t attache s a validato r to a field\nif validatio n is r e q u i r e d (an exampl e of an optiona l strategy) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 945, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 990}}
{"id": "computer_science_design_patterns_gof_chunk_0946_43e5cf43", "text": "The c l i e n t attache s a validato r to a field\nif validatio n is r e q u i r e d (an exampl e of an optiona l strategy) . Whe n the dialo g is\nc l o s e d , the entry fields ask their validator s to validat e the data. The c l a ss librar y\nprovide s validator s for commo n c a s e s , s u ch as a Rang e Validato r for numbers . New c l i e n t - s p e c i f i c validatio n strategie s can be define d e a s i ly by subclassin g the\nValidator class. Related Patterns\nFlyweight (195): Strategy objects o f t e n make good f l y w e i g h t s . ptg\nThis page intentionally left blank \n\nptgTEMPLATE M E T H O D 325\nT E M P L A T E M E T H O D C l a s s B e h a v i o r a l\nIntent\nDefin e the skeleto n of an algorith m in an operation , deferrin g s o me s t e ps to\ns u b c l a s s e s . T e m p l a t e M e t h o d l e ts s u b c l a s s e s r e d e f i n e c e r t a i n s t e ps of an a l g o r i t h m\nwithout changing the algorithm's structure.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 946, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_design_patterns_gof_chunk_0947_b28cc34f", "text": "T e m p l a t e M e t h o d l e ts s u b c l a s s e s r e d e f i n e c e r t a i n s t e ps of an a l g o r i t h m\nwithout changing the algorithm's structure. Motivation\nConside r an applicatio n f r a m e w o r k t h at provide s Applicatio n and Documen t\nc l a s s e s . The Applicatio n c l a ss is r e s p o n s i b l e for o p e n i n g existin g document s store d\nin an externa l f o r m a t , such as a file. A Documen t objec t represent s the informatio n\nin a documen t o n ce i t 's r e ad from t he file. Application s built with the f r a m e w o r k can s u b c l a s s Applicatio n and Documen t to\nsuit specifi c needs . For example , a drawin g applicatio n define s Draw Applicatio n\nand DrawDocument subclasses; a spreadsheet application defines Spreadsheet-\nApplication and SpreadsheetDocument subclasses.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 947, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 830}}
{"id": "computer_science_design_patterns_gof_chunk_0948_d1397875", "text": "For example , a drawin g applicatio n define s Draw Applicatio n\nand DrawDocument subclasses; a spreadsheet application defines Spreadsheet-\nApplication and SpreadsheetDocument subclasses. The abstrac t Applicatio n c l a ss define s the algorith m for openin g and readin g a\ndocument in its OpenDocument operation:\nvoid Application::OpenDocumen t ( c o n st char^\nif (!CanOpenDocument(name) ) {\n// cannot handle this document\nreturn;\n}name) {\n\nptg3 2 6 BEHAVIORAL PATTERNS CHAPTER 5\nDocument * doc = DoCreateDocument();\nif ( d o c) { \n_docs->AddDocument(doc);\nAboutToOpenDocument(doc) ;\ndoc->Open() ;\nd o c - > D o R e a d ( ) ;\n}\n}\nOpenDocumen t define s each step for openin g a document . It c h e c k s if the d o c u -\nment can be o p e n e d , create s the application-specifi c Documen t o b j e c t , adds it to\nits set of documents , and reads the Documen t from a file. We c a ll OpenDocumen t a templat e method .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 948, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_design_patterns_gof_chunk_0949_76b2525f", "text": "We c a ll OpenDocumen t a templat e method . A templat e metho d define s an a l g o -\nrithm in term s of abstrac t operation s that s u b c l a s s e s overrid e to p r o v i d e c o n c r e t e\nb e h a v i o r . Applicatio n s u b c l a s s e s defin e the s t e ps of the algorith m that c h e ck if\nthe documen t can be o p e n e d (CanOpenDocument ) and that creat e the Documen t\n(DoCreateDocument) . Documen t c l a s s e s defin e the step t h at reads the documen t\n(DoRead) . The templat e metho d a l so define s an operatio n that l e ts Applicatio n\ns u b c l a s s e s know when the documen t is abou t to be o p e n e d (AboutToOpenDocu-\nment) , in c a se t h ey c a r e . By definin g s o me of the s t e ps of an algorith m using abstrac t o p e r a t i o n s , the tem-\nplate metho d fixes their ordering , but it lets Applicatio n and Documen t s u b c l a s s e s\nvary those steps to suit their needs.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 949, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_design_patterns_gof_chunk_0950_debec626", "text": "A p p l i c a b i l i t y\nThe Templat e Metho d patter n shoul d be u s e d\n• to implemen t the invarian t parts of an algorith m o n ce and l e a ve it up to\nsubclasse s to implemen t the behavio r that can v a r y . • when commo n behavio r amon g s u b c l a s s e s s h o u l d be factore d and l o c a l i z e d\nin a commo n c l a ss to a v o id c o de duplication . T h is is a g o od exampl e of\n\"refactorin g to g e n e r a l i z e \" as d e s c r i b e d by Opdyk e and Johnso n [ O J 9 3 ] . You first identif y the difference s in the e x i s t i n g c o de and then separat e the\ndifference s into n ew o p e r a t i o n s . F i n a l l y , y ou r e p l a c e t he differin g c o de w i th\na templat e metho d t h at c a l ls one of t h e se new operations. • to contro l s u b c l a s s e s extensions .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 950, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 815}}
{"id": "computer_science_design_patterns_gof_chunk_0951_10111ad4", "text": "F i n a l l y , y ou r e p l a c e t he differin g c o de w i th\na templat e metho d t h at c a l ls one of t h e se new operations. • to contro l s u b c l a s s e s extensions . You can defin e a templat e metho d that c a l ls\n\" h o o k \" operation s ( s ee C o n s e q u e n c e s ) at s p e c i f i c p o i n t s , thereb y permittin g \nextensions only at those points. ptgS t r u r t u r eTEMPLATE M E T H O D 327\nP a r t i c i p a n t s\n• A b s t r a c t C l a s s ( A p p l i c a t i o n )\n- d e f i n e s abstrac t primitiv e operation s that c o n c r e t e s u b c l a s s e s defin e to\ni m p l e m e n t s t e ps of an a l g o r i t h m . - i m p l e m e n t s a templat e m e t h o d d e f i n i n g t he s k e l e t o n of an a l g o r i t h m . T he\ntemplat e m e t h o d c a l ls p r i m i t i v e o p e r a t i o n s as w e ll as o p e r a t i o n s d e f i n e d\nin A b s t r a c t C l a s s or t h o se of o t h er o b j e c t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 951, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_design_patterns_gof_chunk_0952_392c92f3", "text": "T he\ntemplat e m e t h o d c a l ls p r i m i t i v e o p e r a t i o n s as w e ll as o p e r a t i o n s d e f i n e d\nin A b s t r a c t C l a s s or t h o se of o t h er o b j e c t s . • C o n c r e t e C l a s s ( M y A p p l i c a t i o n )\n- i m p l e m e n t s t he p r i m i t i v e o p e r a t i o n s to carry o ut s u b c l a s s - s p e c i f i c s t e ps of\nthe algorithm. C o l l a b o r a t i o n s\n• C o n c r e t e C l a s s r e l i es on A b s t r a c t C l a s s to i m p l e m e n t t he i n v a r i a n t s t e ps of t he\na l g o r i t h m . C o n s e q u e n c e s\nT e m p l a t e m e t h o d s a re a fundamenta l t e c h n i q u e f or c o de r e u s e . T h ey a re p a r t i c -\nularly importan t in c l a ss l i b r a r i e s , b e c a u s e they are the m e a n s for factorin g out\nc o m m o n b e h a v i o r in librar y c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 952, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 868}}
{"id": "computer_science_design_patterns_gof_chunk_0953_04abe3dc", "text": "T h ey a re p a r t i c -\nularly importan t in c l a ss l i b r a r i e s , b e c a u s e they are the m e a n s for factorin g out\nc o m m o n b e h a v i o r in librar y c l a s s e s . T e m p l a t e m e t h o d s l e ad to an i n v e r t e d c o n t r o l structur e t h a t 's s o m e t i m e s referre d\nto as \" t he H o l l y w o o d p r i n c i p l e , \" that i s, \" D o n ' t c a ll u s, w e ' ll c a ll you\" [ S w e 8 5 ] . T h is refers to h ow a paren t c l a ss c a l ls t he o p e r a t i o n s of a s u b c l a s s a nd n ot t he\no t h e r way around. Template methods call the following kinds of operations:\n• c o n c r e t e o p e r a t i o n s ( e i t h e r on the ConcreteClass or on client classes);\n\nptg3 28 B E H A V I O R A L PATTERNS CHAPTER 5\n• concret e AbstractClas s operation s ( i . e ., operation s that are generall y usefu l\nto s u b c l a s s e s ) ;\n• primitiv e operation s ( i .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 953, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_design_patterns_gof_chunk_0954_7f9fe8b5", "text": "e ., operation s that are generall y usefu l\nto s u b c l a s s e s ) ;\n• primitiv e operation s ( i . e ., abstrac t operations);\n• factor y method s ( s ee Factor y Metho d ( 1 0 7 ) ) ; and\n• h o ok o p e r a t i o n s , w h i c h provid e defaul t behavio r that s u b c l a s s e s can e x t e n d\nif n e c e s s a r y . A hook operatio n often d o es nothin g by default. It's importan t for templat e method s to specif y w h i c h operation s are h o o k s (may\nbe overridden ) and whic h are abstrac t operation s (must be overridden) . To r e u se\nan abstrac t c l a ss effectively , s u b c l a s s writer s must understan d w h i c h operation s\nare d e s i g n e d for overriding.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 954, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 693}}
{"id": "computer_science_design_patterns_gof_chunk_0955_a99ff030", "text": "To r e u se\nan abstrac t c l a ss effectively , s u b c l a s s writer s must understan d w h i c h operation s\nare d e s i g n e d for overriding. A subclas s can extend a paren t c l a ss operation' s behavio r by overridin g the o p e r -\nation and c a l l i n g the paren t operatio n e x p l i c i t l y :\nvoid DerivedClass::Operatio n () {\nParentClass::Operation() ; \n// DerivedClas s e x t e n d ed b e h a v i o r\n}\nUnfortunately, i t 's easy to forge t to c a ll the i n h e r i t e d operation . We can transfor m\ns u ch an operatio n i n to a templat e metho d to g i ve the paren t c o n t r o l o v er how\ns u b c l a s s e s e x t e n d it. The i d ea is to c a ll a hook operatio n from a templat e metho d\nin the paren t c l a s s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 955, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 748}}
{"id": "computer_science_design_patterns_gof_chunk_0956_c7fbf851", "text": "The i d ea is to c a ll a hook operatio n from a templat e metho d\nin the paren t c l a s s . T h en s u b c l a s s e s can then overrid e t h is hook operation:\nvoid ParentClass::Operatio n () {\n// P a r e n t C l a s s b e h a v i or \nHookOperation();\n}\nHookOperatio n does n o t h i ng in P a r e n t C l a s s :\nvoid P a r e n t C l a s s : : H o o k O p e r a t i o n () { }\nS u b c l a s s e s overrid e H o o k O p e r a t i o n to exten d its behavior:\nvoid D e r i v e d C l a s s : : H o o k O p e r a t i o n () {\n// derived c l a ss e x t e n s i on \n}\nImplementation\nT h r ee implementatio n i s s u e s are wort h n o t i n g :\n1. Using C++ access control. In C++, the primitiv e operation s that a templat e\nmetho d c a l ls can be d e c l a r e d protecte d members . T h is ensure s that they\nare o n l y c a l l e d by the template method. Primitive operations that m u s t be\n\nptgTEMPLATE METHOD 3 2 9\noverridde n are d e c l a r e d pure virtual .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 956, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_design_patterns_gof_chunk_0957_337bd38f", "text": "T h is ensure s that they\nare o n l y c a l l e d by the template method. Primitive operations that m u s t be\n\nptgTEMPLATE METHOD 3 2 9\noverridde n are d e c l a r e d pure virtual . The templat e metho d i t s e lf s h o u l d not\nbe o v e r r i d d e n ; therefor e y ou c an make t he templat e metho d a nonvirtua l\nmembe r function. 2. Minimizing primitive operations. An importan t g o al in d e s i g n i n g templat e\nmethod s is to minimiz e the numbe r of primitiv e operation s that a s u b c l a s s\nmust overrid e to flesh out the algorithm . The more operation s that n e ed\noverriding , the more tediou s thing s get for c l i e n t s . 3. Naming conventions. You can identif y the operation s that shoul d be overrid-\nden by addin g a prefix to their names . For e x a m p l e , the MacAp p f r a m e w o r k \nfor Macintos h application s [ A p p 8 9 ] prefixe s templat e metho d name s with\n\" D o - \" : \"DoCreateDocument\", \"DoRead\", and so forth.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 957, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_design_patterns_gof_chunk_0958_7e2443a3", "text": "For e x a m p l e , the MacAp p f r a m e w o r k \nfor Macintos h application s [ A p p 8 9 ] prefixe s templat e metho d name s with\n\" D o - \" : \"DoCreateDocument\", \"DoRead\", and so forth. S a m p l e C o d e\nThe followin g C++ exampl e show s how a paren t c l a ss can enforc e an invarian t for\nits s u b c l a s s e s . The exampl e c o m e s from N e X T ' s AppKi t [ A d d 9 4 ] . C o n s i d e r a c l a ss\nV i ew that support s drawin g on the s c r e e n . V i ew enforce s the invarian t t h at its\ns u b c l a s s e s can draw into a v i ew o n l y after it b e c o m e s the \" f o c u s , \" whic h r e q u i r e s\ncertai n drawin g state (for e x a m p l e , c o l o r s and f o n t s ) to be set up p r o p e r l y . We can use a D i s p l a y templat e metho d to set up this state. V i ew define s two\nc o n c r e t e o p e r a t i o n s , S e t F o c u s and R e s e t F o c u s , that set up and c l e an up the\ndrawin g state, r e s p e c t i v e l y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 958, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_design_patterns_gof_chunk_0959_c18fce15", "text": "V i ew define s two\nc o n c r e t e o p e r a t i o n s , S e t F o c u s and R e s e t F o c u s , that set up and c l e an up the\ndrawin g state, r e s p e c t i v e l y . V i e w ' s D o D i s p l a y hook operatio n perform s the ac-\ntual drawing . D i s p l a y c a l ls S e t F o c u s befor e D o D i s p l a y to s e t up t he drawin g\nstate; Display calls ResetFocus afterwards t o release the drawing state. void View::Displa y () { \nSetFocus();\nDoDisplay() ; \nResetFocus();\n}\nTo maintai n the invariant , the view' s c l i e n t s alway s c a ll D i s p l a y , and V i ew\ns u b c l a s s e s a l w a y s o v e r r i d e D o D i s p l a y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 959, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 651}}
{"id": "computer_science_design_patterns_gof_chunk_0960_41e23592", "text": "D o D i s p l a y does nothing in View:\nvoid View::DoDisplay ( ) { }\nS u b c l a s s e s o v e r r i d e it to add their specific drawing behavior:\nvoid MyView::DoDispla y () {\n// render the view's contents\n}\nKnown Uses\nTemplate methods are so fundamental that they can be f o u n d i n a l m o s t e v e r y\n\nptg3 30 BEHAVIORAL PATTERNS CHAPTERS\nabstrac t c l a s s. W i r f s - B r o c k et a l. [ W B W W 9 0 , W B J 9 0 ] p r o v i d e a g o od o v e r v i e w\na n d discussion of template methods. R e l a t e d P a t t e r n s\nFactor y M e t h o d s ( 1 0 7) a re often c a l l ed by templat e m e t h o d s . In t he M o t i v a t i o n\ne x a m p l e , t he factor y m e t h o d D o C r e a t e D o c u m e n t is c a l l ed by t he templat e m e t h o d\nO p e n D o c u m e n t . S t r a t e g y ( 3 1 5 ) : T e m p l a t e m e t h o d s u se i n h e r i t a n c e to vary part of an a l g o r i t h m . S t r a t e g i e s use delegation to vary the entire algorithm.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 960, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_design_patterns_gof_chunk_0961_001bcaeb", "text": "S t r a t e g y ( 3 1 5 ) : T e m p l a t e m e t h o d s u se i n h e r i t a n c e to vary part of an a l g o r i t h m . S t r a t e g i e s use delegation to vary the entire algorithm. ptgVISITOR 331\nV I S I T O R O b j e c t Behavioral\nIntent\nRepresen t an operatio n to be performe d on the element s of an objec t structure . V i s -\nitor lets you defin e a new operatio n withou t changin g the c l a s s e s of the element s\non which it operates. Motivation\nC o n s i d e r a c o m p i l e r that represent s program s as abstrac t synta x trees. It w i ll n e ed\nto p e r f o r m operation s on abstrac t synta x trees for \" s t a t i c semantic \" analyse s l i ke\ncheckin g that all variable s are defined . It w i ll also need to generat e c o d e. So it migh t\ndefin e operation s for type-checking , c o de optimization , flow analysis , c h e c k i n g\nfor variable s being assigne d value s befor e they'r e u s e d, and so on.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 961, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 943}}
{"id": "computer_science_design_patterns_gof_chunk_0962_8872e060", "text": "So it migh t\ndefin e operation s for type-checking , c o de optimization , flow analysis , c h e c k i n g\nfor variable s being assigne d value s befor e they'r e u s e d, and so on. M o r e o v e r ,\nwe c o u ld use the abstrac t synta x t rees for pretty-printing , progra m restructuring ,\nc o de instrumentation , and computin g variou s metric s of a program. M o st of these operation s w i ll need to treat node s t h at represen t assignment state-\nment s differentl y f r om node s t h at represen t variable s or arithmeti c e x p r e s s i o n s . Henc e there w i ll be one c l a ss for assignmen t statements , anothe r for variabl e\na c c e s s e s , anothe r f or arithmeti c e x p r e s s i o n s , a nd so o n. T he s et of node c l a s s e s\ndepend s on the languag e b e i ng compiled , of course , but it doesn' t chang e much\nfor a given language. T h is diagra m show s part of the Node c l a ss hierarchy .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 962, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 929}}
{"id": "computer_science_design_patterns_gof_chunk_0963_456fe454", "text": "T he s et of node c l a s s e s\ndepend s on the languag e b e i ng compiled , of course , but it doesn' t chang e much\nfor a given language. T h is diagra m show s part of the Node c l a ss hierarchy . The proble m here is t h at\ndistributin g all t h e se operation s a c r o s s the variou s node c l a s s e s leads to a syste m\nthat's hard to understand , maintain , and change . It will be confusin g to have type-\nche ck in g c o de m i x e d with pretty-printin g c o de or flow analysi s c o d e. M o r e o v e r ,\nadding a new operation usually requires recompiling all of these classes. It w o u l d\n\nptg3 3 2 BEHAVIORAL PATTERNS CHAPTER 5\nbe bette r if e a ch new operatio n c o u ld be adde d separately , and the node c l a s s e s\nwere independen t of the operation s that apply to them. We can have both by packagin g relate d operation s from each c l a ss in a separat e\nobject , c a l l ed a visitor , and passin g it to element s of the abstrac t synta x tree as i t 's\ntraversed.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 963, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_design_patterns_gof_chunk_0964_68343197", "text": "We can have both by packagin g relate d operation s from each c l a ss in a separat e\nobject , c a l l ed a visitor , and passin g it to element s of the abstrac t synta x tree as i t 's\ntraversed. Whe n an e l e m e n t \" a c c e p t s \" the v i s i t o r , it s e n ds a reques t to the visito r\nthat e n c o d e s the element' s c l a s s . It a l so i n c l u d e s the elemen t as an argument . The\nvisito r w i ll then execut e the operatio n for t h at element—th e operatio n t h at used\nto be in the c l a ss of the element. For example , a compile r t h at didn' t use visitor s migh t type-chec k a procedur e\nby c a l l i n g the T y p e C h e c k operatio n on its abstrac t synta x t r e e. Each of the node s\nw o u l d i m p l e m e n t T y p e C h e c k by c a l l i n g T y p e C h e c k on i ts c o m p o n e n t s ( s ee t he\np r e c e d i n g c l a ss diagram) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 964, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 882}}
{"id": "computer_science_design_patterns_gof_chunk_0965_ab2a5a2d", "text": "Each of the node s\nw o u l d i m p l e m e n t T y p e C h e c k by c a l l i n g T y p e C h e c k on i ts c o m p o n e n t s ( s ee t he\np r e c e d i n g c l a ss diagram) . If the compile r t y p e - c h e c k e d a procedur e using v i s i t o r s ,\nthen it woul d creat e a T y p e C h e c k i n g V i s i t o r objec t and c a ll the A c c e p t operatio n\non the abstrac t synta x tree with that objec t as an argument . Each of the node s\nwoul d implemen t A c c e p t by c a l l i n g back on the visitor : an assignmen t node\nc a l ls VisitAssignmen t operatio n on the visitor , while a variabl e referenc e c a l ls\nV i s i t V a r i a b l e R e f e r e n c e . Wha t u s ed to be t he T y p e C h e c k o p e r a t i o n in c l a ss A s s i g n -\nmentNod e is now the VisitAssignmen t operatio n on T y p e C h e c k i n g V i s i t o r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 965, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 853}}
{"id": "computer_science_design_patterns_gof_chunk_0966_60cbca71", "text": "Wha t u s ed to be t he T y p e C h e c k o p e r a t i o n in c l a ss A s s i g n -\nmentNod e is now the VisitAssignmen t operatio n on T y p e C h e c k i n g V i s i t o r . To make visitor s work f or more than just t y p e - c h e c k i n g , we n e ed an abstrac t paren t\nc l a ss NodeVisito r for all v i s i t o r s of an abstrac t synta x tree. N o d e V i s i t o r must\ndeclar e an operatio n for e a ch node c l a s s. An applicatio n that needs to comput e\nprogra m metric s w i ll defin e new s u b c l a s s e s of NodeVisito r and will no l o n g e r \nn e ed to add application-specifi c c o de to the node c l a s s e s . The V i s i t o r patter n\nencapsulate s the operation s for each compilatio n phase in a V i s i t o r a s s o c i a t e d\nwith that phase.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 966, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 781}}
{"id": "computer_science_design_patterns_gof_chunk_0967_18f4e296", "text": "The V i s i t o r patter n\nencapsulate s the operation s for each compilatio n phase in a V i s i t o r a s s o c i a t e d\nwith that phase. ptgVISITOR 333\nWith the Visito r pattern , you defin e two c l a ss h i e r a r c h i e s : one for the element s\nb e i ng operate d on (the Node hierarchy ) and one for the v i s i t o r s that defin e op-\neration s on the e l e m e n t s (the Node V i s i t o r hierarchy) . You creat e a new operatio n\nby addin g a new s u b c l a s s to the v i s i t o r c l a ss h i e r a r c h y . As long as the gramma r\nthat the c o m p i l e r accept s doesn' t chang e (that i s, we don't have to add new Node \ns u b c l a s s e s ) , we can add new functionalit y s i m p l y by definin g new Node V i s i t o r\ns u b c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 967, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 770}}
{"id": "computer_science_design_patterns_gof_chunk_0968_a6a3fdb5", "text": "Applicability\nUse the V i s i t o r patter n when\n• an o b j e c t structur e contain s many c l a s s e s of o b j e c t s with differin g interfaces ,\nand you want to perfor m operation s on these o b j e c t s t h at depen d on their\nc o n c r e t e c l a s s e s . • many distinc t and unrelate d operation s n e ed to be performe d on object s in an\no b j e c t structure , and you want to a v o id \" p o l l u t i n g \" their c l a s s e s with t h e se\noperations . V i s i t o r l e ts you keep r e l a t e d operation s togethe r by definin g them\nin o ne c l a s s. Whe n t he o b j e c t structur e is s h a r e d by many a pp li ca ti on s , u se\nV i s i t o r to put operation s in just those application s that n e ed them. • the c l a s s e s definin g the o b j e c t structur e rarely c h a n g e , but you often want\nto defin e new operation s o v er the structure .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 968, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 884}}
{"id": "computer_science_design_patterns_gof_chunk_0969_482ca52e", "text": "• the c l a s s e s definin g the o b j e c t structur e rarely c h a n g e , but you often want\nto defin e new operation s o v er the structure . Changin g the o b j e c t structur e\nc l a s s e s r e q u i r e s redefinin g t he interfac e to a ll v i s i t o r s , whic h is potentiall y\nc o s t l y . If the o b j e c t structur e c l a s s e s c h a n g e often , then it's probabl y bette r to\ndefine the operations in those classes. ptg3 3 4 BEHAVIORAL PATTERNS\nS t r u c t u r eCHAPTER 5\nP a r t i c i p a n t s\n• Visito r (NodeVisitor)\n- declare s a V i s it operatio n for each c l a ss of ConcreteElemen t in the o b j e c t\nstructure . The operation' s name and signatur e identifie s the c l a ss t h at s e n ds\nthe V i s it reques t to the v i s i t o r . That lets the visito r determin e the c o n c r e t e\nc l a ss of the elemen t being visited . Then the visito r can a c c e s s the e l e m e n t\ndirectl y throug h its particula r interface.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 969, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_design_patterns_gof_chunk_0970_6f6c2fcd", "text": "That lets the visito r determin e the c o n c r e t e\nc l a ss of the elemen t being visited . Then the visito r can a c c e s s the e l e m e n t\ndirectl y throug h its particula r interface. • Concret e Visito r (TypeCheckingVisitor)\n- implement s each operatio n declare d by V i s i t o r . Each operatio n implement s\na f r a g m e n t of the algorith m define d for the correspondin g c l a ss of o b j e c t\nin the structure . ConcreteVisito r provide s the contex t for the algorith m\nand store s its l o c al state. T h is state o f t en accumulate s result s durin g the\ntraversal of the structure. • Element (Node)\n- defines an Accept operation that takes a visitor as an argument. ptgVISITOR 335\n• C o n c r e t e E l e m e n t (AssignmentNode,VariableRefNode)\n- implement s an Accep t operatio n that takes a v i s i t o r as an argument. • O b j e c t S t r u c t u r e (Program)\n- can enumerat e its e l e m e n t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 970, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 932}}
{"id": "computer_science_design_patterns_gof_chunk_0971_d56c0459", "text": "• O b j e c t S t r u c t u r e (Program)\n- can enumerat e its e l e m e n t s . - may provid e a h i g h - l e v e l interfac e to a l l ow the v i s i t o r to v i s it its e l e m e n t s . - may eithe r be a composit e ( s ee Composit e ( 1 6 3 ) ) or a c o l l e c t i o n such as a\nl i s t or a set. C o l l a b o r a t i o n s\n• A c l i e n t that u s es the Visito r patter n must creat e a C o n c r e t e V i s i t o r objec t and\nthen travers e the o b j e c t structure , visitin g each e l e m e n t with the v i s i t o r . • Whe n an elemen t is v i s i t e d , it c a l ls the Visito r operatio n that c o r r e s p o n d s to\nits c l a s s. The e l e m e n t s u p p l i e s i t s e lf as an argumen t to this operatio n to let the\nv i s i t o r a c c e s s i ts s t a t e, if n e c e s s a r y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 971, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 813}}
{"id": "computer_science_design_patterns_gof_chunk_0972_389edf65", "text": "The e l e m e n t s u p p l i e s i t s e lf as an argumen t to this operatio n to let the\nv i s i t o r a c c e s s i ts s t a t e, if n e c e s s a r y . The followin g interactio n diagra m illustrate s the collaboration s betwee n an\no b j e c t structure, a visitor, and two elements:\nC o n s e q u e n c e s\nS o me of the benefit s and l i a b i l i t i e s of the Visito r patter n are as follows:\n1. Visitor makes adding new operations easy. Visitor s make it e a sy to add operation s\nthat depen d on the component s of comple x objects . You can defin e a new\noperatio n over an objec t structur e simpl y by addin g a new v i s i t o r . In contrast ,\nif you s p r e a d functionalit y o v er many c l a s s e s , then you must chang e each\nc l a ss to defin e a new operation. 2. A visitor gathers related operations and separates unrelated ones.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 972, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 858}}
{"id": "computer_science_design_patterns_gof_chunk_0973_30450c5d", "text": "2. A visitor gathers related operations and separates unrelated ones. Relate d behav-\ni or i s n 't s p r e a d o v er t he c l a s s e s definin g t he o b j e c t s t r u c t u r e ; i t 's l o c a l i z e d\nin a visitor. Unrelated sets o f behavior a r e partitioned i n their o w n v i s i t o r\n\nptg3 36 BEHAVIORAL PATTERNS CHAPTER 5\ns u b c l a s s e s . That s i m p l i f i e s both the c l a s s e s definin g the e l e m e n t s and the al-\ngorithm s define d in the v i s i t o r s . Any algorithm-specifi c data structure s can\nbe hidde n in the v i s i t o r . 3. Adding n ew ConcreteElement classes is hard. T he V i s i t o r patter n m a k e s it hard\nto add new s u b c l a s s e s of Element . E a ch new ConcreteElemen t g i v es r i se to\na new abstrac t operatio n on V i s i t o r and a correspondin g implementatio n\nin e v e ry C o n c r e t e V i s i t o r c l a s s.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 973, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_design_patterns_gof_chunk_0974_95097c9a", "text": "E a ch new ConcreteElemen t g i v es r i se to\na new abstrac t operatio n on V i s i t o r and a correspondin g implementatio n\nin e v e ry C o n c r e t e V i s i t o r c l a s s. S o m e t i m e s a defaul t implementatio n can be\nprovide d in V i s i t o r that can be inherite d by most of the C o n c r e t e V i s i t o r s , but\nthis is the e x c e p t i o n rathe r than the r u l e . So t he k ey consideratio n in applyin g t he V i s i t o r patter n is whethe r y ou a re\nmostl y l i k e ly to chang e the algorith m a p p l i e d o v er an o b j e c t structur e or\nthe c l a s s e s of o b j e c t s that make up the structure . The V i s i t o r c l a ss hierarch y\ncan be difficul t to maintai n when new C o n c r e t e E l e m e n t c l a s s e s are adde d\nfrequently . In such c a s e s , it's probabl y e a s i e r just to defin e operation s on the\nc l a s s e s that make up the structure .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 974, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 913}}
{"id": "computer_science_design_patterns_gof_chunk_0975_1d1b432b", "text": "In such c a s e s , it's probabl y e a s i e r just to defin e operation s on the\nc l a s s e s that make up the structure . If the Elemen t c l a ss hierarch y is s t a b l e ,\nbut you are continuall y addin g operation s or changin g a l g o r i t h m s , then the\nV i s i t o r patter n w i ll help you manag e the c h a n g e s . 4.Visiting across class hierarchies. An iterato r ( s ee Iterato r ( 2 5 7 ) ) can v i s it the\nobject s in a structur e as it traverse s them by c a l l i n g their operations . But an\niterato r can't work a c r o s s o b j e c t structure s with differen t t y p es of e l e m e n t s . For e x a m p l e , the Iterato r interfac e define d on page 263 can a c c e s s o n ly o b j e c t s\nof type I t e m :\ntemplate <class Item>\nclass Iterator {\n// . . . I t em C u r r e n t l t e m ( ) c o n s t ;\n} ;\nT h is i m p l i e s that all element s the iterato r can v i s it have a commo n paren t\nc l a ss I t e m . Visito r d o es not have this r e s t r i c t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 975, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_design_patterns_gof_chunk_0976_3dc591cb", "text": "Visito r d o es not have this r e s t r i c t i o n . It can v i s it o b j e c t s t h at don't have a\ncommo n paren t c l a s s. You can add any type of o b j e c t to a Visito r interface . F or e x a m p l e , i n\nclass Visitor {\npublic:\n// . . . void VisitMyType(MyType*) ;\nvoid VisitYourType(YourType*);\n} ;\nM y T y p e and Y o u r T y p e do not have to be r e l a t e d throug h inheritanc e at a l l . 5. Accumulating state. V i s i t o r s c an accumulat e state as they v i s it e a ch e l e m e n t\nin the o b j e c t structure . Withou t a v i s i t o r , t h is state woul d be p a s s e d as extra\nargument s to the operation s that perfor m the traversal , or they migh t appea r\na s global variables. ptgVISITOR 3 3 7\n6.Breaking encapsulation. Visitor' s approac h assume s t h at the ConcreteElemen t\ninterfac e is p o w e r f u l enoug h to let visitor s do their job.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 976, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 887}}
{"id": "computer_science_design_patterns_gof_chunk_0977_af2da5d9", "text": "ptgVISITOR 3 3 7\n6.Breaking encapsulation. Visitor' s approac h assume s t h at the ConcreteElemen t\ninterfac e is p o w e r f u l enoug h to let visitor s do their job. As a result , the p a t t e r n\no f t en force s you to provid e publi c operation s that a c c e s s an element' s interna l\nstate, which may compromise i t s encapsulation. Implementation\nEach objec t structur e will have an associate d Visito r c l a s s. T h is abstrac t visito r\nc l a ss declare s a VisitConcreteElemen t operatio n for each c l a ss of ConcreteEle-\nment definin g the objec t structure . Each V i s it operatio n on the Visito r declare s\nits argumen t to be a particula r ConcreteElement , allowin g the Visito r to a c c e s s \nthe i n t e r f a c e of the ConcreteElemen t d i r e c t l y . Concret e Visito r c l a s s e s overrid e\neach V i s it operatio n to implemen t visitor-specifi c behavio r for the correspondin g\nConcreteElement class.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 977, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 943}}
{"id": "computer_science_design_patterns_gof_chunk_0978_433076be", "text": "Concret e Visito r c l a s s e s overrid e\neach V i s it operatio n to implemen t visitor-specifi c behavio r for the correspondin g\nConcreteElement class. The Visitor class would be declared like this in C + + :\nclass Visitor {\npublic:\nvirtual void VisitElementA(ElementA*) ;\nvirtual void VisitElementB(ElementB*);\n// and so on for other concrete elements\nprotected:\nVisitor() ;\n} ;\nEach c l a ss of ConcreteElemen t implement s an A c c e p t operatio n t h at c a l ls the\nmatchin g V i s i t . . . operatio n on the visito r for t h at ConcreteElement . Thus the \noperatio n t h at ends up gettin g c a l l ed depend s on both the c l a ss of the elemen t\nand the class of the visitor.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 978, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 689}}
{"id": "computer_science_design_patterns_gof_chunk_0979_cc5bbfe0", "text": ". . operatio n on the visito r for t h at ConcreteElement . Thus the \noperatio n t h at ends up gettin g c a l l ed depend s on both the c l a ss of the elemen t\nand the class of the visitor. 1 0\nThe concrete elements are declared a s\nclass Element {\npublic:\nvirtual ~Element() ; \nvirtual void Accept(Visitors ) = 0;\nprotected:\nElement() ;\n} ;\n10 We could use f u n c t i o n overloadin g to give these operation s the same simpl e name , like V i s i t , s i n ce\nthe operation s are alread y differentiate d by the paramete r they'r e passed . There are p r os and cons to such \noverloading . On the one hand , it reinforce s the f a ct t h at each operatio n involve s the same analysis , albei t on\na d i f f e r e n t argument . On the other h a n d , that migh t make what' s going on at the call s i te l e ss obviou s to\nsomeone r e a d i n g the code. It really boils down to whether you believe function overloading is good or not.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 979, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 941}}
{"id": "computer_science_design_patterns_gof_chunk_0980_54091517", "text": "It really boils down to whether you believe function overloading is good or not. ptg3 3 8 BEHAVIORAL PATTERNS CHAPTER 5\nclass ElementA : public Element {\npublic:\nElementA() ; \nvirtual void Accept(Visitor & v) { v.VisitElementA(this) ; }\n} ;\nclass Elements : public Element {\npublic:\nElements() ; \nvirtual void Accept(Visitors v) { v . V i s i t E l e m e n t B ( t h i s ) ; }\n} ;\nA CompositeElement class might implement A c c e p t l i k e this:\nclass CompositeElemen t : public Element {\npublic:\nvirtual void Accept(Visitor^) ;\nprivate:\nList<Element.*> * __children ;\n} ;\nvoid CompositeElement::Accep t (Visitor k v) {\nListIterator<Element* > i(_children);\nfor ( i. First (); 1 i . I s D o ne () ; i.NextO ) {\ni.Currentltem()->Accept(v) ;\n}\nv.VisitCompositeElement(this) ;\n}\nH e re are two other implementatio n i s s u e s t h at arise when you apply the V i s i t o r\npattern:\n1. Double dispatch.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 980, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_design_patterns_gof_chunk_0981_45f17a4e", "text": "Double dispatch. Effectively , the Visito r patter n l e ts you add operation s to\nc l a s s e s withou t changin g them . Visito r a c h i e v e s this by using a techniqu e\nc a l l ed double-dispatch . It's a well-know n technique . In fact, some program-\nming language s suppor t it directl y ( C L O S , for example) . Language s l i ke C++\nand Smalltal k suppor t single-dispatch. In s i n g l e - d i s p a t c h l a n g u a g e s , two criteri a determin e whic h operatio n w i ll\nf u l f i l l a request : the name of the reques t and the type of r e c e i v e r . For ex-\na m p l e , the operatio n t h at a GenerateCod e r e q u e s t w i ll c a ll depend s on the\ntype of node objec t you ask. In C++, c a l l i n g G e n e r a t e C o d e on an instanc e of\nV a r i a b l e R e f N o de w i ll c a ll V a r i a b l e R e f N o d e : : G e n e r a t e C o d e ( w h i c h\ngenerate s c o de for a variabl e reference) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 981, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_design_patterns_gof_chunk_0982_0cd277cf", "text": "C a l l i n g G e n e r a t e C o d e on an\nA s s i g n m e n t N o d e w i ll c a ll A s s i g n m e n t N o d e : : G e n e r a t e C o d e (whic h\nw i ll generat e c o de for an assignment) . The operatio n that g e ts e x e c u t e d\nd e p e n d s both on t he k i nd of r e q u e s t a nd t he type of t he r e c e i v e r . \" D o u b l e - d i s p a t c h \" simpl y mean s the operatio n that g e ts execute d depend s\non the kind o f request a n d t h e types o f two receivers. Accept i s a d o u b l e -\ndispatch operation. Its meaning depends o n t w o types: the Visitor's and the\n\nptgVISITOR 3 3 9\nElement's . D o u b l e - d i s p a t c h i n g l e ts visitor s r e q u e s t differen t operation s on\ne a ch c l a ss of e l e m e n t . 1 1\nT h is is t he k ey to t he V i s i t o r pattern : T he operatio n that g e ts e x e c u t e d d e -\npend s on both the type of V i s i t o r and the type of Elemen t it v i s i t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 982, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_design_patterns_gof_chunk_0983_1aa23e52", "text": "1 1\nT h is is t he k ey to t he V i s i t o r pattern : T he operatio n that g e ts e x e c u t e d d e -\npend s on both the type of V i s i t o r and the type of Elemen t it v i s i t s . Instea d of\nbindin g operation s staticall y into the Elemen t interface , you can c o n s o l i d a t e\nthe operation s in a V i s i t o r and use A c c e p t to do the bindin g at run-time . Ex-\ntendin g the Elemen t interfac e amount s to definin g one new V i s i t o r s u b c l a s s\nrathe r than many new Elemen t s u b c l a s s e s . 2. Who is responsible for traversing the object structure? A visito r must v i s it e a ch\ne l e m e n t of t he o b j e c t structure . T he questio n i s, h ow d o es it g et there ? We c an\np ut r e s p o n s i b i l i t y f or t r a v e r s a l in a ny of three p l a c e s : in t he o b j e c t s t r u c t u r e ,\nin the v i s i t o r , or in a separat e iterato r o b j e c t ( s ee Iterato r ( 2 5 7 ) ) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 983, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_design_patterns_gof_chunk_0984_2bf127d7", "text": "Often the o b j e c t structur e is r e s p o n s i b l e for iteration . A c o l l e c t i o n w i ll s i m p l y\niterat e o v er i ts e l e m e n t s , c a l l i n g t he A c c e p t operatio n on e a c h. A c o m p o s i t e\nw i ll c o m m o n l y travers e i t s e lf by havin g e a ch A c c e p t operatio n travers e t he\ne l e m e n t ' s c h i l d r e n a nd c a ll A c c e p t on e a ch of them r e c u r s i v e l y . Anothe r solutio n is to use an iterato r to v i s it the e l e m e n t s . In C++, you c o u ld\nuse e i t h e r an interna l or externa l iterator , dependin g on what is a v a i l a b l e\nand what is m o st efficient . In S m a l l t a l k , you usuall y use an interna l iterato r\nusing d o: and a b l o c k . S i n ce interna l iterator s are implemente d by the o b j e c t\nstructure , using an interna l iterato r is a lot l i ke makin g the o b j e c t structur e\nr e s p o n s i b l e for iteration .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 984, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_design_patterns_gof_chunk_0985_287d9abd", "text": "S i n ce interna l iterator s are implemente d by the o b j e c t\nstructure , using an interna l iterato r is a lot l i ke makin g the o b j e c t structur e\nr e s p o n s i b l e for iteration . The main differenc e is that an interna l iterato r w i ll\nnot c a u se double-dispatching—i t w i ll c a ll an operatio n on the visitor with\nan element as an argumen t as o p p o s e d to c a l l i n g an o p e r a t i o n on the element\nwith the visitor as an argument . But it's e a sy to use the V i s i t o r patter n with \nan interna l iterato r if the operatio n on the visito r s i m p l y c a l ls the operatio n\non the e l e m e n t withou t r e c u r s i n g . You c o u ld e v en put the traversa l algorith m in the v i s i t o r , althoug h y o u ' l l end\nup duplicatin g the traversa l c o de in e a ch C o n c r e t e V i s i t o r for e a ch aggregat e\nC o n c r e t e E l e m e n t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 985, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_design_patterns_gof_chunk_0986_eef7236a", "text": "The main reaso n to put the traversa l strateg y in the v i s i t o r\nis to implemen t a particularl y c o m p l e x traversal , one that d e p e n d s on the\nr e s u l t s of t he operation s on t he o b j e c t structure . W e ' ll g i ve an exampl e of\nsuch a case in the Sample Code. S a m p l e Code\nB e c a u s e v i s i t o r s are usuall y a s s o c i a t e d with c o m p o s i t e s , w e ' ll use the E q u i p m e n t\nc l a s s e s define d in t he S a m p l e C o de of C o m p o s i t e ( 1 6 3) to illustrat e t he V i s i t o r\npattern . We w i ll use V i s i t o r to defin e operation s for computin g the inventor y of\nmaterial s and the total c o st for a p i e ce of equipment . The E q u i p m e n t c l a s s e s are\n11 If we can have double-dispatch, then why not triple or quadruple, or any o t h er number ? Actually , d o u b l e -\ndispatc h is just a s p e c i a l c a se of multipl e dispatch , in whic h the operatio n is c h o s e n b a s ed on any numbe r \nof t y p e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 986, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_design_patterns_gof_chunk_0987_e08ee04d", "text": "Actually , d o u b l e -\ndispatc h is just a s p e c i a l c a se of multipl e dispatch , in whic h the operatio n is c h o s e n b a s ed on any numbe r \nof t y p e s . ( C L O S actuall y support s multipl e dispatch. ) Language s that suppor t d o u b l e - or multipl e dispatc h\nl e s s e n the need for the Visitor pattern. ptg340 BEHAVIORAL PATTERNS CHAPTER 5\nso s i m p l e t h at u s i ng Visito r i s n 't reall y n e c e s s a r y , b ut they m a ke it e a sy to s ee\nwhat' s involve d in i m p l e m e n t i n g the pattern. H e re a g a in is the E q u i p m e n t class from C o m p o s i t e (163) . W e ' v e a u g m e n t e d it\nwith an A c c e p t o p e r a t i o n to let it work with a v i s i t o r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 987, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 721}}
{"id": "computer_science_design_patterns_gof_chunk_0988_a574c687", "text": "H e re a g a in is the E q u i p m e n t class from C o m p o s i t e (163) . W e ' v e a u g m e n t e d it\nwith an A c c e p t o p e r a t i o n to let it work with a v i s i t o r . class Equipmen t {\npublic:\nvirtual ~Equipment();\nconst char* Name() { return _name; }\nvirtual Watt Power(); \nvirtual Currency NetPrice() ;\nvirtual Currency DiscountPrice();\nvirtual void Accept(EquipmentVisitork) ;\nprotected:\nEquipment(cons t char*);\nprivate:\nconst char* _name;\n} ;\nT he E q u i p m e n t o p e r a t i o n s r e t u r n t he a t t r i b u t e s of a p i e ce of e q u i p m e n t , s u ch as\ni ts p o w e r c o n s u m p t i o n a nd cost. S u b c l a s s e s r e d e f i n e t h e se o p e r a t i o n s a p p r o p r i -\nately for specifi c types of e q u i p m e n t (e.g., a c h a s s i s , d r i v e s , and p l a n a r b o a r d s ) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 988, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 842}}
{"id": "computer_science_design_patterns_gof_chunk_0989_898d3ae3", "text": "S u b c l a s s e s r e d e f i n e t h e se o p e r a t i o n s a p p r o p r i -\nately for specifi c types of e q u i p m e n t (e.g., a c h a s s i s , d r i v e s , and p l a n a r b o a r d s ) . T he a b s t r a c t class f or a ll visitor s of e q u i p m e n t h as a virtua l functio n f or e a ch\ns u b c l a s s of e q u i p m e n t , as s h o w n next. A ll of t he virtua l f u n c t i o n s do n o t h i n g by\ndefault.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 989, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 433}}
{"id": "computer_science_design_patterns_gof_chunk_0990_2939b668", "text": "A ll of t he virtua l f u n c t i o n s do n o t h i n g by\ndefault. class EquipmentVisito r {\npublic:\nvirtual ~EquipmentVisitor();\nvirtual void VisitFloppyDisk(FloppyDisk*) ;\nvirtual void VisitCard(Card*) ; \nvirtual void VisitChassis(Chassis*) ;\nvirtual void VisitBus(Bus*);\n// and so on for other concrete subclasse s of Equipmen t\nprotected:\ntquipmentvisitor() ;\n} ;\nE q u i p m e n t s u b c l a s s e s defin e A c c e p t in basicall y the s a me way: It calls the\nE q u i p m e n t V i s i t o r o p e r a t i o n that c o r r e s p o n d s to the class that r e c e i v e d the\nA c c e p t r e q u e s t , like t h i s :\nvoid FloppyDisk::Accep t (EquipmentVisitor k visitor) {\nvisitor.VisitFloppyDisk(this);\n}\n\nptgVISITOR 3 4 1\nEquipmen t that c o n t a i n s other equipmen t (in particular , s u b c l a s s e s of Com-\np o s i t e E q u i p m e n t in the Composit e pattern ) implement s A c c e p t by iteratin g\nover its c h i l d r e n and c a l l i n g A c c e p t on e a ch of them .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 990, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1000}}
{"id": "computer_science_design_patterns_gof_chunk_0991_aa2be0f3", "text": "T h en it c a l ls the V i s i t\noperatio n as usual . For e x a m p l e , C h a s s i s : : A c c e p t c o u ld travers e all the parts\ni n t h e chassis as follows:\nvoid Chassis::Accep t ( E q u i p m e n t V i s i t o r & visitor) {\nfor (\nListIterator<Equipment* > i(_parts) ;\n! i . I s D o n e ( ) ;\ni.Next()\n) {\ni.Currentltem()->Accept(visitor) ;\n}\nv i s i t o r . V i s i t C h a s s i s ( t h i s ) ;\n}\nS u b c l a s s e s of E q u i p m e n t V i s i t o r defin e particula r algorithm s o v er the equip-\nm e nt s t r u c t u r e . T he Pr i c ingV i s i t or c o m p u t e s t he c o st of t he e q u i p m e n t s t r u c -\nture. It compute s t he n et price of a ll simpl e equipmen t ( e . g ., f l o p p i e s ) a nd t he\nd i s c o u n t p r i c e of all composite equipment (e.g., chassis and b u s e s ) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 991, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 823}}
{"id": "computer_science_design_patterns_gof_chunk_0992_cd15db0e", "text": "It compute s t he n et price of a ll simpl e equipmen t ( e . g ., f l o p p i e s ) a nd t he\nd i s c o u n t p r i c e of all composite equipment (e.g., chassis and b u s e s ) . c l a ss P r i c i n g V i s i t o r : p u b l ic E q u i p m e n t V i s i t o r {\npublic:\nPricingVisitor();\nC u r r e n c y & GetTotalPrice();\nvirtual void VisitFloppyDisk(FloppyDisk*) ;\nv i r t u al v o id V i s i t C a r d ( C a r d * ) ; \nvirtual void VisitChassis(Chassis*) ;\nvirtual void VisitBus(Bus*) ; \n// . . . private:\nCurrency _total;\n} ;\nvoid PricingVisitor::VisitFloppyDis k ( F l o p p y D i s k * e) {\n_total += e->NetPrice() ;\n}\nvoid PricingVisitor::VisitChassi s ( C h a s s i s * e) {\n_total +- e->DiscountPrice() ;\n}\nP r i c i n g V i s i t o r w i ll comput e the total c o st of all n o d e s in the equipmen t\nstructure .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 992, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 826}}
{"id": "computer_science_design_patterns_gof_chunk_0993_eec724d2", "text": "Note that P r i c i n g V i s i t o r c h o o s e s the appropriat e p r i c i n g polic y\nfor a c l a ss of equipmen t by d i s p a t c h i n g to the c o r r e s p o n d i n g membe r function . What' s m o r e , we can c h a n g e the p r i c i n g p o l i c y of an equipmen t structur e just by\nc h a n g i n g the PricingVisitor class. ptg342 BEHAVIORAL PATTERNS CHAPTERS\nWe c an d e f i n e a v i s i t o r f or c o m p u t i n g i n v e n t o r y l i ke t h i s :\nclass I n v e n t o r y - V i s i t o r : public EquipmentVisito r {\npublic:\nInventoryVisitor();\nI n v e n t o r y ^ Getlnventory();\nvirtual void VisitFloppyDisk(FloppyDisk*) ;\nvirtual void VisitCard(Card*) ; \nvirtual void VisitChassis(Chassis*) ;\nvirtual void VisitBus(Bus*) ; \n// . . . private:\nI n v e n t o ry _inventory ;\n} ;\nT he I n v e n t o r y V i s i t o r a c c u m u l a t e s t he total s f or e a ch t y pe of e q u i p m e n t in\nt he o b j e c t s t r u c t u r e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 993, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_design_patterns_gof_chunk_0994_2f34d0e9", "text": ". . private:\nI n v e n t o ry _inventory ;\n} ;\nT he I n v e n t o r y V i s i t o r a c c u m u l a t e s t he total s f or e a ch t y pe of e q u i p m e n t in\nt he o b j e c t s t r u c t u r e . I n v e n t o r y V i s i t o r u s es an Inventor y c l a ss t h at d e f i n e s\nan i n t e r f a c e f or a d d i n g e q u i p m e n t ( w h i c h we w o n ' t b o t h e r d e f i n i n g h e r e ) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 994, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 402}}
{"id": "computer_science_design_patterns_gof_chunk_0995_3142e975", "text": "void InventoryVisitor::VisitFloppyDis k ( F l o p p y D i s k * e) {\n_inventory.Accumulate(e) ;\n}\nvoid InventoryVisitor::VisitChassi s ( C h a s s i s* e) {\n_inventory.Accumulate(e) ;\n}\nH e r e ' s h ow we c an u se an I n v e n t o r y V i s i t o r on an e q u i p m e n t s t r u c t u r e :\nE q u i p m e n t * c o m p o n e n t ;\nI n v e n t o r y V i s i t o r visitor;\ncomponent->Accept(visitor) ;\ncout « \" I n v e n t o r y \"\n« component->Name( ) « visitor.Getlnventory();\nN ow w e ' ll s h ow h ow to i m p l e m e n t t he S m a l l t a l k e x a m p l e f r om t he I n t e r p r e t e r\np a t t e r n ( s ee p a ge 2 4 8) with t he V i s i t o r p a t t e r n . L i ke t he p r e v i o u s e x a m p l e , t h is\no ne is so s m a l l t h at V i s i t o r p r o b a b l y w o n ' t b uy us m u c h , b ut it p r o v i d e s a g o od\ni l l u s t r a t i o n of h ow to u se t he p a t t e r n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 995, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 904}}
{"id": "computer_science_design_patterns_gof_chunk_0996_9b0f322f", "text": "F u r t h e r , it i l l u s t r a t e s a s i t u a t i o n in w h i c h\ni t e r a t i o n is t he v i s i t o r ' s r e s p o n s i b i l i t y . T he o b j e c t s t r u c t u r e ( r e g u l a r e x p r e s s i o n s ) is m a de of f o ur c l a s s e s , a nd a ll of\nt h em h a ve an a c c e p t : m e t h o d t h at t a k es t he v i s i t o r as an a r g u m e n t . In c l a ss\nS e q u e n c e E x p r e s s i o n , the a c c e p t : method is\n\nptgVISITOR 343\naccept: aVisitor \naVisitor visitSequence: self\nIn c l a ss R e p e a t E x p r e s s i o n , t he a c c e p t : metho d sends t he v i s i t R e p e a t :\nm e s s a g e . In c l a ss A l t e r n a t i o n E x p r e s s i o n , it sends the v i s i t A l t e r n a -\nt i o n : m e s s a g e . In c l a ss L i t e r a l - E x p r e s s i o n , it s e n ds the v i s i t L i t e r a l :\nm e s s a g e . T he f o ur c l a s s e s a l so must have a c c e s s i n g function s that t he v i s i t o r c an u s e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 996, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_design_patterns_gof_chunk_0997_360e4b55", "text": "T he f o ur c l a s s e s a l so must have a c c e s s i n g function s that t he v i s i t o r c an u s e. F or S e q u e n c e E x p r e s s i o n these a re e x p r e s s i o n l a nd e x p r e s s i o n 2 ; f or\nA l t e r n a t i o n E x p r e s s i o n these a re a l t e r n a t i v e l a nd a l t e r n a t i v e 2 ; f or\nR e p e a t E x p r e s s i on it is r e p e t it ion; and f or L it e r a l E x p r e s s i on these a re\nc o m p o n e n t s . T he C o n c r e t e V i s i t o r c l a ss is R E M a t c h i n g V i s i t o r . It is r e s p o n s i b l e f or t he tra-\nversa l becaus e its traversa l algorith m is irregular . The b i g g e s t irregularit y is\nt h at a R e p e a t E x p r e s s i o n w i ll repeatedl y travers e its component . The c l a ss\nR E M a t c h i n g V i s i t o r has an instanc e variabl e i n p u t S t a t e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 997, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 858}}
{"id": "computer_science_design_patterns_gof_chunk_0998_6f1fcb6a", "text": "The c l a ss\nR E M a t c h i n g V i s i t o r has an instanc e variabl e i n p u t S t a t e . Its method s are\nessentiall y the same as the m a t c h : method s of the e x p r e s s i o n c l a s s e s in the In-\nterprete r patter n e x c e p t they r e p l a c e the argumen t name d i n p u t S t a t e with the\ne x p r e s s i o n node being matched . However , they s t i ll retur n the set of stream s that\nthe expression would match to identify the current state. visitSequence : sequenceEx p \ninputStat e := s e q u e n c e E x p e x p r e s s i o n l accept: self. sequenceEx p expression 2 accept: self. visitRepeat : repeatEx p \n! finalStat e I \nfinalStat e := inputStat e copy. [ i n p u t S t a t e i s E m p t y ]\nwhileFalse:\n[inputStat e := repeatEx p repetitio n accept: self. finalStat e addAll: inputState]. \" finalState\nvisitAlternation : alternateExp\nI finalStat e originalStat e I \noriginalStat e := inputState . finalStat e := alternateEx p alternative l accept: self.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 998, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_design_patterns_gof_chunk_0999_c72f1b8a", "text": "finalStat e addAll: inputState]. \" finalState\nvisitAlternation : alternateExp\nI finalStat e originalStat e I \noriginalStat e := inputState . finalStat e := alternateEx p alternative l accept: self. inputStat e := originalState . finalStat e addAll: (alternateEx p alternative 2 accept: self). ~ f i n a l S t a t e\n\nptg344 BEHAVIORAL P A T T E R N S CHAPTER 5\nvisitLiteral : literalEx p\nI finalStat e tStream I \nfinalStat e := Set n e w. inputState\ndo: \n[:stream I tStream := stream copy. (tStream nextAvailable :\nliteralEx p component s size\n) = literalEx p component s \nifTrue: [finalState add: tStream]\n] . \" finalState\nKnown Uses\nThe Smalltalk-8 0 compile r has a Visito r c l a ss c a l l ed ProgramNodeEnumerator . It's used primaril y for algorithm s that analyz e s o u r c e c o d e. It isn't u s ed for c o de\ngeneratio n or pretty-printing , althoug h it c o u ld be. IRIS Invento r [ S t r 9 3 1 is a toolki t f or d e v e l o p i n g 3 -D graphic s applications .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 999, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_design_patterns_gof_chunk_1000_c517d75e", "text": "It isn't u s ed for c o de\ngeneratio n or pretty-printing , althoug h it c o u ld be. IRIS Invento r [ S t r 9 3 1 is a toolki t f or d e v e l o p i n g 3 -D graphic s applications . Invento r\nrepresent s a three-dimensiona l s c e ne as a hierarch y of n o d e s , e a ch representin g\neithe r a geometri c objec t or an attribut e of o n e. Operation s l i ke renderin g a s c e ne\nor mappin g an input event r e q u i r e traversin g this hierarch y in differen t ways . Invento r d o es this using visitor s c a l l ed \" a c t i o n s . \" T h e re are differen t visitor s for\nrendering , event handling , searching , filing , and determinin g boundin g b o x e s . To m a ke addin g new node s e a s i e r , Invento r implement s a double-dispatc h s c h e m e\nfor C + +. The schem e r e l i es on run-tim e type informatio n and a two-dimensiona l\ntable in whic h r o ws r e p r e s e n t visitor s and column s represen t node c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1000, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_design_patterns_gof_chunk_1001_9a5dae5d", "text": "The schem e r e l i es on run-tim e type informatio n and a two-dimensiona l\ntable in whic h r o ws r e p r e s e n t visitor s and column s represen t node c l a s s e s . The\nc e l ls store a pointe r to the functio n boun d to the visito r and node c l a s s . Mark Linto n c o i n e d the term \" V i s i t o r \" in the X Consortium' s F r e s c o Applicatio n\nT o o l k i t specification [LP93]. Related Patterns\nComposit e ( 1 6 3 ) : Visitor s can be used to apply an operatio n o v er an o b j e c t structur e\ndefined by the Composite pattern. Interpreter (243): Visitor m a y b e applied to do the i n t e r p r e t a t i o n . ptgDISCUSSION O F BEHAVIORAL P A T T E R N S 345\nDiscussion o f Behavioral Patterns\nEncapsulatin g Variation\nEncapsulatin g variatio n is a them e of many behaviora l patterns . When an aspec t of\na progra m change s frequently , t h e se pattern s defin e an objec t that encapsulate s that\naspect .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1001, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 937}}
{"id": "computer_science_design_patterns_gof_chunk_1002_4e2a6e9f", "text": "When an aspec t of\na progra m change s frequently , t h e se pattern s defin e an objec t that encapsulate s that\naspect . T h en other parts of the progra m can collaborat e with the objec t wheneve r they\ndepen d on that aspect . The pattern s usuall y defin e an abstrac t c l a ss that d e s c r i b e s the\nencapsulatin g object , and the patter n derive s its name f r om that object. 12 For example,\n• a Strateg y objec t encapsulate s an algorith m (Strateg y ( 3 1 5 ) ) ,\n• a State objec t encapsulate s a state-dependen t behavio r (State ( 3 0 5 ) ) ,\n• a Mediato r o b j e c t encapsulate s the protoco l betwee n object s (Mediato r ( 2 7 3 ) ) , and\n• an Iterato r objec t encapsulate s the way you a c c e s s and travers e the component s\nof an aggregat e objec t (Iterato r ( 2 5 7 ) ) . T h e se pattern s d e s c r i b e a s p e c t s of a progra m that are l i k e ly to change .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1002, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 900}}
{"id": "computer_science_design_patterns_gof_chunk_1003_2b5bed04", "text": "T h e se pattern s d e s c r i b e a s p e c t s of a progra m that are l i k e ly to change . M o st pattern s\nhave two k i n ds of o b j e c t s : the new object(s ) that encapsulat e the aspect , and the existin g\nobject(s ) that use the new o n e s. Usuall y the functionalit y of new object s woul d be an\nintegra l p a rt of the e x i s t i n g object s were it not for the pattern . For example , c o de for\na Strateg y woul d probabl y be wired into the strategy' s Context , and c o de for a State\nwoul d be implemente d d i r e c t l y in the state' s Context. But not all objec t behaviora l pattern s partitio n functionalit y l i ke this. For example ,\nC h a in of R e s p o n s i b i l i t y ( 2 2 3) deals with an arbitrar y numbe r of object s ( i . e ., a c h a i n ) ,\nall of whic h may alread y exist in the system.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1003, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 834}}
{"id": "computer_science_design_patterns_gof_chunk_1004_7176d3d0", "text": "For example ,\nC h a in of R e s p o n s i b i l i t y ( 2 2 3) deals with an arbitrar y numbe r of object s ( i . e ., a c h a i n ) ,\nall of whic h may alread y exist in the system. C h a in of R e s p o n s i b i l i t y illustrate s anothe r differenc e in behaviora l patterns : Not all\ndefin e static communicatio n relationship s betwee n c l a s s e s . Chain of Responsibilit y\nprescribe s communicatio n betwee n an open-ende d numbe r of objects . Othe r pattern s\ni n v o l v e object s that are passe d aroun d as arguments. Object s as A r g u m e n t s\nS e v e r a l pattern s introduc e an objec t that's always used as an argument . One of t h e se\nis Visito r ( 3 3 1 ) . A Visito r objec t is the argumen t to a polymorphi c Accep t operatio n on\nthe object s it v i s i t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1004, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 794}}
{"id": "computer_science_design_patterns_gof_chunk_1005_86a62f72", "text": "One of t h e se\nis Visito r ( 3 3 1 ) . A Visito r objec t is the argumen t to a polymorphi c Accep t operatio n on\nthe object s it v i s i t s . The visito r is never c o n s i d e r e d a p a rt of those objects , e v en thoug h\nthe conventiona l alternativ e to the patter n is to distribut e Visito r c o de a c r o s s the objec t\nstructur e c l a s s e s . 12 T h is them e runs throug h other kinds of patterns , too. Abstrac t Factor y ( 8 7 ), Builde r ( 9 7 ), and Proto-\ntype ( 1 1 7) all encapsulat e knowledg e abou t how object s are created . Decorato r ( 1 7 5) encapsulate s responsi-\nbility that can be adde d to an object . Bridg e ( 1 5 1) separate s an abstractio n from its implementation , lettin g\nthem vary independently. ptg346 BEHAVIORAL PATTERNS CHAPTER 5\nOthe r pattern s defin e object s t h at act as magi c token s to be p a s s e d aroun d and i n v o k e d\nat a later time. Both Comman d ( 2 3 3) and Mement o ( 2 8 3) f a ll into this c a t e g o r y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1005, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_design_patterns_gof_chunk_1006_4f664db6", "text": "Both Comman d ( 2 3 3) and Mement o ( 2 8 3) f a ll into this c a t e g o r y . In\nCommand , the token represent s a request ; in Memento , it represent s the interna l state\nof an objec t at a particula r time. In both c a s e s , the token can have a comple x interna l\nrepresentation , but the c l i e n t is neve r awar e of it. But even here there are differences . P o l y m o r p h i s m is importan t in t he C o m m a n d pattern , b e c a u s e e x e c u t i n g t he C o m m a n d\nobjec t is a polymorphi c operation . In contrast , the Mement o interfac e is so narro w that\na mement o can only be passe d as a value . So it's l i k e ly to presen t no polymorphi c\noperation s at all to its c l i e n t s . S h o u l d C o m m u n i c a t i o n be E n c a p s u l a t e d or D i s t r i b u t e d ? Mediato r ( 2 7 3) and Observe r ( 2 9 3) are competin g patterns .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1006, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 879}}
{"id": "computer_science_design_patterns_gof_chunk_1007_4061d458", "text": "S h o u l d C o m m u n i c a t i o n be E n c a p s u l a t e d or D i s t r i b u t e d ? Mediato r ( 2 7 3) and Observe r ( 2 9 3) are competin g patterns . The differenc e betwee n\nthem is t h at O b s e r v e r distribute s communicatio n by introducin g O b s e r v e r and S u b j e c t\no b j e c t s , wherea s a Mediato r objec t encapsulate s the communicatio n betwee n other\nobjects. In the O b s e r v e r pattern , there is no s i n g le objec t that encapsulate s a constraint. Instead ,\nthe O b s e r v e r and the S u b j e c t must cooperat e to maintai n the constraint . Communica-\ntion pattern s are determine d by the way o b s e r v e r s and subject s are interconnected : a\ns i n g le subjec t usuall y has many o b s e r v e r s , and sometime s the o b s e r v e r of one subjec t is\na subjec t of anothe r o b s e r v e r . The Mediato r patter n centralize s rathe r than distributes . It p l a c e s the responsibilit y for maintainin g a constrain t squarel y in the mediator.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1007, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1007}}
{"id": "computer_science_design_patterns_gof_chunk_1008_ba373377", "text": "The Mediato r patter n centralize s rathe r than distributes . It p l a c e s the responsibilit y for maintainin g a constrain t squarel y in the mediator. W e ' v e f o u nd it e a s i e r to make reusabl e O b s e r v e r s and Subject s than to make reusabl e\nMediators . The O b s e r v e r patter n promote s partitionin g and l o o se c o u p l i n g betwee n\nO b s e r v e r and Subject , and that leads to finer-graine d c l a s s e s that are more apt to be \nreused. On the other hand , it's e a s i e r to understan d the flow of communicatio n in Mediato r\nthan in O b s e r v e r . O b s e r v e r s a nd s u b j e c t s a re u s u a l l y c o n n e c t e d s h o r t l y after they'r e\ncreated , and it's hard to see how they are connecte d later in the program . If you know\nthe O b s e r v e r pattern , then you understan d t h at the way observer s and subject s are\nconnecte d is important , and you a l so know w h at connection s to l o ok for.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1008, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_design_patterns_gof_chunk_1009_65f45eb6", "text": "If you know\nthe O b s e r v e r pattern , then you understan d t h at the way observer s and subject s are\nconnecte d is important , and you a l so know w h at connection s to l o ok for. However , the\nindirectio n that O b s e r v e r introduce s w i ll s t i ll make a syste m harde r to understand. Observer s in Smalltal k can be parameterize d with m e s s a g e s to a c c e s s the S u b j e c t state,\nand so they are e v en more reusabl e than they are in C++. T h is make s O b s e r v e r more\nattractiv e than Mediato r in Smalltalk . Thus a Smalltal k programme r w i ll often use\nO b s e r v e r wher e a C++ programme r woul d use Mediator. Decouplin g S e n d e r s a nd Receivers\nWhe n collaboratin g object s r e f er to each other directly , they becom e dependen t on\ne a c h other, and t h a t can have an a d v e r s e i m p a c t on the layering a n d r e u s a b i l i t y o f a\n\nptgDISCUSSION OF BEHAVIORAL PATTERNS 347\nsystem .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1009, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_design_patterns_gof_chunk_1010_cfe5e731", "text": "Command , O b s e r v e r , Med iat o r , a nd C h a in of R e s p o n s i b i l i t y a d d r e s s h ow y ou\ncan d e c o u p l e s e n d e r s and r e c e i v e r s , but with differen t trade-offs. T he C o m m a n d patter n s u p p o r t s d e c o u p l i n g by u s i ng a C o m m a n d o b j e c t to d e f i n e t he\nbinding between a sender and receiver:\nThe Comman d o b j e c t p r o v i d e s a s i m p l e interfac e for i s s u i n g the r e q u e s t (that is, the\nExecut e operation) . Definin g t he s e n d e r - r e c e i v e r c o n n e c t i o n in a separat e o b j e c t l e ts\nthe s e n d e r work with differen t r e c e i v e r s . It k e e ps the s e n d e r d e c o u p l e d from the re-\nc e i v e r s , makin g s e n d e r s e a sy to r e u s e . M o r e o v e r , y ou c an r e u se t he Comman d o b j e c t\nto parameteriz e a r e c e i v e r with differen t s e n d e r s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1010, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 906}}
{"id": "computer_science_design_patterns_gof_chunk_1011_2290600f", "text": "M o r e o v e r , y ou c an r e u se t he Comman d o b j e c t\nto parameteriz e a r e c e i v e r with differen t s e n d e r s . The Comman d patter n n o m i n a l l y\nr e q u i r e s a s u b c l a s s f or e a ch s e n d e r - r e c e i v e r c o n n e c t i o n , althoug h t he patter n d e s c r i b e s\nimplementatio n t e c h n i q u e s that a v o id s u b c l a s s i n g . T he O b s e r v e r patter n d e c o u p l e s s e n d e r s (subjects ) from r e c e i v e r s ( o b s e r v e r s ) by defin-\ni ng an interfac e f or s i g n a l i n g c h a n g e s in s u b j e c t s . O b s e r v e r d e f i n e s a l o o s e r s e n d e r -\nr e c e i v e r bindin g than Command , s i n ce a s u b j e c t may have m u l t i p l e o b s e r v e r s , and\ntheir number can vary at run-time. The S u b j e c t and O b s e r v e r interface s in the O b s e r v e r patter n are d e s i g n e d for c o m m u -\nnicatin g c h a n g e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1011, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_design_patterns_gof_chunk_1012_b0639e95", "text": "The S u b j e c t and O b s e r v e r interface s in the O b s e r v e r patter n are d e s i g n e d for c o m m u -\nnicatin g c h a n g e s . Therefor e the O b s e r v e r patter n is b e st f or d e c o u p l i n g o b j e c t s w h en\nthere are data d e p e n d e n c i e s betwee n them. T he M e d i a t o r patter n d e c o u p l e s o b j e c t s by h a v i n g t h em refer to e a ch o t h er i n d i r e c t l y\nthrough a Mediator object. ptg3 4 8 B E H A V I O R A L P A T T E R N S CHAPTER 5\nA Mediato r o b j e c t route s request s betwee n C o l l e a g u e o b j e c t s and centralize s their c o m -\nmunication . C o n s e q u e n t l y , c o l l e a g u e s can o n ly talk to e a ch other throug h the Mediato r\ni n t e r f a c e . B e c a u s e t h is interfac e is f i x e d , t he M e d i a t o r m i g h t h a ve to i m p l e m e n t i ts\nown dispatchin g s c h e m e f or adde d flexibility .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1012, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_design_patterns_gof_chunk_1013_fd09101c", "text": "B e c a u s e t h is interfac e is f i x e d , t he M e d i a t o r m i g h t h a ve to i m p l e m e n t i ts\nown dispatchin g s c h e m e f or adde d flexibility . Request s can be e n c o d e d and argument s\np a c k e d in s u ch a way that c o l l e a g u e s can r e q u e s t an o p e n - e n d e d set of operations. The Mediato r patter n can r e d u c e s u b c l a s s i n g in a s y s t e m , b e c a u s e it centralize s c o m -\nmunicatio n behavio r in o ne c l a ss instea d of distributin g it amon g s u b c l a s s e s . H o w e v e r ,\nad hoc dispatchin g s c h e m e s often d e c r e a s e type safety.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1013, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 624}}
{"id": "computer_science_design_patterns_gof_chunk_1014_05bc0c46", "text": "H o w e v e r ,\nad hoc dispatchin g s c h e m e s often d e c r e a s e type safety. F i n a l l y , the Chai n of R e s p o n s i b i l i t y patter n d e c o u p l e s the s e n d e r f r om the r e c e i v e r by\np a s s i n g the request along a chain of potential receivers:\nS i n ce t he interfac e betwee n sender s a nd r e c e i v e r s is f i x e d , C h a in of R e s p o n s i b i l i t y\nmay a l so r e q u i r e a c u s t o m dispatchin g s c h e m e . H e n c e it has the same type-safet y\ndrawback s as Mediator . C h a in of Responsibilit y is a g o od way to d e c o u p l e the s e n d e r\nand the r e c e i v e r if the chain is alread y part of the system' s structure , and one of s e v e r a l\no b j e c t s may be in a p o s i t i o n to handl e the request . M o r e o v e r , the patter n offer s a d d e d\nflexibility in that the chain can be changed or extended easily.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1014, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 898}}
{"id": "computer_science_design_patterns_gof_chunk_1015_73acf3ba", "text": "M o r e o v e r , the patter n offer s a d d e d\nflexibility in that the chain can be changed or extended easily. ptgDISCUSSION O F BEHAVIORAL P A T T E R N S 349\nS u m m a r y\nWith few e x c e p t i o n s , behaviora l d e s i g n pattern s complemen t and reinforc e e a ch o t h e r . A c l a ss in a c h a in of r e s p o n s i b i l i t y , for example , will probabl y includ e at l e a st one ap-\nplicatio n of Templat e Metho d ( 3 2 5 ) . T he templat e metho d c an u se primitiv e operation s\nto determin e whethe r the objec t s h o u l d handl e the reques t and to c h o o s e the o b j e c t to\nforwar d to. The c h a in can use the Comman d patter n to represen t request s as objects . Interprete r ( 2 4 3) can use the State patter n to defin e parsin g contexts . An iterato r can\ntravers e an aggregate , and a v i s i t o r can apply an operatio n to e a ch e l e m e n t in the\naggregate. Behaviora l pattern s work well with other patterns , too.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1015, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_design_patterns_gof_chunk_1016_6b0d6029", "text": "An iterato r can\ntravers e an aggregate , and a v i s i t o r can apply an operatio n to e a ch e l e m e n t in the\naggregate. Behaviora l pattern s work well with other patterns , too. For e x a m p l e , a syste m that u s es\nthe Composit e ( 1 6 3) patter n m i g h t use a visito r to perfor m operation s on component s of\nthe c o m p o s i t i o n . It c o u ld use C h a in of Responsibilit y to let component s a c c e s s g l o b a l\npropertie s throug h their parent . It c o u ld a l so use Decorato r ( 1 7 5) to overrid e t h e se\np r o p e r t i e s on parts of t he c o m p o s i t i o n . It c o u ld u se t he O b s e r v e r patter n to t ie o ne\nobjec t structur e to anothe r and the State patter n to let a componen t c h a n g e its behavio r\nas i ts state c h a n g e s . T he compositio n i t s e lf migh t be cr e at e d using t he approac h in\nB u i l d e r ( 9 7 ), a nd it m i g h t be treate d as a Prototyp e ( 1 1 7) by s o me other part of t he\ns y s t e m .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1016, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_design_patterns_gof_chunk_1017_88af58ec", "text": "T he compositio n i t s e lf migh t be cr e at e d using t he approac h in\nB u i l d e r ( 9 7 ), a nd it m i g h t be treate d as a Prototyp e ( 1 1 7) by s o me other part of t he\ns y s t e m . W e l l - d e s i g n e d object-oriente d system s are j u st l i ke this—the y have multipl e pattern s\ne m b e d d e d in them—bu t n ot b e c a u s e t h e ir d e s i g n e r s n e c e s s a r i l y t h o u g h t in t h e se t e r m s . C o m p o s i t i o n at the pattern l e v el rathe r than the c l a ss or objec t l e v e ls l e ts us a c h i e v e the\ns a m e s y n e r g y w i t h g r e a t e r e a s e . ptg\nThis page intentionally left blank \n\nptgC h a p t e r 6\nC o n c l u s i o n\nIt's p o s s i b l e to argue that this book hasn' t accomplishe d much . A f t er a l l, it doesn' t\npresen t any algorithm s or programmin g technique s that haven' t been used before .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1017, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 880}}
{"id": "computer_science_design_patterns_gof_chunk_1018_483dd86d", "text": "A f t er a l l, it doesn' t\npresen t any algorithm s or programmin g technique s that haven' t been used before . It d o e s n ' t g i ve a r i g o r o u s metho d f or d e s i g n i n g s y s t e m s , n or d o es it d e v e l o p a n ew\ntheor y of design—i t just document s existin g d e s i g n s . You c o u ld c o n c l u d e that it make s\na reasonabl e tutorial , perhaps , but it certainl y can't o f f er much to an e x p e r i e n c e d object-\noriente d d e s i g n e r . We hope you think differently . Catalogin g d e s i g n pattern s is important . It g i v es us\nstandar d n a m e s and definition s for the t e c h n i q u e s we u s e. If we don't study d e s i g n\npattern s in software , we won' t be a b le to improv e them , and it'll be harde r to come up\nwith new o n e s . T h is book is o n ly a start.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1018, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 829}}
{"id": "computer_science_design_patterns_gof_chunk_1019_b7aae90c", "text": "If we don't study d e s i g n\npattern s in software , we won' t be a b le to improv e them , and it'll be harde r to come up\nwith new o n e s . T h is book is o n ly a start. It contain s s o me of the most commo n d e s i g n pattern s t h at\nexper t object-oriente d designer s u s e, and yet p e o p l e hear and learn abou t them s o l e ly\nby w o rd of mout h or by s t u d y i n g e x i s t i n g s y s t e m s . E a r ly draft s of t he b o ok p r o m p t e d\nother p e o p l e to write down the d e s i g n pattern s they u s e, and it shoul d promp t e v en\nmore in its curren t f o r m . We hope this will m a rk the start of a movemen t to documen t\nt he e x p e r t i s e of softwar e p r a c t i t i o n e r s . T h is chapte r d i s c u s s e s the impac t we think d e s i g n pattern s will ha ve, how they are\nrelate d to other work in d e s i g n , and how you can get i n v o l v e d in findin g and catalogin g\npatterns. 6 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1019, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_design_patterns_gof_chunk_1020_ab96a61c", "text": "6 . 1 What to Expect from Design Patterns\nHere are severa l ways in whic h the d e s i g n pattern s in this book can a f f e c t the way you\ndesign object-oriented software, based on our day-to-day experience with them. 3 5 1\n\nptg3 52 CONCLUSION CHAPTER 6\nA C o m m o n Desig n Vocabulary\nStudie s of exper t programmer s for conventiona l language s have show n that knowledg e\na nd e x p e r i e n c e i s n 't o r g a n i z e d s i m p l y aroun d synta x b ut in l a r g e r c o n c e p t u a l s t r u c t u r e s\nsuch as algorithms , data structure s a nd idiom s [ A S 8 5 , C o p 9 2 , C u r 8 9 , S S 8 6 ] , a nd plans\nf or fulfillin g a particula r g o al [ S E 8 4 ] .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1020, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 681}}
{"id": "computer_science_design_patterns_gof_chunk_1021_46f651c5", "text": "D e s i g n e r s p r o b a b l y don't t h i nk a b o u t t he n o t a t i o n\nthey'r e using for recordin g the desig n as much as they try to matc h the curren t d e s i g n\ns i t u a t i o n a g a i n s t p l a n s , a l g o r i t h m s , data s t r u c t u r e s , a nd i d i o m s they have l e a r n e d in\nthe past. Compute r scientist s name and catalo g algorithm s and data structures , but we don't\noften name other kinds of patterns . D e s i g n pattern s provid e a commo n vocabular y for\nd e s i g n e r s to use to communicate , document , and explor e d e s i g n alternatives . D e s i g n\npattern s make a s y s t e m s e em l e ss comple x by lettin g you talk abou t it at a h i g h e r l e v el\nof abstractio n than that of a d e s i g n notatio n or programmin g language . D e s i g n pattern s\nraise the l e v el at whic h you d e s i g n and d i s c u s s d e s i g n with your colleagues.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1021, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_design_patterns_gof_chunk_1022_f2a6db23", "text": "D e s i g n pattern s\nraise the l e v el at whic h you d e s i g n and d i s c u s s d e s i g n with your colleagues. O n ce you'v e absorbe d the d e s i g n pattern s in this book , your d e s i g n vocabular y will\na l m o s t c e r t a i n l y c h a n g e . Y ou w i ll s p e ak d i r e c t l y in terms of t he n a m e s of t he d e s i g n\npatterns . You'l l find yoursel f sayin g thing s l i k e, \" L e t 's use an Observe r h e r e , \" or, \" L e t 's\nmake a S t r a t e g y o ut of t h e se c l a s s e s . \"\nA Documentatio n and L e a r n i n g Aid\nKnowin g the d e s i g n pattern s in this book make s it easie r to understan d existin g s y s -\nt e m s. M o st l a r ge o b j e c t - o r i e n t e d s y s t e m s u se t h e se d e s i g n patterns . P e o p l e l e a r n i n g \nobject-oriente d programmin g often complai n that the system s they'r e workin g with\nuse inheritanc e in convolute d ways and that it's d i f f i c u l t to follow the flow of c o n t r o l .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1022, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_design_patterns_gof_chunk_1023_5f6d72db", "text": "In large p a rt this is becaus e they do not understan d the d e s i g n pattern s in the s y s -\nt e m. Learnin g these d e s i g n pattern s will help you understan d e x i s t i n g object-oriente d\ns y s t e m s . T h e se d e s i g n pattern s c an a l so make y ou a bette r d e s i g n e r . T h ey p r o v i d e s o l u t i o n s\nto commo n problems . If you work with object-oriente d s y s t e m s l o ng e n o u g h , you'l l\np r o b a b l y l e a rn t h e se d e s i g n pattern s on your o w n. B ut r e a d i n g t he b o ok w i ll h e lp y ou\nlearn them much faster . Learnin g these pattern s will help a n o v i c e act more l i ke an\ne x p e r t . M o r e o v e r , describin g a syste m in terms of the d e s i g n pattern s that it uses will make it\na lot easie r to understand . Otherwise , peopl e will have to r e v e r s e - e n g i n e e r the d e s i g n\nto uneart h the pattern s it u s e s.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1023, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_design_patterns_gof_chunk_1024_9b6caf61", "text": "Otherwise , peopl e will have to r e v e r s e - e n g i n e e r the d e s i g n\nto uneart h the pattern s it u s e s. Havin g a commo n vocabular y mean s you don't have\nto d e s c r i b e the whol e d e s i g n pattern ; you can j u st name it and expec t your reade r to\nknow it. A reade r who doesn' t know the pattern s will have to look them up at first, but\nthat's s t i ll easie r than reverse-engineering. We u se t h e se pattern s in o ur o wn d e s i g n s , a nd we've found them i n v a l u a b l e . Y et we\nuse the p a t t e r n s i n a r g u a b l y n a i v e w a y s . We use t h e m t o pick names f o r classes, t o\n\nptgSECTION 6.1 WHAT TO EXPECT FROM DESIGN PATTERNS 353\nthink abou t and teach g o od d e s i g n , and to d e s c r i b e d e s i g n s in terms of the s e q u e n c e\nof d e s i g n pattern s we applie d [ B J 9 4 ] . It's easy to imagin e more s o p h i s t i c a t e d ways of\nusing patterns , such as pattern-base d C A SE tools or hypertex t documents .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1024, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_design_patterns_gof_chunk_1025_3a591a1b", "text": "It's easy to imagin e more s o p h i s t i c a t e d ways of\nusing patterns , such as pattern-base d C A SE tools or hypertex t documents . But pattern s\nare a big help e v en withou t sophisticate d tools. An Adjunc t to Existin g M e t h o d s\nObject-oriente d d e s i g n method s are s u p p o s e d to promot e g o od d e s i g n , to teach new\nd e s i g n e r s how to d e s i g n w e l l, and to standardize the way d e s i g n s are d e v e l o p e d . A\nd e s i g n metho d typicall y define s a set of notation s (usuall y graphical ) for m o d e l i n g\nvariou s aspect s of a d e s i g n , along with a set of rules that gover n how and when to use\ne a ch notation . D e s i g n method s usuall y d e s c r i b e p r o b l e m s t h at o c c ur in a d e s i g n , how\nto r e s o l v e them , and how to evaluat e d e s i g n . But they haven' t been a b le to captur e the\nexperienc e of exper t d e s i g n e r s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1025, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_design_patterns_gof_chunk_1026_da7d407c", "text": "But they haven' t been a b le to captur e the\nexperienc e of exper t d e s i g n e r s . We b e l i e v e our d e s i g n pattern s are an importan t p i e ce that's b e en missin g f r om object-\noriente d d e s i g n methods . The d e s i g n pattern s show how to use primitiv e technique s\nsuch as objects , inheritance , and polymorphism . T h ey s h ow how to parameteriz e a \nsyste m with an algorithm , a behavior , a state, or the kind of o b j e c t s it's s u p p o s e d to\nc r e a t e . D e s i g n pattern s provid e a way to d e s c r i b e more of the \" w h y \" of a d e s i g n and\nnot just r e c o r d the result s of your d e c i s i o n s . The A p p l i c a b i l i t y , C o n s e q u e n c e s , and\nImplementatio n s e c t i o n s of the d e s i g n pattern s help g u i de you in the d e c i s i o n s you\nhave to make. D e s i g n pattern s are e s p e c i a l l y usefu l in turnin g an analysi s m o d e l into an implementa-\ntion model .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1026, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_design_patterns_gof_chunk_1027_bb0e9449", "text": "D e s i g n pattern s are e s p e c i a l l y usefu l in turnin g an analysi s m o d e l into an implementa-\ntion model . D e s p i t e many c l a i m s t h at promis e a smoot h transitio n f r om object-oriente d\nanalysi s to d e s i g n , in practic e the transitio n is anythin g but smooth . A flexibl e and \nreusabl e d e s i g n w i ll contai n o b j e c t s that aren' t in the analysi s model . The program-\nming languag e and c l a ss librarie s you use a f f e c t the d e s i g n . Analysi s model s often\nmust be redesigne d to make them r e u s a b l e . Many of the d e s i g n pattern s in the catalo g\naddres s these i s s u e s , whic h is why we c a ll them design patterns. A full-fledge d desig n metho d r e q u i r e s more kinds of pattern s than j u st d e s i g n patterns . T h e re can also be analysi s patterns , user i n t e r f a c e d e s i g n patterns , or performance-\ntunin g patterns .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1027, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_design_patterns_gof_chunk_1028_f1225093", "text": "T h e re can also be analysi s patterns , user i n t e r f a c e d e s i g n patterns , or performance-\ntunin g patterns . But the d e s i g n pattern s are an essentia l part, one that's been m i s s i n g\nuntil n o w . A T a r g e t for Refactoring\nOne of the p r o b l e m s in d e v e l o p i n g reusabl e softwar e is that it o f t en has to be reorga-\nnized or refactore d [ O J 9 0 ] . D e s i g n pattern s help you determin e how to r e o r g a n i z e a\nd e s i g n , and they can reduc e the amoun t of refactorin g you need to do later. The lifecycl e of object-oriente d softwar e has s e v e r a l p h a s e s . B r i an F o o te identifie s t h e se\nphases as the prototyping, expansionary, a n d consolidating phases [ F o o 9 2 ] .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1028, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 749}}
{"id": "computer_science_design_patterns_gof_chunk_1029_fd24e167", "text": "The lifecycl e of object-oriente d softwar e has s e v e r a l p h a s e s . B r i an F o o te identifie s t h e se\nphases as the prototyping, expansionary, a n d consolidating phases [ F o o 9 2 ] . ptg3 54 CONCLUSION CHAPTER 6\nT he p r o t o t y p i n g p h a se is a flurry of a c t i v i t y as t he softwar e is b r o u g h t to l i fe throug h\nrapid prototypin g and incrementa l c h a n g e s , until it meet s an initia l set of requirement s\nand r e a c h e s a d o l e s c e n c e . At this point , the softwar e usuall y c o n s i s t s of c l a ss h i e r a r c h i e s\nthat c l o s e l y r e f l e c t e n t i t i e s in t he i n i t i a l p r o b l e m domain . T he main k i nd of r e u se is\nwhite-bo x r e u se by inheritance.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1029, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 743}}
{"id": "computer_science_design_patterns_gof_chunk_1030_ecffbd40", "text": "T he main k i nd of r e u se is\nwhite-bo x r e u se by inheritance. O n ce t he softwar e h as r e a c h e d a d o l e s c e n c e a nd is p ut i n to s e r v i c e , i ts e v o l u t i o n is\ngoverne d by two conflictin g n e e d s : (1) the softwar e must satisf y more r e q u i r e m e n t s ,\nand (2) the softwar e mus t be m o re r e u s a b l e . New requirement s usuall y add new c l a s s e s\na nd o p e r a t i o n s a nd perhap s w h o l e c l a ss h i e r a r c h i e s . T he softwar e g o es throug h an \nexpansionar y phase to meet new requirements . T h is can't continu e for l o n g, h o w e v e r . Eventuall y the softwar e w i ll b e c o m e too inflexibl e and arthriti c for f u r t h e r change . The c l a ss h i e r a r c h i e s w i ll no l o n g e r matc h any p r o b l e m domain . Instea d they'l l reflec t\nmany proble m domains , and c l a s s e s w i ll defin e many unrelate d operation s and instanc e\nv a r i a b l e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1030, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 958}}
{"id": "computer_science_design_patterns_gof_chunk_1031_c7914665", "text": "Instea d they'l l reflec t\nmany proble m domains , and c l a s s e s w i ll defin e many unrelate d operation s and instanc e\nv a r i a b l e s . To continu e to e v o l v e , the softwar e must be r e o r g a n i z e d in a p r o c e s s know n as refactor-\ning. T h is is the phase in whic h framework s o f t en e m e r g e . Refactorin g i n v o l v e s tearin g\napart c l a s s e s into s p e c i a l - and general-purpos e c o m p o n e n t s , movin g operation s up or\ndown the c l a ss h i e r a r c h y , and rationalizin g the interface s of c l a s s e s . T h is c o n s o l i d a t i o n\np h a se p r o d u c e s many n ew k i n ds of o b j e c t s , often by d e c o m p o s i n g e x i s t i n g o b j e c t s\na nd u s i ng objec t compositio n instea d of inheritance . H e n c e b l a c k - b o x r e u se r e p l a c e s\nw h i t e - b o x r e u s e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1031, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 869}}
{"id": "computer_science_design_patterns_gof_chunk_1032_c6c4f1c0", "text": "H e n c e b l a c k - b o x r e u se r e p l a c e s\nw h i t e - b o x r e u s e . The continua l n e ed to satisf y m o re requirement s along with the n e ed\nf or m o re r e u se p r o p e l s o b j e c t - o r i e n t e d softwar e throug h r e p e a t e d p h a s e s of e x p a n s i o n\nand consolidation—expansio n as new requirement s are satisfied , and consolidatio n as\nthe software becomes more general. T h is c y c le is unavoidable . B ut g o od d e s i g n e r s a re awar e of t he c h a n g e s that c an promp t\nr e f a c t o r i n g s . G o od d e s i g n e r s a l so know c l a ss a nd o b j e c t s t r u c t u r e s that c an h e lp a v o id\nrefactorings—thei r d e s i g n s are robus t in the face of requiremen t c h a n g e s . A thoroug h\nrequirement s analysi s w i ll highligh t those requirement s that are l i k e ly to c h a n g e durin g\nt he l i fe of t he software , a nd a g o od d e s i g n w i ll be r o b u s t to them.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1032, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_design_patterns_gof_chunk_1033_e623f7e6", "text": "Our d e s i g n pattern s captur e many of the structure s that resul t from refactoring . U s i ng\nthese patterns early in the l i f e o f a design prevents later refactorings. But even if you\n\nptgSECTION 62 A BRIEF HISTORY 355\nd o n 't s ee h ow to a p p ly a patter n u n t il after y o u ' v e b u i lt y o ur s y s t e m , t he patter n c an s t i ll\ns h o w you how to change it. Design patterns thus provide targets for your refactorings. 6 . 2 A Brief History\nT he catalo g b e g a n as a part of Erich' s P h . D . t h e s is [ G a m 9 1 , G a m 9 2 ] . Roughl y h a lf of\nt he c u r r e n t p a t t e r n s w e re in h is t h e s i s . By O O P S L A ' 91 it w as officiall y an i n d e p e n d e n t\nc a t a l o g , and R i c h a r d had j o i n e d E r i ch to work on it. John starte d workin g on it s o on\nthereafter . By O O P S L A ' 9 2, Ralp h had joine d the g r o u p .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1033, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 890}}
{"id": "computer_science_design_patterns_gof_chunk_1034_6ac28c92", "text": "John starte d workin g on it s o on\nthereafter . By O O P S L A ' 9 2, Ralp h had joine d the g r o u p . We worke d hard to make the\nc a t a l o g fit for publicatio n at E C O O P ' 9 3, but s o on we r e a l i z e d that a 9 0 - p a g e pape r was\nnot g o i ng to be a c c e p t e d . So we summarize d the catalo g and submitte d the summary ,\nwhic h was accepted . We d e c i d e d to t u rn the catalo g into a book shortl y thereafter. Our n a m e s for the pattern s have c h a n g e d a little a l o ng the way. \" W r a p p e r \" b e c a m e\n\" D e c o r a t o r , \" \" G l u e \" b e c a m e \" F a c a d e , \" \" S o l i t a i r e \" b e c a m e \" S i n g l e t o n , \" a nd \" W a l k e r \"\nb e c a m e \" V i s i t o r . \" A c o u p l e of pattern s g ot d r o p p e d b e c a u s e they didn' t s e em importan t\ne n o u g h . B ut o t h e r w i s e t he s et of pattern s in t he c a t a l o g h as change d l i t t le s i n ce t he e nd\nof 1 9 9 2.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1034, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_design_patterns_gof_chunk_1035_cb85d372", "text": "B ut o t h e r w i s e t he s et of pattern s in t he c a t a l o g h as change d l i t t le s i n ce t he e nd\nof 1 9 9 2. T he pattern s t h e m s e l v e s , h o w e v e r , have e v o l v e d tremendously. In fact, n o t i c i n g that somethin g is a patter n is the e a sy part. All f o ur of us are a c t i v e l y\nworkin g on buildin g o b j e c t - o r i e n t e d s y s t e m s , and we'v e found that it's e a sy to s p ot\npattern s when you l o ok at e n o u g h s y s t e m s . But finding pattern s is much e a s i e r than\ndescribing t h e m . If you build s y s t e m s and then reflec t on what you b u i l d , you w i ll see pattern s in what\nyou do. But it's hard to d e s c r i b e pattern s so that p e o p l e who don't know them w i ll\nunderstan d them and r e a l i z e why they are important . Expert s immediatel y r e c o g n i z e d \nthe value of the c a t a l o g in its e a r ly s t a g e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1035, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_design_patterns_gof_chunk_1036_5a1ec398", "text": "Expert s immediatel y r e c o g n i z e d \nthe value of the c a t a l o g in its e a r ly s t a g e s . But the o n ly o n es who c o u ld understan d the\npattern s w e re those who had alread y u s ed them. S i n ce o ne of t he main p u r p o s e s of t he book w as to teach object-oriente d d e s i g n to n ew\nd e s i g n e r s , we k n ew we h ad to i m p r o v e t he c a t a l o g . We expande d t he averag e s i ze of\na pattern from l e ss than 2 to m o re than 10 page s by i n c l u d i n g a d e t a i l e d motivating\ne x a m p l e and s a m p l e c o d e. We a l so starte d examinin g the trade-off s and the variou s\nways of implementin g the pattern . T h is made the pattern s e a s i e r to l e a r n . Anothe r importan t chang e o v er the past year has been a greate r emphasi s on the\np r o b l e m that a pattern s o l v e s . It's e a s i e s t to see a patter n as a s o l u t i o n , as a techniqu e\nthat can be adapte d and r e u s e d .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1036, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_design_patterns_gof_chunk_1037_cb2d66df", "text": "It's e a s i e s t to see a patter n as a s o l u t i o n , as a techniqu e\nthat can be adapte d and r e u s e d . It's harde r to see when it is appropriate—to characteriz e\nt he p r o b l e m s it s o l v e s a nd t he c o n t e x t in w h i c h i t 's t he b e st s o l u t i o n . In g e n e r a l , i t 's\ne a s i e r to see what s o m e o n e is d o i ng than to know why, and the \" w h y \" for a patter n is the\nproble m it s o l v e s . Knowin g t he purpos e of a patter n is importan t t o o, becaus e it h e l ps\nus c h o o s e pattern s to a p p l y . It a l so h e l ps us understan d the d e s i g n of existin g s y s t e m s . A patter n autho r must determin e and characteriz e the p r o b l e m that the patter n s o l v e s ,\ne v e n if you have to do it after you've discovered i t s s o l u t i o n . ptg3 5 6 CONCLUSION CHAPTER 6\n6 . 3 The Pattern Community\nWe aren' t the o n ly o n es intereste d in writin g book s that catalo g the pattern s expert s\nuse.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1037, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_design_patterns_gof_chunk_1038_dea5fd72", "text": "ptg3 5 6 CONCLUSION CHAPTER 6\n6 . 3 The Pattern Community\nWe aren' t the o n ly o n es intereste d in writin g book s that catalo g the pattern s expert s\nuse. We are a part of a l a r g e r communit y intereste d in pattern s in g e n e r a l and software-\nrelate d pattern s in particular . Christophe r Alexande r is the a r c h i t e c t who first studie d\npattern s in b u i l d i n g s and communitie s and d e v e l o p e d a \"patter n language \" for g e n e r -\nating them . His work has i n s p i r e d us time and again . So it's f i t t i n g and worthwhil e to\ncompar e our work to h i s. T h en w e ' ll l o ok at o t h e r s ' work in software-relate d patterns. A l e x a n d e r ' s P a t t e r n L a n g u a g e s\nT h e re are many ways in whic h our work is like Alexander's . Both are b a s ed on ob-\ns e r v i n g e x i s t i n g s y s t e m s a nd l o o k i n g f or p a t t e r n s in them .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1038, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 913}}
{"id": "computer_science_design_patterns_gof_chunk_1039_55f1443e", "text": "Both are b a s ed on ob-\ns e r v i n g e x i s t i n g s y s t e m s a nd l o o k i n g f or p a t t e r n s in them . B o th h a ve t e m p l a t e s f or\nd e s c r i b i n g pattern s (althoug h our template s are quite different) . Both r e ly on natura l\nl a n g u a g e a nd l o ts of e x a m p l e s to d e s c r i b e pattern s rathe r than forma l l a n g u a g e s , a nd\nboth g i ve rationale s for e a ch pattern. But there are just as many ways in whic h our work s are different:\n1. P e o p l e have been makin g building s f or thousand s of years , and there are many\nc l a s s i c e x a m p l e s to draw upon . We have b e en makin g softwar e system s for a\nrelativel y short t i m e, and few are c o n s i d e r e d c l a s s i c s . 2. A l e x a n d e r g i v es an o r d er in w h i ch h is pattern s s h o u l d be u s e d; we h a ve not. 3.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1039, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 863}}
{"id": "computer_science_design_patterns_gof_chunk_1040_9109a94c", "text": "2. A l e x a n d e r g i v es an o r d er in w h i ch h is pattern s s h o u l d be u s e d; we h a ve not. 3. Alexander' s pattern s emphasiz e the problem s they a d d r e s s , wherea s d e s i g n pat-\nterns d e s c r i b e the s o l u t i o n s in more detail. 4. Alexande r c l a i m s h is pattern s w i ll generat e c o m p l e t e b u i l d i n g s . We do n ot c l a im\nthat our pattern s w i ll generat e complet e programs. Whe n Alexande r c l a i m s you can d e s i g n a house s i m p l y by applyin g his pattern s one\nafter another , he h as g o a ls s i m i l a r to t h o se of o b j e c t - o r i e n t e d d e s i g n m e t h o d o l o g i s t s w ho\ng i ve step-by-ste p rules for d e s i g n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1040, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 717}}
{"id": "computer_science_design_patterns_gof_chunk_1041_11a366d8", "text": "Alexande r doesn' t deny the n e ed for creativity ; s o me\nof h is pattern s requir e understandin g t he l i v i ng h a b i t s of t he p e o p l e w ho w i ll u se t he\nb u i l d i n g , a nd h is b e l i ef in t he \" p o e t r y \" of d e s i g n i m p l i e s a l e v el of e x p e r t i s e beyon d t he\npatter n languag e i t s e l f . 1 B ut h is d e s c r i p t i o n of h ow pattern s generat e d e s i g n s i m p l i e s\nthat a patter n languag e can make the d e s i g n p r o c e s s deterministi c and repeatable. The Alexandria n point of v i ew has h e l p e d us focus on d e s i g n trade-offs—th e differen t\n\" f o r c e s \" that help shape a d e s i g n . His influenc e made us work harde r to understan d\nthe a p p l i c a b i l i t y and c o n s e q u e n c e s of our patterns . It a l so kept us from worryin g abou t\ndefinin g a forma l representatio n of patterns .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1041, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_design_patterns_gof_chunk_1042_6981f30a", "text": "It a l so kept us from worryin g abou t\ndefinin g a forma l representatio n of patterns . Althoug h s u ch a representatio n migh t\nmake automatin g pattern s p o s s i b l e , at this stage it's more importan t to e x p l o r e the \ns p a c e of design patterns than to formalize it. 1 S e e \"The poetry of the language\" [AIS+ 77]. ptgSECTION 6.3 THE PATTERN COMMUNITY 357\nF r om Alexander' s point of v i e w , the pattern s in this book do not f o rm a patter n lan-\nguage . G i v e n the variet y of softwar e s y s t e m s that p e o p l e build , it's hard to see how\nwe c o u ld provid e a \" c o m p l e t e \" set of patterns , one t h at o f f e r s step-by-ste p instruction s\nfor d e s i g n i n g an application . We can do that for certai n c l a s s e s of applications , such as\nreport-writin g or makin g a forms-entr y system . But our catalo g is just a collectio n of\nrelate d patterns ; we can't preten d it's a patter n language.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1042, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_design_patterns_gof_chunk_1043_7c843b0a", "text": "But our catalo g is just a collectio n of\nrelate d patterns ; we can't preten d it's a patter n language. In fact, we think it's unlikel y that there w i ll ever be a complet e patter n languag e for\nsoftware . But it's certainl y p o s s i b l e to make one that is more complete . Addition s woul d\nhave to includ e framework s and how to use them [ J o h 9 2 ] , pattern s for user interfac e de-\ns i gn [ B J 9 4 ] , analysi s pattern s [ C o a 9 2 1 , and all the other aspect s of developin g software . D e s i g n pattern s are just a part of a large r patter n languag e for software. P a t t e r n s in Software\nOur first c o l l e c t i v e e x p e r i e n c e in the study of softwar e architectur e was at an\nO O P S L A ' 91 worksho p led by Bruc e Anderson . The worksho p was dedicate d to de-\nvelopin g a handboo k for softwar e architects .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1043, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 858}}
{"id": "computer_science_design_patterns_gof_chunk_1044_64a490e3", "text": "The worksho p was dedicate d to de-\nvelopin g a handboo k for softwar e architects . (Judgin g from this b o o k , we suspec t\n\"architectur e e n c y c l o p e d i a \" w i ll be a more appropriat e name than \"architectur e hand-\nb o o k . \" ) That first worksho p has led to a s e r i es of m e e t i n g s , the most recen t of whic h\nbeing the first conferenc e on Patter n Language s of Program s h e ld in Augus t 1 9 9 4 . T h is\nhas create d a communit y of p e o p l e intereste d in documentin g softwar e expertise. Of course , other s have had this goal as w e l l. Donal d Knuth' s The Art of Computer Pro-\ngramming [ K n u 7 3 ] was one of the first attempt s to catalo g softwar e knowledge , thoug h\nhe focuse d on describin g algorithms . Even so, the task prove d too great to finish . The\nGraphics Gems s e r i es [ G l a 9 0 , A r v 9 1 , K i r 9 2 ] is anothe r catalo g of desig n knowledge , \nthoug h it too tends to focus on algorithms .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1044, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_design_patterns_gof_chunk_1045_56cace6f", "text": "The\nGraphics Gems s e r i es [ G l a 9 0 , A r v 9 1 , K i r 9 2 ] is anothe r catalo g of desig n knowledge , \nthoug h it too tends to focus on algorithms . The Domai n S p e c i f i c Softwar e Architectur e\nprogra m sponsore d by the U . S. Departmen t of Defens e [ G M 9 2 ] concentrate s on gather-\ning architectura l information . The knowledge-base d softwar e engineerin g communit y\ntries to represen t software-relate d knowledg e in general . T h e r e are many other group s\nwith goals at l e a st a little l i ke ours. Jame s C o p l i e n ' s Advanced C++: Programming Styles and Idioms [ C o p 9 2 ] has influence d\nus, too. The pattern s in his book tend to be more C++-specifi c than our d e s i g n patterns,\nand his book contain s lots of l o w e r - l e v e l pattern s as w e l l. But there is s o me overlap ,\nas we point out in our patterns . Jim has b e en activ e in the patter n community .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1045, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_design_patterns_gof_chunk_1046_6c4b7bf5", "text": "But there is s o me overlap ,\nas we point out in our patterns . Jim has b e en activ e in the patter n community . H e 's\ncurrentl y workin g on pattern s that d e s c r i b e p e o p l e ' s r o l es in softwar e developmen t\norganizations. T h e re are a lot of other p l a c e s in whic h to find description s of patterns . Kent B e ck was\none of the first peopl e in the s o f t w a r e communit y to advocat e Christophe r Alexander' s\nwork . In 1 9 93 he starte d writin g a colum n in The Smalltalk Report on Smalltal k patterns . Peter Coad has a l so been c o l l e c t i n g pattern s for some time. His pape r on pattern s s e e m s \nto us to contai n mostl y analysi s pattern s [ C o a 9 2 ] ; we haven' t s e en his lates t patterns ,\nthough we know he is still working on them. We've heard of several books on patterns\n\nptg3 58 CONCLUSION CHAPTER 6\nthat are in the works , but we haven' t s e en any of them , e i t h e r . All we can do is let\nyou know they'r e c o m i n g .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1046, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_design_patterns_gof_chunk_1047_2ad363cc", "text": "We've heard of several books on patterns\n\nptg3 58 CONCLUSION CHAPTER 6\nthat are in the works , but we haven' t s e en any of them , e i t h e r . All we can do is let\nyou know they'r e c o m i n g . One of these b o o k s w i ll be from the Patter n Language s of\nPrograms c o n f e r e n c e . 6 . 4 An Invitation\nWha t can you do if you are intereste d in patterns ? F i r s t, use them and l o ok for other\npattern s that fit the way you d e s i g n . A lot of b o o k s and a r t i c l e s abou t pattern s w i ll be\nc o m i n g o ut in t he n e xt f ew y e a r s , so t h e re w i ll be p l e n t y of s o u r c e s f or n ew p a t t e r n s . D e v e l o p your vocabular y of patterns, and use it. Use it when you talk with other p e o p l e\nabou t your d e s i g n s . Use it when you think and write abou t them. S e c o n d , be a critica l c o n s u m e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1047, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 868}}
{"id": "computer_science_design_patterns_gof_chunk_1048_b328d2fa", "text": "Use it when you talk with other p e o p l e\nabou t your d e s i g n s . Use it when you think and write abou t them. S e c o n d , be a critica l c o n s u m e r . T he d e s i g n patter n catalo g is t he r e s u l t of hard work , n ot\njust ours but t h at of dozen s of r e v i e w e r s who gave us feedback . If you s p ot a p r o b l e m\nor b e l i e v e more explanatio n is n e e d e d , contac t u s. T he s a me g o es f or a ny other catalo g\nof patterns: Give the author s feedback ! One of the great thing s abou t pattern s is that\nthey move desig n d e c i s i o n s out of the r e a lm of vagu e intuition . T h ey let author s be\ne x p l i c i t abou t the trade-off s they make . T h is make s it e a s i e r to see what is wron g with\ntheir pattern s and to argue with them . Take advantag e of that. T h i r d , l o ok for pattern s you u s e, and write them down . Make them a part of your\nd o c u m e n t a t i o n . S h ow them to o t h er p e o p l e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1048, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_design_patterns_gof_chunk_1049_82068f7b", "text": "Take advantag e of that. T h i r d , l o ok for pattern s you u s e, and write them down . Make them a part of your\nd o c u m e n t a t i o n . S h ow them to o t h er p e o p l e . Y ou don't h a ve to be in a r e s e a r c h l ab to\nfind patterns . In fact, findin g relevan t pattern s is nearl y i m p o s s i b l e if you don't have \npractica l e x p e r i e n c e . F e el free to write your own catalo g of patterns...bu t make s u re\ns o m e o n e else helps you beat them into shape! 6 . 5 A Parting Thought\nThe best d e s i g n s w i ll use many d e s i g n pattern s that dovetai l and intertwin e to produc e\na greate r w h o l e . As Christophe r Alexande r s a y s :\nIt is p o s s i b l e to make building s by stringin g togethe r patterns , in a rathe r\nl o o se w a y. A buildin g made l i ke t h i s, is an a s s e m b l y of patterns . It is n ot\nd e n s e . It is not profound .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1049, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 898}}
{"id": "computer_science_design_patterns_gof_chunk_1050_0269f771", "text": "A buildin g made l i ke t h i s, is an a s s e m b l y of patterns . It is n ot\nd e n s e . It is not profound . But it is a l so p o s s i b l e to put pattern s togethe r\nin such a way that many pattern s overla p in the same p h y s i c a l s p a c e : the\nbuildin g is very d e n s e ; it has many meaning s capture d in a smal l s p a c e ; and\nthrough this density, it becomes profound. A Pattern Language [AIS+77, page x l i ]\n\nptgAppendix A\nG l o s s a r y\na b s t r a c t c l a ss A c l a ss w h o s e primar y purpos e is to defin e an interface . An abstrac t\nc l a ss defer s s o me or a ll of i ts implementatio n to s u b c l a s s e s . An abstrac t c l a ss\ncanno t be instantiated. a b s t r a c t c o u p l i n g G i v e n a c l a ss A that maintain s a referenc e to an abstrac t c l a ss B,\nc l a ss A is s a id to be abstractly coupled to B. We c a ll t h is abstrac t couplin g becaus e\nA refer s to a type of object , not a c o n c r e t e object.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1050, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_design_patterns_gof_chunk_1051_d40a7dc3", "text": "We c a ll t h is abstrac t couplin g becaus e\nA refer s to a type of object , not a c o n c r e t e object. a b s t r a c t operatio n An operatio n that d e c l a r e s a signatur e but doesn' t implemen t it. In\nC++, an abstrac t operatio n c o r r e s p o n d s to a p u re virtua l membe r function. a c q u a i n t a n c e relationshi p A c l a ss that refer s to anothe r c l a ss has an acquaintance with\nthat c l a s s . a g g r e g a t e objec t An objec t that's c o m p o s e d of subobjects . T he subobject s a re c a l l ed\nthe aggregate' s p a r t s , and the aggregat e is r e s p o n s i b l e for them. aggregatio n relationshi p The relationshi p of an aggregat e o b j e c t to its parts . A c l a ss\ndefine s this r e l a t i o n s h i p for its i n s t a n c e s ( e . g ., aggregat e objects). black-bo x r e u se A style of r e u se based on objec t c o m p o s i t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1051, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 897}}
{"id": "computer_science_design_patterns_gof_chunk_1052_fd550e7d", "text": "A c l a ss\ndefine s this r e l a t i o n s h i p for its i n s t a n c e s ( e . g ., aggregat e objects). black-bo x r e u se A style of r e u se based on objec t c o m p o s i t i o n . C o m p o s e d object s revea l\nno interna l detail s to e a ch other and are thus analogou s to \" b l a c k b o x e s . \"\nc l a ss A c l a ss define s an object' s interfac e and implementation . It s p e c i f i e s the object' s\ninterna l representatio n and define s the operation s the objec t can perform. c l a ss d i a g r a m A diagra m that d e p i c t s c l a s s e s , t h e ir interna l structur e and o p e r a t i o n s ,\nand the static relationship s betwee n them. class operatio n An operatio n targete d to a c l a ss and not to an individua l o b j e c t . In \nC++, c l a s s o p e r a t i o n s are are called static member f u n c t i o n s . c o n c r e t e class A class having no abstract operations. It can be instantiated.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1052, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_design_patterns_gof_chunk_1053_ee162d87", "text": "In \nC++, c l a s s o p e r a t i o n s are are called static member f u n c t i o n s . c o n c r e t e class A class having no abstract operations. It can be instantiated. 3 5 9\n\nptg3 60 G L O S S A R Y APPENDIX A\nconstructo r In C++, an operatio n that is automaticall y i n v o k e d to i n i t i a l i z e new in-\ns t a n c e s . couplin g T he d e g r e e to w h i c h softwar e c o m p o n e n t s d e p e n d on e a ch o t h e r . delegatio n An implementatio n m e c h a n i s m in whic h an o b j e c t forward s or delegates a\nreques t to anothe r object . The delegat e carrie s out the r e q u e s t on behal f of the\no r i g i n a l o b j e c t . desig n patter n A d e s i g n patter n systematicall y names , motivates , and e x p l a i n s a g e n -\neral d e s i g n that a d d r e s s e s a recurrin g d e s i g n proble m in o b j e c t - o r i e n t e d s y s t e m s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1053, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_design_patterns_gof_chunk_1054_f909de76", "text": "It d e s c r i b e s the problem , the s o l u t i o n , when to apply the solution , and its c o n -\ns e q u e n c e s . It also g i v es implementatio n hints a nd examples . T he s o l u t i o n is a\ng e n e r a l a r r a n g e m e n t of o b j e c t s a nd c l a s s e s that s o l ve t he p r o b l e m . T he s o l u t i o n\nis customize d and implemente d to s o l ve the proble m in a particula r context. destructo r In C++, an operatio n that is automaticall y invoke d to finaliz e an objec t that\nis abou t to be d e l e t e d . dynami c bindin g The run-tim e associatio n of a r e q u e s t to an o b j e c t and one of its\noperations . In C++, o n ly virtua l function s are dynamicall y bound. encapsulatio n T he resul t of h i d i n g a representatio n a nd implementatio n in an object . The representatio n is not v i s i b l e and canno t be a c c e s s e d directl y f r om outsid e the\nobject . Operation s are the o n ly way to a c c e s s and modif y an object' s representa-\ntion.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1054, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_design_patterns_gof_chunk_1055_53e38a35", "text": "The representatio n is not v i s i b l e and canno t be a c c e s s e d directl y f r om outsid e the\nobject . Operation s are the o n ly way to a c c e s s and modif y an object' s representa-\ntion. f r a m e w o r k A set of cooperatin g c l a s s e s that make s up a r e u s a b l e d e s i g n for a s p e c i f i c\nc l a ss of software . A framewor k p r o v i d e s architectura l guidanc e by partitionin g\nthe d e s i g n into abstrac t c l a s s e s and definin g their r e s p o n s i b i l i t i e s and c o l l a b o -\nrations . A d e v e l o p e r customize s the framewor k to a particula r applicatio n by \ns u b c l a s s i n g a nd c o m p o s i n g i n s t a n c e s of f r a m e w o r k c l a s s e s . f r i e n d c l a ss In C++, a c l a ss that has the s a me a c c e s s right s to the operation s and data\nof a c l a ss as that c l a ss i t s e l f . inheritanc e A r e l a t i o n s h i p that d e f i n e s o ne entity in t e r ms of a n o t h e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1055, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_design_patterns_gof_chunk_1056_decc04b2", "text": "inheritanc e A r e l a t i o n s h i p that d e f i n e s o ne entity in t e r ms of a n o t h e r . C l a ss i n h e r i t a n c e\ndefine s a n ew c l a ss in terms of o ne or more paren t c l a s s e s . T he n ew c l a ss i n h e r i t s i ts\ninterfac e a nd implementatio n f r om i ts parents . T he n ew c l a ss is c a l l ed a s u b c l a s s\nor (in C + + ) a derive d c l a s s . C l a ss i n h e r i t a n c e c o m b i n e s i n t e r f a c e inheritanc e\nand implementatio n inheritance . Interfac e inheritanc e define s a new interfac e\nin terms of one or more e x i s t i n g interfaces . Implementatio n i n h e r i t a n c e define s a\nn ew implementatio n in term s of o ne or more e x i s t i n g implementations. instanc e variabl e A p i e ce of data that define s part of an object' s representation . C++\nu s e s the term data member. interaction diagram A diagram that shows the flow of r e q u e s t s b e t w e e n o b j e c t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1056, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_design_patterns_gof_chunk_1057_172e95ca", "text": "C++\nu s e s the term data member. interaction diagram A diagram that shows the flow of r e q u e s t s b e t w e e n o b j e c t s . ptg3 6 1\ni n t e r f a c e T he s et of a ll s i g n a t u r e s d e f i n e d by an o b j e c t ' s o p e r a t i o n s . T he interfac e\nd e s c r i b e s the set of request s to whic h an objec t can respond. metaclas s C l a s s e s are object s in Smalltalk . A metaclas s is the c l a ss of a c l a ss object. mixi n c l a ss A c l a ss designe d to be c o m b i n e d with other c l a s s e s throug h inheritance . Mixi n c l a s s e s are usuall y abstract. objec t A run-tim e entity that package s both data and the procedure s that operat e on\nthat data. objec t c o m p o s i t i o n Assemblin g or composing object s to get m o re comple x behavior. objec t d i a g r a m A diagra m that depict s a particula r objec t structur e at run-time. objec t referenc e A value t h at identifie s anothe r object.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1057, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_design_patterns_gof_chunk_1058_90ab9f13", "text": "objec t d i a g r a m A diagra m that depict s a particula r objec t structur e at run-time. objec t referenc e A value t h at identifie s anothe r object. operatio n An object' s d a ta can be manipulate d o n ly by its operations . An objec t p e r -\nform s an operatio n when it r e c e i v e s a request . In C++, operation s are c a l l ed\nm e m b e r functions . Smalltal k u s es the term method. o v e r r i d i n g Redefinin g an operatio n ( i n h e r i t e d f r om a paren t c l a s s ) in a s u b c l a s s . parameterize d type A type that l e a v e s s o me constituen t types unspecified . The un-\ns p e c i f i e d t y p es a re s u p p l i e d as parameter s at t he p o i nt of u s e. In C++, parame-\nterize d types are c a l l ed templates. p a r e n t c l a ss The c l a ss f r om whic h anothe r c l a ss inherits . Synonym s are s u p e r c l a s s\n(Smalltalk) , b a se class (C++) , and a n c e s t o r class.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1058, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_design_patterns_gof_chunk_1059_828c6e00", "text": "p a r e n t c l a ss The c l a ss f r om whic h anothe r c l a ss inherits . Synonym s are s u p e r c l a s s\n(Smalltalk) , b a se class (C++) , and a n c e s t o r class. p o l y m o r p h i s m The abilit y to substitut e object s of matchin g interfac e for one anothe r\nat r u n - t i m e . privat e i n h e r i t a n c e In C++ , a c l a ss inherite d s o l e ly for its implementation. protoco l Extend s the concep t of an interfac e to includ e the allowabl e s e q u e n c e s of\nrequests. r e c e i v e r T he targe t o b j e c t of a r e q u e s t . r e q u e s t An objec t perform s an operatio n when it r e c e i v e s a correspondin g reques t\nf r om anothe r object . A commo n synony m for reques t is message. s i g n a t u r e An operation' s signatur e define s its name , parameters , and retur n value. s u b c l a s s A c l a ss that i n h e r i t s from anothe r c l a s s. In C++, a s u b c l a s s is c a l l ed a d e r i v e d\nclass.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1059, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_design_patterns_gof_chunk_1060_6b9bf6a7", "text": "s u b c l a s s A c l a ss that i n h e r i t s from anothe r c l a s s. In C++, a s u b c l a s s is c a l l ed a d e r i v e d\nclass. s u b s y s t e m A n independent group of classes that collaborate to fulfill a s e t o f respon -\ns i b i l i t i e s . ptg3 62 G L O S S A R Y APPENDIX A\ns u b t y p e A type is a subtyp e of anothe r if its interfac e contain s the interfac e of the other\nt y p e . s u p e r t y p e The paren t type from whic h a type i n h e r i t s . toolki t A c o l l e c t i o n of c l a s s e s that provide s usefu l functionalit y but d o es not defin e\nt he d e s i g n of an a p p l i c a t i o n . t y pe The name of a particula r interface. white-bo x r e u se A s t y le of r e u se based on c l a ss inheritance . A s u b c l a s s r e u s e s t he i n -\nterfac e a nd i m p l e m e n t a t i o n of i ts p a r e n t c l a s s, b ut it m ay h a ve a c c e s s to o t h e r w i s e\nprivate aspects of its parent.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1060, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_design_patterns_gof_chunk_1061_7bdb8196", "text": "A s u b c l a s s r e u s e s t he i n -\nterfac e a nd i m p l e m e n t a t i o n of i ts p a r e n t c l a s s, b ut it m ay h a ve a c c e s s to o t h e r w i s e\nprivate aspects of its parent. ptgA p p e n d i x B\nG u i d e to N o t a t i o n\nWe u se d i a g r a m s throughou t t he b o ok to i l l u s t r a t e importan t i d e a s . S o me d i a g r a m s a re\ninformal , like a s c r e e n shot of a d i a l o g box or a schemati c showin g a tree of objects . But the desig n pattern s in particula r use more f o r m a l notation s to denot e relationship s\nand interaction s betwee n c l a s s e s and objects . T h is appendi x d e s c r i b e s t h e se notation s\nin detail. We u se t h r ee differen t diagrammati c n o t a t i o n s :\n1.A class diagra m depict s c l a s s e s , their structure , and the static relationship s be-\ntwee n them. 2.An objec t d i a g r a m depict s a particula r objec t structur e at run-time.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1061, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 943}}
{"id": "computer_science_design_patterns_gof_chunk_1062_b67360e6", "text": "2.An objec t d i a g r a m depict s a particula r objec t structur e at run-time. 3.An interactio n d i a g r a m show s the flow of request s betwee n objects. E a ch d e s i g n patter n i n c l u d e s at l e a st one c l a ss diagram . The other notation s are u s ed\nas n e e d e d to supplemen t the discussion . The c l a ss and objec t diagram s are based on\nO MT ( O b j e c t M o d e l i n g T e c h n i q u e ) [ R B P + 9 1 , R u m 9 4 1 . 1 T he interactio n diagram s a re\ntaken f r om Objector y [ J C J O 9 2 ] and the Booc h metho d [ B o o 9 4 ] . T h e s e notation s are\nsummarized on the inside back cover of the book. B.I Class Diagram\nF i g u r e B.I a s h o w s the OMT notatio n for abstrac t and concret e c l a s s e s . A c l a ss is denote d\nby a b ox with t he c l a ss name in b o ld type at t he t o p. T he k ey o p e r a t i o n s of t he c l a ss\nappea r b e l ow the c l a ss name . Any instanc e variable s appea r below the operations.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1062, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_design_patterns_gof_chunk_1063_5de83139", "text": "T he k ey o p e r a t i o n s of t he c l a ss\nappea r b e l ow the c l a ss name . Any instanc e variable s appea r below the operations. 1 O MT u s es t he term \" o b j e c t diagram \" to refer to c l a ss diagrams . We u se \" o b j e c t diagram \" exclusivel y to\nrefer to diagrams of object structures. 3 6 3\n\nptg364 GUIDE TO NOTATION APPENDIX B\nT y pe informatio n is o p t i o n a l ; we u se t he C ++ c o n v e n t i o n , w h i c h puts t he t y pe n a me\nbefor e the name of the operatio n (to signif y the retur n type) , i n s t a n c e variable , or actua l\nparameter . S l a n t e d type i n d i c a t e s that t he c l a ss or operatio n is abstract. In s o me d e s i g n pattern s i t 's helpfu l to s ee w h e r e c l i e nt c l a s s e s r e f e r e n c e P a r t i c i p a n t\nc l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1063, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 812}}
{"id": "computer_science_design_patterns_gof_chunk_1064_a2fed626", "text": "In s o me d e s i g n pattern s i t 's helpfu l to s ee w h e r e c l i e nt c l a s s e s r e f e r e n c e P a r t i c i p a n t\nc l a s s e s . Whe n a patter n i n c l u d e s a C l i e n t c l a ss as o ne of i ts participant s ( m e a n i n g\nthe c l i e nt has a r e s p o n s i b i l i t y in the pattern) , the C l i e n t appear s as an ordinar y c l a s s. T h is is true in F l y w e i g h t ( 1 9 5 ) , f or example . Whe n t he patter n d o es n ot i n c l u d e a\nC l i e n t participan t ( i . e ., c l i e n t s have no r e s p o n s i b i l i t i e s in t he pattern) , b ut i n c l u d i n g it\nn e v e r t h e l e s s c l a r i f i e s w h i ch patter n p a r t i c i p a n t s i n t e r a c t with c l i e n t s , t h en t he C l i e n t\nc l a ss is show n in g r a y, as show n in Figur e B.lb. An exampl e is P r o xy ( 2 0 7 ) . A gray C l i e n t\nalso make s it c l e ar that we haven' t a c c i d e n t a l l y omitte d the C l i e n t from the Participant s\nd i s c u s s i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1064, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_design_patterns_gof_chunk_1065_2c5e6c27", "text": "An exampl e is P r o xy ( 2 0 7 ) . A gray C l i e n t\nalso make s it c l e ar that we haven' t a c c i d e n t a l l y omitte d the C l i e n t from the Participant s\nd i s c u s s i o n . F i g u r e B.lc s h o w s variou s relationship s betwee n c l a s s e s . The OMT notatio n for c l a ss\ninheritanc e is a triangl e c o n n e c t i n g a s u b c l a s s ( L i n e S h a p e in the figure ) to its paren t\nc l a ss ( S h a p e ) . An o b j e c t r e f e r e n c e r e p r e s e n t i n g a p a r t - o f or a g g r e g a t i o n r e l a t i o n s h i p is\nindicate d by an arrowheade d l i ne with a diamon d at the base. The arrow point s to\nt he c l a ss that is a g g r e g a t e d ( e . g ., S h a p e ) . An a r r o w h e a d e d l i ne withou t t he d i a m o n d\nd e n o t e s acquaintanc e ( e . g ., a L i n e S h a p e k e e ps a referenc e to a C o l o r o b j e c t , w h i c h other\ns h a p e s may share) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1065, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_design_patterns_gof_chunk_1066_5ab9173e", "text": "g ., a L i n e S h a p e k e e ps a referenc e to a C o l o r o b j e c t , w h i c h other\ns h a p e s may share) . A name for the referenc e may appea r near the base to d i s t i n g u i s h\nit from o t h er r e f e r e n c e s . 2\nAnothe r usefu l t h i ng to s h ow is whic h c l a s s e s instantiat e w h i c h o t h e r s . We use a\ndashe d arrowheade d l i ne to indicat e t h i s, s i n ce O MT doesn' t suppor t i t. We c a ll t h is t he \n\" c r e a t e s \" r e l a t i o n s h i p . T he a r r ow p o i n t s to t he c l a ss that's i n s t a n t i a t e d . In F i g u r e B . l c,\nC r e a t i o n T o o l create s L i n e S h a p e o b j e c t s . OMT a l so define s a filled c i r c le to mean \" m o r e than o n e .\" Whe n the c i r c le appear s at\nt he h e ad of a r e f e r e n c e , it m e a n s m u l t i p l e o b j e c t s a re b e i ng r e f e r e n c e d or a g g r e g a t e d . Figur e B.lc s h o w s that Drawin g aggregate s multipl e object s of type S h a p e .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1066, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_design_patterns_gof_chunk_1067_e34515b0", "text": "Figur e B.lc s h o w s that Drawin g aggregate s multipl e object s of type S h a p e . F i n a l l y , we've augmente d OMT with pseudocod e annotation s to let us s k e t c h the im-\np l e m e n t a t i o n s of o p e r a t i o n s . F i g u r e B . ld s h o w s t he p s e u d o c o d e a n n o t a t i o n f or t he\nDraw operation on the Drawing class. B.2 Object Diagram\nAn o b j e c t d i a g r a m s h o w s i n s t a n c e s e x c l u s i v e l y . It p r o v i d e s a s n a p s h o t of t he o b j e c t s in a\nd e s i g n pattern . T he o b j e c t s a re name d \"aSomething\", wher e Something is t he c l a ss of t he\no b j e c t . Our s y m b o l for an o b j e c t (modifie d s l i g h t l y from standar d O M T ) is a r o u n d e d\n2 O MT a l so d e f i n e s a s s o c i a t i o n s betwee n c l a s s e s , w h i c h appea r as plain l i n es betwee n c l a ss b o x e s . A s s o c i -\nation s are bidirectional .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1067, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 932}}
{"id": "computer_science_design_patterns_gof_chunk_1068_fbb1a0af", "text": "A s s o c i -\nation s are bidirectional . Althoug h a s s o c i a t i o n s are appropriat e durin g analysis , we feel they'r e too h i g h - l e v e l \nfor e x p r e s s i n g the r e l a t i o n s h i p s in d e s i g n patterns , s i m p l y b e c a u s e a s s o c i a t i o n s must be m a p p e d down to\no b j e c t reference s or pointer s durin g d e s i g n . Objec t reference s are intrinsicall y d i r e c t e d and are therefor e\nb e t t er s u i t ed to t he r e l a t i o n s h i p s that c o n c e r n u s. F or e x a m p l e , D r a w i n g k n o w s a b o u t S h a p e s , b ut t he S h a p e s\ndon't know about the Drawing they're in. You can't express this relationship with associations alone. ptgSECTION B . 2 OBJECT D I A G R A M 365\nF i g u r e B . 1 : C l a s s d i a g r a m n o t a t i o n\n\nptg3 6 6 GUIDE T O N O T A T I O N APPENDIX B\nb ox with a l i ne s e p a r a t i n g t he o b j e c t n a me from a ny o b j e c t r e f e r e n c e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1068, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_design_patterns_gof_chunk_1069_31019d79", "text": "1 : C l a s s d i a g r a m n o t a t i o n\n\nptg3 6 6 GUIDE T O N O T A T I O N APPENDIX B\nb ox with a l i ne s e p a r a t i n g t he o b j e c t n a me from a ny o b j e c t r e f e r e n c e s . A r r o w s i n d i c a t e\nt h e object referenced. Figure B.2 s h o w s an example. B . 3 Interaction Diagram\nAn i n t e r a c t i o n d i a g r a m s h o w s t he o r d er in w h i c h r e q u e s t s b e t w e e n o b j e c t s g et e x e c u t e d . F i g u r e B.3 is an interactio n diagra m that s h o w s how a s h a pe g e ts adde d to a drawing. T i me flows from t op to botto m in an i n t e r a c t i o n d i a g r a m . A s o l id v e r t i c a l l i ne i n d i c a t e s\nthe lifetim e of a particula r object . The namin g conventio n for o b j e c t s is the s a me as for\no b j e c t d i a g r a m s — t h e c l a ss n a me p r e f i x e d by t he l e t t er \" a\" ( e . g ., a S h a p e ) .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1069, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 906}}
{"id": "computer_science_design_patterns_gof_chunk_1070_f5416245", "text": "The namin g conventio n for o b j e c t s is the s a me as for\no b j e c t d i a g r a m s — t h e c l a ss n a me p r e f i x e d by t he l e t t er \" a\" ( e . g ., a S h a p e ) . If t he o b j e c t\ndoesn' t get instantiate d until a f t er the b e g i n n i n g of time as r e c o r d e d in the diagram ,\nthen i ts v e r t i c a l l i ne a p p e a r s d a s h e d until t he p o i nt of c r e a t i o n . A vertica l r e c t a n g l e s h o w s that an o b j e c t is a c t i v e ; that i s, it is handlin g a r e q u e s t . T he\no p e r a t i o n c an s e nd r e q u e s t s to o t h er o b j e c t s ; t h e se a re i n d i c a t e d w i th a h o r i z o n t a l a r r ow\npointin g to t he r e c e i v i n g o b j e c t . T he name of t he r e q u e s t is show n a b o v e t he a r r o w . A\nr e q u e s t to c r e a te an o b j e c t is s h o w n with a d a s h e d a r r o w h e a d e d l i n e.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1070, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 906}}
{"id": "computer_science_design_patterns_gof_chunk_1071_aa235501", "text": "T he name of t he r e q u e s t is show n a b o v e t he a r r o w . A\nr e q u e s t to c r e a te an o b j e c t is s h o w n with a d a s h e d a r r o w h e a d e d l i n e. A r e q u e s t to t he\ns e n d i n g object itself points back to the sender.F i g u r e B.3: Interaction diagram notation\n\nptgSECTION B.3 INTERACTION DIAGRAM 367\nF i g u r e B.3 show s that the first r e q u e s t is f r om a C r e a t i o n T o o l to creat e a L i n e S h a p e . Later ,\naLineShap e is Adde d to aDrawing , whic h prompt s aDrawin g to s e nd a Refres h reques t\nto itself . Note that aDrawin g s e n ds a Draw r e q u e s t to a L i n e S h a p e as part of the Refres h\noperation. ptg\nThis page intentionally left blank \n\nptgA p p e n d i x C\nF o u n d a t i o n C l a s s e s\nT h is appendi x d o c u m e n t s t he foundatio n c l a s s e s we u se in t he C ++ s a m p l e c o de of\ns e v e r a l d e s i g n patterns .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1071, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_design_patterns_gof_chunk_1072_9313f586", "text": "W e ' v e i n t e n t i o n a l l y kept t he c l a s s e s s i m p l e a nd m i n i m a l . We\nd e s c r i b e t he followin g c l a s s e s :\n• List, an o r d e r e d l i st of o b j e c t s . •I t e r a t o r , the interfac e for a c c e s s i n g an aggregate' s o b j e c t s in a s e q u e n c e . •L i st I t e r a t o r , an iterato r f or traversin g a L i s t . •P o i n t , a t w o - d i m e n s i o n a l point. •R e c t , an a x i s - a l i g n e d r e c t a n g l e . S o me newe r C ++ standar d t y p es m ay n ot be a v a i l a b l e on a ll c o m p i l e r s . In p a r t i c u l a r , if\nyour c o m p i l e r d o e s n ' t defin e b o o l , then defin e it manuall y as\nt y p e d e f i nt b o o l ;\nc o n s t int t r ue = 1; \nc o n s t i n t false = 0 ;\nC . 1 List\nT he L i st c l a ss templat e p r o v i d e s a b a s ic c o n t a i n e r for s t o r i n g an o r d e r e d l i st of o b j e c t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1072, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 920}}
{"id": "computer_science_design_patterns_gof_chunk_1073_23682485", "text": "1 List\nT he L i st c l a ss templat e p r o v i d e s a b a s ic c o n t a i n e r for s t o r i n g an o r d e r e d l i st of o b j e c t s . L i st s t o r es e l e m e n t s by v a l u e , w h i c h m e a n s it work s f or b u i l t - i n t y p es as w e ll as c l a ss \ni n s t a n c e s . For e x a m p l e , Li s t < i n t > d e c l a r e s a l i st of ints. But m o st of the pattern s use\nL i s t to s t o re p o i n t e r s to o b j e c t s , as in L i s t < G lyph * >. That way L i st can be u s ed for\nh e t e r o g e n e o u s l i s t s . 3 6 9\n\nptg370 FOUNDATION CLASSES APPENDIX C\nFor c o n v e n i e n c e , L i st a l so p r o v i d e s synonym s for s t a ck o p e r a t i o n s , whic h make c o de\nthat u s es L i st for stack s m o re e x p l i c i t withou t definin g anothe r c l a s s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1073, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 813}}
{"id": "computer_science_design_patterns_gof_chunk_1074_753c8285", "text": "t e m p l a t e < c l a s s I t e m >\nc l a s s L i st { \np u b l i c :\nL i s t ( l o n g s i ze = D E F A U L T _ L I S T _ C A P A C I T Y ) ;\nL i s t ( L i s t & ) ; \n~ L i s t ( ) ;\nList& operator=(cons t List&);\nl o ng C o u n t () const;\nI t e m& Get(long i n d e x) c o n s t;\nI t e m& First() const;\nI t e m& Last() const; \nb o ol I n c l u d e s ( c o n s t I t e m &) const;\nvoid Append(cons t I t e m & );\nvoid P r e p e n d ( c o n s t I t e m & ) ;\nvoid Remove(cons t I t e m & );\nv o id RemoveLast( ) ; \nvoid RemoveFirst( ) ; \nvoid RemoveAll();\nI t e m& T o p () c o n s t; \nvoid P u s h ( c o n s t I t e m & ); \nI t e m& Pop();\n} ;\nT he followin g s e c t i o n s d e s c r i b e t h e se operation s in g r e a t e r d e t a i l . C o n s t r u c t i o n , D e s t r u c t i o n , Initialization , a nd A s s i g n m e n t\nList(long size) \ninitialize s the l i s t. The s i ze paramete r is a hint f or the i n i t i a l numbe r of e l e m e n t s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1074, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_design_patterns_gof_chunk_1075_99359766", "text": "The s i ze paramete r is a hint f or the i n i t i a l numbe r of e l e m e n t s . L i s t ( L i s t & ) \no v e r r i d e s the defaul t c o py constructo r so that membe r data are i n i t i a l i z e d p r o p -\ne r l y . ~ L i s t ( )\nfrees the l i s t 's interna l data structure s but not the e l e m e n t s in the l i s t. The c l a ss is\nnot d e s i g n e d for s u b c l a s s i n g ; therefor e the destructo r i s n 't virtual. L i s t& o p e r a t o r ^ ( c o n s t L i s t &) \nimplements the assignment operation to assign member data properly. ptgSECTION C.I LIST 3 7 1\nA c c e s s i n g\nT h e se operation s p r o v i d e b a s ic a c c e s s to t he l i s t 's e l e m e n t s . l o ng Count() c o n s t\nreturn s the numbe r of o b j e c t s in the l i s t . I t e m Sc G et ( l o ng i n d e x) c o n s t\nreturn s the o b j e c t at the g i v en i n d e x . I t e m& First() c o n st \nreturn s the first o b j e c t in the l i s t .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1075, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_design_patterns_gof_chunk_1076_210dc8ab", "text": "I t e m Sc G et ( l o ng i n d e x) c o n s t\nreturn s the o b j e c t at the g i v en i n d e x . I t e m& First() c o n st \nreturn s the first o b j e c t in the l i s t . I t e m& Last() c o n st \nreturn s t he l a st o b j e c t in t he l i s t . Adding\nvoid Append(cons t I t e m &) \nadds the argumen t to the l i s t, makin g it the l a st element. void P r e p e n d ( c o n s t I t e m &) \nadds the argumen t to the l i s t, makin g it the first e l e m e n t . R e m o v i n g\nv o id Remove(cons t I t e m &) \nr e m o v e s the g i v en e l e m e n t from the l i s t. T h is operatio n r e q u i r e s t h at the type of\ne l e m e n t s in the l i st support s the == operato r for c o m p a r i s o n . void RemoveFirst( ) \nr e m o v e s the first e l e m e n t from the l i s t . void RemoveLast( ) \nr e m o v e s the last element from t h e list. v o i d RemoveAll()\nr e m o v e s all elements from t h e list.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1076, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_design_patterns_gof_chunk_1077_89753260", "text": "void RemoveLast( ) \nr e m o v e s the last element from t h e list. v o i d RemoveAll()\nr e m o v e s all elements from t h e list. ptg372 FOUNDATION CLASSES APPENDIX C\nS t a ck Interface\nI t e m& T o p () c o n st \nreturn s the top e l e m e n t (whe n the L i st is v i e w e d as a stack). void P u s h ( c o n s t I t e m &) \npushe s the e l e m e n t onto the stack. I t e m & P o p ( ) \np o p s the top element from the stack. C . 2 Iterator\nI t e r a t o r is an a b s t r a c t c l a ss that d e f i n e s a t r a v e r s a l interfac e for a g g r e g a t e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1077, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 570}}
{"id": "computer_science_design_patterns_gof_chunk_1078_d3909cac", "text": "I t e m & P o p ( ) \np o p s the top element from the stack. C . 2 Iterator\nI t e r a t o r is an a b s t r a c t c l a ss that d e f i n e s a t r a v e r s a l interfac e for a g g r e g a t e s . t e m p l a t e < c l a s s I t e m >\nc l a s s I t e r a t o r {\np u b l i c :\nv i r t u a l v o idF i r s t () - 0; \nv i r t u a l v o idN e x t ( ) = 0; \nv i r t u a l boolI s D o n e O c o n s t = 0;\nv i r t u a l I t emC u r r e n t l t e m ( ) c o n s t = 0 ;\np r o t e c t e d :\nI t e r a t o r ( ) ;\n} ;\nThe operation s do the following:\nvirtual v o id First() \np o s i t i o n s the iterato r to the first o b j e c t in the aggregate. virtual void Next() \np o s i t i o n s the iterato r to the next o b j e c t in the s e q u e n c e . v i r t u a l b o ol I s D o n e ( ) c o n s t \nreturn s t r ue when there are no more object s in the s e q u e n c e . virtual I t em Currentltem( ) c o n st \nreturns the object at the current position in the s e q u e n c e . C .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1078, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_design_patterns_gof_chunk_1079_d00673df", "text": "virtual I t em Currentltem( ) c o n st \nreturns the object at the current position in the s e q u e n c e . C . 3 Listlterator\nL i s t l t e r a t o r implements t h e Iterator i n t e r f a c e to traverse List objects. Its con-\nstructor takes a list to traverse as an argument. ptgSECTION C A POINT 3 7 3\nt e m p l a te < c l a ss I t e m> \nc l a ss L i s t l t e r a t o r : p u b l ic I t e r a t o rs I t e m> {\np u b l i c :\nL i s t l t e r a t o r ( c o n s t List<Item> * a L i s t ) ;\nv i r t u al v o id F i r s t ( ); \nv i r t u al v o id N e x t ( ); \nv i r t u al b o ol I s D o n e () c o n s t;\nvirtual I t e m Currentltem() const;\nC . 4 Point\nP o i nt r e p r e s e n ts a p o i nt in a t w o - d i m e n s i o n a l C a r t e s i an c o o r d i n a te s p a c e. P o i nt\ns u p p o r ts s o me m i n i m al v e c t or a r i t h m e t i c.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1079, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 855}}
{"id": "computer_science_design_patterns_gof_chunk_1080_e0c725c7", "text": "P o i nt\ns u p p o r ts s o me m i n i m al v e c t or a r i t h m e t i c. T he c o o r d i n a t e s of a P o i nt a re d e f i n ed a s\nt y p e d ef f l o at C o o r d ;\nP o i n t 's o p e r a t i o n s a re s e l f - e x p l a n a t o r y . c l a ss P o i nt {\np u b l i c :\ns t a t ic c o n st P o i nt Z e r o ;\nP o i n t ( C o o r d x = 0.0, C o o rd y = 0 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1080, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 365}}
{"id": "computer_science_design_patterns_gof_chunk_1081_748af42e", "text": "c l a ss P o i nt {\np u b l i c :\ns t a t ic c o n st P o i nt Z e r o ;\nP o i n t ( C o o r d x = 0.0, C o o rd y = 0 . 0 ) ;\nC o o rd X () c o n s t; v o id X ( C o o rd x) ;\nC o o rd Y () c o n s t; void Y ( C o o rd y) ;\nf r i e nd P o i nt o p e r a t o r + ( c o n s t P o i n t &, c o n st P o i n t & );\nf r i e nd P o i nt o p e r a t o r - ( c o n s t P o i n t &, c o n st P o i n t & ); \nf r i e nd P o i nt o p e r a t o r * ( c o n s t P o i n t &, c o n st P o i n t & );\nf r i e nd P o i nt o p e r a t o r / ( c o n s t P o i n t &, c o n st P o i n t & ) ;\nP o i n t& o p e r a t o r + = ( c o n s t P o i n t & ) ;\nP o i n t& operator-=(cons t P o i n t & );\nP o i n t& o p e r a t o r * = ( c o n s t P o i n t & );\nP o i n t& o p e r a t o r / ^ ( c o n s t P o i n t & ) ;\nP o i nt operator-();\nf r i e nd b o ol operator==(cons t P o i n t &, c o n st P o i n t & );\nf r i e nd b o ol o p e r a t o r !", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1081, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 925}}
{"id": "computer_science_design_patterns_gof_chunk_1082_2ba2f452", "text": "= ( c o n s t P o i n t &, c o n st P o i n t & ) ;\nf r i e nd o s t r e a m& o p e r a t o r « ( o s t r e a m & , c o n st P o i n t & );\nf r i e n d istream& operator» ( i s t r e a m & , Point&) ;\nT h e s t a t i c m e m b e r Z e r o r e p r e s e n t s P o i n t ( 0 , 0 ) . ptg374 FOUNDATION CLASSES APPENDIX C\nC 5 Rect\nRect r e p r e s e n ts an a x i s - a l i g n e d r e c t a n g l e. A Rect is d e f i n ed by an o r i g in p o i nt a nd\nan e x t e nt ( t h at i s, w i d th a nd h e i g h t ). T he Rect o p e r a t i o ns a re s e l f - e x p l a n a t o r y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1082, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 575}}
{"id": "computer_science_design_patterns_gof_chunk_1083_6699cb22", "text": "A Rect is d e f i n ed by an o r i g in p o i nt a nd\nan e x t e nt ( t h at i s, w i d th a nd h e i g h t ). T he Rect o p e r a t i o ns a re s e l f - e x p l a n a t o r y . c l a ss Rect {\np u b l i c :\ns t a t ic c o n st Rect Z e r o ;\nR e c t ( C o o r d x, C o o rd y, C o o rd w, C o o rd h ) ;\nR e c t ( c o n s t P o i n t& o r i g i n, c o n st P o i n t& e x t e n t ) ;\nC o o rd W i d t h () c o n s t;v o id W i d t h ( C o o r d ) ;\nC o o rd H e i g h t () c o n s t;v o id H e i g h t ( C o o r d ) ;\nC o o rd Left() c o n s t;v o id L e f t ( C o o r d ) ;\nC o o rd B o t t o m () c o n s t;v o id B o t t o m ( C o o r d ) ;\nP o i n t& O r i g i n () c o n s t;v o id O r i g i n ( c o n s t P o i n t & ) ;\nP o i n t& E x t e n t () c o n s t;v o id E x t e n t ( c o n s t P o i n t & ) ;\nv o id M o v e T o ( c o n s t P o i n t & );\nv o id M o v e B y ( c o n s t P o i n t & ) ;\nb o ol I s E m p t yO c o n s t; \nb o o l Contains(const P o i n t & ) const;\n} ;\nT h e static m e m b e r Z e r o i s e q u i v a l e n t t o t h e r e c t a n g l e\nRect(Point(0, 0 ) , Point(0, 0 ) ) ;\n\nptgB i b l i o g r a p h y\n[ A d d 9 4 ] A d d i s o n - W e s l e y , Reading , MA.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1083, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1194}}
{"id": "computer_science_design_patterns_gof_chunk_1084_eacd609d", "text": "NEXTSTEP General Reference: Release 3, \nVolumes 1 and 2,1994. [ A G 9 0 ] D . B. Anderso n a nd S. Gossain . Hierarch y evolutio n a nd t he softwar e\nl i f e c y c l e . In TOOLS '90 Conference Proceedings, p a g e s 4 1 - 5 0 , P a r i s , June\n1 9 9 0. Prentic e H a l l . [ A I S + 7 71 Christophe r Alexander , S a ra Ishikawa , Murra y S i l v e r s t e i n , M ax J a c o b s o n ,\nIngri d F i k s d a h l - K i n g , and S h l o m o Angel . A Pattern Language. Oxfor d\nUniversit y P r e s s , N ew York , 1 9 7 7 . [ A p p 8 9 1 Appl e Computer , I n c ., Cupertino , C A. Macintosh Programmers Workshop \nPascal 3 .0 Reference, 1 9 8 9 . [ A p p 9 2 1 Appl e Computer , I n c ., Cupertino , CA. Dylan. An object-oriented dynamic\nlanguage, 1 9 9 2 . [ A r v 9 1 1 Jame s Arvo . Graphics Gems I I. Academi c P r e s s , B o s t o n , M A, 1 9 9 1 . [ A S 8 5 1 B. A d e l s o n a nd E. S o l o w a y . T he r o le of domai n e x p e r i e n c e in softwar e\nd e s i g n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1084, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_design_patterns_gof_chunk_1085_d2159cab", "text": "Graphics Gems I I. Academi c P r e s s , B o s t o n , M A, 1 9 9 1 . [ A S 8 5 1 B. A d e l s o n a nd E. S o l o w a y . T he r o le of domai n e x p e r i e n c e in softwar e\nd e s i g n . IEEE Transactions on Software Engineering, 1 1 ( 1 1 ) : 1 3 5 1 - 1 3 6 0 , 1 9 8 5 . [ B E 9 3 1 Andrea s B i r r e r a nd Thoma s E g g e n s c h w i l e r . Framework s in t he financia l\ne n g i n e e r i n g d o m a i n : An e x p e r i e n c e r e p o r t . In European Conference on\nObject-Oriented Programming, page s 2 1 - 3 5 , Kaiserslautern , Germany , July\n1 9 9 3. S p r i n g e r - V e r l a g . [ B J 9 4 ]Kent B e ck and Ralp h Johnson . Pattern s generat e architectures . In European\nConference on Object-Oriented Programming, page s 1 3 9 - 1 4 9 , B o l o g n a , Italy,\nJuly 1 9 9 4. S p r i n g e r - V e r l a g . [ B o o 9 4 ]Grad y B o o c h . Object-Oriented Analysis and Design with Applications. B e n -\njamin/Cummings , Redwoo d C i t y, C A, 1 9 9 4. S e c o n d E d i t i o n . [BorSl ]A.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1085, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1014}}
{"id": "computer_science_design_patterns_gof_chunk_1086_298bca3c", "text": "[ B o o 9 4 ]Grad y B o o c h . Object-Oriented Analysis and Design with Applications. B e n -\njamin/Cummings , Redwoo d C i t y, C A, 1 9 9 4. S e c o n d E d i t i o n . [BorSl ]A. Borning . The programmin g languag e aspect s of ThingLab— a\nc o n s t r a i n t - o r i e n t e d simulation laboratory. A C M T r a n s a c t i o n s o n Program-\nming Languages and Systems, 3(4):343-387, O c t o b e r 1981. 3 7 5\n\nptg3 76 BIBLIOGRAPHY\n[ B o r 9 4 ] B o r l a n d International , I n c ., S c o t t s V a l l e y , C A. A Technical Comparison of \nBorland ObjectWindows 2.0 and Microsoft MFC 2.5,1994. [ B V 9 0 ] Grad y B o o c h a nd M i c h a e l V i l o t . T he d e s i g n of t he C ++ B o o c h c o m p o -\nnents . In Object-Oriented Programming Systems, Languages, and Applications\nConference Proceedings, p a g es 1 - 1 1, Ottawa , Canada , O c t o b e r 1 9 9 0. A CM\nP r e s s . [ C a l 9 3 ] Paul R. C a l d e r . Building User Interfaces with Lightweight Objects.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1086, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_design_patterns_gof_chunk_1087_c6742d25", "text": "A CM\nP r e s s . [ C a l 9 3 ] Paul R. C a l d e r . Building User Interfaces with Lightweight Objects. PhD t h e s i s , \nStanfor d U n i v e r s i t y , 1 9 9 3 . [ C a r 8 9 ] J. C a r o l a n . Constructin g b u l l e t - p r o o f c l a s s e s . In Proceedings C++ at Work \n'89. S I GS P u b l i c a t i o n s , 1 9 8 9 . [ C a r 9 2 ]T om C a r g i l l . C ++ Programming Style. A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 9 2 . [ C I R M 9 3 ]R oy H. C a m p b e l l , N a y e e m I s l a m , D a v i d R a i l a , a nd P e t er M a d e a n y . D e -\ns i g n i n g a nd implementin g C h o i c e s : An o b j e c t - o r i e n t e d s y s t e m in C++. Communications of t he ACM, 3 6 ( 9 ) : 1 1 7 - 1 2 6 , S e p t e m b e r 1 9 9 3 . [ C L 9 0 1Paul R. C a l d e r a nd Mark A. Linton . G l y p h s : F l y w e i g h t o b j e c t s f or u s er\ninterfaces . In ACM User Interface Software Technologies Conference, p a g es\n9 2 - 1 0 1 , S n o w b i r d , U T, O c t o b e r 1 9 9 0 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1087, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_design_patterns_gof_chunk_1088_b898a921", "text": "G l y p h s : F l y w e i g h t o b j e c t s f or u s er\ninterfaces . In ACM User Interface Software Technologies Conference, p a g es\n9 2 - 1 0 1 , S n o w b i r d , U T, O c t o b e r 1 9 9 0 . [ C L 9 2 ]Paul R. C a l d e r a nd Mark A. L i n t o n . T he o b j e c t - o r i e n t e d i m p l e m e n t a t i o n\nof a documen t e d i t o r . In Object-Oriented Programming Systems, Languages,\na nd Applications Conference Proceedings, p a g es 1 5 4 - 1 6 5 , V a n c o u v e r , B r i t i s h\nC o l u m b i a , Canada , O c t o b e r 1 9 9 2. A CM P r e s s . [ C o a 9 2 1 P e t er C o a d . O b j e c t - o r i e n t e d patterns . Communications of the ACM, \n3 5 ( 9 ) : 1 5 2 - 1 5 9 , S e p t e m b e r 1 9 9 2 . [ C o o 9 2 ] W i l l i a m R. C o o k . Interface s a nd s p e c i f i c a t i o n s f or t he S m a l l t a l k - 8 0 c o l -\nl e c t i o n c l a s s e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1088, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 881}}
{"id": "computer_science_design_patterns_gof_chunk_1089_e430c451", "text": "[ C o o 9 2 ] W i l l i a m R. C o o k . Interface s a nd s p e c i f i c a t i o n s f or t he S m a l l t a l k - 8 0 c o l -\nl e c t i o n c l a s s e s . In Object-Oriented Programming Systems, Languages, and\nApplications Conference Proceedings, p a g es 1 - 1 5, V a n c o u v e r , B r i t i s h C o l u m -\nb i a, C a n a d a , O c t o b e r 1 9 9 2. A CM P r e s s . [ C o p 9 2 ] J a m e s O. C o p l i e n . Advanced C++ Programming Styles and Idioms. A d d i s o n -\nW e s l e y , R e a d i n g , M A, 1 9 9 2 . [ C u r 8 9 ]B i ll C u r t i s . C o g n i t i v e i s s u e s in r e u s i n g softwar e artifacts . In T ed J. B i g g e r -\nstaff a nd A l an J. P e r l i s , e d i t o r s , Software Reusability, Volume I I: Applications\na nd Experience, p a g es 2 6 9 - 2 8 7 . A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 8 9 . [ d C L F 9 3 ]D e n n i s de C h a m p e a u x , D o ug L e a, a nd P e n e l o p e F a u r e . Object-Oriented \nSystem Development.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1089, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_design_patterns_gof_chunk_1090_c1eb6a14", "text": "A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 8 9 . [ d C L F 9 3 ]D e n n i s de C h a m p e a u x , D o ug L e a, a nd P e n e l o p e F a u r e . Object-Oriented \nSystem Development. A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 9 3 . [ D e u 8 9 ]L. P e t er D e u t s c h . D e s i g n r e u se a nd framework s in t he S m a l l t a l k - 8 0 s y s -\ntem. In T ed J. B i g g e r s t a f f a nd Alan J. P e r l i s , e d i t o r s , Software Reusability,\nVolume II: A p p l i c a t i o n s and Experience, p a g e s 5 7 - 7 1 . A d d i s o n - W e s l e y , R e a d -\ni n g , MA, 1989. ptgBIBLIOGRAPHY 3 7 7\n[ E d e 9 2 ] D. R. E d e l s o n . S m a r t p o i n t e r s : T h e y ' r e smart , b ut they'r e n ot p o i n t e r s . In\nProceedings of t he 1992 USENIX C ++ Conference, p a g e s 1 - 1 9, Portland , O R,\nA u g u s t 1 9 9 2. U S E N I X A s s o c i a t i o n . [ E G 9 2 ] T h o m a s E g g e n s c h w i l e r a nd E r i ch Gamma.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1090, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_design_patterns_gof_chunk_1091_4b3a21bf", "text": "U S E N I X A s s o c i a t i o n . [ E G 9 2 ] T h o m a s E g g e n s c h w i l e r a nd E r i ch Gamma. T he E T + + S w a p s M a n a g e r :\nU s i ng o b j e c t t e c h n o l o g y in t he financia l e n g i n e e r i n g d o m a i n . In Object-\nOriented Programming Systems, Languages, and Applications Conference Pro-\nceedings, p a g e s 1 6 6 - 1 7 8 , V a n c o u v e r , B r i t i s h C o l u m b i a , C a n a d a , O c t o b e r\n1 9 9 2. A CM P r e s s . [ E S 9 0 ] Margare t A. E l l is and Bjarn e Stroustrup . The Annotated C++ Reference \nManual. A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 9 0 . [ F o o 9 2 lB r i an F o o t e . A fracta l m o d e l of t he l i f e c y c l e s of r e u s a b l e o b j e c t s . O O P -\nS LA '92 Workshop on Reuse, O c t o b e r 1 9 9 2. V a n c o u v e r , B r i t i s h C o l u m b i a ,\nCanada. [ G A 8 9 ]S. G o s s a i n a nd D . B. A n d e r s o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1091, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 920}}
{"id": "computer_science_design_patterns_gof_chunk_1092_56b61bee", "text": "O O P -\nS LA '92 Workshop on Reuse, O c t o b e r 1 9 9 2. V a n c o u v e r , B r i t i s h C o l u m b i a ,\nCanada. [ G A 8 9 ]S. G o s s a i n a nd D . B. A n d e r s o n . D e s i g n i n g a c l a ss h i e r a r c h y f or d o m a i n\nr e p r e s e n t a t i o n and r e u s a b i l i t y . In TOOLS '89 Conference Proceedings, p a g e s \n2 0 1 - 2 1 0 , C N IT Paris—L a D e f e n s e , F r a n c e , Novembe r 1 9 8 9. P r e n t i c e H a l l . [ G a m 9 1 1E r i ch Gamma . Object-Oriented Software Development based on ET++: Design\nPatterns, Class Library, Tools (in German) . PhD t h e s i s , U n i v e r s i t y of Zuric h\nInstitutfiir Informatik, 1 9 9 1 . [ G a m 9 2 ]E r i ch Gamma . Object-Oriented Software Development based on ET++: Design \nPatterns, Class Library, Tools ( in G e r m a n ) . S p r i n g e r - V e r l a g , B e r l i n , 1 9 9 2 . [ G l a 9 0 ]Andre w G l a s s n e r . Graphics Gems. A c a d e m i c P r e s s , B o s t o n , M A, 1 9 9 0 . [ G M 9 2 ]M. Graha m a nd E. Mettala .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1092, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1019}}
{"id": "computer_science_design_patterns_gof_chunk_1093_1e266876", "text": "S p r i n g e r - V e r l a g , B e r l i n , 1 9 9 2 . [ G l a 9 0 ]Andre w G l a s s n e r . Graphics Gems. A c a d e m i c P r e s s , B o s t o n , M A, 1 9 9 0 . [ G M 9 2 ]M. Graha m a nd E. Mettala . T he D o m a i n - S p e c i f i c Softwar e Architectur e\nProgram . In Proceedings of DARPA Software Technology Conference, 1992,\np a g e s 2 0 4 - 2 1 0 , A p r il 1 9 9 2. A l so p u b l i s h e d in CrossTalk, T he Journal of\nDefense Software Engineering, p a g e s 1 9 - 2 1 , 3 2 , O c t o b e r 1 9 9 2 . [ G R 8 3 ]A d e l e J. G o l d b e r g and D a v i d R o b s o n . Smalltalk-80: The Language and Its \nImplementation. A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 8 3 . [ H H M V 9 2 ]Richar d H e l m , T i en Huynh , K im Marriott , a nd John V l i s s i d e s . An o b j e c t -\no r i e n t e d architectur e f or c o n s t r a i n t - b a s e d g r a p h i c a l e d i t i n g .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1093, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 912}}
{"id": "computer_science_design_patterns_gof_chunk_1094_ace662c4", "text": "An o b j e c t -\no r i e n t e d architectur e f or c o n s t r a i n t - b a s e d g r a p h i c a l e d i t i n g . In Proceedings\nof the Third Eurographics Workshop on Object-Oriented Graphics, p a g e s 1 - 2 2,\nC h a m p e r y , S w i t z e r l a n d , O c t o b e r 1 9 9 2. A l so a v a i l a b l e as I BM R e s e a r c h\nD i v i s i o n T e c h n i c a l Repor t RC 1 8 5 24 ( 7 9 3 9 2 ) . [ H O 8 7 ]D a n i e l C. H a l b e r t a nd P a t r i c k D. O ' B r i e n . O b j e c t - o r i e n t e d d e v e l o p m e n t . IEEE Software, 4 ( 5 ) : 7 1 - 7 9 , S e p t e m b e r 1 9 8 7 . [ I O N 9 4 ] I O NA T e c h n o l o g i e s , L t d ., D u b l i n , I r e l a n d . Programmer's Guide f or Orbix, \nVersion 1 . 2 , 1994. ptg3 78 BIBLIOGRAPHY\n[ J C J O 9 2 ]Ivar J a c o b s o n , Magnu s C h r i s t e r s o n , Patri k Jonsson , and Gunna r O v e r -\ngaard . Object-Oriented Software Engineering—A Use Case Driven Approach. A d d i s o n - W e s l e y , Wokingham , England , 1 9 9 2 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1094, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_design_patterns_gof_chunk_1095_e9f66201", "text": "Object-Oriented Software Engineering—A Use Case Driven Approach. A d d i s o n - W e s l e y , Wokingham , England , 1 9 9 2 . [ J F 8 8 ]R a l ph E. J o h n s o n a nd B r i an F o o t e . D e s i g n i n g r e u s a b l e c l a s s e s . Journal of \nObject-Oriented Programming, l ( 2 ) : 2 2 - 3 5 J u n e / J u l y 1 9 8 8 . [ J M L 9 2 ]Ralp h E. J o h n s o n , Carl M c C o n n e l l , a nd J. M i c h a e l L a k e . T he R TL s y s t e m :\nA framewor k for c o de optimization . In Rober t G i e g e r i c h and S u s an L. Graham , e d i t o r s , Code Generation—Concepts, Tools, Techniques. Proceedings\nof the International Workshop on Code Generation, pages 2 5 5 - 2 7 4 , D a g s t u h l ,\nG e r m a n y , 1 9 9 2. S p r i n g e r - V e r l a g . [ J o h 9 2 ]Ralp h Johnson . Documentin g framework s u s i ng patterns .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1095, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 836}}
{"id": "computer_science_design_patterns_gof_chunk_1096_10d13653", "text": "S p r i n g e r - V e r l a g . [ J o h 9 2 ]Ralp h Johnson . Documentin g framework s u s i ng patterns . In Object-\nOriented Programming Systems, Languages, and Applications Conference Pro-\nceedings, p a g es 6 3 - 7 6 , Vancouver , B r i t i s h Columbia , Canada , O c t o b e r 1 9 9 2. A CM P r e s s . [ J Z 9 1 ]Ralph E. J o h n s o n a nd Jonatha n Z w e i g . D e l e g a t i o n in C++. Journal of \nObject-Oriented Programming, 4 ( 1 1 ) : 2 2 - 3 5 , Novembe r 1 9 9 1 . [ K i r 9 2 ]D a v i d Kirk. Graphics Gems III. Harcourt , B r a c e , J o v a n o v i c h , B o s t o n , MA, \n1 9 9 2 . [ K n u 7 3 ]Donal d E. Knuth . The Art of Computer Programming, Volumes 1, 2, and 3. A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 7 3 . [ K n u 8 4 ]D o n a l d E. Knuth . T he TEXbook. A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 8 4 . [ K o f 9 3 ]Thoma s Kofler . Robus t iterator s in ET++ . Structured Programming, 1 4 : 6 2 -\n8 5, M a r c h 1 9 9 3 . [ K P 8 8 ]Glen n E.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1096, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_design_patterns_gof_chunk_1097_06acff35", "text": "A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 8 4 . [ K o f 9 3 ]Thoma s Kofler . Robus t iterator s in ET++ . Structured Programming, 1 4 : 6 2 -\n8 5, M a r c h 1 9 9 3 . [ K P 8 8 ]Glen n E. Krasne r a nd S t e p h e n T. P o p e . A c o o k b o o k f or using t he m o d e l -\nv i ew c o n t r o l l e r user interfac e paradig m in S m a l l t a l k - 8 0 . Journal of Object-\nOriented Programming, l ( 3 ) : 2 6 - 4 9 , August/Septembe r 1 9 8 8 . [ L a L 9 4 ]W i lf LaLonde . Discovering Smalltalk. Benjamin/Cummings , Redwoo d \nC i t y, C A, 1 9 9 4 . [LCI+92 ]Mark Linton , Paul C a l d e r , John Interrante , S t e v e n T a n g , and John V l i s -\ns i d e s . Interviews Reference Manual. C S L, Stanfor d U n i v e r s i t y , 3 .1 e d i t i o n ,\n1 9 9 2 . [ L e a 8 8 ]Doug Lea. libg++ , the GNU C++ l i b r a r y . In Proceedings of the 1988 USENIX\nC ++ Conference, p a g es 2 4 3 - 2 5 6 , D e n v e r , C O, O c t o b e r 1 9 8 8. U S E N I X A s s o -\nc i a t i o n .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1097, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_design_patterns_gof_chunk_1098_373feabe", "text": "libg++ , the GNU C++ l i b r a r y . In Proceedings of the 1988 USENIX\nC ++ Conference, p a g es 2 4 3 - 2 5 6 , D e n v e r , C O, O c t o b e r 1 9 8 8. U S E N I X A s s o -\nc i a t i o n . [ L G 8 6 ]B a r b a r a L i s k o v and J o hn Guttag . Abstraction and Specification in Program \nDevelopment. M c G r a w - H i l l , New Y o r k , 1986. ptgBIBLIOGRAPHY 3 7 9\n[ L i e 8 5 ] Henr y Lieberman . T h e r e ' s more to menu s y s t e m s than meet s the s c r e e n . In SIGGRAPH Computer Graphics, p a g es 1 8 1 - 1 8 9 , S an F r a n c i s c o , C A, J u ly\n1 9 8 5 . [ L i e 8 6 ] Henr y L i e b e r m a n . U s i ng p r o t o t y p i c a l o b j e c t s to i m p l e m e n t s h a r e d b e -\nhavio r in object-oriente d s y s t e m s . In Object-Oriented Programming Sys-\ntems, Languages, and Applications Conference Proceedings, p a g es 2 1 4 - 2 2 3 ,\nPortland , O R, Novembe r 1 9 8 6 . [ L i n 9 2 ] Mark A. L i n t o n . Encapsulatin g a C++ l i b r a r y .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1098, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_design_patterns_gof_chunk_1099_03e84985", "text": "[ L i n 9 2 ] Mark A. L i n t o n . Encapsulatin g a C++ l i b r a r y . In Proceedings of the 1992\nUSENIX C ++ Conference, pages 5 7 - 6 6 , Portland , O R, Augus t 1 9 9 2. A CM\nP r e s s . [ L P 9 3 ] Mark Linto n and Chuc k P r i c e . B u i l d i n g distribute d user interface s with\nF r e s c o . In Proceedings of the 7th X Technical Conference, pages 7 7 - 8 7 , B o s t o n ,\nM A, Januar y 1 9 9 3 . [ L R 9 3 ] Danie l C. Lync h a nd Marshal l T. R o s e . Internet System Handbook. A d d i s o n -\nW e s l e y , Reading , M A, 1 9 9 3 . [ L V C 8 9 ] Mark A. Linton , John M. V l i s s i d e s , and Paul R. C a l d e r . C o m p o s i n g u s er\ninterface s with Interviews . Computer, 2 2 ( 2 ) : 8 - 2 2 , Februar y 1 9 8 9 . [ M a r 9 1 ]Bruce Martin . The separatio n of interfac e and implementatio n in C++. In\nProceedings of t he 1991 USLNIX C ++ Conference, p a g es 5 1 - 6 3 , W a s h i n g t o n ,\nD . C ., April 1 9 9 1. USENI X Association. [ M c C 8 7 ]Paul M c C u l l o u g h .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1099, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1007}}
{"id": "computer_science_design_patterns_gof_chunk_1100_5370cb6a", "text": "In\nProceedings of t he 1991 USLNIX C ++ Conference, p a g es 5 1 - 6 3 , W a s h i n g t o n ,\nD . C ., April 1 9 9 1. USENI X Association. [ M c C 8 7 ]Paul M c C u l l o u g h . Transparen t forwarding : F i r st s t e p s . In Object-Oriented\nProgramming Systems, Languages, and Applications Conference Proceedings, \np a g es 3 3 1 - 3 4 1 , O r l a n d o , F L, O c t o b e r 1 9 8 7. A CM P r e s s . [ M e y 8 8 ]Bertran d M e y e r . Object-Oriented Software Construction. S e r i e s in Compute r \nS c i e n c e . Prentic e H a l l, Englewoo d Cliffs , N J, 1 9 8 8 . [ M u r 9 3 1Rober t B. Murray . C++ Strategies and Tactics. A d d i s o n - W e s l e y , R e a d i n g , \nM A, 1 9 9 3 . [ O J 9 0 ]W i l l i a m F. O p d y k e a nd R a l ph E. J o h n s o n . R e f a c t o r i n g : An a id in d e -\ns i g n i n g applicatio n framework s and e v o l v i n g o b j e c t - o r i e n t e d s y s t e m s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1100, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_design_patterns_gof_chunk_1101_fc34adde", "text": "O p d y k e a nd R a l ph E. J o h n s o n . R e f a c t o r i n g : An a id in d e -\ns i g n i n g applicatio n framework s and e v o l v i n g o b j e c t - o r i e n t e d s y s t e m s . In\nSOOPPA Conference Proceedings, p a ges 1 4 5 - 1 6 1 , Maris t C o l l e g e , P o u g h -\nk e e p s i e , N Y, S e p t e m b e r 1 9 9 0. A CM P r e s s . [ O J 9 3 ]W i l l i a m F. O p d y k e a nd R a l ph E. J o h n s o n . C r e a t i n g a b s t r a c t s u p e r c l a s s e s\nby refactoring . In Proceedings of the 21st Annual Computer Science Conference\n(ACM C SC '93), p a g es 6 6 - 7 3 , I n d i a n a p o l i s , I N, F e b r u a r y 1 9 9 3 . [ P + 8 8 ]Andre w J. Palay et a l. The Andre w T o o l k i t : An o v e r v i e w . In Proceedings\nof t he 1988 Winter USENIX Technical Conference, p a g es 9 - 2 1, D a l l a s , T X,\nFebruary 1988. USENIX Association. ptg3 80 BIBLIOGRAPHY\n[ P a r 9 0 ] P a r c P l a c e S y s t e m s , Mountai n V i e w , C A.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1101, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_design_patterns_gof_chunk_1102_56b2a56d", "text": "USENIX Association. ptg3 80 BIBLIOGRAPHY\n[ P a r 9 0 ] P a r c P l a c e S y s t e m s , Mountai n V i e w , C A. ObjectWorks\\Smalltalk Release 4 \nUsers Guide, 1 9 9 0 . [ P a s 8 6 ] Geoffre y A. P a s c o e . Encapsulators : A new softwar e paradig m in\nS m a l l t a l k - 8 0 . In Object-Oriented Programming Systems, Languages, and Ap-'\nplications Conference Proceedings, p a g es 3 4 1 - 3 4 6 , P o r t l a n d , O R, O c t o b e r\n1 9 8 6. A CM P r e s s . [ P u g 9 0 ] W i l l i a m P u g h . S k i p l i s t s : A probabilisti c alternativ e to b a l a n c e d t r e e s. Communications of t he ACM, 3 3 ( 6 ) : 6 6 8 - 6 7 6 , June 1 9 9 0 . [ R B P +9 1] Jame s Rumbaugh , M i c h a e l B l a h a , W i l l i a m P r e m e r l a n i , F r e d e r i c k E d d y ,\nand W i l l i a m L o r e n s o n . Object-Oriented Modeling and Design. P r e n t i c e\nH a l l, E n g l e w o o d C l i f f s , N J, 1 9 9 1 . [ R u m 9 4 ] J a m e s Rumbaugh .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1102, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 955}}
{"id": "computer_science_design_patterns_gof_chunk_1103_d710e757", "text": "Object-Oriented Modeling and Design. P r e n t i c e\nH a l l, E n g l e w o o d C l i f f s , N J, 1 9 9 1 . [ R u m 9 4 ] J a m e s Rumbaugh . T he l i fe of an o b j e c t m o d e l : H ow t he o b j e c t m o d e l\nc h a n g e s durin g d e v e l o p m e n t . Journal of Object-Oriented Programming,\n7 ( l ) : 2 4 - 3 2 , March/Apri l 1 9 9 4 . [ S E 8 4 ] E l l i ot S o l o w a y a nd Kate E h r l i c h . Empirica l s t u d i e s of programmin g\nk n o w l e d g e . IEEE Transactions on Software Engineering, 1 0 ( 5 ) 5 9 5 - 6 0 9 , S e p -\nt e m b e r 1 9 8 4 . [ S h a 9 0 ] Y e n - P i n g S h a n . M o D E : A U I MS f or S m a l l t a l k . In A CM OOPSLA/ECOOP\n'90 Conference Proceedings, p a g es 2 5 8 - 2 6 8 , O t t a w a , O n t a r i o , C a n a d a , O c t o -\nb er 1 9 9 0. A CM P r e s s . [ S n y 8 6 ] Alan S n y d e r . Encapsulatio n a nd i n h e r i t a n c e in o b j e c t - o r i e n t e d l a n g u a g e s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1103, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_design_patterns_gof_chunk_1104_e65bf1ac", "text": "A CM P r e s s . [ S n y 8 6 ] Alan S n y d e r . Encapsulatio n a nd i n h e r i t a n c e in o b j e c t - o r i e n t e d l a n g u a g e s . In Object-Oriented Programming Systems, Languages, and Applications Confer-\nence Proceedings, p a g es 3 8 - 4 5 , P o r t l a n d , O R, N o v e m b e r 1 9 8 6. A CM P r e s s . [ S S 8 6 ] Jame s C. S p o h r e r a nd E l l i ot S o l o w a y . N o v i c e m i s t a k e s : A re t he folk w i s -\nd o ms c o r r e c t ? Communications of t he ACM, 2 9 ( 7 ) : 6 2 4 - 6 3 2 , J u ly 1 9 8 6 . [ S S 9 4 ] D o u g l a s C. S c h m i d t a nd T a t s u y a S u d a . T he S e r v i c e C o n f i g u r a t o r F r a m e -\nwork : An e x t e n s i b l e architectur e for dynamicall y c o n f i g u r i n g c o n c u r r e n t ,\nm u l t i - s e r v i c e networ k d a e m o n s . In Proceeding of the Second International\nWorkshop on Configurable Distributed Systems, page s 1 9 0 - 2 0 1 , P i t t s b u r g h ,\nP A, M a r c h 1 9 9 4.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1104, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_design_patterns_gof_chunk_1105_0a107cfd", "text": "In Proceeding of the Second International\nWorkshop on Configurable Distributed Systems, page s 1 9 0 - 2 0 1 , P i t t s b u r g h ,\nP A, M a r c h 1 9 9 4. I E EE C o m p u t e r S o c i e t y . [ S t r 9 1 ] B j a r n e S t r o u s t r u p . T he C ++ Programming Language. A d d i s o n - W e s l e y , \nR e a d i n g , M A, 1 9 9 1. S e c o n d E d i t i o n . [ S t r 9 3 ] P a ul S. S t r a u s s . I R IS I n v e n t o r , a 3D g r a p h i c s t o o l k i t . In Object-Oriented\nProgramming Systems, Languages, and Applications Conference Proceedings,\np ag es 1 9 2 - 2 0 0 , W a s h i n g t o n , D . C ., S e p t e m b e r 1 9 9 3. A CM P r e s s . [ S t r 9 4 ] Bjarn e Stroustrup . The Design and Evolution of C++. A d d i s o n - W e s l e y , \nR e a d i n g , MA, 1994. ptgBIBLIOGRAPHY 3 8 1\n[ S u t 6 3 ] I . E. Sutherland . Sketchpad: A Man-Machine Graphical Communication Sys-\ntem. P hD t h e s i s , M I T, 1 9 6 3 . [ S w e 8 5 ] Richar d E. S w e e t . The M e sa programmin g environment .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1105, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1009}}
{"id": "computer_science_design_patterns_gof_chunk_1106_e1252126", "text": "E. Sutherland . Sketchpad: A Man-Machine Graphical Communication Sys-\ntem. P hD t h e s i s , M I T, 1 9 6 3 . [ S w e 8 5 ] Richar d E. S w e e t . The M e sa programmin g environment . SIGPLAN No-\ntices, 2 0 ( 7 ) : 2 1 6 - 2 2 9 , J u ly 1 9 8 5 . [ S y m 9 3 a ] Symante c Corporation , Cupertino , C A. Bedrock Developer's Architecture \nKit, 1 9 9 3 . [ S y m 9 3 b ] S y m a n t e c C o r p o r a t i o n , C u p e r t i n o , C A. THINK Class Library Guide, 1 9 9 3 . [ S z a 9 2 ] Duan e Szafron . S P E C T a l k : An object-oriente d data specificatio n language . In Technology of Object-Oriented Languages and Systems (TOOLS 8), page s\n1 2 3 - 1 3 8 , Santa Barbara , C A, Augus t 1 9 9 2. P r e n t i c e Hall. [ U S 8 7 ] D a v i d Unga r a nd Randal l B. S m i t h . S e l f: T he powe r of s i m p l i c i t y . In\nObject-Oriented Programming Systems, Languages, and Applications Confer-\nence Proceedings, page s 2 2 7 - 2 4 2 , O r l a n d o , F L, O c t o b e r 1 9 8 7. A CM P r e s s .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1106, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_design_patterns_gof_chunk_1107_b3ee4e40", "text": "In\nObject-Oriented Programming Systems, Languages, and Applications Confer-\nence Proceedings, page s 2 2 7 - 2 4 2 , O r l a n d o , F L, O c t o b e r 1 9 8 7. A CM P r e s s . [ V L 8 8 ] John M. V l i s s i d e s and Mark A. Linton . Applyin g object-oriente d d e s i g n\nto structure d g r a p h i c s . In Proceedings of the 1988 USENIX C++ Conference,\npage s 8 1 - 9 4 , D e n v e r , C O, O c t o b e r 1 9 8 8. U S E N I X Association. [ V L 9 0 ] John M. V l i s s i d e s a nd Mark A. L i n t o n . U n i d r a w : A framewor k f or b u i l d -\ning domain-specifi c graphica l editors . ACM Transactions on Information\nSystems, 8 ( 3 ) : 2 3 7 - 2 6 8 , July 1 9 9 0 . [ W B J 9 0 ]R e b e c c a W i r f s - B r o c k and Ralp h E. Johnson . A surve y of curren t r e s e a r c h\nin o b j e c t - o r i e n t e d d e s i g n . Communications of t he ACM, 3 3 ( 9 ) : 1 0 4 - 1 2 4 , 1 9 9 0 . [ W B W W 9 0 ]R e b e c c a W i r f s - B r o c k , B r i an W i l k e r s o n , a nd L a u r e n W i e n e r .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1107, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 1016}}
{"id": "computer_science_design_patterns_gof_chunk_1108_1d9db03c", "text": "Communications of t he ACM, 3 3 ( 9 ) : 1 0 4 - 1 2 4 , 1 9 9 0 . [ W B W W 9 0 ]R e b e c c a W i r f s - B r o c k , B r i an W i l k e r s o n , a nd L a u r e n W i e n e r . Designing \nObject-Oriented Software. Prentic e H a l l, E n g l e w o o d Cliffs , N J, 1 9 9 0 . [ W G M 8 8 ]Andr e W e i n a n d , E r i ch Gamma , and R u d o l f M a r t y . ET++—A n o b j e c t -\noriente d applicatio n f r a m e w o r k in C++. In Object-Oriented Programming\nSystems, Languages, and Applications Conference Proceedings, p a g e s 4 6 - 5 7 ,\nS a n Diego, CA, September 1988. ACM Press. ptg\nThis page intentionally left blank \n\nptgI n d e x\nN a m e s of d e s i g n pattern s appea r in s m a ll c a p i t a l s : e . g ., A D A P T E R . P a ge number s in b o ld\ni n d i c a t e t he d e f i n i t i o n of a term. Number s in italics i n d i c a t e a diagra m f or t he term.", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1108, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 880}}
{"id": "computer_science_design_patterns_gof_chunk_1109_783ed0d0", "text": "g ., A D A P T E R . P a ge number s in b o ld\ni n d i c a t e t he d e f i n i t i o n of a term. Number s in italics i n d i c a t e a diagra m f or t he term. L e t t e r s after a d i a g r a m ' s p a ge n u m b e r i n d i c a t e t he k i nd of d i a g r a m : a \"c\" d e n o t e s a\nc l a ss d i a g r a m , an \"i\" d e n o t e s an i n t e r a c t i o n d i a g r a m , a nd an \"o\" d e n o t e s an o b j e c t\nd i a g r a m . For example, 88co means that a class and object diagram appears on page 8 8 .", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1109, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 511}}
{"id": "computer_science_design_patterns_gof_chunk_1110_cb42c9d5", "text": "For example, 88co means that a class and object diagram appears on page 8 8 . abstrac t c l a ss 1 5 ,1 6 c, 3 5 9 , 3 6 4 , 365c\na b s t r a c t c o u p l i n g , s ee c o u p l i n g , a b s t r a c t\nin O B S E R V E R 2 96\nA B S T R A C T F A C T O R Y 8 7\ne x t e n s i b i l i t y of 91 \nin catalo g summar y 8 \nL e x i ' s u se of 51 \nu s ed to c o n f i g u r e a s u b s y s t e m 1 9 3\nAbstrac t Factor y \nparticipan t of A B S T R A C T F A C T O R Y 88c, 8 9\nabstrac t o p e r a t i o n , see o p e r a t i o n , abstrac t\nu se to i m p l e m e n t A D A P T E R 1 4 4\na b s t r a c t s y n t a x t r ee 2 4 4 , 2 5 1 , 3 3 1\nc l a ss structur e for 2 4 4 c, 331c\nc o n s t r u c t i n g in S m a l l t a l k 2 50\no b j e c t structur e for 2 4 4 0\nA b s t r a c t E x p r e s s i o n \np a r t i c i p a n t of I N T E R P R E T E R 2 4 5 c, 2 4 5\nAbstractio n \nparticipan t of B R I D G E 153c, 1 5 4\nAbstractProduc t \np a r t i c i p a n t of A B S T R A C T F A C T O R Y 88c, 8 9\na c c u m u l a t i n g s t a te 3 36\na c q u a i n t a n c e 2 2 , 3 5 9\nC++, define d in 23 \ncompare d with a g g r e g a t i o n 23\nS m a l l t a l k , d e f i n e d in 23\nA c t i o n , s e e C O M M A N Da c t i ve i t e r a t o r , s ee i t e r a t o r , a c t i ve\nA da 4, 21 \nAdaptee\nparticipan t of ADAPTE R 1 4 1 ,1 4 1c\nA D A P T E R 1 3 9\nc o m p a r e d with B R I D G E 1 6 1 , 2 1 9\nc o m p a r e d with D E C O R A T O R 1 84\ncompare d with PROX Y 2 16 \nin c a t a l o g summary 8\nAdapte r \nparticipan t of A D A P T E R 1 4 1 ,1 4 1 c\na d a p t e r 1 40 \nc l a ss adapte r 1 4 1 ,1 4 1c \no b j e c t adapte r 1 4 1 ,1 4 1c\nparameterize d 1 45 \np l u g g a b l e , see p l u g g a b l e adapte r\nt w o - w a y 1 4 3 ,1 4 3 c\nadorne r 1 79\nAggregate\nparticipan t of ITERATO R 259,259c\naggregat e o b j e c t 2 57 \na g g r e g a t i o n 2 2, 3 5 9\nC++, d e f i n e d in 23 \ncompare d with acquaintanc e 23\nnotatio n for 23 \nS m a l l t a l k , d e f i n e d in 23\nA l e x a n d e r , Christopher x i i i , 2 , 3 5 6 , 3 5 8\n3 8 3\nA\n\nptg3 84 INDEX\na l g o r i t h m \na v o i d i n g d e p e n d e n c e on 24\nd e f i n i n g s t e ps of 3 26\nfamil y of 3 17 \ns k e l e t o n 3 2 7\nA l t e r n a t i o n E x p r e s s i o n 244co, 3 43\ni m p l e m e n t e d in S m a l l t a l k 2 4 9\naluminu m a l l oy 76\nAmbassador , see also P R O X Y\nC++idio m 2 08\nA n a l o g C l o c k 3 03\na n a l y s i s o b j e c t model\ntransformin g to d e s i g n objec t m o d e l 3 53\na n c e s t o r c l a ss 3 6 1, s ee also c l a s s, paren t\nA n d e r s o n , B r u ce x i, 3 57 \nAndEx p 2 53 \nAndre w T o o l k i t\nu se of O B S E R V E R 3 03 \nA p p l i c a t i o n 1 0 7 ,1 0 7 c, 223o, 224ci, 2 3 1 , 3 2 5 , 3 2 5c\na p p l i c a t i o n p r o g r a m s 25\nA p p l i c a t i o n W i n d o w 5 3 ,5 4 c, 55c, 1 5 7 ,2 3 3 c, 234c\nArrayComposito r 42c, 3 1 5 , 3 1 5 c, 3 22\nA S C I I 7 S t r e a m 1 8 3 ,1 8 3c \na s p e c t of an o b j e c t 2 98 \nA s s i g n m e n t N o d e 333c \na s s o c i a t i o n s , s e e a l s o acquaintance, aggregation\ninOMT 364B o o l e a n\ne x p r e s s i o n 2 51\nvariabl e 2 5 4\nB o o l e a n E x p 2 52 \nB o r d e r 44,45c, 46o\nB o r d e r D e c o r a t o r 176o, 176c, 1 80\nB R I D G E 1 5 1\nc o m p a r e d with A D A P T E R 2 19\nc o n f i g u r e d by A B S T R A C T F A C T O R Y 1 55\nin c a t a l o g summar y 8 \nL e x i 's u se of 58 \nu se of d e l e g a t i o n in 2 1\nbridg e 1 52 \nb r o a d c a s t c o m m u n i c a t i o n 2 96 \nB U I L D E R 9 7\nc o m p a r e d w i th A B S T R A C T F A C T O R Y 1 0 5 ,\n1 35 \ncompare d with P R O T O T Y P E 1 35\nin c a t a l o g summar y 8 \nu se in c o m p i l e r e x a m p l e 1 8 9\nBuilde r \np a r t i c i p a n t of B U I L D E R 9 8, 9 8 c\nBureaucra t 2 3 2, s ee also C H A I N OF R E S P O N S I B I L -\nI TY \nB u t t o n 5 0 c , 223o f 2 2 4 c i , 2 2 9 , 2 7 9\n6\nB T r ee 2 02 \nb a se c l a s s, s ee c l a s s, paren t\nB e c k, Kent x i, 3 57\nB e d r o c k\nu se of D E C O R A T O R 1 7 9 , 1 8 0\nb e h a v i o r a l patter n 1 0 , 2 2 1\nc o m p a r i s o n b e t w e e n c l a ss a nd o b j e c t\ns c o pe 2 2 1\nd i s c u s s i o n 3 45 \nb l a c k - b o x r e u s e , s ee r e u s e , b l a c k - b o x\nb l o c k , S m a l l t a l k 2 70 \nB N F f o r m 247\ne x a m p l e s of 2 4 3 , 2 4 8 , 2 5 1\nB o m b e d M a z e F a c t o r y 93\nB o m b e d M a z e G a m e 1 15\nB o m b e d W a l l 9 3 , 9 4 , 1 2 4\nB o o c h C o m p o n e n t s\nu se of I T E R A T O R 2 70\nu se of S T R A T E G Y 3 2 3\nB o o c h , Grad y xiii, 2 60\nB o o c h method 3 6 3C 4 \nC a l d e r , P a ul 3 3 , 38\nc a l l b a c k functio n 2 35\nCaretaker\nparticipan t of M E M E N T O 2 8 5 ,2 8 5 c, 2 8 6i\nC a r g i l l , T om 3 08 \nC H A I N OF R E S P O N S I B I L I T Y 2 2 3\nc o m b i n e d with C O M P O S I T E 1 6 6 , 2 3 2\nc o m p a r e d with M E D I A T O R 3 48\ncompare d w i th O B S E R V E R 3 48\nd e f i n e d by p a r e n t r e f e r e n c e s 1 6 6 , 2 3 2\nin c a t a l o g summar y 8 \nu se of d e l e g a t i o n in 2 1\nC h a n g e M a n a g e r 282,299, 300c\nC h a r a c t e r 38,38c \nc h a r a c t e r\nr e p r e s e n t e d as o b j e c t 3 8 , 1 9 5 - 1 9 6\nC h e s h i r e C at 1 55 \nC h o i c e s o p e r a t i n g s y s t e m\nu se of F A C A D E 1 92\nu se of P R O X Y 2 0 9\nc l a ss 14,35 9 \na b s t r a c t , s ee abstrac t c l a ss\na d a p t e r , s e e a d a p t e r , class\nC\n\nptgI N D E X 385\ncompare d with type 16\nc o n c r e t e , see concret e c l a ss\nderive d 3 60 \nfriend , see friend c l a ss\ni n a b i l i t y to a l t er 24\ninheritance , see inheritanc e\ninstanc e 15 \nl i b r a r y , s ee t o o l k i t \nmixin , see mixin c l a ss\nnotatio n f or 1 5 , 3 6 3\nparen t 1 5 , 3 6 1 \ns u b c l a s s 15 \nt e m p l a t e , see t e m p l a t e\nc l a ss diagra m 3 6 3 , 3 6 5 c , 3 59\nc l a ss hierarchy\naddin g o p e r a t i o n s to 3 56 \nconnectin g p a r a l l e l 1 0 9 , 2 5 8 \ne x p l o s i o n 2 5 , 4 3 , 1 5 1 , 1 7 7 \nminimizin g s i ze of 1 1 3 , 1 2 0 , 1 7 7 , 2 7 7 , 3 1 7 ,\n3 48 \nv i s i t i n g m u l t i p l e 3 3 6\nc l a ss operatio n 3 59 \na l t e r n a t i v e s p r o v i d e d by S I N G L E T O N 1 2 8\nC l i e n t \nparticipan t of A B S T R A C T F A C T O R Y 88c, 89\np a r t i c i p a n t of A D A P T E R 1 4 1 ,1 4 1c\nparticipan t of BUILDE R 98,98c, 99i\nparticipan t of C H A I N O F\nR E S P O N S I B I L I T Y 225d, 226,348i\nparticipan t of COMMAN D 2 3 6 , 2 3 6 c , 237z\np a r t i c i p a n t of C O M P O S I T E 164c, 1 65\nparticipan t of FLYWEIGH T 198c, 1 99\nparticipan t of INTERPRETE R 245c, 2 46\nparticipan t of P R O T O T Y P E 1 1 9 ,1 1 9 c\nc l i e nt 11 \ni s o l a t i n g c o n c r e t e c l a s s e s from 8 9\nC l o c k T i m e r 3 02\nc l o ne operatio n 1 1 7\nu s ed in P R O T O T Y P E 1 17\nimplementin g 1 2 1\nc l o n e d o b j e c t 1 17\ninitializin g 1 2 1\nC L OS 4,260 , 3 38\nc l o s u r e 2 6 0 , 2 6 7\nC o a d , Peter 3 57\nc o de structure\nrun-tim e versu s c o m p i l e - t i m e 23\nCodeGenerationVisito r 3 3 2c\nC o l l e a g u e\ncommunicatin g with Mediato r 2 7 8 , 2 8 2\nparticipan t of M E D I A T O R 2 7 6 c o , 2 7 7, 348i\nCOMMAN D 2 33 \nc o m b i n e d with MEMENT O 239,28 7\nc o m b i n e d w i t h PROTOTYPE 2 3 8in catalo g summar y 8\nu se in Lexi 6 4\nComman d 6 0, 61 c, 2 3 3 , 2 3 3 c , 2 39\nconfigure d in Menulte m 61 \nh i s t o r y of 62 \nparticipan t of COMMAN D 236,236c , 237z,\n3 4 7i\nc o m m a n d\nC++ i d i o m , see functo r \ncopyin g befor e e x e c u t i o n 2 38 \nh i s t o r y , see histor y l i st \nimplemente d throug h C++ template s 2 3 9 ,\n2 40\nintelligenc e of 2 3 8\ncommo n vocabular y 3 52\ncommunication\nencapsulate d or distribute d 3 46\nb e t w e e n S t r a t e g y a nd C o n t e x t 3 18\nbetwee n Visito r a nd Elemen t 3 3 7\ncompilatio n dependencie s\nr e d u c i n g u s i ng F A C A D E 1 8 8\nCompile r 185,186c , 1 91\nc o m p i l e r\nexampl e in FACAD E 185,186c , 1 88\nimplemente d using V I S I T O R 3 31\nS m a l l t a l k , s ee R TL S m a l l t a l k c o m p i l e r\nComponen t \nparticipan t of C O M P O S I T E 164c, 1 6 5 , 1 6 8\nparticipan t of D E C O R A T O R 1 7 7 ,1 77 c\nC O M P O S I T E 1 63 \nc a c h i n g c h i l d r e n of 1 69 \nc h i ld managemen t 1 67 \nc o m b i n e d with INTERPRETE R 2 55 \nc o m b i n e d with I T E R A T O R 2 62\nc o m b i n e d with V I S I T O R 3 39\nc o m p a r e d w i th D E C O R A T O R 2 1 9 - 2 2 0\ncompare d with INTERPRETE R 247\ndata structur e for 1 6 9 , 1 7 0 \nin c a t a l o g summar y 8 \ninterfac e of 1 67 \nL e x i ' s u se of 40 \nparen t reference s 1 66 \nsharin g component s 1 66 \nu se in M o d e l / V i e w / C o n t r o l l e r 5\nComposit e \nparticipan t of C O M P O S I T E 164c, 1 6 5 ,1 6 5 o ,\n1 68\nCompositeEquipmen t 1 71\nC o m p o s i t i o n 41,42c, 3 1 5 ,3 1 5 c, 3 20\ncomposition , see objec t compositio n\nC o m p o s i t o r 4 1 , 4 2 , 3 1 5 , 3 1 5 c , 3 2 1\ninterfac e 41\nCompressingStream 1 8 3 c , 184\n\nptg3 86 INDEX\nconcret e c l a s s, 1 5 , 3 5 9 \navoidin g specificatio n of 24\ni s o l a t i n g c l i e n t s from 8 9\nConcreteAggregat e \nparticipan t of I T E R A T O R 259,259c\nConcreteBuilde r \nparticipan t of BUILDE R 98c, 99, 99i\nConcreteComman d \nparticipan t of COMMAN D 236,236c , 238\nConcreteComponen t \nparticipan t of D E C O R A T O R 1 7 7 ,1 7 7 c\nConcreteDecorato r \nparticipan t of D E C O R A T O R 2 7 7 c, 1 7 8\nConcreteElemen t \nparticipan t of V I S I T O R 334,334c , 335i\nConcreteFactor y \nparticipan t of A B S T R A C T F A C T O R Y 8 9\nConcreteFlyweigh t \nparticipan t of FLYWEIGH T 198co, 1 9 9\nConcreteHandle r\nparticipan t of CHAI N O F\nRESPONSIBILIT Y 2 2 5 c, 2 26\nConcretelmplementor\nparticipan t of BRIDG E 153c, 1 54\nConcretelterator\nparticipan t of I T E R A T O R 259,259c\nC o n c r e t e O b s e r v e r\nparticipan t of O B S E R V E R 294c, 295,295i\nConcreteProduct\nparticipan t of A B S T R A C T F A C T O R Y 8 8, 89\nparticipan t of FACTOR Y METHO D 1 0 8 ,1 0 8 c\nConcretePrototyp e \nparticipan t of P R O T O T Y P E 1 1 9 ,1 1 9 c\nC o n c r e t e S t a t e \nparticipan t of S T A T E 3 0 7 ,3 0 7 c\nConcreteStrateg y \nparticipan t of STRATEG Y 316c, 3 1 6\nConcreteSubjec t \nparticipan t of OBSERVE R 294c, 2 9 5 , 2 9 5 ?", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1110, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 10164}}
{"id": "computer_science_design_patterns_gof_chunk_1111_9b1adde6", "text": "Concret e Visito r \nparticipan t 3 3 4, 334c, 3 3 5 *\nconditiona l statement s \navoidin g using S T A T E 3 07\navoidin g using S T R A T E G Y 3 1 7\nc o n s o l i d a t i o n p h a se of lifecycl e 3 53\nconstrain t s o l v i n g 282,283\nsee also ThingLab , Q O C A\nConstraintSolve r 2 8 3 - 2 8 4 , 2 88\nconstructo r 3 60 \nContex t 2 5 2\nparticipan t of INTERPRETE R 2 4 5 c, 2 46\nparticipan t of S T A T E 3 0 6, 306c\nparticipant of STRATEGY 3 1 6 c , 316contro l flow \ne n c a p s u l a t i n g , see M E D I A T O R\ni n v e r s i o n of 2 7\nC o p l i e n , Jame s 1 2 5 , 1 5 3 , 1 6 0 , 2 4 2 , 3 1 3 , 3 5 7\nc o p y\ndeep 1 21 \non write 2 10\nshallo w 1 2 1\nCountingMazeBuilde r 1 04\ncouplin g 3 6 0\na b s t r a c t 1 8 8 , 2 7 8 , 2 9 6 , 3 59 \nl o o se 24,26 , 2 7 7 , 3 4 7 , see also d e c o u p l i n g\nr e d u c i n g 2 4 , 1 8 7 , 1 8 8 , 2 2 3 , 2 2 6 \ntight 2 4\nCreateMaz e o p e r a t i o n 84 \nA B S T R A C T F A C T O R Y varian t ( C + + ) 92\nA B S T R A C T F A C T O R Y varian t ( S m a l l t a l k ) 94\nBUILDE R varian t 1 02 \nF A C T O R Y M E T H O D varian t 1 14\nP R O T O T Y P E varian t (Smalltalk ) 1 2 3 , 1 2 5\nc r e a t i o n a l patter n 1 0 ,8 1\nd i s c u s s i o n of 1 3 5\nC r e a t o r \nparticipan t of F A C T O R Y METHO D 1 0 8 ,1 0 8c\ni m p l e m e n t a t i o n of 1 1 1, 1 1 3\nCursor , see I T E R A T O R\nc u r s o r , s e e i t e r a t o r , c u r s o r\nD\ndata membe r 360\nDebuggingGlyp h 1 82\nD E C O R A T O R 1 7 5\ncompare d with ADAPTE R 1 7 5 , 1 8 4\ncompare d with C O M P O S I T E 4 4 , 1 7 3 , 2 1 9 -\n2 20 \ncompare d with P R O X Y 2 1 6 , 2 1 9 - 2 2 0\ncompare d with S T R A T E G Y 1 79 \nin catalo g summar y 8 \nL e x i ' s use of 45c, 46o, 47\nlightweigh t versu s heavyweigh t 1 7 9\nDecorato r 276,18 0 \nparticipan t of D E C O R A T O R 1 7 7 , 1 7 7 c , 180o\ndecorato r 1 75 \nd e c o u p l i n g , see also c o u p l i n g , l o o s e\ninterfac e a nd implementatio n 1 54\ns e n d e r s a nd r e c e i v e r s 3 4 6\ndeep c o p y , s ee c o p y, d e ep\ndelegat e 2 0 , 1 4 4\nd e l e g a t i o n 2 0 , 278,360\ncompared with inheritance 2 0 - 2 1\n\nptgI N D E X 387\ni m p l e m e n t i n g pluggabl e adapter s\nwith 1 4 4\npattern s that rely on 21\nd e p e n d e n c y 2 9 3\nm a n a g i n g c o m p l e x 2 99\nD e p e n d e n t s , s ee O B S E R V E R\nd e r i v e d c l a s s, s ee c l a s s, d e r i v e d\nd e s i g n\ndeja-vu 2 \nd e n s i t y 3 58 \nd o c u m e n t i n g with pattern s 2 7 , 3 5 2\nfor c h a n g e 23 \np o e t r y of 3 56 \nf or r e u se 2 3\nd e s i g n o b j e c t mode l 3 53\nd e s i g n patter n 3 6 0\nadjunc t to d e s i g n m e t h o d o l o g y 3 53\na s p e c t s of d e s i g n v a r i e d by 30\nbenefit s 3 51 \nc a t a l o g summar y 8 \nc a t a l o g templat e 6 \nc l a s s i f i c a t i o n 10 \nc o m p a r e d with framework s 28\ndiagra m of r e l a t i o n s h i p s 12\nd o c u m e n t i n g d e s i g n s with 2 7 , 3 5 2\ne s s e n t i a l e l e m e n t s 3 \nfindin g 3 55 \nh i s t o r y of 3 55 \nh ow to u se 29 \np u r p o s e 10 \nrefactorin g with 3 53 \ns c o pe 10 \ns e l e c t i o n of 28 \nt a b le of 1 0\ndestructo r 3 6 0\ne n s u r i n g iterator' s is c a l l ed 2 6 6\nD i a l o g 2 2 3 , 2 3 1\nD i a l o g D i r e c t o r 2 7 4 o, 2 7 5 c z , 2 78\nD i a l o g W i n d o w 53,54c, 55c\nD i g i t a l C l o c k 3 02 \nD i r e c t o r\nparticipan t of BUILDE R 98c, 9 9, 9 9i\nD i r e c t o r y B r o w s e r 144,144c , 145c\ndiscretionar y glyph 75 \nd i s p a t c h\nd o u b l e 3 38\nmultipl e 3 39\ns i n g le 3 3 8\nD oc 2 0 5, s ee also L e xi \nD o c u m e n t 1 0 7 ,1 0 7 c , 233c, 234,234c , 325,325c\ndocument\nc o l or 4 2, 3 22\nformatting 4 0l o g i c a l structur e 40\np h y s i c a l structur e 3 5\ndocumentin g d e s i g n with pattern s 2 7, 3 52\ndoesNotUnderstan d m e s s a g e\nu s ed to implemen t CHAI N OF\nR E S P O N S I B I L I T Y 2 29 \nu s ed to implemen t P R O X Y 2 1 2 , 2 1 5\nD o m a i n 192,192c\nD o or 82c,83\ne x t e n s i o n s f or P R O T O T Y P E 1 23\nd o u b l e - d i s p a t c h , see d i s p a t c h , doubl e\ndowncas t 91 \nDyla n 4\nu se of M E M E N T O 2 89\ndynami c bindin g 14,36 0\nd y n a m i c i n h e r i t a n c e 3 09\ndynamic_cast in C++ 9 1 , 1 6 8\ne - m a i l addres s \nr e a c h i n g the author s xii\nE i f f e l 1 7, 21\nE l e m e n t\np a r t i c i p a n t of V I S I T O R 3 3 4 ,3 3 4c\ne n c a p s u l a t i o n 1 1 , 3 6 0\nbreakin g with i n h e r i t a n c e 19 \nbreakin g with V I S I T O R 3 37 \npreservin g b o u n d a r i e s of 2 86 \nof a l g o r i t h m s , s ee S T R A T E G Y \nof comple x updat e s e m a n t i c s , 2 9 9, s ee also\nC h a n g e M a n a g e r \nof c o n c e p t that varie s 29,54 \nof documen t analysi s a nd traversa l 71 \nof protoco l b e t w e e n o b j e c t s , s ee M E D I A T O R\nof h ow o b j e c t s a re c r e a t e d , s ee A B S T R A C T\nF A C T O R Y , B U I L D E R , P R O T O T Y P E\nof traversal , s ee I T E R A T O R \nof r e q u e s t s 5 9, s ee also COMMAN D\nof s t a t e - s p e c i f i c b e h a v i o r , s ee S T A T E\nEnchantedMazeFactor y 93\ne n v e l o p e - l e t t e r idiom 3 13\nEquipmen t 1 7 0 , 3 4 0\nEquipmentVisito r 3 41\nerror accumulation\navoidin g durin g undo/red o 239\nET++\nu seof A B S T R A C T F A C T O R Y 95 \nu seof A D A P T E R 1 2 6 , 1 4 8 \nu seof B R I D G E 1 60 \nu seof B U I L D E R 1 05 \nu s eo f C H A I N OF R E S P O N S I B I L I T Y 2 3 2\nE\n\nptg3 88 INDEX\nu seof C O M P O S I T E 1 72 \nu seof C O M M A N D 2 42 \nu seof D E C O R A T O R 1 8 2 , 1 8 3\nuseof FACAD E 1 92 \nu seof F A C T O R Y M E T H O D 1 15\nu seof F L Y W E I G H T 2 06 \nu seof I T E R A T O R 2 61 \nu seof M E D I A T O R 2 81 \nu seof O B S E R V E R 3 03 \nu seof P R O T O T Y P E 1 2 0 , 1 2 5\nu seof P R O X Y 2 16 \nu seof S T R A T E G Y 3 2 2 - 3 2 3\nET++SwapsManage r \nu se of S T R A T E G Y 3 2 3\nETgd b 1 25 \ne x p a n s i o n p h a se of l i f e c y c l e 3 5 3 , 3 5 4\ne x p l o s i o n , s ee c l a ss hierarchy , e x p l o s i o n\nE x t e n d e d H a n d l e r 2 28 \nexterna l iterator , see iterator , externa l\ne x t r i n s i c state, s e e s t a t e , extrinsicframewor k 26,36 0 \nc o m p a r e d with d e s i g n p a t t e r n s 28\ndocumentin g with pattern s 27\ngraphica l edito r 1 17 \nsee Bedroc k \ns ee C h o i c e s \nsee ET++ \nsee HotDra w \nsee M a c A p p \nsee N E X T S T E P \nsee N e XT A p p K i t \nsee RAp p \nsee RTL Smalltal k c o m p i l e r \nsee Unidra w \ntrade-offs a s s o c i a t e d with 27\nF r e s c o 3 44\nfriend c l a ss 3 6 0\nu s ed to grant I t e r a t o r p r i v i l e g e d a c c e s s to\nc o l l e c t i o n 2 6 2\nu s ed to s u p p o r t M e m e n t o 2 87\nfuncto r 242 \nf u t u r e cash flow 323F\nF A C A D E 1 85 \nc o m p a r e d with M E D I A T O R 1 9 3 , 2 8 2\nin catalo g summar y 8 \nu se in C h o i c e s 1 9 2\nF a c a d e \nparticipan t of FACAD E 185c, 1 8 7 ,1 8 7 c\nfacad e 1 85 \nF A C T O R Y METHO D 1 0 7\nin c a t a l o g s u m m a r y 8\nlanguage-specifi c variant s 1 12\nparameterize d with produc t identifie r 1 10\nu s ed to implemen t A B S T R A C T F A C T O R Y 9 0 ,\n9 1 , 1 1 0 \nu s ed to creat e an iterato r 258\nF i l e S t r e a m 1 8 3 ,1 8 3c\nF L Y W E I G H T 1 9 5\ncombine d with C O M P O S I T E 1 6 7 , 2 0 0\nc o m b i n e d with I N T E R P R E T E R 2 47\ncombine d with S T A T E 3 08 \nin catalo g summar y 9 \nL e x i ' s u se of 39 \nparticipan t of F L Y W E I G H T 198,198co\nflyweigh t 196,196o\nmanagin g s h a r e d 2 0 0\nF l y w e i g h t F a c t o r y 2 04 \nparticipan t of F L Y W E I G H T 198co, 1 9 9\nF o n t D i a l o g D i r e c t o r 2 7 4 , 2 7 4 o , 2 7 5 cf\nF o o t e , Brian 3 53 \nforwarding requests 2 2 9G\ng db 1 26 \ng e n e r i c s 21 \nGlyp h 38,38c, 42c, 430,45c, 46o, 50c, 54c, 67c\nimplemente d as a f l y w e i g h t 2 0 1 - 2 0 4\ninterfac e 39 \ninterfac e for traversa l 66\nG l u e , s ee F A C A D E\nGlyphArraylterato r 67,67 c\nGNU g db 1 26 \ngramma r 243\nmaintainin g c o m p l e x 2 47\nGraphi c 163c, 208c, 213\nGraphicToo l Il7,118c\nguarantee d r e c e i p t of r e q u e s t 2 26\nGUIFactory 4 9 ,50c, 5 1\nH\nHamle t 1 \nHandle/Body , see also B R I D G E\nC++idio m 1 5 5 , 1 6 0\nHandler\nparticipan t of CHAI N OF \nR E S P O N S I B I L I T Y 2 2 5 , 2 2 5 c z , 348i\n\nptgINDEX 389\nhardwar e platform\ni s o l a t i n g applicatio n from 2 4\nh e l p\ncontext-sensitiv e 2 23\no n - l i n e 2 2 3\nHelpHandle r 224,224c , 227,229\nhistor y l i st 6 2 - 6 4 , 2 3 8\nc o p y i n g command s o n to 2 38\nH o l l y w o o d principl e 3 27 \nh o ok operatio n 3 2 6 , 3 2 8\ninA B S T R A C T F A C T O R Y 1 09 \ninF A C T O R Y M E T H O D 1 09 \ninP R O X Y 2 12 \ninT E M P L A T E M E T H O D 3 2 6 , 3 2 8\nHotDra w \nu se of S T A T E 3 1 3\nh ub of communicatio n 2 74\nhyphenation 6 4\nI\nI c o n W i n d o w 5 3 , 5 4 c , 1 5 1 - 1 5 2 , 1 5 1 c, 1 57\nImag e 2 0 7 o, 208c, 2 13 \nImageProx y 207o,208c \nImplementor\nparticipan t of BRIDG E 153c, 1 54\ni m p l i c i t r e c e i v e r , s ee r e c e i v e r , implici t\nincrementa l c h a n g e s 2 87\ninheritanc e 1 5 , 3 6 0\nC++, define d in 17 \nc l a ss versu s interfac e 16 \nc o m b i n e d with polymorphis m 18\ncompare d with o b j e c t c o m p o s i t i o n 1 8 , 1 7 8\ncompare d with parameterize d types 21\ndynami c 3 09 \nEiffel , define d in 17 \nimplementatio n 1 7, 3 60 \ninterfac e 1 7 , 3 6 0 \nm i x i n , see mixin c l a ss \nn o t a t i o n for 1 5 , 3 6 4 , 365c \nprope r u se of 18 \nr e u se throug h 18 \nS m a l l t a l k , define d in 1 7\ni n o r d e r traversal , see traversal , inorde r\ni n s t a n c e , see also c l a s s, i n s t a n c e\nensurin g u n i q u e n e s s , s ee S I N G L E T O N\nvariabl e 1 5 , 3 6 0\ninstantiatio n 15 \nabstractin g p r o c e s s of 48 \nnotation for 15, 364, 365c\nintegrated circuit 323interactio n diagra m 7, 3 66 \nin B U I L D E R 9 9?", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1111, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 9730}}
{"id": "computer_science_design_patterns_gof_chunk_1112_268af0ec", "text": "in CHAI N OF R E S P O N S I B I L I T Y 224z, 348i\nin COMMAN D 2 3 7 z, 347i \nin M E D I A T O R 274i, 348i \nin M E M E N T O 286i \nin O B S E R V E R 295i, 347i \nin V I S I T O R 3 3 5z \nL e x i ' s V i s i t o r 74i\ninterfac e 13 \nbenefit s of programmin g to 18 \nb l o at 2 57 \nc o n v e r s i o n , see ADAPTE R \nfor iteratio n 262 \ni n h e r i t a n c e 1 3 , 17 \nnarro w versu s wide in MEMENT O 2 85\nspecifyin g in C ++ 17 \nsimplifyin g s u b s y s t e m s , see FACADE\ninterna l iterator , see iterator , interna l\nINTERPRETE R 2 4 3\nc o m b i n e d with C O M P O S I T E 2 55\nc o m b i n e d with V I S I T O R 247,25 5 \nin c a t a l o g summary 9\nInterview s \nu se of A B S T R A C T F A C T O R Y 95\nu se of ADAPTE R 1 48 \nu se of C O M M A N D 2 42 \nu se of C O M P O S I T E 1 72 \nu se of D E C O R A T O R 1 82 \nu se of F L Y W E I G H T 2 05 \nu se of O B S E R V E R 3 03 \nu se of S I N G L E T O N 1 33 \nu se of S T R A T E G Y 3 2 0 , 3 2 2 - 3 2 3\ni n t r i n s i c s t a t e, see s t a t e, intrinsi c\ni n v e r s i o n of contro l flow 27\ninvitatio n 3 58 \nInvoker\nparticipan t of COMMAN D 2 3 6 , 2 3 6 c , 237z,\n347i\nIRIS I n v e n t o r\nu se of V I S I T O R 3 44\nI T E R A T O R 2 5 7\nc o m b i n e d with C O M P O S I T E 3 62\nc o m b i n e d with V I S I T O R 3 39\ncompare d with V I S I T O R 3 36 \nin catalo g summar y 9 \nu se in L e xi 6 9\nIterato r 6 7, 67c, 258c, 2 6 3 , 3 7 2\nparticipan t of I T E R A T O R 259,259c\niterato r 6 6, 2 5 7 , 3 3 9 \na c c e s s to a g g r e g a t e 2 62\na c t i ve 2 60 \nalternativ e to in S m a l l t a l k 2 70\ncontrolling 2 6 0\n\nptg3 9 0 INDEX \ncurso r 2 61 \nensurin g deletio n of 2 66 \nexterna l 260,339,26 9 \ninterfac e to 2 6 1 , 2 6 3 \ninterna l 260,267,339 , see also ListTraverse r\nnull 2 6 2, see also Nulllterato r \nover recursiv e structure s 262\nparameterize d with an operatio n 267\np a s s i v e 2 60 \npolymorphi c 2 5 8 , 2 6 1 , 2 6 5 \nprivilege d a c c e s s to Aggregat e 2 62 \nrobust 2 6 1M\nK\nKit, see also A B S T R A C T FACTOR Y\ni n Inter V i e w s 9 5\nKnuth, Donald 3 5 7\nL\nlazy initializatio n 1 12\nLeaf\nparticipan t of C O M P O S I T E 164c, 1 6 5 , 1 6 5 0 ,\n1 68 \nL e m p e l - Z i v compressio n 1 83\nLexi 3 3\ndocumen t structur e 35 \ndocumen t traversa l and analysi s 64\nlook-and-fee l standard s 47\nmultipl e windo w system s 51 \nuser interfac e 3 3, 34 \nuser operation s 5 8\nlibg+ + \nuse of BRIDG E 1 6 0\nlifecycl e of softwar e 3 5 3, 3 54 \nLinton , M a rk 3 44 \nL i st 2 5 7 , 2 5 7 c , 258c, 2 6 3 , 3 6 9 \nl i st b ox 2 74 \nl i st traversa l 2 57 \nListBo x 274o, 275ci, 279 \nListlterato r 6 7, 2 5 7 , 2 5 7 c , 258c, 264,37 2\nListTraverse r 2 67 \nLiteralExpressio n 244co, 3 4 4\nimplemente d in Smalltal k 2 50\nlook-and-feel standards 8 7\nsupport in Lexi 3 5 , 4 7MacAp p \nu se of CHAI N OF R E S P O N S I B I L I T Y 2 32\nuse of COMMAN D 2 42 \nu se of D E C O R A T O R 1 7 9 , 1 8 0 \nu se of FACTOR Y M E T H O D 1 1 3 , 1 1 5\nMacbet h 1 \nMacFactor y 50c \nMacintos h 4 8, 52\nMacroComman d 2 3 5 , 2 3 5 c , 2 41\nmagi c token 3 46\nManipulato r 1 0 9, llOc\nM a p S i t e 8 2, 8 2c \nMarriag e of C o n v e n i e n c e 1 49\nMaze S2c,8 4 \nMazeBuide r 1 01\nMazeFactor y 9 2\nas singleto n 1 33\nMazeGam e 8 4 , 1 1 4\nMazePrototypeFactor y 1 22\nMEDIATO R 2 7 3\nc o m b i n e d with OBSERVE R 299\ncompare d with CHAI N OF\nR E S P O N S I B I L I T Y 3 48\ncompare d with FACAD E 2 82\ncompare d with O B S E R V E R 3 4 6 , 3 4 8 \nin catalo g summar y 9 \nu se of delegatio n in 2 1\nMediato r \ncommunicatin g with Colleagu e 2 7 8, 2 82\nparticipan t of MEDIATO R 2 7 6 c o , 277,348i\nomittin g abstrac t c l a ss of 2 7 8\nmediato r 2 74 \nmembe r functio n 3 6 1, s ee also operatio n\nM E M E N T O 2 8 3\nin catalo g summar y 9\nMemento\nc o m b i n e d with COMMAN D 2 3 9 , 2 8 7\nparticipan t of MEMENT O 285,285c , 286i\nmement o 2 84 \nc o s ts a s s o c i a t e d with 2 86\nlanguag e suppor t for 287\nMemoryStrea m 1 83\nMenu 50c,233c\nmenu 2 3 3\nconfigurin g 6 0, 2 34\npull-dow n 5 8\nMenulte m 5 9, 6 1 c, 2 3 3 , 2 3 3 c\nmetaclas s 1 3 3 , 3 6 1 \nmetho d 3 6 1, s ee also operatio n\nMicrosof t Window s 52 \nmixin class 1 6 , 1 6 c , 361\n\nptgI N D E X 391\nModel/View/Controlle r 4 ,5 \nu se of C O M P O S I T E 5 , 1 72 \nu se of F A C T O R Y M E T H O D 1 15\nu se of O B S E R V E R 5 , 3 03 \nu se of S T R A T E G Y 6\nM o n o G l y p h 44,45c \nM o t if 35,47,48,49,51 , 87\nMotifFactor y 4 9, 5 0c \nmultipl e d i s p a t c h , see d i s p a t c h , multipl e\nm u l t i p l e i n h e r i t a n c e , see also m i x in c l a s s\nu s ed to i m p l e m e n t c l a ss adapte r 1 41\nu s ed to i m p l e m e n t B R I D G E 1 5 6\nM V C , see Model/View/Controlle r\nM e y e r , Bertrand 149\nN\nnamin g c o n v e n t i o n s 2 9 , 31 \nF A C T O R Y M E T H O D 3 1 , 1 13\nT E M P L A T E M E T H O D 3 29\nV I S I T O R 3 3 7\nN e XT AppKi t \nu se of A D A P T E R 1 49 \nu se of B R I D G E 1 60 \nu se of C H A I N OF R E S P O N S I B I L I T Y 2 32\nu se of T E M P L A T E M E T H O D 3 2 9\nN E X T S T E P \nu se of A D A P T E R 1 45 \nu se of P R O X Y 2 0 8 , 2 1 2 , 2 1 6\nNode 3 3 3c\nN o d e V i s i t o r 3 3 2c \nnontermina l s y m b o l 2 46\nN o n T e r m i n a l E x p r e s s i o n\nparticipan t of I N T E R P R E T E R 245c, 2 46\nnotificatio n 2 94 \nnull i t e r a t o r , see iterator , null\nN u l l l t e r a t o r 6 7 c, 6 7 - 6 8 , 2 6 2 \nNXProxy 2 0 8 , 2 1 2\no\nobjec t 1 1 , 3 6 1 \na d a p t e r , s ee a d a p t e r , o b j e c t\nacquaintanc e 22 \naggregatio n 22 \nas argumen t to r e q u e s t 3 45 \na s p e c t of 2 98 \navoidin g d e p e n d e n c e on implementation\nof 24 \nc o m p o s i t i o n , s e e o b j e c t c o m p o s i t i o nfindin g 11 \ngranularit y of 1 3, s ee also F L Y W E I G H T\ng u ts 1 79 \nreferenc e 3 61 \ns h a r e d , s ee F L Y W E I G H T \ns k in 1 79 \nspecifyin g implementatio n of 14\nspecifyin g interfac e to 1 3\no b j e c t c o m p o s i t i o n 1 8, 3 61 \nc o m p a r e d with inheritanc e 1 8 - 20\ncompare d with parameterize d types 22\nr e u se throug h 1 9\no b j e c t diagra m 3 6 4 , 3 6 1 \nO b j e c t s for S t a t e s , see S T A T E \nO b j e c t M o d e l i n g T e c h n i q u e 7,14,363,36 4\nO b j e c t i v e C 9 0 , 1 2 0 , 1 2 1 , 1 3 5 , 1 4 4\nObjector y 3 63 \nO b j e c t W i n d o w s\nu se of I T E R A T O R 2 70\nu se of S T R A T E G Y 3 2 3\nObjectWorksXSmalltalk , see also S m a l l t a l k\nu se of A D A P T E R 1 4 8 - 1 4 9 \nu se of D E C O R A T O R 1 82 \nu se of FACAD E 1 9 1\nO B S E R V E R 2 93 \nc o m b i n e d with M E D I A T O R 2 7 8 , 2 8 2\ncompare d with CHAI N OF\nR E S P O N S I B I L I T Y 3 4 6 , 3 4 8\ncompare d with M E D I A T O R 3 4 6 , 3 4 8\nin Model/View/Controlle r 5 \nin catalo g summar y 8 \nl i m i t i n g unexpecte d update s in 2 9 6\nO b s e r v e r 3 00 \nc o m b i n i n g with Subjec t 3 00\nparticipan t of O B S E R V E R 294c, 295,295i,\n300c, 347i \nO M T, s ee O b j e c t M o d e l i n g T e c h n i q u e\noperatio n 1 1 , 3 6 1\nabstrac t 1 5 , 3 5 9 \naddin g to c l a s s e s 3 35 \navoidin g d e p e n d e n c e on specifi c 24\nc l a s s, s ee c l a ss operatio n \nc o n c r e t e 3 27 \nd i s p a t c h , see dispatc h \nh o o k , see h o ok operatio n\noverridin g 16 \nprimitiv e 3 2 7 , 3 2 9\nOrbix \nu se of F A C T O R Y M E T H O D 1 1 6\nO r i g i n a t o r \nparticipant of MEMENTO 2 8 5 , 285c, 286i\noriginator 2 8 4\n\nptg3 9 2 INDEX\noverloadin g \nu s ed to implemen t PROX Y 2 11\nu s e d to implement V I S I T O R 7 2 , 3 3 7\nparameterize d types 2 1, 3 6 1, s ee also templat e\ncompare d with inheritanc e 22\ncompare d with c o m p o s i t i o n 2 2\nparen t c l a s s , see c l a s s, paren t\nparen t references\ndefine d in C O M P O S I T E 1 66\nparse r 247 \np a r t - w h o l e , s ee r e c u r s i v e c o m p o s i t i o n\nsee also aggregatio n \nP a s c a l 4 \np a s s i v e iterator , see iterator , passiv e\nPassivityWrappe r 1 82 \npath\nspecifyin g m u l t i - s e g m e n t s h a p e s 57\npatter n languag e 3 56 \nPatter n Language s of Program s 3 57\npatter n matchin g 243 \np e r s i s t e n c e 2 09 \nPictur e 163c, 164o \nP L o P , see Patter n Language s of Program s \npluggabl e adapte r 1 4 2\nimplementatio n of 1 4 4 - 1 4 5 , 1 4 4 c , 145c,\n148,149c \nPMFactor y 50c \nPMIconWindo w 1 5 1 ,1 5 1c\nP M W i n d o w 1 5 1 ,1 5 1c\nPMWindowIm p 152,152c , 1 5 8 - 1 5 9\nPoint 3 73 \nP o l i c y , s ee STRATEG Y \npolymorphi c iteratio n 2 5 8\ni m p l e m e n t i n g in C ++ 2 61\npolymorphis m 1 4, 3 6 1\nu s ed with inheritanc e 18 \npostorde r traversal , see traversal , postorde r\npreorde r traversal , see traversal , preorde r\nPreorderlterato r 6 7\nmembe r function s 6 8 - 69 \nPresentatio n Manage r 35,48,52,56,57 , 8 7 , 1 5 1 ,\n1 58 \nP r i c i n g V i s i t o r 3 41 \nPrintDialo g 223o,224i \nprivat e inheritanc e 3 6 1, s ee also inheritance,\nimplementatio n\nP r o d u c t\nparticipan t of BUILDE R 98c, 99\nparticipant o f F A C T O R Y METHOD 1 0 8 , 1 0 8 cproduc t object s 49 \nc h a n g i n g at run-tim e 1 19\ncreatin g in A B S T R A C T F A C T O R Y 90\nexchangin g 89 \nfamil y of 87 \nvaryin g representatio n of 1 0 0\nprotectio n proxy , see proxy , protectio n\np r o t o c o l 3 61 \nP R O T O T Y P E 1 1 7\ncompare d with A B S T R A C T F A C T O R Y 1 2 6 ,\n1 35 \nc o m b i n e d with COMMAN D 2 38\nc o m p a r e d with F A C T O R Y M E T H O D 1 1 6 , 1 2 0\nin catalo g summar y 9 \nparticipan t of P R O T O T Y P E 1 1 9 ,1 1 9c \nu s ed to implemen t A B S T R A C T FACTOR Y 9 0\nprototyp e 1 17 \nprototyp e m a n a g e r 1 21\nprototypin g p h a se of lifecycl e 3 53\nP R O X Y 2 0 7\nc o m b i n e d with ITERATO R 2 62\ncompare d with D E C O R A T O R 220\nin catalo g summar y 9\nProx y \nparticipan t of PROX Y 209co, 209\nproxy 2 07 \nprotectio n 2 0 8 , 2 1 0\nr e m o t e 2 0 8 , 2 1 0\nvirtua l 2 0 8 , 2 1 0\np s e u d o c o d e 16,16c, 365c\nP u b l i s h - S u b s c r i b e , s ee O B S E R V E R \npull mode l 2 98 \npull-dow n menu , see menu , pull-dow n\npurpos e of d e s i g n pattern , see d e s i g n pattern,\npurpos e\np u s h model 298\nQ\nQ O C A \nuse of ADAPTE R 1 43\nu se of I N T E R P R E T E R 2 55\nuse of MEMENTO 2 9 1\nR\nRAp p \nu se of S T R A T E G Y 3 2 3\nRealSubjec t \nparticipant of P R O X Y 2 0 9 c o , 210\n\nptgINDEX 393\nR e c e i v e r \nparticipan t of COMMAND 236,236c , 237i,\n2 38\nreceive r 3 6 1\ndecouplin g from sende r 3 46\nimplici t 224\nR e ct 3 74 \nRectangl e 20,20 c \nrecursiv e c o m p o s i t i o n 3 6, s ee also C O M P O S I T E\niteratio n o v er 2 62 \nof documen t structur e 36 \nof graphi c e l e m e n t s 1 63 \nof part-whol e structure s 1 6 4\nr e d e s i g n , c a u s e s of 24\nr e d o, see u n d o / r e d o\nrefactorin g 3 2 6 , 3 5 3\nreferenc e countin g 2 10\nRefinedAbstraction\np a r t i c i p a n t of B R I D G E 153c, 1 54\nregula r e x p r e s s i o n 2 4 3\nrepresentin g in Smalltal k 2 48\nRegularExpressio n 244c \nremot e proxy , see proxy , remot e\nRepetitionExpressio n 244co, 3 4 3\nimplemente d in Smalltal k 2 49\nr e q u e s t 1 1 , 3 6 1\nautomati c forwardin g of 229\nencapsulatio n of 59, see also COMMAN D\nguarantee d receip t of 2 26\nrepresentin g 227 \ns e q u e n c i n g 2 3 4\nResponde r 2 32\nreuse\nblack-bo x 1 9 , 3 5 4 , 3 5 9 \nby compositio n 19 \nby parameterize d types 21\nby s u b c l a s s i n g 19 \ncode 26 \ndesignin g for 2 4 - 25\nframework s 26 \ninterna l 25 \nmaximizin g 23 \nof i m p l e m e n t a t i o n 18\ntoolkit s 26 \nwhite-bo x 1 9 , 3 5 4 , 3 6 2\nR i ch T e xt Forma t 97 \nrobus t iterator , see iterator , robus t\nR o om 82c,83 \nR T F, see Rich T e xt Forma t\nR T F R e a d e r 9 7, 9 7c \nR TL Smalltal k compiler\nu se of C O M P O S I T E 1 72\nu s e o f S T R A T E G Y 3 2 3S\ns c o pe of desig n pattern , see desig n pattern ,\ns c o p e\nScrollba r 50c\nS c r o l l D e c o r a t o r 17 60,17 6c\nS c r o l l e r 4 5 ,4 6o \nS e lf 4,121,30 9 \nsender\ndecouplin g from receive r 346\nS e q u e n c e E x p r e s s i o n 244co, 3 4 3\nimplemente d in Smalltal k 2 49\ns e q u e n c i n g r e q u e s t s 2 34 \ns h a l l o w c o p y , see c o p y , shallo w \nS h a p e 139,140c , 1 46 \nshrinkabilit y 3 20 \nsignatur e 1 3 , 3 6 1 \nS i m p l e C o m p o s i t o r 42,42c, 3 1 5, 315c, 3 21\ns i n g l e static a s s i g n m e n t form , S SA 1 72\ns i n g l e - d i s p a t c h , see dispatch , s i n g le \nSINGLETO N 1 2 7\nC++ implementatio n 1 2 9 , 1 3 1 \nin c a t a l o g summar y 9 \nregistr y of 1 30 \nsubclassin g 1 30 \nu s ed to implemen t ABSTRAC T FACTOR Y 90\nS i n g l e t o n \nparticipan t of SINGLETO N 1 2 7 c, 1 2 8\nSketchpa d 1 25 \nS k i p L i s t 258c,265 \nskiplis t 2 58 \nSmalltalk-80 , see also Objec t Work s \\Smalltalk,\nSmalltalk/ V \nuse of BUILDE R 1 05 \nu se of C O M P O S I T E 1 72 \nu se of FACTOR Y METHO D 1 15\nu se of INTERPRETE R 2 51 \nu se of ITERATO R 2 70 \nu se of OBSERVE R 3 03 \nu se of S I N G L E T O N 1 33 \nuse of V I S I T O R 3 4 4\nSmalltalk/ V \nu se of INTERPRETE R 2 51\nu se of MEDIATO R 2 7 8 , 2 8 1\nsmar t pointer s 209\nsmar t reference s 209\nsoftwar e platform\nisolatin g applicatio n from 24\nS o l i t a i r e , see SINGLETO N\nS o l v e r S t a t e 2 8 3 - 2 8 4 \nS P E C T a l k\nu se of INTERPRETE R 2 55\ns p e l l i n g c h e c k i n g 64\n\nptg3 94 I N D E X\nS p e l l i n g C h e c k e r 7 1 - 73\nS p e l l i n g C h e c k e r V i s i t o r 75\nStandardMazeBuilde r 1 03\nS T A T E 3 0 5\nC++ idiom for, see envelope-lette r idiom\nin catalo g summary 9 \nu se of d e l e g a t i o n in 2 1\nS t a t e\nparticipan t of S T A T E 306,306c\ns t a t e\naccumulatin g durin g traversa l 336\navoidin g inconsisten t 3 08\ne x t r i n s i c 1 96 \nincrementa l change s to 287\nintrinsi c 1 96 \ns h a r i n g 3 0 8, s ee also F L Y W E I G H T\nstate transition s\natomi c 3 08\ndefinin g 3 08\ntable-drive n 3 0 8\nS T R A T E G Y 3 15 \nc o m p a r e d with D E C O R A T O R 1 79\nin catalo g summar y 8 \nL e x i ' s u se of 42 \nu se in C h o i c e s 1 93 \nuse in Model/View/Controlle r 6\nu se of delegatio n in 2 1\nS t r a t e g y 180o \nmakin g optiona l 3 20 \nparticipan t of S T R A T E G Y 316c, 3 1 6\ns t r a t e g y 3 15 \nStrea m 1 8 3 ,1 8 3c\nStreamDecorato r 1 8 3 ,1 8 3c\ns t r e t c h a b i l i t y 3 20\nStroustrup , Bjarn e 1 60\nstructura l patter n 1 0 , 1 3 7\nc o m p a r i s o n b e t w e e n c l a ss a nd o b j e c t\ns c o pe 1 3 7\nd i s c u s s i o n of 2 19\ns u b c l a s s , s ee c l a s s, s u b c l a s s \nsubclassing\nextendin g functionalit y by 24\nS u b j e c t 3 0 1\navoidin g danglin g reference s to 297\ncombinin g with O b s e r v e r 3 00\np a r t i c i p a n t of O B S E R V E R 294c, 2 9 5 ,2 9 5 i ,\n300c, 347i \nparticipan t of PROX Y 209co, 2 1 0\ns u b j e c t 2 94 \nmappin g to observer s 297\no b s e r v i n g more than one 297\ns u b s y s t e m 3 61 \nsimplifying interface to, s e e F A C A D E\ns u b t y p e , s e e t y p e , s u b t y p es u c c e s s o r 2 24 \nconnectin g in chain 2 27\nimplementin g chain of 2 2 5\ns u p e r c l a s s 3 6 1, s ee also c l a s s, p a r e n t\nsupertype , see t y p e, supertyp e\nS u r r o g a t e , s ee P R O X Y \nS u t h e r l a n d , I v an 1 25 \nswaps 3 2 3\nT\nTarge t \nparticipan t of ADAPTE R 141,141c\nT CP p r o t o c o l 3 09 \nT C P C o n n e c t i o n 3 0 5 , 3 0 5 c , 3 09\nT C P S t a t e 3 0 5 , 3 0 5 c , 3 1 0 \nt e m p l a t e 2 1, s ee also p a r a m e t e r i z e d t y p e s\nu s ed to i m p l e m e n t COMMAN D 2 39 \nused to implemen t F A C T O R Y M E T H O D 1 13\nu s ed to i m p l e m e n t S T R A T E G Y 3 1 9 , 3 2 3\nTEMPLAT E METHO D 3 25 \nc a l l i n g F a c t o r y Method s 1 16 \nin c a t a l o g summar y 9 \nnamin g convention s for 329\nu s ed to implemen t I T E R A T O R 2 7 0\nt e m p l a t e m e t h o d 3 26\ntermina l s y m b o l 2 4 6\ns h a r e d using F L Y W E I G H T 2 47\nT e r m i n a l E x p r e s s i o n\nparticipan t of INTERPRETE R 2 4 5 c, 2 46\nT gX 42,97,316\nT e X C o m p o s i t o r 42c, 3 1 5 ,3 1 5 c, 3 22\nT e x t S h a p e 1 3 9 ,1 4 0 c , 1 4 6 , 1 4 7\nT e x t V i e w\nu se in A D A P T E R 1 3 9 ,1 4 0 c, 1 46\nuse in D E C O R A T O R 176c, 1760\nThingLa b 1 25\nT H I N K\nuse of COMMAN D 2 42\nu se of O B S E R V E R 3 0 3\nT o k e n , s ee M E M E N T O\nT o ol 1 1 7 ,1 1 8 c, 3 1 3 ,3 1 3c\nt o o l k i t 26,233,362\nsee Andre w \nsee B o o c h Component s\ns ee F r e s c o \nsee I n t e r v i e w s \nsee I R IS Invento r \nsee O b j e c t Window s \ns ee Q O C A \nsee T H I N K\nT r a n s a c t i o n , s e e COMMAND\n\nptgtransactio n 2 36 \nt r a n s p a r e n t e n c l o s u r e 4 3, s ee also D E C O R A T O R\ntraversa l of aggregat e o b j e c t s , see also I T E R A T O R\na c r o s s c l a ss hierarchie s 3 36 \na s s i g n i n g r e s p o n s i b i l i t y f or in V I S I T O R 3 39\ninorder , preorder , postorde r 262\nT r e e A c c e s s o r D e l e g a t e 1 4 5 ,1 4 5c\nT r e e D i s p l a y 142,144, 144c , 145c\ntwo-wa y adapter , see adapter , two-wa y\ntype 1 3\ncompare d with c l a ss 16\nC++, definitio n in 17\nEiffel , definitio n in 17\nS m a l l t a l k , d e f i n i t i o n in 17\nsubtyp e 13 \nsupertyp e 1 3\nt y p e - c h e c k i n g 3 32 \nto identif y request s at run-tim e 228\nsee also dynamic_cast\nT y p e C h e c k i n g V i s i t o r 3 3 2 c\nU\nundo/red o 5 9 - 6 0 , 62-64,235,238,283,28 7\navoidin g error accumulatio n durin g 239\nUnidra w \nu se of ADAPTE R 1 43 \nu se of CHAI N OF R E S P O N S I B I L I T Y 2 32\nu se of C O M M A N D 2 3 2 , 2 4 2 \nu se of F A C T O R Y M E T H O D 1 11 \nu seof I T E R A T O R 2 70 \nu seof M E D I A T O R 2 82 \nu seof MEMENT O 2 89 \nu seof O B S E R V E R 3 03 \nu seof P R O T O T Y P E 1 26 \nuseof S T A T E 3 1 3\nUnsharedConcreteFlyweigh t\nparticipan t of FLYWEIGH T 1 9 9\nupdate s \nencapsulatin g comple x 2 99\nl i m i t i n g u n e x p e c t e d 2 96\nprotoco l f or in O B S E R V E R 2 96\ntriggering 2 9 7INDEX 395\nVirtua l Constructor , see F A C T O R Y M E T H O D\nvirtua l m e m o r y framewor k 1 92 \nvirtua l proxy , see proxy , virtua l \nV I S I T O R 3 3 1\nc o m b i n e d with INTERPRETE R 247,25 5\nin catalo g summar y 9 \ni n t e r a c t i o n d i a g r a m f or L e xi 74 \nu se in Lexi 76 \nu se in c o m p i l e r exampl e 1 9 0 , 3 3 1\nu se of delegatio n in 2 1\nVisito r 7 5 , 3 3 7 \nparticipan t of V I S I T O R 3 3 4 ,3 3 4 c\nv i s i t o r 7 4 , 3 3 2\nV i s u a l C o m p o n e n t 1 7 6 ,17 6 c, 1 80\nvocabulary, defining common 352\nW\nWall 82c, 83 \nw h i t e - b o x r e u s e , see reuse , white-bo x\nWidge t 2 2 4 c, 2 3 0 , 2 7 5 c , 2 78 \nw i d g e t 4 8, 8 7\nGlyp h hierarch y 50\nWidgetFactor y 87 \nWindo w 20c, 39, 54c, 55c, 152,156\nconfigurin g with Windowlm p 5 7 - 58\ninterfac e 5 3\nwindo w s y s t e m s 35\ns u p p o r t in L e xi 5 1\nWindowlm p 55,55c, 152,152c , 1 57\ns u b c l a s s e s 5 5\nW i n d o w s , see Microsof t Window s\nWindowSystemFactor y 57\nW r a p p e r , s ee A D A P T E R , D E C O R A T O R\nWYSIWYG 3 3\nX\nX W i n d o w S y s t e m 5 2, 5 6 , 5 7 , 1 5 1 , 1 5 8\nX l c o n W i n d o w 1 5 1 ,1 5 1c \nXWindo w 1 5 1 ,1 5 1c \nX W i n d o w I m p 1 5 2 , 1 5 2 c , 1 5 8\nV\nValidato r 3 23\nVariableEx p 2 52\nV a r i a b l e R e f N o d e 3 3 3c\nViewManager 2 8 1 , 2 8 1 o\n\nptgI n t e r a c t i o n D i a g r a m N o t a t i o n\nObject Diagram NotationClass Diagram Notation\n\nptg", "metadata": {"book_id": "computer_science_design_patterns_gof", "book_title": "Design_Patterns_GoF", "category": "computer_science", "chunk_index": 1112, "total_chunks": 1113, "source_file": "Design_Patterns_GoF.pdf", "file_type": "pdf", "char_count": 19043}}
