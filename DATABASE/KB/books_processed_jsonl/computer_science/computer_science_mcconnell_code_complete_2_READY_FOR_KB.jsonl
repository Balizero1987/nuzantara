{"id": "computer_science_mcconnell_code_complete_2_chunk_0000_7aca9840", "text": "PUBLISHED BY\nMicrosoft Press\nA Division of Microsoft Corporation\nOne Microsoft Way\nRedmond, Washington 98052-6399\nCopyright © 2004 by Steven C. McConnell\nAll rights reserved. No part of the contents of this book may be reproduced or transmitted in any form or by \nany means without the written permission of the publisher. Library of Congress Cataloging-in-Publication Data\nMcConnell, Steve\nCode Complete / Steve McConnell.--2nd ed. p. cm. Includes index. ISBN 0-7356-1967-0\n1. Computer Software--Development--Handbooks, manuals, etc. I. Title. QA76.76.D47M39 2004\n005.1--dc22 2004049981\nPrinted and bound in the United States of America. 15 16 17 18 19 20 21 22 23 24 QGT 6 5 4 3 2 1\nDistributed in Canada by H.B. Fenn and Company Ltd. A CIP catalogue record for this book is available from \nthe British Library. Microsoft Press books are available through booksellers and distributors worldwide.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 0, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 897}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0001_b9836128", "text": "Fenn and Company Ltd. A CIP catalogue record for this book is available from \nthe British Library. Microsoft Press books are available through booksellers and distributors worldwide. For further information \nabout international editions, contact your local Microsoft Corporation office or contact Microsoft Press Inter-\nnational directly at fax (425) 936-7329. Visit our Web site at www.microsoft.com/mspress. Send comments \nto mspinput@microsoft.com . Microsoft, Microsoft Press, PowerPoint, Visual Basic, Windows, and Windows NT are either registered trade-\nmarks or trademarks of Microsoft Corporation in the United States and/or other countries. Other product and \ncompany names mentioned herein may be the trademarks of their respective owners. The example companies, organizations, products, domain names, e-mail addresses, logos, people, places, and \nevents depicted herein are fictitious.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 896}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0002_7849e687", "text": "The example companies, organizations, products, domain names, e-mail addresses, logos, people, places, and \nevents depicted herein are fictitious. No association with any real company, organization, product, domain \nname, e-mail address, logo, person, place, or event is intended or should be inferred. This book expresses the author’s views and opinions. The information contained in this book is provided with-\nout any express, statutory, or implied warranties. Neither the authors, Microsoft Corporation, nor its resellers, \nor distributors will be held liable for any damages caused or alleged to be caused either directly or indirectly \nby this book. Acquisitions Editors: Linda Engelman and Robin Van Steenburgh\nProject Editor: Devon Musgrave\nIndexer: Bill Myers\nPrincipal Desktop Publisher: Carl Diltz\nBody Part No.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 2, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 822}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0003_d57fae1c", "text": "Acquisitions Editors: Linda Engelman and Robin Van Steenburgh\nProject Editor: Devon Musgrave\nIndexer: Bill Myers\nPrincipal Desktop Publisher: Carl Diltz\nBody Part No. X10-53130\nTo my wife, Ashlie, who doesn't have much to do with computer programming \nbut who has everything to do with enriching the rest of my life \nin more ways than I could possibly describe\nFurther Praise for\nCode Complete\n“An excellent guide to programming style and software construction.”\n—Martin Fowler, Refactoring\n“Steve McConnell’s Code Complete . . . provides a fast track to wisdom for programmers. . . . His books are fun to read, and you never forget that he is speaking fr om hard-won personal \nexperience.” —Jon Bentley, Programming Pearls , 2d ed. “This is simply the best book on software construction that I've ever read. Every developer \nshould own a copy and read it cover to cover every year.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 3, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 882}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0004_ae39cfd3", "text": "“This is simply the best book on software construction that I've ever read. Every developer \nshould own a copy and read it cover to cover every year. After reading it annually for nine \nyears, I'm still learning things from this book!”\n—John Robbins, Debugging Applications for Micros oft .NET and Microsoft Windows\n“Today’s software must be robust and resilient , and secure code starts with disciplined software \nconstruction. After ten years, there is still no better authority than Code Complete .”\n—Michael Howard, Security Engineering, Microsoft Corporation; Coauthor, Writing Secure Code \n“A comprehensive examination of the tactical is sues that go into crafting a well-engineered \nprogram. McConnell’s work covers such diverse topics as architecture, coding standards, \ntesting, integration, and the natu re of software craftsmanship.”\n—Grady Booch, Object Solutions\n“The ultimate encyclopedia for the software developer is Code Complete by Steve McConnell.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 4, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0005_839805f1", "text": "Subtitled ‘A Practical Handbook of Software Construction,’ this 850-page book is exactly \nthat. Its stated goal is to narrow the gap be tween the knowledge of ‘industry gurus and pro-\nfessors’ (Yourdon and Pressman, for exampl e) and common commercial practice, and ‘to \nhelp you write better programs in less time with fewer headaches.’ . . . Every developer should \nown a copy of McConnell's book. Its styl e and content are thoroughly practical.”\n—Chris Loosley, High-Performance Client/Server\n“Steve McConnell’s seminal book Code Complete is one of the most accessible works discuss-\ning in detail software development methods. . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 5, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 635}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0006_0dca7801", "text": ". . .”\n—Erik Bethke, Game Development and Production\n“A mine of useful information and advice on the broader issues in designing and producing \ngood software.”\n—John Dempster, The Laboratory Computer: A Practical Guide for Physiologists and Neuroscien-\ntists\n“If you are serious about improving your programming skills, you should get Code Complete \nby Steve McConnell.”\n—Jean J. Labrosse, Embedded Systems Building Blocks: Complete and Ready-To-Use Modules in C\n“Steve McConnell has written one of the best books on software development independent \nof computer environment . . . Code Complete .”\n—Kenneth Rosen, Unix: The Complete Reference\n“Every half an age or so, you come across a book that short-circuits th e school of experience \nand saves you years of purgatory. . . . I cannot adequately express how go od this book really \nis.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 6, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 838}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0007_7b6ce70b", "text": ". . . I cannot adequately express how go od this book really \nis. Code Complete is a pretty lame title for a work of brilliance.”\n—Jeff Duntemann, PC Techniques\n“Microsoft Press has published what I consider to be the definitive book on software con-\nstruction. This is a book that belong s on every software developer’s shelf.”\n—Warren Keuffel, Software Development\n“Every programmer should read this ou tstanding book.” —T. L. (Frank) Pappas, Computer\n“If you aspire to be a professional programmer, this may be the wise st $35 investment you’ll \never make. Don’t stop to read the rest of this review: just run out and buy it. McConnell’s stat-\ned purpose is to narrow the gap between the knowledge of industry gurus and common com-\nmercial practice. . . . The amazin g thing is that he succeeds.”\n—Richard Mateosian, IEEE Micro\n“Code Complete should be required reading for an yone . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 7, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 890}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0008_cc07086d", "text": ". . . The amazin g thing is that he succeeds.”\n—Richard Mateosian, IEEE Micro\n“Code Complete should be required reading for an yone . . . in software development.”\n—Tommy Usher, C Users Journal\n“I’m encouraged to stick my neck out a bit further than usual and recommend, without res-\nervation, Steve McConnell’s Code Complete . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 8, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 333}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0009_aba5a35a", "text": ". . in software development.”\n—Tommy Usher, C Users Journal\n“I’m encouraged to stick my neck out a bit further than usual and recommend, without res-\nervation, Steve McConnell’s Code Complete . . . . My copy has replaced my API reference man-\nuals as the book that’s closes t to my keyboard while I work.”\n—Jim Kyle, Windows Tech Journal\n“This well-written but massive tome is arguably the best single volume ever written on the \npractical aspects of software implementation.”\n—Tommy Usher, Embedded Systems Programming\n“This is the best book on software engineering that I have yet read.”\n—Edward Kenworth, .EXE Magazine\n“This book deserves to become a classic, and should be comp ulsory reading for all develop-\ners, and those responsible for managing them.” —Peter Wright, Program Now\nCode Complete, Second Edition\n0-7356-1967-0\nSteve McConnell\nvii\nContents at a Glance\nPart\n \nI\nLaying the Foundation\n1 Welcome to Software Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 9, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0010_bbed89e6", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3\n2 Metaphors for a Richer Understanding of Software Development . . . . .9\n 3 Measure Twice, Cut Once: Upstream Prerequisites. . . . . . . . . . . . . . . . . 23\n 4 Key Construction Decisions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\nPart\n \nII\nCreating High-Quality Code\n 5 Design in Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73\n 6 Working Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n 7 High-Quality Routines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161\n 8 Defensive Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187\n 9 The Pseudocode Programming Process . . . . . . . . . . . . . . . . . . . . . . . . . 215\nPart\n \nIII\nVariables\n 10 General Issues in Using Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237\n11 The Power of Variable Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259\n 12 Fundamental Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291\n 13 Unusual Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319\nPart\n \nIV\nStatements\n14 Organizing Straight-Line Code. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 10, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1448}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0011_5777a04d", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291\n 13 Unusual Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319\nPart\n \nIV\nStatements\n14 Organizing Straight-Line Code. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 347\n 15 Using Conditionals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355\n 16 Controlling Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n 17 Unusual Control Structures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 391\n 18 Table-Driven Methods. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 411\n19 General Control Issues. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 431\nviii\nTable of Contents\nPart\n \nV\nCode Improvements\n 20 The Software-Quality Landscape. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463\n 21 Collaborative Construction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 479\n 22 Developer Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 499\n 23 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 535\n 24 Refactoring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 563\n 25 Code-Tuning Strategies. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 11, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1556}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0012_eaf4905e", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 535\n 24 Refactoring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 563\n 25 Code-Tuning Strategies. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 587\n 26 Code-Tuning Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 609\nPart\n \nVI\nSystem Considerations\n 27 How Program Size Affects Construction . . . . . . . . . . . . . . . . . . . . . . . . 649\n 28 Managing Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 661\n 29 Integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 689\n 30 Programming Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709\nPart\n \nVII\nSoftware Craftsmanship\n31 Layout and Style. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 729\n 32 Self-Documenting Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 777\n 33 Personal Character . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 819\n34 Themes in Software Craftsmanship. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 837\n 35 Where to Find More Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 855\nix\nWhat do you think of this book?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 12, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1487}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0013_f8d1c9d7", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . 819\n34 Themes in Software Craftsmanship. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 837\n 35 Where to Find More Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 855\nix\nWhat do you think of this book? We want to hear from you! Microsoft is interested in hearing your feedback about this publication so we can \ncontinually improve our books and learning resources for you. To participate in a brief \nonline survey, please visit: www.microsoft.com/learning/booksurvey/\n \nTable of Contents\nPreface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xix\nAcknowledgments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .x xvii\nList of Checklists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxix\nList of Tables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxxi\nList of Figures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxxiii\nPart\n \nI\nLaying the Foundation\n1 Welcome to Software Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 13, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1392}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0014_82c9308b", "text": ". . . . . . . . . . . . . . . . . . xxxi\nList of Figures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxxiii\nPart\n \nI\nLaying the Foundation\n1 Welcome to Software Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3\n1.1 What Is Software Construction?. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.2 Why Is Software Construction Important? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n1.3 How to Read This Book. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\n2 Metaphors for a Richer Understanding of Software Development . . . . .9\n2.1 The Importance of Metaphors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n2.2 How to Use Software Metaphors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n2.3 Common Software Metaphors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n 3 Measure Twice, Cut Once: Upstream Prerequisites. . . . . . . . . . . . . . . . . 23\n3.1 Importance of Prerequisites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n3.2 Determine the Kind of Software You’re Working On. . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 14, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1416}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0015_8762ce90", "text": ". . . . . . . . . . . . . . . . 23\n3.1 Importance of Prerequisites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n3.2 Determine the Kind of Software You’re Working On. . . . . . . . . . . . . . . . . . . . . . . . 31\n3.3 Problem-Definition Prerequisite . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\n3.4 Requirements Prerequisite . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\n3.5 Architecture Prerequisite . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n3.6 Amount of Time to Spend on Upstream Prerequisites . . . . . . . . . . . . . . . . . . . . . . 55\n 4 Key Construction Decisions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\n4.1 Choice of Programming Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\n4.2 Programming Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n4.3 Your Location on the Technology Wave . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n4.4 Selection of Major Construction Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69\nx\nTable of Contents\nPart\n \nII\nCreating High-Quality Code\n 5 Design in Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 15, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1466}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0016_40ecdd64", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69\nx\nTable of Contents\nPart\n \nII\nCreating High-Quality Code\n 5 Design in Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73\n5.1 Design Challenges. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74\n5.2 Key Design Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77\n5.3 Design Building Blocks: Heuristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87\n5.4 Design Practices. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110\n5.5 Comments on Popular Methodologies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118\n 6 Working Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n6.1 Class Foundations: Abstract Data Types (ADTs) . . . . . . . . . . . . . . . . . . . . . . . . . . . 126\n6.2 Good Class Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133\n6.3 Design and Implementation Issues. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143\n6.4 Reasons to Create a Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152\n6.5 Language-Specific Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 16, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1542}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0017_b0a5c202", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143\n6.4 Reasons to Create a Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152\n6.5 Language-Specific Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156\n6.6 Beyond Classes: Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156\n 7 High-Quality Routines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161\n7.1 Valid Reasons to Create a Routine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164\n7.2 Design at the Routine Level. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168\n7.3 Good Routine Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171\n7.4 How Long Can a Routine Be? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173\n7.5 How to Use Routine Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174\n7.6 Special Considerations in the Use of Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 181\n7.7 Macro Routines and Inline Routines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182\n 8 Defensive Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 17, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1487}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0018_8fd8f461", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . 181\n7.7 Macro Routines and Inline Routines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182\n 8 Defensive Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187\n8.1 Protecting Your Program from Invalid Inputs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188\n8.2 Assertions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189\n8.3 Error-Handling Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n8.4 Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n8.5 Barricade Your Program to Contain the Damage Caused by Errors . . . . . . . . . . 203\n8.6 Debugging Aids. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 05\n8.7 Determining How Much Defensive Programming to Leave in \nProduction Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209\n8.8 Being Defensive About Defensive Programming. . . . . . . . . . . . . . . . . . . . . . . . . . 210\nTable of Contents\nxi\n 9 The Pseudocode Programming Process . . . . . . . . . . . . . . . . . . . . . . . . . 215\n9.1 Summary of Steps in Building Classes and Routines . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 18, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1461}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0019_1d8a62d8", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . 210\nTable of Contents\nxi\n 9 The Pseudocode Programming Process . . . . . . . . . . . . . . . . . . . . . . . . . 215\n9.1 Summary of Steps in Building Classes and Routines . . . . . . . . . . . . . . . . . . . . . . . 216\n9.2 Pseudocode for Pros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\n9.3 Constructing Routines by Using the PPP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220\n9.4 Alternatives to the PPP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232\nPart\n \nIII\nVariables\n 10 General Issues in Using Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237\n10.1 Data Literacy. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2 3 8\n10.2 Making Variable Declarations Easy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239\n10.3 Guidelines for Initializing Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n10.4 Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244\n10.5 Persistence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 251\n10.6 Binding Time. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 19, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1536}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0020_b19e3250", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244\n10.5 Persistence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 251\n10.6 Binding Time. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2 5 2\n10.7 Relationship Between Data Types and Control Structures . . . . . . . . . . . . . . . . . 254\n10.8 Using Each Variable for Exactly One Purpose . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255\n11 The Power of Variable Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259\n11.1 Considerations in Choosing Good Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259\n11.2 Naming Specific Types of Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n11.3 The Power of Naming Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\n11.4 Informal Naming Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272\n11.5 Standardized Prefixes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279\n11.6 Creating Short Names That Are Readable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282\n11.7 Kinds of Names to Avoid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 20, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1486}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0021_9a8fa184", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279\n11.6 Creating Short Names That Are Readable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282\n11.7 Kinds of Names to Avoid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285\n 12 Fundamental Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291\n12.1 Numbers in General. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292\n12.2 Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293\n12.3 Floating-Point Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295\n12.4 Characters and Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297\n12.5 Boolean Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301\n12.6 Enumerated Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\n12.7 Named Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307\n12.8 Arrays. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310\n12.9 Creating Your Own Types (Type Aliasing) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 21, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1572}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0022_ff887a50", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307\n12.8 Arrays. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310\n12.9 Creating Your Own Types (Type Aliasing) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311\nTable of Contents\nxiii\n19.3 Null Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 44\n19.4 Taming Dangerously Deep Nesting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 445\n19.5 A Programming Foundation: Structured Programming . . . . . . . . . . . . . . . . . . . 454\n19.6 Control Structures and Complexity. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 456\nPart\n \nV\nCode Improvements\n 20 The Software-Quality Landscape. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463\n20.1 Characteristics of Software Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463\n20.2 Techniques for Improving Software Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 466\n20.3 Relative Effectiveness of Quality Techniques. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469\n20.4 When to Do Quality Assurance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 22, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1399}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0023_a3139ec0", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . 466\n20.3 Relative Effectiveness of Quality Techniques. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469\n20.4 When to Do Quality Assurance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 473\n20.5 The General Principle of Software Quality. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 474\n 21 Collaborative Construction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 479\n21.1 Overview of Collaborative Development Practices . . . . . . . . . . . . . . . . . . . . . . . 480\n21.2 Pair Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 483\n21.3 Formal Inspections. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 485\n21.4 Other Kinds of Collaborative Development Practices . . . . . . . . . . . . . . . . . . . . . 492\n 22 Developer Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 499\n22.1 Role of Developer Testing in Software Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . 500\n22.2 Recommended Approach to Developer Testing . . . . . . . . . . . . . . . . . . . . . . . . . 503\n22.3 Bag of Testing Tricks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 505\n22.4 Typical Errors . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 23, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1467}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0024_bc7b135e", "text": ". . . . . . 500\n22.2 Recommended Approach to Developer Testing . . . . . . . . . . . . . . . . . . . . . . . . . 503\n22.3 Bag of Testing Tricks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 505\n22.4 Typical Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .5 1 7\n22.5 Test-Support Tools. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 523\n22.6 Improving Your Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 528\n22.7 Keeping Test Records . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n 23 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 535\n23.1 Overview of Debugging Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 535\n23.2 Finding a Defect. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 40\n23.3 Fixing a Defect . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .5 5 0\n23.4 Psychological Considerations in Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 554\n23.5 Debugging Tools—Obvious and Not-So-Obvious. . . . . . . . . . . . . . . . . . . . . . . . 556\nxiv\nTable of Contents\n 24 Refactoring . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 24, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1547}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0025_e150a04c", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . 554\n23.5 Debugging Tools—Obvious and Not-So-Obvious. . . . . . . . . . . . . . . . . . . . . . . . 556\nxiv\nTable of Contents\n 24 Refactoring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 563\n24.1 Kinds of Software Evolution. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 564\n24.2 Introduction to Refactoring. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 565\n24.3 Specific Refactorings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 571\n24.4 Refactoring Safely . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 9\n24.5 Refactoring Strategies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 582\n 25 Code-Tuning Strategies. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 587\n25.1 Performance Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 588\n25.2 Introduction to Code Tuning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 591\n25.3 Kinds of Fat and Molasses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 597\n25.4 Measurement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 03\n25.5 Iteration . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 25, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1571}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0026_41038270", "text": ". . . . . . . . . . . . . . 591\n25.3 Kinds of Fat and Molasses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 597\n25.4 Measurement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 03\n25.5 Iteration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 605\n25.6 Summary of the Approach to Code Tuning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 606\n 26 Code-Tuning Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 609\n26.1 Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 610\n26.2 Loops. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 616\n26.3 Data Transformations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 624\n26.4 Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 630\n26.5 Routines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 639\n26.6 Recoding in a Low-Level Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 640\n26.7 The More Things Change, the More They Stay the Same . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 26, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1512}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0027_0fc406c8", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 639\n26.6 Recoding in a Low-Level Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 640\n26.7 The More Things Change, the More They Stay the Same . . . . . . . . . . . . . . . . . 643\nPart\n \nVI\nSystem Considerations\n 27 How Program Size Affects Construction . . . . . . . . . . . . . . . . . . . . . . . . 649\n27.1 Communication and Size . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 650\n27.2 Range of Project Sizes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 651\n27.3 Effect of Project Size on Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 651\n27.4 Effect of Project Size on Productivity. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 653\n27.5 Effect of Project Size on Development Activities . . . . . . . . . . . . . . . . . . . . . . . . . 654\nTable of Contents\nxv\n 28 Managing Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 661\n28.1 Encouraging Good Coding. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 662\n28.2 Configuration Management. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 664\n28.3 Estimating a Construction Schedule . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 27, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1447}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0028_e4fc48b5", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 662\n28.2 Configuration Management. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 664\n28.3 Estimating a Construction Schedule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 671\n28.4 Measurement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 7\n28.5 Treating Programmers as People . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 680\n28.6 Managing Your Manager . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 686\n 29 Integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 689\n29.1 Importance of the Integration Approach. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 689\n29.2 Integration Frequency—Phased or Incremental? . . . . . . . . . . . . . . . . . . . . . . . . . 691\n29.3 Incremental Integration Strategies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 694\n29.4 Daily Build and Smoke Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 702\n 30 Programming Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709\n30.1 Design Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7 1 0\n30.2 Source-Code Tools. . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 28, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1553}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0029_4ab3c53c", "text": ". . . . . . . . . . . . . . . . 702\n 30 Programming Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709\n30.1 Design Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7 1 0\n30.2 Source-Code Tools. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 710\n30.3 Executable-Code Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 716\n30.4 Tool-Oriented Environments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 720\n30.5 Building Your Own Programming Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 721\n30.6 Tool Fantasyland . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 2\nPart\n \nVII\nSoftware Craftsmanship\n31 Layout and Style. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 729\n31.1 Layout Fundamentals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 730\n31.2 Layout Techniques. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 736\n31.3 Layout Styles. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7 3 8\n31.4 Laying Out Control Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 29, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1545}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0030_d0f3a798", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 736\n31.3 Layout Styles. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7 3 8\n31.4 Laying Out Control Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 745\n31.5 Laying Out Individual Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 753\n31.6 Laying Out Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 763\n31.7 Laying Out Routines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 766\n31.8 Laying Out Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 768\nxvi\nTable of Contents\n 32 Self-Documenting Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 777\n32.1 External Documentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 777\n32.2 Programming Style as Documentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 778\n32.3 To Comment or Not to Comment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 781\n32.4 Keys to Effective Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 785\n32.5 Commenting Techniques. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 30, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1545}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0031_5b55ad17", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 781\n32.4 Keys to Effective Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 785\n32.5 Commenting Techniques. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 792\n32.6 IEEE Standards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 813\n 33 Personal Character . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 819\n33.1 Isn’t Personal Character Off the Topic? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 820\n33.2 Intelligence and Humility. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 821\n33.3 Curiosity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 822\n33.4 Intellectual Honesty . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 826\n33.5 Communication and Cooperation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 828\n33.6 Creativity and Discipline. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 829\n33.7 Laziness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 830\n33.8 Characteristics That Don’t Matter As Much As You Might Think . . . . . . . . . . . 830\n33.9 Habits . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 31, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1575}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0032_6d2c439b", "text": ". . . . . . . . . . 829\n33.7 Laziness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 830\n33.8 Characteristics That Don’t Matter As Much As You Might Think . . . . . . . . . . . 830\n33.9 Habits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 833\n34 Themes in Software Craftsmanship. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 837\n34.1 Conquer Complexity. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 837\n34.2 Pick Your Process. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 39\n34.3 Write Programs for People First, Computers Second . . . . . . . . . . . . . . . . . . . . . 841\n34.4 Program into Your Language, Not in It . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 843\n34.5 Focus Your Attention with the Help of Conventions. . . . . . . . . . . . . . . . . . . . . . 844\n34.6 Program in Terms of the Problem Domain. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 845\n34.7 Watch for Falling Rocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 848\n34.8 Iterate, Repeatedly, Again and Again . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 32, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1402}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0033_538733e3", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . 845\n34.7 Watch for Falling Rocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 848\n34.8 Iterate, Repeatedly, Again and Again . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 850\n34.9 Thou Shalt Rend Software and Religion Asunder . . . . . . . . . . . . . . . . . . . . . . . . 851\nTable of Contents\nxvii\nWhat do you think of this book? We want to hear from you! Microsoft is interested in hearing your feedback about this publication so we can \ncontinually improve our books and learning resources for you. To participate in a brief \nonline survey, please visit: www.microsoft.com/learning/booksurvey/\n 35 Where to Find More Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 855\n35.1 Information About Software Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 856\n35.2 Topics Beyond Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 857\n35.3 Periodicals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 859\n35.4 A Software Developer’s Reading Plan. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 33, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1299}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0034_dc956844", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 857\n35.3 Periodicals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 859\n35.4 A Software Developer’s Reading Plan. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 860\n35.5 Joining a Professional Organization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 862\nBibliography. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 863\nIndex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 885\n\nxix\nPreface\nThe gap between the best software engineering practice and the average practice \nis very wide—perhaps wider than in any other engineering discipline. A tool that \ndisseminates good practice would be important. —Fred Brooks\nMy primary concern in writing this book has been to narrow the gap between the \nknowledge of industry gurus and profe ssors on the one hand and common commer-\ncial practice on the other. Many powerful programming techniques hide in journals \nand academic papers for years before trickling down to the programming public.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 34, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1292}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0035_0cf05e5f", "text": "Many powerful programming techniques hide in journals \nand academic papers for years before trickling down to the programming public. Although leading-edge software-development practice has advanced rapidly in recent \nyears, common practice hasn’t. Many programs are still buggy, late, and over budget, \nand many fail to satisfy the needs of their users. Researchers in both the software \nindustry and academic settings have discover ed effective practices that eliminate most \nof the programming problems that have been prevalent since the 1970s. Because \nthese practices aren’t often reported outsid e the pages of highly specialized technical \njournals, however, most programming organizations aren’t yet using them today. Studies have found that it typically takes 5 to 15 years or more for a research develop-\nment to make its way into commercial practice (Raghavan and Chand 1989, Rogers \n1995, Parnas 1999).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 35, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0036_2d077a97", "text": "Studies have found that it typically takes 5 to 15 years or more for a research develop-\nment to make its way into commercial practice (Raghavan and Chand 1989, Rogers \n1995, Parnas 1999). This handbook shortc uts the process, making key discoveries \navailable to the average programmer now. Who Should Read This Book? The research and programming experience co llected in this handbook will help you \nto create higher-quality software and to do your work more quickly and with fewer \nproblems. This book will give you insight into why you’ve had problems in the past \nand will show you how to avoid problems in the future. The programming practices \ndescribed here will help you keep big projects under control and help you maintain \nand modify software successfully as the demands of your projects change. Experienced Programmers\nThis handbook serves experienced programmers who want a comprehensive, easy-to-\nuse guide to software development.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 36, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0037_199419ee", "text": "Experienced Programmers\nThis handbook serves experienced programmers who want a comprehensive, easy-to-\nuse guide to software development. Because this book focuses on construction, the \nmost familiar part of the software life cy cle, it makes powerful software development \ntechniques understandable to self-taught programmers as well as to programmers \nwith formal training. xx\nPreface\nTechnical Leads\nMany technical leads have used Code Complete to educate less-experienced program-\nmers on their teams. You can also use it to fill your own knowledge gaps. If you’re an \nexperienced programmer, you might not agree with all my conclusions (and I would be \nsurprised if you did), but if you read this b ook and think about each issue, only rarely \nwill someone bring up a construction issue that you haven’t previously considered. Self-Taught Programmers\nIf you haven’t had much formal training, yo u’re in good company.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 37, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0038_aac5e239", "text": "Self-Taught Programmers\nIf you haven’t had much formal training, yo u’re in good company. About 50,000 new \ndevelopers enter the profession each year (BLS 2004, Hecker 2004), but only about \n35,000 software-related degrees are awarde d each year (NCES 2002). From these fig-\nures it’s a short hop to the conclusion that many programmers don’t receive a formal \neducation in software development. Self-taught programmers are found in the emerg-\ning group of professionals—engineers, a ccountants, scientists, teachers, and small-\nbusiness owners—who program as part of th eir jobs but who do not necessarily view \nthemselves as programmers. Regardless of the extent of your programming educa-\ntion, this handbook can give you insigh t into effective programming practices. Students\nThe counterpoint to the programmer with experience but little formal training is the \nfresh college graduate.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 38, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 890}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0039_2ce1f914", "text": "Students\nThe counterpoint to the programmer with experience but little formal training is the \nfresh college graduate. The recent graduate is often rich in theoretical knowledge but \npoor in the practical know-how that goes into building production programs. The \npractical lore of good coding is often passe d down slowly in the ritualistic tribal \ndances of software architects, project lead s, analysts, and more-experienced program-\nmers. Even more often, it’s the product of the individual programmer’s trials and \nerrors. This book is an alternative to the slow workings of the traditional intellectual \npotlatch. It pulls together the helpful tips and effective development strategies previ-\nously available mainly by hunting and gathering from other people’s experience. It’s a \nhand up for the student making the transition from an academic environment to a \nprofessional one. Where Else Can You Find This Information? This book synthesizes construc tion techniques from a variety of sources.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 39, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0040_5bd82a11", "text": "Where Else Can You Find This Information? This book synthesizes construc tion techniques from a variety of sources. In addition \nto being widely scattered, much of the accumulated wisdom about construction has \nresided outside written sources for ye ars (Hildebrand 1989, McConnell 1997a). There is nothing mysterious about the effective, high-powered programming tech-\nniques used by expert programmers. In the da y-to-day rush of grinding out the latest \nproject, however, few experts take the time to share what they have learned. Conse-\nPreface xxi\nquently, programmers may have difficulty finding a good source of programming \ninformation. The techniques described in this book fill the void after introductory and advanced \nprogramming texts. After you have read Introduction to Java , Advanced Java , and \nAdvanced Advanced Java , what book do you read to learn more about programming?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 40, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0041_fdfe0ec3", "text": "After you have read Introduction to Java , Advanced Java , and \nAdvanced Advanced Java , what book do you read to learn more about programming? You could read books about the details of Intel or Motorola hardware, Microsoft Win-\ndows or Linux operating-system functions, or another programming language—you \ncan’t use a language or program in an environment without a good reference to such \ndetails. But this is one of the few books that discusses programming per se. Some of \nthe most beneficial programming aids are practices that you can use regardless of the \nenvironment or language you’re working in. Other books generally neglect such prac-\ntices, which is why this book concentrates on them. The information in this book is distilled from many sources, as shown below. The \nonly other way to obtain the information you’ll find in this handbook would be to \nplow through a mountain of books and a few hundred technical journals and then \nadd a significant amount of real-world experience.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 41, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0042_9af1d495", "text": "If you’ve already done all that, you \ncan still benefit from this book’s collecting the information in one place for easy refer-\nence. Key Benefits of This Handbook\nWhatever your background, this handbook can help you write better programs in less \ntime and with fewer headaches. Complete software-construction reference This handbook discusses general aspects \nof construction such as software quality and ways to think about programming. It gets \ninto nitty-gritty construction details such as steps in building cla sses, ins and outs of \nusing data and control structures, debugging, refactoring, and code-tuning tech-\nniques and strategies. You don’t need to read it cover to cover to learn about these top-\nics. The book is designed to make it easy to find the specific information that interests \nyou.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 42, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 807}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0043_46b86e5c", "text": "You don’t need to read it cover to cover to learn about these top-\nics. The book is designed to make it easy to find the specific information that interests \nyou. Professional \nexperience\nOther software \nbooks\nProgramming \nlanguage books\nMagazine \narticles Technology \nreferences\nConstruction\nxxii\nPreface\nReady-to-use checklists This book includes dozens of checklists you can use to \nassess your software architecture, design ap proach, class and routine quality, variable \nnames, control structures, layout, test cases, and much more. State-of-the-art information This handbook describes some of the most up-to-date \ntechniques available, many of which have not yet made it into common use. Because \nthis book draws from both practice and research, the techniques it describes will \nremain useful for years. Larger perspective on software development This book will give you a chance to rise \nabove the fray of day-to-day fire fighting and figure out what works and what doesn’t.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 43, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0044_933bd890", "text": "Larger perspective on software development This book will give you a chance to rise \nabove the fray of day-to-day fire fighting and figure out what works and what doesn’t. Few practicing programmers have the time to read through the hundreds of books \nand journal articles that have been distille d into this handbook. The research and real-\nworld experience gathered into this handbo ok will inform and stimulate your think-\ning about your projects, enabling you to take strategic action so that you don’t have to \nfight the same battles again and again. Absence of hype Some software books contain 1 gram of insight swathed in 10 \ngrams of hype. This book presents balanced discussions of each technique’s strengths \nand weaknesses. You know the demands of your particular project better than anyone \nelse. This book provides the objective information you need to make good decisions \nabout your specific circumstances.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 44, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0045_6d86710d", "text": "You know the demands of your particular project better than anyone \nelse. This book provides the objective information you need to make good decisions \nabout your specific circumstances. Concepts applicable to most common languages This book describes techniques \nyou can use to get the most out of whatever language you’re using, whether it’s C++, \nC#, Java, Microsoft Visual Basi c, or other similar languages. Numerous code examples The book contains almost 500 examples of good and bad \ncode. I’ve included so many examples beca use, personally, I learn best from exam-\nples. I think other programmers learn best that way too. The examples are in multiple languages beca use mastering more than one language is \noften a watershed in the career of a professional programmer. Once a programmer \nrealizes that programming principles tran scend the syntax of any specific language, \nthe doors swing open to knowledge that truly makes a difference in quality and pro-\nductivity.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 45, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0046_4312105d", "text": "Once a programmer \nrealizes that programming principles tran scend the syntax of any specific language, \nthe doors swing open to knowledge that truly makes a difference in quality and pro-\nductivity. To make the multiple-language burden as li ght as possible, I’ve avoided esoteric lan-\nguage features except where they’re specifically discussed. You don’t need to under-\nstand every nuance of the code fragments to understand the points they’re making. If \nyou focus on the point being illustrated, you’ll find that you can read the code regard-\nless of the language. I’ve tried to make your job even easier by annotating the signifi-\ncant parts of the examples. Access to other sources of information This book collects much of the available \ninformation on software construction, but it’s hardly the last word. Throughout the \nPreface xxiii\nchapters, “Additional Resources” sections de scribe other books and articles you can \nread as you pursue the topics you find most interesting.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 46, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0047_677f9ed9", "text": "Throughout the \nPreface xxiii\nchapters, “Additional Resources” sections de scribe other books and articles you can \nread as you pursue the topics you find most interesting. cc2e.com/1234\nBook website Updated checklists, books, magazine articles, Web links, and other \ncontent are provided on a companion website at cc2e.com . To access information \nrelated to Code Complete , 2d ed., enter cc2e.com/ followed by a four-digit code, an \nexample of which is shown here in the left margin. These website references appear \nthroughout the book. Why This Handbook Was Written\nThe need for development handbooks that capture knowledge about effective devel-\nopment practices is well recognized in th e software-engineering community.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 47, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 726}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0048_de1eb923", "text": "Why This Handbook Was Written\nThe need for development handbooks that capture knowledge about effective devel-\nopment practices is well recognized in th e software-engineering community. A report \nof the Computer Science and Technology Board stated that the biggest gains in soft-\nware-development quality and productivity will come from codifying, unifying, and \ndistributing existing knowledge about ef fective software-development practices \n(CSTB 1990, McConnell 1997a). The board co ncluded that the strategy for spreading \nthat knowledge should be built on the concept of software-engineering handbooks. The Topic of Construction Has Been Neglected \nAt one time, software development and coding were thought to be one and the same. But as distinct activities in the software-d evelopment life cycle have been identified, \nsome of the best minds in the field have sp ent their time analyzing and debating meth-\nods of project management, requirements, design, and testing.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 48, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0049_a73e66ad", "text": "The rush to study \nthese newly identified areas has left code co nstruction as the ignorant cousin of soft-\nware development. Discussions about construction have also be en hobbled by the suggestion that treat-\ning construction as a distinct software development activity implies that construction \nmust also be treated as a distinct phase . In reality, software activities and phases don’t \nhave to be set up in any particular relationship to each other, and it’s useful to discuss \nthe activity of construction regardless of whether other software activities are per-\nformed in phases, in iterations, or in some other way. Construction Is Important\nAnother reason construction has been neglected by researchers and writers is the mis-\ntaken idea that, compared to other software -development activities, construction is a \nrelatively mechanical process that presents little opportunity for improvement. Noth-\ning could be further from the truth.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 49, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0050_7a05765f", "text": "Noth-\ning could be further from the truth. xxiv\nPreface\nCode construction typically makes up about 65 percent of the effort on small projects \nand 50 percent on medium projects. Constr uction accounts for about 75 percent of \nthe errors on small projects and 50 to 75 percent on medium and large projects. Any \nactivity that accounts for 50 to 75 percen t of the errors presents a clear opportunity \nfor improvement. (Chapter 27 contains more details on these statistics.)\nSome commentators have pointed out that al though construction errors account for a \nhigh percentage of total errors, construction errors tend to be less expensive to fix \nthan those caused by requirements and architecture, the suggestion being that they \nare therefore less important. The claim that construction errors cost less to fix is true \nbut misleading because the cost of not fixing them can be incredibly high.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 50, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 894}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0051_3dee0b34", "text": "The claim that construction errors cost less to fix is true \nbut misleading because the cost of not fixing them can be incredibly high. Researchers \nhave found that small-scale coding errors a ccount for some of the most expensive soft-\nware errors of all time, with costs running into hundreds of millions of dollars (Wein-\nberg 1983, SEN 1990). An inexpensive cost to fix obviously does not imply that fixing \nthem should be a low priority. The irony of the shift in focus away from construction is that construction is the only \nactivity that’s guaranteed to be done. Requ irements can be assumed rather than devel-\noped; architecture can be shortchanged ra ther than designed; and testing can be \nabbreviated or skipped rather than fully pl anned and executed. But if there’s going to \nbe a program, there has to be construction, and that makes construction a uniquely \nfruitful area in which to improve development practices.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 51, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0052_36068827", "text": "But if there’s going to \nbe a program, there has to be construction, and that makes construction a uniquely \nfruitful area in which to improve development practices. No Comparable Book Is Available\nIn light of construction’s obvious importan ce, I was sure when I conceived this book \nthat someone else would already have written a book on effective construction prac-\ntices. The need for a book about how to program effectively seemed obvious. But I \nfound that only a few books had been writ ten about construction and then only on \nparts of the topic. Some had been written 15 years or more earlier and employed rel-\natively esoteric languages such as ALGOL, PL/I, Ratfor, and Smalltalk. Some were \nwritten by professors who were not work ing on production code. The professors \nwrote about techniques that worked for student projects, but they often had little idea \nof how the techniques would play out in full-scale development environments.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 52, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0053_95155274", "text": "The professors \nwrote about techniques that worked for student projects, but they often had little idea \nof how the techniques would play out in full-scale development environments. Still \nother books trumpeted the authors’ newest favorite methodologies but ignored the \nhuge repository of mature practices that have proven their effectiveness over time. When art critics get together \nthey talk about Form and \nStructure and Meaning. When artists get together \nthey talk about where you \ncan buy cheap turpentine. —Pablo Picasso\nIn short, I couldn’t find any book that had even attempted to capture the body of prac-\ntical techniques available from profession al experience, industry research, and aca-\ndemic work. The discussion needed to be brought up to date for current \nprogramming languages, object-oriented programming, and leading-edge develop-\nment practices.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 53, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 869}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0054_1d81fa5d", "text": "The discussion needed to be brought up to date for current \nprogramming languages, object-oriented programming, and leading-edge develop-\nment practices. It seemed clear that a book about programming needed to be written \nby someone who was knowledgeable about th e theoretical state of the art but who \nwas also building enough production code to appreciate the state of the practice. I \nPreface xxv\nconceived this book as a full discussion of code construction—from one programmer \nto another. Author Note\nI welcome your inquiries about the topics discussed in this book, your error reports, \nor other related subjects. Please contact me at stevemcc@construx.com , or visit my \nwebsite at www.stevemcconnell.com . Bellevue, Washington\nMemorial Day, 2004\nMicrosoft Learning Technical Support\nEvery effort has been made to ensure th e accuracy of this book.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 54, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 857}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0055_5e5e0220", "text": "Bellevue, Washington\nMemorial Day, 2004\nMicrosoft Learning Technical Support\nEvery effort has been made to ensure th e accuracy of this book. Microsoft Press \nprovides corrections for books through the World Wide Web at the following \naddress:\nhttp://www.microsoft.com/learning/support/\nTo connect directly to the Microsoft Knowledge Base and enter a query regard-\ning a question or issue that you may have, go to: \nhttp://www.microsoft.com/learning/support/search.asp\nIf you have comments, questions, or id eas regarding this book, please send \nthem to Microsoft Press using either of the following methods: \nPostal Mail: \nMicrosoft Press \nAttn: Code Complete 2E Editor \nOne Microsoft Way \nRedmond, WA 98052-6399\nE-mail:\nmspinput@microsoft.com\n\nxxvii\nAcknowledgments\nA book is never really written by one person (a t least none of my books are). A second edition \nis even more a collective undertaking.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 55, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 903}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0056_15fccd44", "text": "A second edition \nis even more a collective undertaking. I’d like to thank the people who contributed re view comments on significant portions of the \nbook: Hákon Ágústsson, Scott Ambler, Will Barn s, William D. Bartholomew, Lars Bergstrom, \nIan Brockbank, Bruce Butler, Jay Cincotta, Alan Cooper, Bob Corrick, Al Corwin, Jerry Deville, \nJon Eaves, Edward Estrada, Steve Gouldstone, Owain Griffiths, Matthew Harris, Michael \nHoward, Andy Hunt, Kevin Hutchison, Rob Jasper, Stephen Jenkins, Ralph Johnson and his \nSoftware Architecture Group at the University of Illinois, Marek Konopka, Jeff Langr, Andy \nLester, Mitica Manu, Steve Mattingly, Gareth McCaughan, Robert McGovern, Scott Meyers, \nGareth Morgan, Matt Peloquin, Bryan Pflug, Je ffrey Richter, Steve Rinn, Doug Rosenberg, \nBrian St. Pierre, Diomidis Spinellis, Matt Step hens, Dave Thomas, Andy Thomas-Cramer, John \nVlissides, Pavel Vozenilek, Denny Williford, Jack Woolley, and Dee Zsombor.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 56, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0057_f79d0281", "text": "Pierre, Diomidis Spinellis, Matt Step hens, Dave Thomas, Andy Thomas-Cramer, John \nVlissides, Pavel Vozenilek, Denny Williford, Jack Woolley, and Dee Zsombor. Hundreds of readers sent comments about the fi rst edition, and many more sent individual \ncomments about the second edition. Thanks to everyone who took time to share their reac-\ntions to the book in its various forms. Special thanks to the Construx Software reviewers who formally inspected the entire manu-\nscript: Jason Hills, Bradey Honsinger, Abdul Nizar, Tom Reed, and Pamela Perrott. I was truly \namazed at how thorough their review was, espe cially considering how many eyes had scruti-\nnized the book before they began working on it. Thanks also to Bradey, Jason, and Pamela for \ntheir contributions to the cc2e.com website. Working with Devon Musgrave, project editor for this book, has been a special treat.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 57, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 878}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0058_27964ef4", "text": "Thanks also to Bradey, Jason, and Pamela for \ntheir contributions to the cc2e.com website. Working with Devon Musgrave, project editor for this book, has been a special treat. I’ve \nworked with numerous excellent editors on other projects, and Devon stands out as espe-\ncially conscientious and easy to work with. Thanks, Devon! Thanks to Linda Engleman who \nchampioned the second edition; this book wouldn’t have happened without her. Thanks also \nto the rest of the Microsoft Press staff, including Robin Van Steenburgh, Elden Nelson, Carl \nDiltz, Joel Panchot, Patricia Masserman, Bill Myers, Sandi Resnick, Barbara Norfleet, James \nKramer, and Prescott Klassen.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 58, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 665}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0059_42c9f10b", "text": "I’d like to remember the Microsoft Press staff that published the first edition: Alice Smith, \nArlene Myers, Barbara Runyan, Carol Luke, Co nnie Little, Dean Holmes, Eric Stroo, Erin \nO'Connor, Jeannie McGivern, Jeff Carey, Jenni fer Harris, Jennifer Vick, Judith Bloch, \nKatherine Erickson, Kim Eggleston, Lisa Sandbu rg, Lisa Theobald, Margarite Hargrave, Mike \nHalvorson, Pat Forgette, Peggy Herman, Ruth Pettis, Sally Brunsman, Shawn Peck, Steve Mur-\nray, Wallis Bolz, and Zaafar Hasnain. xxviii\nAcknowledgments\nThanks to the reviewers who contributed so signif icantly to the first edition: Al Corwin, Bill \nKiestler, Brian Daugherty, Dave Moore, Greg Hitchcock, Hank Meuret, Jack Woolley, Joey \nWyrick, Margot Page, Mike Klein, Mike Zevenbergen, Pat Forman, Peter Pathe, Robert L. Glass, Tammy Forman, Tony Pisculli, and Wayne Beardsley.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 59, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 843}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0060_43f17b4b", "text": "Glass, Tammy Forman, Tony Pisculli, and Wayne Beardsley. Special thanks to Tony Garland \nfor his exhaustive review: with 12 years’ hind sight, I appreciate more than ever how excep-\ntional Tony’s several thousand review comments really were.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 60, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 241}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0061_01fc51c1", "text": "Special thanks to Tony Garland \nfor his exhaustive review: with 12 years’ hind sight, I appreciate more than ever how excep-\ntional Tony’s several thousand review comments really were. xxix\nChecklists\nRequirements 42\nArchitecture 54\nUpstream Prerequisites 59\nMajor Construction Practices 69\nDesign in Construction 122\nClass Quality 157\nHigh-Quality Routines 185\nDefensive Programming 211\nThe Pseudocode Programming Process 233\nGeneral Considerations In Using Data 257\nNaming Variables 288\nFundamental Data 316\nConsiderations in Using Unusual Data Types 343\nOrganizing Straight-Line Code 353\nUsing Conditionals 365\nLoops 388\nUnusual Control Structures 410\nTable-Driven Methods 429\nControl-Structure Issues 459\nA Quality-Assurance Plan 476\nEffective Pair Programming 484\nEffective Inspections 491\nTest Cases 532\nDebugging Reminders 559\nReasons to Refactor 570\nSummary of Refactorings 577\nRefactoring Safely 584\nCode-Tuning Strategies 607\nCode-Tuning Techniques 642\nxxx\nChecklists\nConfiguration Management 669\nIntegration 707\nProgramming Tools 724\nLayout 773\nSelf-Documenting Code 780\nGood Commenting Technique 816\nxxxi\nTables\nTable 3-1\nAverage Cost of Fixing Defects Base d on When They’re Introduced and \nDetected 29\nTable 3-2\nTypical Good Practices for Three Co mmon Kinds of Software Projects 31\nTable 3-3\nEffect of Skipping Prerequisites on Sequential and Iterative Projects 33\nTable 3-4\nEffect of Focusing on Prerequisites on Sequential and Iterative Projects 34\nTable 4-1\nRatio of High-Level-Language Statements to Equivalent C Code 62\nTable 5-1\nPopular Design Patterns 104\nTable 5-2\nDesign Formality and Level of Detail Needed 116\nTable 6-1\nVariations on Inherited Routines 145\nTable 8-1\nPopular-Language Support for Exceptions 198\nTable 11-1\nExamples of Good and Bad Variable Names 261\nTable 11-2\nVariable Names That Are Too Long, Too Short, or Just Right 262\nTable 11-3\nSample Naming Conventi ons for C++ and Java 277\nTable 11-4\nSample Naming Conventions for C 278\nTable 11-5\nSample Naming Conventi ons for Visual Basic 278\nTable 11-6\nSample of UDTs for a Word Processor 280\nTable 11-7\nSemantic Prefixes 280\nTable 12-1\nRanges for Different Types of Integers 294\nTable 13-1\nAccessing Global Data Directly and Through Access Routines 341\nTable 13-2\nParallel and Nonparallel Uses of Complex Data 342\nTable 16-1\nThe Kinds of Loops 368\nTable 19-1\nTransformations of Logical Expressi ons Under DeMorgan’s Theorems 436\nTable 19-2\nTechniques for Counting the Decision Points in a Routine 458\nTable 20-1\nTeam Ranking on Each Objective 469\nTable 20-2\nDefect-Detection Rates 470\nTable 20-3\nExtreme Programming’s Estimated Defect-Detection Rate 472\nTable 21-1\nComparison of Collaborative Construction Techniques 495\nTable 23-1\nExamples of Psychological Dist ance Between Variable Names 556\nTable 25-1\nRelative Execution Time of Programming Languages 600\nTable 25-2\nCosts of Common Operations 601\nxxxii\nTables\nTable 27-1\nProject Size and Typical Error Density 652\nTable 27-2\nProject Size and Productivity 653\nTable 28-1\nFactors That Influence Software-Project Effort 674\nTable 28-2\nUseful Software-Development Measurements 678\nTable 28-3\nOne View of How Programmers Spend Their Time 681\nxxxiii\nFigures\nFigure 1-1\nConstruction activities are shown in side the gray circle.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 61, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 3265}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0062_0ecbd261", "text": "Construction \nfocuses on coding and debugging but also includes detailed design, unit \ntesting, integration testing, and other activities. 4\nFigure 1-2\nThis book focuses on coding and debugging, detailed design, construction \nplanning, unit testing, integration, inte gration testing, and other activities in \nroughly these proportions. 5\nFigure 2-1\nThe letter-writing metaphor suggests that the software process relies on \nexpensive trial and error rather than careful planning and design. 14\nFigure 2-2\nIt’s hard to extend the farming metaphor to software development \nappropriately. 15\nFigure 2-3\nThe penalty for a mistake on a simple structure is only a little time and \nmaybe some embarrassment. 17\nFigure 2-4\nMore complicated structures require more careful planning. 18\nFigure 3-1\nThe cost to fix a defect rises dramatically as the time from when it’s intro-\nduced to when it’s detected increases.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 62, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 904}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0063_aad7537c", "text": "18\nFigure 3-1\nThe cost to fix a defect rises dramatically as the time from when it’s intro-\nduced to when it’s detected increases. This remains true whether the \nproject is highly sequential (doing 100 percent of requirements and design \nup front) or highly iterative (doing 5 percent of requirements and design \nup front). 30\nFigure 3-2\nActivities will overlap to some degree on most projects, even those that are \nhighly sequential. 35\nFigure 3-3\nOn other projects, activiti es will overlap for the du ration of the project. One \nkey to successful construction is understanding the degree to which prereq-\nuisites have been completed and adju sting your approach accordingly. 35\nFigure 3-4\nThe problem definition lays the foundation for the rest of the programming \nprocess. 37\nFigure 3-5\nBe sure you know what you’re aiming at before you shoot. 38\nFigure 3-6\nWithout good requirements, you can have the right general problem but \nmiss the mark on specific aspects of the problem.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 63, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0064_d6ad5d52", "text": "38\nFigure 3-6\nWithout good requirements, you can have the right general problem but \nmiss the mark on specific aspects of the problem. 39\nFigure 3-7\nWithout good software architecture, yo u may have the right problem but the \nwrong solution. It may be impossible to have successful construction. 44\nFigure 5-1\nThe Tacoma Narrows bridge—an example of a wicked problem. 75\nxxxiv\nFigures\nFigure 5-2\nThe levels of design in a program. The system (1) is first organized into sub-\nsystems (2). The subsystems are furthe r divided into classes (3), and the \nclasses are divided into routines and data (4). The inside of each routine is \nalso designed (5). 82\nFigure 5-3\nAn example of a system with six subsystems. 83\nFigure 5-4\nAn example of what happens with no restrictions on intersubsystem \ncommunications. 83\nFigure 5-5\nWith a few communication rules, you can simplify subsystem interactions \nsignificantly. 84\nFigure 5-6\nThis billing system is composed of four major objects.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 64, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0065_711ace85", "text": "83\nFigure 5-5\nWith a few communication rules, you can simplify subsystem interactions \nsignificantly. 84\nFigure 5-6\nThis billing system is composed of four major objects. The objects have been \nsimplified for this example. 88\nFigure 5-7\nAbstraction allows you to take a simpler view of a complex concept. 90\nFigure 5-8\nEncapsulation says that, not only are you allowed to take a simpler view of a \ncomplex concept, you are not allowed to look at any of the details of the \ncomplex concept. What you see is what you get—it’s all you get! 91\nFigure 5-9\nA good class interface is like the tip of an iceberg, leaving most of the class \nunexposed. 93\nFigure 5-10\nG. Polya developed an approach to problem solving in mathematics that’s \nalso useful in solving problems in software design (Polya 1957). 109\nFigure 8-1\nPart of the Interstate-90 floating bridge in Seattle sank during a storm \nbecause the flotation tanks were left uncovered, they filled with water, and \nthe bridge became too heavy to float.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 65, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1000}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0066_d0578f75", "text": "During construction, protecting your-\nself against the small stuff matters more than you might think. 189\nFigure 8-2\nDefining some parts of the software that work with dirty data and some that \nwork with clean data can be an effective way to relieve the majority of the \ncode of the responsibility for checking for bad data. 204\nFigure 9-1\nDetails of class construction vary, but the activities generally occur in the \norder shown here. 216\nFigure 9-2\nThese are the major activities that go into constructing a routine. They’re \nusually performed in the order shown. 217\nFigure 9-3\nYou’ll perform all of these steps as you design a routine but not necessarily \nin any particular order. 225\nFigure 10-1\n“Long live time” means that a variable is live over the course of many state-\nments. “Short live time” means it’s live for only a few statements. “Span” \nrefers to how close together the references to a variable are. 246\nFigure 10-2\nSequential data is data that’s handled in a defined order.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 66, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0067_0596f600", "text": "“Span” \nrefers to how close together the references to a variable are. 246\nFigure 10-2\nSequential data is data that’s handled in a defined order. 254\nFigure 10-3\nSelective data allows you to use one piece or the other, but not both. 255\nFigures\nxxxv\nFigure 10-4\nIterative data is repeated. 255\nFigure 13-1\nThe amount of memory used by each data type is shown by double \nlines. 324\nFigure 13-2\nAn example of a picture that helps us think through the steps involved in \nrelinking pointers. 329\nFigure 14-1\nIf the code is well organized into groups, boxes drawn around related sec-\ntions don’t overlap. They might be nested. 352\nFigure 14-2\nIf the code is organized poorly, boxes drawn around related sections \noverlap. 353\nFigure 17-1\nRecursion can be a valuable tool in the battle against complexity—when used \nto attack suitable problems. 394\nFigure 18-1\nAs the name suggests, a direct-access table allows you to access the table ele-\nment you’re interested in directly.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 67, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0068_78a24dfd", "text": "394\nFigure 18-1\nAs the name suggests, a direct-access table allows you to access the table ele-\nment you’re interested in directly. 413\nFigure 18-2\nMessages are stored in no particular order, and each one is identified with a \nmessage ID. 417\nFigure 18-3\nAside from the Message ID, each kind of message has its own format. 418\nFigure 18-4\nRather than being accessed directly, an indexed access table is accessed via \nan intermediate index. 425\nFigure 18-5\nThe stair-step approach categorizes each entry by determining the level at \nwhich it hits a “staircase.” The “step” it hits determines its category. 426\nFigure 19-1\nExamples of using number-line ordering for boolean tests. 440\nFigure 20-1\nFocusing on one external characteristic of software quality can affect other \ncharacteristics posi tively, adversely, or not at all. 466\nFigure 20-2\nNeither the fastest nor the slowest deve lopment approach produces the soft-\nware with the most defects.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 68, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0069_4e11cbc8", "text": "466\nFigure 20-2\nNeither the fastest nor the slowest deve lopment approach produces the soft-\nware with the most defects. 475\nFigure 22-1\nAs the size of the project increases, developer testing consumes a smaller \npercentage of the total development time. The effects of program size are \ndescribed in more detail in Chapter 27, “How Program Size Affects \nConstruction.” 502\nFigure 22-2\nAs the size of the project increases, the proportion of errors committed dur-\ning construction decreases. Nevertheless, construction errors account for \n45–75% of all errors on even the largest projects. 521\nFigure 23-1\nTry to reproduce an error several different ways to determine its exact \ncause. 545\nFigure 24-1\nSmall changes tend to be more error-prone than larger changes (Weinberg \n1983). 581\nxxxvi\nFigures\nFigure 24-2\nYour code doesn’t have to be messy just because the real world is messy.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 69, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 884}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0070_f382f6e5", "text": "545\nFigure 24-1\nSmall changes tend to be more error-prone than larger changes (Weinberg \n1983). 581\nxxxvi\nFigures\nFigure 24-2\nYour code doesn’t have to be messy just because the real world is messy. Conceive your system as a combination of ideal code, interfaces from the \nideal code to the messy real world, and the messy real world. 583\nFigure 24-3\nOne strategy for improving production code is to refactor poorly written leg-\nacy code as you touch it, so as to move it to the other side of the “interface to \nthe messy real world.” 584\nFigure 27-1\nThe number of communication paths increases proportionate to the square \nof the number of people on the team. 650\nFigure 27-2\nAs project size increases, errors usually come more from requirements and \ndesign. Sometimes they still come pr imarily from construction (Boehm \n1981, Grady 1987, Jones 1998). 652\nFigure 27-3\nConstruction activities dominate smal l projects.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 70, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 919}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0071_3f940a49", "text": "Sometimes they still come pr imarily from construction (Boehm \n1981, Grady 1987, Jones 1998). 652\nFigure 27-3\nConstruction activities dominate smal l projects. Larger projects require \nmore architecture, integration work, and system testing to succeed. Require-\nments work is not shown on this diagram because requirements effort is not \nas directly a function of program size as other activities are (Albrecht 1979; \nGlass 1982; Boehm, Gray, and Seewaldt 1984; Boddie 1987; Card 1987; \nMcGarry, Waligora, and McDermott 19 89; Brooks 1995; Jones 1998; Jones \n2000; Boehm et al. 2000). 654\nFigure 27-4\nThe amount of software construction work is a near-linear function of \nproject size. Other kinds of work in crease nonlinearly as project size \nincreases. 655\nFigure 28-1\nThis chapter covers the software-management topics related to \nconstruction. 661\nFigure 28-2\nEstimates created early in a project are inherently inaccurate. As the project \nprogresses, estimates can become more accurate.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 71, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0072_23e72ef0", "text": "661\nFigure 28-2\nEstimates created early in a project are inherently inaccurate. As the project \nprogresses, estimates can become more accurate. Reestimate periodically \nthroughout a project, and use what you learn during each activity to improve \nyour estimate for the next activity. 673\nFigure 29-1\nThe football stadium add-on at the Un iversity of Washington collapsed \nbecause it wasn’t strong enough to support itself during construction. It \nlikely would have been strong enough when completed, but it was con-\nstructed in the wrong order—an integration error. 690\nFigure 29-2\nPhased integration is also called “big bang” integration for a good \nreason! 691\nFigure 29-3\nIncremental integration helps a project build momentum, like a snowball \ngoing down a hill. 692\nFigures\nxxxvii\nFigure 29-4\nIn phased integration, you integrate so many components at once that it’s \nhard to know where the error is. It might be in any of the components or in \nany of their connections.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 72, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0073_00e55d05", "text": "It might be in any of the components or in \nany of their connections. In incremental integration, the error is usually \neither in the new component or in the connection between the new compo-\nnent and the system. 693\nFigure 29-5\nIn top-down integration, you add classes at the top first, at the bottom \nlast. 695\nFigure 29-6\nAs an alternative to proceeding strictly top to bottom, you can integrate from \nthe top down in vertical slices. 696\nFigure 29-7\nIn bottom-up integration, you integrate classes at the bottom first, at the top \nlast. 697\nFigure 29-8\nAs an alternative to proceeding purely bottom to top, you can integrate from \nthe bottom up in sections. This blurs the line between bottom-up integration \nand feature-oriented integration, which is described later in this \nchapter. 698\nFigure 29-9\nIn sandwich integration, you integrate top-level and widely used bottom-\nlevel classes first and you save middle-level classes for last.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 73, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0074_3db0242c", "text": "698\nFigure 29-9\nIn sandwich integration, you integrate top-level and widely used bottom-\nlevel classes first and you save middle-level classes for last. 698\nFigure 29-10\nIn risk-oriented integration, you integrate classes that you expect to be most \ntroublesome first; you implem ent easier classes later. 699\nFigure 29-11\nIn feature-oriented integration, you integrate classes in groups that make up \nidentifiable features—usually, but not always, multiple classes at a \ntime. 700\nFigure 29-12\nIn T-shaped integration, you build and integrate a deep slice of the system to \nverify architectural assumptions an d then you build and integrate the \nbreadth of the system to provide a framework for developing the remaining \nfunctionality. 701\nFigure 34-1\nPrograms can be divided into levels of abstraction. A good design will allow \nyou to spend much of your time focusing on only the upper layers and ignor-\ning the lower layers.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 74, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0075_09c12d8d", "text": "701\nFigure 34-1\nPrograms can be divided into levels of abstraction. A good design will allow \nyou to spend much of your time focusing on only the upper layers and ignor-\ning the lower layers. 846\nPart I\nLaying the Foundation\nIn this part:\nChapter 1: Welcome to Software Construction . . . . . . . . . . . . . . . . . . . . . . .3\nChapter 2: Metaphors for a Richer Understanding of \nSoftware Development . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9\nChapter 3: Measure Twice, Cut Once: Upst ream Prerequisites . . . . . . . . .23\nChapter 4: Key Construction Decisions . . . . . . . . . . . . . . . . . . . . . . . . . . . . .61\n\n3\nChapter 1\nWelcome to Software \nConstruction\ncc2e.com/0178\nContents\n■\n1.1 What Is Software Construction?: page 3\n■\n1.2 Why Is Software Construction Important?: page 6\n■\n1.3 How to Read This Book: page 8\nRelated Topics\n■\nWho should read this book: Preface \n■\nBenefits of reading the book: Preface \n■\nWhy the book was written: Preface\nYou know what “construction” means when it’s used outside software development.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 75, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1084}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0076_e94a3f40", "text": "“Construction” is the work “construction workers” do when they build a house, a \nschool, or a skyscraper. When you were younger, you built things out of “construction \npaper.” In common usage, “con struction” refers to the process of building. The con-\nstruction process might include some aspect s of planning, designing, and checking \nyour work, but mostly “constru ction” refers to the hands-on part of creating something. 1.1 What Is Software Construction? Developing computer software can be a complicated process, and in the last 25 years, \nresearchers have identified numerous distinct activities that go into software develop-\nment.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 76, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 640}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0077_d407b685", "text": "Developing computer software can be a complicated process, and in the last 25 years, \nresearchers have identified numerous distinct activities that go into software develop-\nment. They include\n■\nProblem definition\n■\nRequirements development \n■\nConstruction planning\n■\nSoftware architecture, or high-level design\n■\nDetailed design\n■\nCoding and debugging \n■\nUnit testing \n4\nChapter 1: \nWelcome to Software Construction\n■\nIntegration testing\n■\nIntegration\n■\nSystem testing\n■\nCorrective maintenance\nIf you’ve worked on informal projects, you might think that this list represents a lot of \nred tape. If you’ve worked on projects that are too formal, you know that this list rep-\nresents a lot of red tape! It’s hard to stri ke a balance between too little and too much \nformality, and that’s discussed later in the book. If you’ve taught yourself to program or worked mainly on informal projects, you might \nnot have made distinctions among the many activities that go into creating a software \nproduct.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 77, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0078_942b0cd6", "text": "If you’ve taught yourself to program or worked mainly on informal projects, you might \nnot have made distinctions among the many activities that go into creating a software \nproduct. Mentally, you might have grouped all of these activities together as “program-\nming.” If you work on informal projects, the main activity you think of when you think \nabout creating software is probably the activity the researchers refer to as “construction.”\nThis intuitive notion of “construction” is fa irly accurate, but it suffers from a lack of \nperspective. Putting construction in its context with other activities helps keep the \nfocus on the right tasks during constructi on and appropriately emphasizes important \nnonconstruction activities. Figure 1-1 illust rates construction’s place related to other \nsoftware-development activities. Figure 1-1 Construction activities are shown inside the gray circle.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 78, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 900}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0079_398f2da9", "text": "Figure 1-1 illust rates construction’s place related to other \nsoftware-development activities. Figure 1-1 Construction activities are shown inside the gray circle. Construction focuses on \ncoding and debugging but also includes detailed design, unit testing, integration testing, \nand other activities. Problem\nDefinition\nRequirements\nDevelopment\nSoftware\nArchitectureSystem\nTestingDetailed\nDesign\nCoding and\nDebuggingConstruction\nPlanningIntegrationCorrective\nMaintenance\nUnit\nTesting\nIntegration\nTesting\n1.1 What Is Software Construction? 5\nAs the figure indicates, construction is mo stly coding and debugging but also involves \ndetailed design, construction planning, unit testing, integration, integration testing, \nand other activities. If this were a book ab out all aspects of software development, it \nwould feature nicely balanced discussions of all activities in the development process.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 79, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0080_725801c2", "text": "If this were a book ab out all aspects of software development, it \nwould feature nicely balanced discussions of all activities in the development process. Because this is a handbook of construction techniques, however, it places a lopsided \nemphasis on construction and only touches on related topics. If this book were a dog, \nit would nuzzle up to construction, wag its ta il at design and testing, and bark at the \nother development activities. Construction is also sometimes known as “c oding” or “programming.” “Coding” isn’t \nreally the best word because it implies the mechanical translation of a preexisting \ndesign into a computer language; constructi on is not at all mechanical and involves \nsubstantial creativity and judgment. Throug hout the book, I use “programming” inter-\nchangeably with “construction.”\nIn contrast to Figure 1-1’s flat-earth view of software development, Figure 1-2 shows \nthe round-earth perspective of this book.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 80, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0081_ae7e79cd", "text": "Figure 1-2 This book focuses on coding and debugging, detailed design, construction \nplanning, unit testing, integration, integration testing, and other activities in roughly these \nproportions. Figure 1-1 and Figure 1-2 are high-level views of construction activities, but what \nabout the details?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 81, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 298}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0082_17fc5208", "text": "Figure 1-1 and Figure 1-2 are high-level views of construction activities, but what \nabout the details? Here are some of the specific tasks involved in construction:\n■\nVerifying that the groundwork has been laid so that construction can proceed \nsuccessfully\n■\nDetermining how your code will be tested\nKEY POINT\nDetailed \nDesign\nIntegration\nUnit \nTesting\nIntegration \nTesting\nRequirements \nDevelopmentProblem \nDefinition\nSoftware \nArchitecture\nSystem \nTesting\nCorrective \nMaintenance\nConstruction \nPlanning\nCoding and \nDebugging\n6\nChapter 1: \nWelcome to Software Construction\n■\nDesigning and writing classes and routines \n■\nCreating and naming variables and named constants\n■\nSelecting control structures and organizing blocks of statements\n■\nUnit testing, integration testin g, and debugging your own code\n■\nReviewing other team members’ low-level designs and code and having them \nreview yours\n■\nPolishing code by carefully formatting and commenting it\n■\nIntegrating software components that were created separately\n■\nTuning code to make it faster and use fewer resources\nFor an even fuller list of construction activi ties, look through the chapter titles in the \ntable of contents.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 82, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1185}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0083_5d047341", "text": "With so many activities at work in construction, you might say, “OK, Jack, what activ-\nities are not part of construction?” That’s a fair question. Important nonconstruction \nactivities include management, requiremen ts development, software architecture, \nuser-interface design, system testing, and ma intenance. Each of these activities affects \nthe ultimate success of a project as much as construction—at least the success of any \nproject that calls for more than one or two people and lasts longer than a few weeks. You can find good books on each activity; many are listed in the “Additional \nResources” sections throughout the book and in Chapter 35, “Where to Find More \nInformation,” at the end of the book. 1.2 Why Is Software Construction Important? Since you’re reading this book, you probably agree that improving software quality \nand developer productivity is important. Ma ny of today’s most exciting projects use \nsoftware extensively.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 83, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0084_9e4b8abb", "text": "Since you’re reading this book, you probably agree that improving software quality \nand developer productivity is important. Ma ny of today’s most exciting projects use \nsoftware extensively. The Internet, movie spec ial effects, medical life-support systems, \nspace programs, aeronautics, high-speed financial analysis, and scientific research are \na few examples. These projects and more conventional projects can all benefit from \nimproved practices because many of the fundamentals are the same. If you agree that improving software development is important in general, the question \nfor you as a reader of this book becomes, Why is construction an important focus? 1.2 Why Is Software Construction Important? 7\nHere’s why:\nCross-Reference For details \non the relationship between \nproject size and the percent-\nage of time consumed by \nconstruction, see “Activity \nProportions and Size” in Sec-\ntion 27.5.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 84, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 910}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0085_e430660c", "text": "7\nHere’s why:\nCross-Reference For details \non the relationship between \nproject size and the percent-\nage of time consumed by \nconstruction, see “Activity \nProportions and Size” in Sec-\ntion 27.5. Construction is a large part of software development Depending on the size of the \nproject, construction typically takes 30 to 80 percent of the total time spent on a \nproject. Anything that takes up that much pr oject time is bound to affect the success \nof the project. Construction is the central activity in software development Requirements and \narchitecture are done before construction so that you can do construction effectively. System testing (in the strict sense of indepe ndent testing) is done after construction \nto verify that construction has been done correctly. Construction is at the center of the \nsoftware-development process. Cross-Reference For data on \nvariations among program-\nmers, see “Individual Varia-\ntion” in Section 28.5.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 85, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0086_13af19b7", "text": "Construction is at the center of the \nsoftware-development process. Cross-Reference For data on \nvariations among program-\nmers, see “Individual Varia-\ntion” in Section 28.5. With a focus on construction, the individual programmer’s productivity can improve \nenormously A classic study by Sackman, Erikso n, and Grant showed that the pro-\nductivity of individual programmers varied by a factor of 10 to 20 during construction \n(1968). Since their study, their results have been confirmed by numerous other stud-\nies (Curtis 1981, Mills 1983, Curtis et al. 1986, Card 1987, Valett and McGarry 1989, \nDeMarco and Lister 1999, Boehm et al. 2000). This book helps all programmers learn \ntechniques that are already used by the best programmers. Construction’s product, the source code, is often the only accurate description of the \nsoftware In many projects, the only documentation available to programmers is the \ncode itself.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 86, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0087_7d115515", "text": "Construction’s product, the source code, is often the only accurate description of the \nsoftware In many projects, the only documentation available to programmers is the \ncode itself. Requirements specifications and design documents can go out of date, but \nthe source code is always up to date. Cons equently, it’s imperative that the source \ncode be of the highest possi ble quality. Consistent appl ication of techniques for \nsource-code improvement makes the difference between a Rube Goldberg contraption \nand a detailed, correct, and therefore informative program. Such techniques are most \neffectively applied du ring construction. Construction is the only activity that’s guaranteed to be done The ideal software \nproject goes through careful requirements development and architectural design \nbefore construction begins. The ideal proj ect undergoes comprehensive, statistically \ncontrolled system testing after construction.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 87, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 934}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0088_2451b952", "text": "The ideal proj ect undergoes comprehensive, statistically \ncontrolled system testing after construction. Imperfect, real-world projects, however, \noften skip requirements and design to jump into construction. They drop testing \nbecause they have too many errors to fix and they’ve run out of time. But no matter \nhow rushed or poorly planned a project is, you can’t drop construction; it’s where the \nrubber meets the road. Improving construction is thus a way of improving any soft-\nware-development effort, no matter how abbreviated. KEY POINT\n8\nChapter 1: \nWelcome to Software Construction\n1.3 How to Read This Book\nThis book is designed to be read either cove r to cover or by topic.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 88, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 687}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0089_f5a52d67", "text": "KEY POINT\n8\nChapter 1: \nWelcome to Software Construction\n1.3 How to Read This Book\nThis book is designed to be read either cove r to cover or by topic. If you like to read \nbooks cover to cover, you might simply dive into Chapter 2, “Metaphors for a Richer \nUnderstanding of Software Development.” If you want to get to specific programming \ntips, you might begin with Chapter 6, “Working Classes,” and then follow the cross ref-\nerences to other topics you find interesting. If you’re not sure whether any of this applies \nto you, begin with Section 3.2, “Determine the Kind of Software You’re Working On.”\nKey Points\n■\nSoftware construction is the central activity in software development; construc-\ntion is the only activity that’s guaranteed to happen on every project. ■\nThe main activities in construction are detailed design, coding, debugging, inte-\ngration, and developer testing (unit testing and integration testing).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 89, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0090_9b5b04fc", "text": "■\nThe main activities in construction are detailed design, coding, debugging, inte-\ngration, and developer testing (unit testing and integration testing). ■\nOther common terms for construction are “coding” and “programming.”\n■\nThe quality of the construction substantia lly affects the quality of the software. ■\nIn the final analysis, your understanding of how to do construction determines \nhow good a programmer you are, and that’s the subject of the rest of the book. 9\nChapter 2\nMetaphors for a Richer \nUnderstanding of Software \nDevelopment\ncc2e.com/0278\nContents\n■\n2.1 The Importance of Metaphors: page 9\n■\n2.2 How to Use Software Metaphors: page 11\n■\n2.3 Common Software Metaphors: page 13\nRelated Topic\n■\nHeuristics in design: “Design Is a Heuristic Process” in Section 5.1 \nComputer science has some of the most color ful language of any field.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 90, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 854}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0091_8ff7811e", "text": "In what other \nfield can you walk into a sterile room, carefu lly controlled at 68°F, and find viruses, \nTrojan horses, worms, bugs, bombs, crashe s, flames, twisted sex changers, and fatal \nerrors? These graphic metaphors describe specific software phenomena. Equally vivid meta-\nphors describe broader phenomena, and you can use them to improve your under-\nstanding of the softwa re-development process. The rest of the book doesn’t directly depend on the discussion of metaphors in this \nchapter. Skip it if you want to get to the pr actical suggestions. Read it if you want to \nthink about software development more clearly. 2.1 The Importance of Metaphors\nImportant developments often arise out of an alogies. By comparing a topic you under-\nstand poorly to something similar you un derstand better, you can come up with \ninsights that result in a better understanding of the less-familiar topic.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 91, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0092_44a81fa7", "text": "By comparing a topic you under-\nstand poorly to something similar you un derstand better, you can come up with \ninsights that result in a better understanding of the less-familiar topic. This use of met-\naphor is called “modeling.”\nThe history of science is full of discover ies based on exploiting the power of meta-\nphors. The chemist Kekulé had a dream in which he saw a snake grasp its tail in its \nmouth. When he awoke, he realized that a molecular structure based on a similar ring \nshape would account for the properties of benzene. Further experimentation con-\nfirmed the hypothesis (Barbour 1966). 10\nChapter 2: Metaphors for a Richer Understanding of Software Development\nThe kinetic theory of gases was based on a “billiard-ball” model. Gas molecules were \nthought to have mass and to collide elastically, as billiard balls do, and many useful \ntheorems were developed from this model. The wave theory of light was developed largely by exploring similarities between light \nand sound.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 92, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0093_4d31584b", "text": "The wave theory of light was developed largely by exploring similarities between light \nand sound. Light and sound have amplitude (brightness, loudness), frequency (color, \npitch), and other properties in common. Th e comparison between the wave theories \nof sound and light was so productive that scientists spent a great deal of effort looking \nfor a medium that would propagate light the way air propagates sound. They even \ngave it a name —“ether”—but they never found the medium. The analogy that had been \nso fruitful in some ways proved to be misleading in this case. In general, the power of models is that they’re vivid and can be grasped as conceptual \nwholes. They suggest properties, relationship s, and additional areas of inquiry. Some-\ntimes a model suggests areas of inquiry that are misleading, in which case the meta-\nphor has been overextended. When the scientists looked for ether, they overextended \ntheir model. As you might expect, some metaphors are better than others.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 93, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0094_5c0f8ac2", "text": "When the scientists looked for ether, they overextended \ntheir model. As you might expect, some metaphors are better than others. A good metaphor is sim-\nple, relates well to other relevant metaphor s, and explains much of the experimental \nevidence and other observed phenomena. Consider the example of a heavy stone swinging back and forth on a string. Before \nGalileo, an Aristotelian looking at the sw inging stone thought that a heavy object \nmoved naturally from a higher position to a state of rest at a lower one. The Aristote-\nlian would think that what the stone was rea lly doing was falling wi th difficulty. When \nGalileo saw the swinging stone, he saw a pendulum. He thought that what the stone \nwas really doing was repeating the same motion again and again, almost perfectly. The suggestive powers of the two models ar e quite different.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 94, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 853}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0095_3995eaf5", "text": "He thought that what the stone \nwas really doing was repeating the same motion again and again, almost perfectly. The suggestive powers of the two models ar e quite different. The Aristotelian who saw \nthe swinging stone as an object falling would observe the stone’s weight, the height to \nwhich it had been raised, and the time it to ok to come to rest. For Galileo’s pendulum \nmodel, the prominent factors were different. Galileo observed the stone’s weight, the \nradius of the pendulum’s swing, the angular displacement, and the time per swing. Galileo discovered laws the Aristotelians could not discover because their model led \nthem to look at different phenomena and ask different questions. Metaphors contribute to a greater understan ding of software-development issues in \nthe same way that they contribute to a greater understanding of scientific questions.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 95, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 869}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0096_59f1eec4", "text": "Metaphors contribute to a greater understan ding of software-development issues in \nthe same way that they contribute to a greater understanding of scientific questions. In his 1973 Turing Award lecture, Charles Bachman described the change from the \nprevailing earth-centered view of the univer se to a sun-centered view. Ptolemy’s earth-\ncentered model had lasted without serious challenge for 1400 years. Then in 1543, \nCopernicus introduced a heliocentric theory, the idea that the sun rather than the \nearth was the center of the universe. This ch ange in mental models led ultimately to \nthe discovery of new planets, the reclassificati on of the moon as a satellite rather than \nas a planet, and a different understanding of humankind’s place in the universe. 2.2 How to Use Software Metaphors 11\nThe value of metaphors \nshould not be underesti-\nmated. Metaphors have the \nvirtue of an expected behav-\nior that is understood by all. Unnecessary communication \nand misunderstandings are \nreduced.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 96, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0097_5161ee0b", "text": "Metaphors have the \nvirtue of an expected behav-\nior that is understood by all. Unnecessary communication \nand misunderstandings are \nreduced. Learning and edu-\ncation are quicker. In effect, \nmetaphors are a way of \ninternalizing and abstracting \nconcepts, allowing one’s \nthinking to be on a higher \nplane and low-level mistakes \nto be avoided. —Fernando J. Corbató\nBachman compared the Ptolemaic-to-Copernican change in astronomy to the change \nin computer programming in the early 19 70s. When Bachman made the comparison \nin 1973, data processing was changing from a computer-centered view of information \nsystems to a database-centered view. Bachman pointed out that the ancients of data \nprocessing wanted to view all data as a se quential stream of cards flowing through a \ncomputer (the computer-centered view). The ch ange was to focus on a pool of data on \nwhich the computer happened to act (a database-oriented view).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 97, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0098_45315ed4", "text": "The ch ange was to focus on a pool of data on \nwhich the computer happened to act (a database-oriented view). Today it’s difficult to imagine anyone thinking that the sun moves around the earth. Similarly, it’s difficult to imagine a programmer thinking that all data could be viewed \nas a sequential stream of cards. In both ca ses, once the old theory has been discarded, \nit seems incredible that anyone ever believed it at all. More fantastically, people who \nbelieved the old theory thought the new theory was just as ridiculous then as you \nthink the old theory is now. The earth-centered view of the universe ho bbled astronomers who clung to it after a \nbetter theory was available. Similarly, th e computer-centered view of the computing \nuniverse hobbled computer scientists who he ld on to it after the database-centered \ntheory was available. It’s tempting to trivialize the power of meta phors.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 98, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0099_22c0928f", "text": "It’s tempting to trivialize the power of meta phors. To each of the earlier examples, the \nnatural response is to say, “Well, of cour se the right metaphor is more useful. The \nother metaphor was wrong!” Though that’s a natural reaction, it’s simplistic. The his-\ntory of science isn’t a series of switches from the “wrong” metaphor to the “right” one. It’s a series of changes from “worse” metaphors to “better” ones, from less inclusive to \nmore inclusive, from suggestive in one area to suggestive in another. In fact, many models that have been replaced by better models are still useful. Engineers \nstill solve most engineering problems by using Newtonian dynamics even though, the-\noretically, Newtonian dynamics have b een supplanted by Einsteinian theory. Software development is a younger field than most other sciences. It’s not yet mature \nenough to have a set of standard metaphor s. Consequently, it has a profusion of com-\nplementary and conflicting metaphors. Some are better than others.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 99, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0100_4a7214b2", "text": "It’s not yet mature \nenough to have a set of standard metaphor s. Consequently, it has a profusion of com-\nplementary and conflicting metaphors. Some are better than others. Some are worse. How well you understand the metaphors determines how well you understand soft-\nware development. 2.2 How to Use Software Metaphors\nA software metaphor is more like a search light than a road map. It doesn’t tell you \nwhere to find the answer; it tells you how to look for it. A metaphor serves more as a \nheuristic than it does as an algorithm. An algorithm is a set of well-defined instruct ions for carrying out a particular task. An \nalgorithm is predictable, deterministic, an d not subject to chance. An algorithm tells \nKEY POINT\n12\nChapter 2: Metaphors for a Richer Understanding of Software Development\nyou how to go from point A to point B with no detours, no side trips to points D, E, \nand F, and no stopping to smell the roses or have a cup of joe.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 100, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0101_f0a7894d", "text": "A heuristic is a technique that helps you look for an answer. Its results are subject to \nchance because a heuristic tells you only how to look, not what to find. It doesn’t tell \nyou how to get directly from point A to point B; it might not even know where point A \nand point B are. In effect, a heuristic is an algorithm in a clown suit. It’s less predict-\nable, it’s more fun, and it comes wi thout a 30-day, money-back guarantee. Here is an algorithm for driving to someone’s house: Take Highway 167 south to Puy-\nallup. Take the South Hill Mall exit and drive 4.5 miles up the hill. Turn right at the \nlight by the grocery store, and then take the first left. Turn into the driveway of the \nlarge tan house on the left, at 714 North Cedar. Cross-Reference For details \non how to use heuristics in \ndesigning software, see \n“Design Is a Heuristic Pro-\ncess” in Section 5.1. Here’s a heuristic for getting to someone’s ho use: Find the last letter we mailed you. Drive to the town in the return address.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 101, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0102_07e16cc3", "text": "Here’s a heuristic for getting to someone’s ho use: Find the last letter we mailed you. Drive to the town in the return address. When you get to town, ask someone where \nour house is. Everyone knows us—someone will be glad to help you. If you can’t find \nanyone, call us from a public phone, and we’ll come get you. The difference between an algorithm and a heuristic is subtle, and the two terms over-\nlap somewhat. For the purposes of this book, the main difference between the two is \nthe level of indirection from the solution. An algorithm gives you the instructions \ndirectly. A heuristic tells you how to discover the instructions for yourself, or at least \nwhere to look for them. Having directions that told you exactly how to solve your programming problems \nwould certainly make programming easier an d the results more predictable. But pro-\ngramming science isn’t yet that advanced and may never be.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 102, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0103_28d65b47", "text": "But pro-\ngramming science isn’t yet that advanced and may never be. The most challenging \npart of programming is conceptualizing the problem, and many errors in program-\nming are conceptual errors. Because each prog ram is conceptually unique, it’s difficult \nor impossible to create a general set of directions that lead to a solution in every case. Thus, knowing how to approach problems in ge neral is at least as valuable as knowing \nspecific solutions for specific problems. How do you use software metaphors? Use them to give you insight into your program-\nming problems and processes. Use them to help you think about your programming \nactivities and to help you imagine better ways of doing things. You won’t be able to \nlook at a line of code and say that it viol ates one of the metaphors described in this \nchapter.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 103, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 826}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0104_9f3e8838", "text": "You won’t be able to \nlook at a line of code and say that it viol ates one of the metaphors described in this \nchapter. Over time, though, the person who uses metaphors to illuminate the soft-\nware-development process will be perceive d as someone who has a better understand-\ning of programming and produces better code faster than people who don’t use them. 2.3 Common Software Metaphors 13\n2.3 Common Software Metaphors\nA confusing abundance of metaphors has gr own up around software development. David Gries says writing software is a scie nce (1981). Donald Knuth says it’s an art \n(1998). Watts Humphrey says it’s a process (1989). P. J. Plauger and Kent Beck say it’s \nlike driving a car, although they draw nearly opposite conclusions (Plauger 1993, \nBeck 2000). Alistair Cockburn says it’s a game (2002). Eric Raymond says it’s like a \nbazaar (2000). Andy Hunt and Dave Thomas say it’s like gardening. Paul Heckel says \nit’s like filming Snow White and the Seven Dwarfs (1994).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 104, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0105_99257b68", "text": "Eric Raymond says it’s like a \nbazaar (2000). Andy Hunt and Dave Thomas say it’s like gardening. Paul Heckel says \nit’s like filming Snow White and the Seven Dwarfs (1994). Fred Brooks says that it’s like \nfarming, hunting werewolves, or drowning with dinosaurs in a tar pit (1995). Which \nare the best metaphors? Software Penmanship: Writing Code\nThe most primitive metaphor for software development grows out of the expression \n“writing code.” The writing metaphor suggests that developing a program is like writing \na casual letter—you sit down with pen, ink, and paper and write it from start to finish. It \ndoesn’t require any formal planning, and you figure out what you want to say as you go. Many ideas derive from the writing metaphor. Jon Bentley says you should be able to \nsit down by the fire with a glass of brandy, a good cigar, and your favorite hunting dog \nto enjoy a “literate program” the way you would a good novel. Brian Kernighan and \nP. J.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 105, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0106_b3ba916f", "text": "Brian Kernighan and \nP. J. Plauger named their programming-style book The Elements of Programming Style \n(1978) after the writing-style book The Elements of Style (Strunk and White 2000). Programmers often talk about “program readability.”\nFor an individual’s work or for small-scale projects, the letter-writing metaphor works \nadequately, but for other purposes it leaves the party early—it doesn’t describe soft-\nware development fully or adequately. Wr iting is usually a one-person activity, \nwhereas a software project will most likely involve many people with many different \nresponsibilities. When you finish writing a letter, you stuff it into an envelope and mail \nit. You can’t change it anymore, and for all intents and purposes it’s complete. Soft-\nware isn’t as difficult to change and is hard ly ever fully complete. As much as 90 per-\ncent of the development effort on a typica l software system co mes after its initial \nrelease, with two-thirds being typical (Pigoski 1997).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 106, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0107_923e801d", "text": "As much as 90 per-\ncent of the development effort on a typica l software system co mes after its initial \nrelease, with two-thirds being typical (Pigoski 1997). In writing, a high premium is \nplaced on originality. In software constructi on, trying to create truly original work is \noften less effective than focusing on the reuse of design ideas, code, and test cases \nfrom previous projects. In short, the wr iting metaphor implies a software-develop-\nment process that’s too simp le and rigid to be healthy. 1\n23\nHARD DATA\n14\nChapter 2: Metaphors for a Richer Understanding of Software Development\nPlan to throw one away; you \nwill, anyhow. —Fred Brooks\nIf you plan to throw one \naway, you will throw away \ntwo. —Craig Zerouni\nUnfortunately, the letter-writing metaphor has been perpetuated by one of the most \npopular software books on the planet, Fred Brooks’s The Mythical Man-Month (Brooks \n1995).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 107, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 904}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0108_cb53a37d", "text": "—Craig Zerouni\nUnfortunately, the letter-writing metaphor has been perpetuated by one of the most \npopular software books on the planet, Fred Brooks’s The Mythical Man-Month (Brooks \n1995). Brooks says, “Plan to throw one away; you will, anyhow.” This conjures up an \nimage of a pile of half-written drafts thrown into a wastebasket, as shown in Figure 2-1. Figure 2-1 The letter-writing metaphor suggests th at the software process relies on expen-\nsive trial and error rather than careful planning and design. Planning to throw one away might be practi cal when you’re writing a polite how-do-\nyou-do to your aunt. But extending the metaphor of “writing” software to a plan to \nthrow one away is poor advice for software development, where a major system \nalready costs as much as a 10-story office buil ding or an ocean liner. It’s easy to grab \nthe brass ring if you can afford to sit on your favorite wooden pony for an unlimited \nnumber of spins around the carousel.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 108, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0109_8190578a", "text": "It’s easy to grab \nthe brass ring if you can afford to sit on your favorite wooden pony for an unlimited \nnumber of spins around the carousel. The trick is to get it the first time around—or to \ntake several chances when they’re cheapest. Other metaphors better illuminate ways \nof attaining such goals. Software Farming: Growing a System\nIn contrast to the rigid writing metaphor, some software developers say you should \nenvision creating software as something li ke planting seeds and growing crops. You \ndesign a piece, code a piece, test a piece, an d add it to the system a little bit at a time. By taking small steps, you minimize the trouble you can get into at any one time. Sometimes a good technique is described with a bad metaphor. In such cases, try to \nkeep the technique and come up with a better metaphor. In this case, the incremental \ntechnique is valuable, but the farming metaphor is terrible.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 109, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0110_7c5105f8", "text": "In such cases, try to \nkeep the technique and come up with a better metaphor. In this case, the incremental \ntechnique is valuable, but the farming metaphor is terrible. Further Reading For an \nillustration of a different \nfarming metaphor, one that’s \napplied to software mainte-\nnance, see the chapter “On \nthe Origins of Designer Intu-\nition” in Rethinking Systems \nAnalysis and Design (Wein-\nberg 1988). The idea of doing a little bit at a time mi ght bear some resemblance to the way crops \ngrow, but the farming analogy is weak and uninformative, and it’s easy to replace with \nthe better metaphors described in the following sections. It’s hard to extend the farm-\ning metaphor beyond the simple idea of doin g things a little bit at a time. If you buy \ninto the farming metaphor, imagined in Figure 2-2, you might find yourself talking \nabout fertilizing the system plan, thinning th e detailed design, increasing code yields \nthrough effective land management, and harvesting the code itself.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 110, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0111_6d50fe86", "text": "You’ll talk about \nKEY POINT\n2.3 Common Software Metaphors 15\nrotating in a crop of C++ instead of barley, of letting the land rest for a year to increase \nthe supply of nitrogen in the hard disk. The weakness in the software-farming metaphor is its suggestion that you don’t have \nany direct control over how the software develops. You plant the code seeds in the \nspring. Farmer’s Almanac and the Great Pumpkin willing, you’ll have a bumper crop of \ncode in the fall. Figure 2-2 It’s hard to extend the farming metaphor to software development \nappropriately. Software Oyster Farming: System Accretion\nSometimes people talk about growing software when they really mean software accre-\ntion. The two metaphors are closely related, but software accretion is the more insight-\nful image. “Accretion,” in case you don’t have a dictionary handy, means any growth or \nincrease in size by a gradual external addi tion or inclusion.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 111, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0112_09ffbd6b", "text": "“Accretion,” in case you don’t have a dictionary handy, means any growth or \nincrease in size by a gradual external addi tion or inclusion. Accretion describes the \nway an oyster makes a pearl, by gradually adding small amounts of calcium carbonate. In geology, “accretion” means a slow addition to land by the deposit of waterborne \nsediment. In legal terms, “accretion” means an increase of land along the shores of a \nbody of water by the deposit of waterborne sediment. Cross-Reference For details \non how to apply incremental \nstrategies to system integra-\ntion, see Section 29.2, “Inte-\ngration Frequency—Phased \nor Incremental?”\nThis doesn’t mean that you have to learn how to make code out of waterborne sedi-\nment; it means that you have to learn how to add to your software systems a small \namount at a time.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 112, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 818}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0113_983fee89", "text": "Other words closely relate d to accretion are “incremental,” “itera-\ntive,” “adaptive,” and “evolutionary.” Increm ental designing, building, and testing are \nsome of the most powerful software -development concepts available. In incremental development, you first make the simplest possible version of the sys-\ntem that will run. It doesn’t have to accept realistic input, it doesn’t have to perform \nrealistic manipulations on data, it doesn’t ha ve to produce realistic output—it just has \nto be a skeleton strong enough to hold the real system as it’s developed. It might call \ndummy classes for each of the basic functi ons you have identified. This basic begin-\nning is like the oyster’s beginning a pearl with a small grain of sand. After you’ve formed the skeleton, little by little you lay on the muscle and skin. You \nchange each of the dummy classes to real classes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 113, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0114_f85da2ae", "text": "After you’ve formed the skeleton, little by little you lay on the muscle and skin. You \nchange each of the dummy classes to real classes. Instead of having your program \n16\nChapter 2: Metaphors for a Richer Understanding of Software Development\npretend to accept input, you drop in code th at accepts real input. Instead of having \nyour program pretend to produce output, you drop in code that produces real output. You add a little bit of code at a time until you have a fully working system. The anecdotal evidence in favor of this approach is impressive. Fred Brooks, who in \n1975 advised building one to throw away, said that nothing in the decade after he \nwrote his landmark book The Mythical Man-Month so radically changed his own \npractice or its effectivenes s as incremental development (1995).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 114, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 804}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0115_bf7a20e8", "text": "Tom Gilb made the \nsame point in his breakthrough book, Principles of Software Engineering Management \n(1988), which introduced Evolutionary Delivery and laid the groundwork for much \nof today’s Agile programming approach. Nu merous current methodologies are based \non this idea (Beck 2000, Cockburn 2002, Highsmith 2002, Reifer 2002, Martin \n2003, Larman 2004). As a metaphor, the strength of the incremental metaphor is that it doesn’t overpromise. It’s harder than the farming metaphor to extend inappropriately. The image of an oyster \nforming a pearl is a good way to visualize incremental development, or accretion. Software Construction: Building Software\nThe image of “building” software is more us eful than that of “writing” or “growing” \nsoftware. It’s compatible with the idea of software accretion and provides more \ndetailed guidance. Building software implie s various stages of planning, preparation, \nand execution that vary in kind and degree depending on what’s being built.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 115, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0116_09d0d140", "text": "Building software implie s various stages of planning, preparation, \nand execution that vary in kind and degree depending on what’s being built. When \nyou explore the metaphor, you find many other parallels. Building a four-foot tower requires a steady hand, a level surface, and 10 undamaged \nbeer cans. Building a tower 100 times that size doesn’t merely require 100 times as \nmany beer cans. It requires a different kind of planning and construction altogether. If you’re building a simple structure—a doghouse, say—you can drive to the lumber \nstore and buy some wood and nails. By the end of the afternoon, you’ll have a new \nhouse for Fido. If you forget to provide for a door, as shown in Figure 2-3, or make \nsome other mistake, it’s not a big problem; you can fix it or even start over from the \nbeginning. All you’ve wasted is part of an afternoon. This loose approach is appropri-\nate for small software projects too.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 116, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0117_69fb5632", "text": "All you’ve wasted is part of an afternoon. This loose approach is appropri-\nate for small software projects too. If you use the wrong design for 1000 lines of code, \nyou can refactor or start over completely without losing much. KEY POINT\n2.3 Common Software Metaphors 17\nFigure 2-3 The penalty for a mistake on a simple st ructure is only a little time and maybe \nsome embarrassment. If you’re building a house, the building process is more complicated, and so are the \nconsequences of poor design. First you have to decide what kind of house you want to \nbuild—analogous in software development to problem definition. Then you and an \narchitect have to come up with a general desi gn and get it approved. This is similar to \nsoftware architectural design. You draw detail ed blueprints and hire a contractor. This \nis similar to detailed software design. You prepare the building site, lay a foundation, \nframe the house, put siding and a roof on it , and plumb and wire it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 117, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0118_a7d5c265", "text": "This \nis similar to detailed software design. You prepare the building site, lay a foundation, \nframe the house, put siding and a roof on it , and plumb and wire it. This is similar to \nsoftware construction. When most of the house is done, the landscapers, painters, \nand decorators come in to make the best of your property and the home you’ve built. This is similar to software optimization. Throughout the process, various inspectors \ncome to check the site, foundation, frame, wiring, and other inspectables. This is sim-\nilar to software reviews and inspections. Greater complexity and size imply greater cons equences in both activities. In building \na house, materials are somewhat expensive, but the main expense is labor. Ripping \nout a wall and moving it six inches is expensive not because you waste a lot of nails \nbut because you have to pay the people for the extra time it takes to move the wall.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 118, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 912}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0119_1e6a4390", "text": "Ripping \nout a wall and moving it six inches is expensive not because you waste a lot of nails \nbut because you have to pay the people for the extra time it takes to move the wall. You \nhave to make the design as good as possible, as suggested by Figure 2-4, so that you \ndon’t waste time fixing mistakes that could have been avoided. In building a software \nproduct, materials are even less expensive, but labor costs just as much. Changing a \nreport format is just as expensive as moving a wall in a house because the main cost \ncomponent in both cases is people’s time. 18\nChapter 2: Metaphors for a Richer Understanding of Software Development\nFigure 2-4 More complicated structures require more careful planning. What other parallels do the two activities sh are? In building a house, you won’t try to \nbuild things you can buy already built. You’ll buy a washer and dryer, dishwasher, \nrefrigerator, and freezer. Unless you’re a mechanical wizard, you won’t consider build-\ning them yourself.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 119, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0120_76c9ce63", "text": "You’ll buy a washer and dryer, dishwasher, \nrefrigerator, and freezer. Unless you’re a mechanical wizard, you won’t consider build-\ning them yourself. You’ll also buy prefabricated cabinets, counters, windows, doors, \nand bathroom fixtures. If you’re building a software system, you’ll do the same thing. You’ll make extensive use of high-level language features rather than writing your own \noperating-system-level code. You might also use prebuilt libraries of container classes, \nscientific functions, user in terface classes, and database-m anipulation classes. It gen-\nerally doesn’t make sense to code things you can buy ready-made. If you’re building a fancy house with first-class furnishings, however, you might have \nyour cabinets custom-made. You might have a dishwasher, refrigerator, and freezer \nbuilt in to look like the rest of your cabinets. You might have windows custom-made in \nunusual shapes and sizes. This customizatio n has parallels in software development.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 120, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0121_d2e96f8e", "text": "You might have windows custom-made in \nunusual shapes and sizes. This customizatio n has parallels in software development. If you’re building a first-class software product, you might build your own scientific \nfunctions for better speed or accuracy. You might build your own container classes, \nuser interface classes, and database classes to give your system a seamless, perfectly \nconsistent look and feel. Both building construction and software co nstruction benefit from appropriate levels \nof planning. If you build software in the wrong order, it’s hard to code, hard to test, \nand hard to debug. It can take longer to complete, or the project can fall apart because \neveryone’s work is too complex and therefore too confusing when it’s all combined. Careful planning doesn’t nece ssarily mean exhaustive pla nning or over-planning.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 121, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 841}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0122_f674ad7a", "text": "Careful planning doesn’t nece ssarily mean exhaustive pla nning or over-planning. You \ncan plan out the structural supports and decide later whether to put in hardwood \nfloors or carpeting, what color to paint the walls, what roofing material to use, and so \n2.3 Common Software Metaphors 19\non. A well-planned project improves your ability to change your mind later about \ndetails. The more experience you have with the kind of software you’re building, the \nmore details you can take for granted. You just want to be sure that you plan enough \nso that lack of planning doesn’t create major problems later. The construction analogy also helps explain why different software projects benefit \nfrom different development approaches. In bu ilding, you’d use different levels of plan-\nning, design, and quality assura nce if you’re building a warehouse or a toolshed than if \nyou’re building a medical center or a nuclear reactor.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 122, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0123_90c9fe7e", "text": "In bu ilding, you’d use different levels of plan-\nning, design, and quality assura nce if you’re building a warehouse or a toolshed than if \nyou’re building a medical center or a nuclear reactor. You’d use still different approaches \nfor building a school, a skyscraper, or a three-bedroom home. Likewise, in software you \nmight generally use flexible, lightweight development approaches, but sometimes you’ll \nneed rigid, heavyweight approaches to achieve safety goals and other goals. Making changes in the software brings up another parallel with building construc-\ntion. To move a wall six inches costs more if the wall is load-bearing than if it’s merely \na partition between rooms. Similarly, maki ng structural changes in a program costs \nmore than adding or deleting peripheral features. Finally, the construction analogy provides insight into extremely large software projects. Because the penalty for failure in an extremely large structure is severe, the structure has \nto be over-engineered.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 123, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0124_8d3246fd", "text": "Because the penalty for failure in an extremely large structure is severe, the structure has \nto be over-engineered. Builders make and inspect their plans carefully. They build in \nmargins of safety; it’s better to pay 10 percent more for stronger material than to have a \nskyscraper fall over. A great deal of attentio n is paid to timing. When the Empire State \nBuilding was built, each delivery truck had a 15-minute margin in which to make its \ndelivery. If a truck wasn’t in place at the right time, the whole project was delayed. Likewise, for extremely large software projec ts, planning of a higher order is needed \nthan for projects that are merely large. Capers Jones reports that a software system \nwith one million lines of code requires an average of 69 kinds of documentation \n(1998). The requirements specification for such a system would typically be about \n4000–5000 pages long, and the design documentation can easily be two or three \ntimes as extensive as the requirements.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 124, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0125_0e866187", "text": "The requirements specification for such a system would typically be about \n4000–5000 pages long, and the design documentation can easily be two or three \ntimes as extensive as the requirements. It’s unlikely that an individual would be able \nto understand the complete design for a projec t of this size—or even read it. A greater \ndegree of preparation is appropriate. We build software projects comparable in economic size to the Empire State Building, \nand technical and managerial controls of similar stature are needed. Further Reading For some \ngood comments about \nextending the construction \nmetaphor, see “What Sup-\nports the Roof?” (Starr 2003). The building-construction metaphor could be extended in a variety of other directions, \nwhich is why the metaphor is so powerful. Many terms common in software develop-\nment derive from the building metaphor: software architecture, scaffolding, construc-\ntion, foundation classes, and tearing code apart. You’ll probably hear many more.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 125, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0126_9a2bb5b0", "text": "You’ll probably hear many more. 20\nChapter 2: Metaphors for a Richer Understanding of Software Development\nApplying Software Techniques: The Intellectual Toolbox \nPeople who are effective at developing high -quality software have spent years accumu-\nlating dozens of techniques, tricks, and magic incantations. The techniques are not \nrules; they are analytical tools. A good craftsman knows the right tool for the job and \nknows how to use it correctly. Programmers do, too. The more you learn about pro-\ngramming, the more you fill your mental toolbox with analytical tools and the knowl-\nedge of when to use them and how to use them correctly. Cross-Reference For details \non selecting and combining \nmethods in design, see Sec-\ntion 5.3, “Des ign Building \nBlocks: Heuristics.”\nIn software, consultants some times tell you to buy into certain software-development \nmethods to the exclusion of other methods.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 126, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0127_9b30f04e", "text": "That’s unfortunate because if you buy \ninto any single methodology 100 percent, yo u’ll see the whole world in terms of that \nmethodology. In some instances, you’ll miss opportunities to use other methods bet-\nter suited to your current problem. The to olbox metaphor helps to keep all the meth-\nods, techniques, and tips in perspe ctive—ready for use when appropriate. Combining Metaphors\nBecause metaphors are heuristic rather than algorithmic, they are not mutually exclu-\nsive. You can use both the accretion and the construction metaphors. You can use \nwriting if you want to, and you can combin e writing with driving, hunting for were-\nwolves, or drowning in a tar pit with dino saurs. Use whatever metaphor or combina-\ntion of metaphors stimulates your own thin king or communicates well with others on \nyour team. Using metaphors is a fuzzy business. You have to extend them to benefit from the \nheuristic insights they provide.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 127, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 937}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0128_0a2bd3e6", "text": "Using metaphors is a fuzzy business. You have to extend them to benefit from the \nheuristic insights they provide. But if you extend them too far or in the wrong direc-\ntion, they’ll mislead you. Just as you can misuse any powerful tool, you can misuse \nmetaphors, but their power makes them a valuable part of your intellectual toolbox. Additional Resources\ncc2e.com/0285\nAmong general books on metaphors, models, and paradigms, the touchstone book is \nby Thomas Kuhn. Kuhn, Thomas S. The Structure of Scientific Revolutions , 3d ed. Chicago, IL: The Univer-\nsity of Chicago Press, 1996. Kuhn’s book on how scientific theories emerge, evolve, and \nsuccumb to other theories in a Darwinian cy cle set the philosophy of science on its ear \nwhen it was first published in 1962. It’s clear and short, and it’s loaded with interesting \nexamples of the rise and fall of metaphors, models, and paradigms in science. Floyd, Robert W. “The Paradigms of Programming.” 1978 Turing Award Lecture.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 128, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0129_4bb846b0", "text": "Floyd, Robert W. “The Paradigms of Programming.” 1978 Turing Award Lecture. Communications of the ACM , August 1979, pp. 455–60. Th is is a fascinating discus-\nsion of models in software development, and Floyd applies Kuhn’s ideas to the topic. KEY POINT\nKEY POINT\nKey Points 21\nKey Points\n■\nMetaphors are heuristics, not algorithms. As such, they tend to be a little sloppy. ■\nMetaphors help you understand the software-development process by relating it \nto other activities you already know about. ■\nSome metaphors are better than others. ■\nTreating software construction as similar to building construction suggests that \ncareful preparation is needed and illumi nates the difference between large and \nsmall projects. ■\nThinking of software-development practices as tools in an intellectual toolbox \nsuggests further that every programmer ha s many tools and that no single tool \nis right for every job. Choosing the righ t tool for each problem is one key to \nbeing an effective programmer.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 129, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0130_52dd2941", "text": "Choosing the righ t tool for each problem is one key to \nbeing an effective programmer. ■\nMetaphors are not mutually exclusive. Use the combination of metaphors that \nworks best for you. 23\nChapter 3\nMeasure Twice, Cut Once: \nUpstream Prerequisites\ncc2e.com/0309\nContents\n■\n3.1 Importance of Prerequisites: page 24\n■\n3.2 Determine the Kind of Software You’re Working On: page 31\n■\n3.3 Problem-Definition Prerequisite: page 36\n■\n3.4 Requirements Prerequisite: page 38\n■\n3.5 Architecture Prerequisite: page 43\n■\n3.6 Amount of Time to Spend on Upstream Prerequisites: page 55\nRelated Topics\n■\nKey construction decisions: Chapter 4\n■\nEffect of project size on construc tion and prerequisites: Chapter 27\n■\nRelationship between quality goals an d construction activities: Chapter 20\n■\nManaging construction: Chapter 28\n■\nDesign: Chapter 5\nBefore beginning construction of a house, a builder reviews blueprints, checks that all \npermits have been obtained, and surveys the house’s foundation.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 130, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0131_67d7bd9d", "text": "A builder prepares \nfor building a skyscraper one way, a housing development a different way, and a dog-\nhouse a third way. No matter what the project, the preparation is tailored to the \nproject’s specific needs and done consci entiously before construction begins. This chapter describes the work that must be done to prepare for software construc-\ntion. As with building construction, much of the success or failure of the project has \nalready been determined before construction begins. If the foundation hasn’t been \nlaid well or the planning is inadequate, the best you can do during construction is to \nkeep damage to a minimum. The carpenter’s saying, “Measure twice, cut once” is highly relevant to the construc-\ntion part of software development, which ca n account for as much as 65 percent of the \ntotal project costs. The worst software projects end up doing construction two or \n24\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\nthree times or more.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 131, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0132_9585444e", "text": "The worst software projects end up doing construction two or \n24\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\nthree times or more. Doing the most expensiv e part of the project twice is as bad an \nidea in software as it is in any other line of work. Although this chapter lays the groundwork for successful software construction, it \ndoesn’t discuss construction directly. If yo u’re feeling carnivorous or you’re already \nwell versed in the software-engineering lif e cycle, look for the construction meat \nbeginning in Chapter 5, “Des ign in Construction.” If you don’t like the idea of pre-\nrequisites to construction, review Sectio n 3.2, “Determine the Kind of Software \nYou’re Working On,” to see how prerequisites apply to your situation, and then take \na look at the data in Section 3.1, which describes the cost of not doing prerequisites. 3.1 Importance of Prerequisites\nCross-Reference Paying \nattention to quality is also \nthe best way to improve pro-\nductivity.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 132, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0133_f0014928", "text": "3.1 Importance of Prerequisites\nCross-Reference Paying \nattention to quality is also \nthe best way to improve pro-\nductivity. For details, see \nSection 20.5, “The General \nPrinciple of Software \nQuality.”\nA common denominator of programmers who bu ild high-quality software is their use \nof high-quality practices. Such practices emphasize quality at the beginning, middle, \nand end of a project. If you emphasize quality at the end of a project, you emphasize system testing. Testing \nis what many people think of when they th ink of software quality assurance. Testing, \nhowever, is only one part of a complete quality-assurance strategy, and it’s not the \nmost influential part. Testing can’t detect a flaw such as building the wrong product or \nbuilding the right product in the wrong way. Such flaws must be worked out earlier \nthan in testing—before construction begins. If you emphasize quality in the middle of the project, you emphasize construction \npractices.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 133, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0134_67e0452f", "text": "Such flaws must be worked out earlier \nthan in testing—before construction begins. If you emphasize quality in the middle of the project, you emphasize construction \npractices. Such practices are the focus of most of this book. If you emphasize quality at the beginning of the project, you plan for, require, and \ndesign a high-quality product. If you start the process with designs for a Pontiac Aztek, \nyou can test it all you want to, and it will never turn into a Rolls-Royce. You might \nbuild the best possible Aztek, but if you want a Rolls-Royce, you have to plan from the \nbeginning to build one. In software deve lopment, you do such planning when you \ndefine the problem, when you specify the s olution, and when you design the solution. Since construction is in the middle of a so ftware project, by the time you get to con-\nstruction, the earlier parts of the project ha ve already laid some of the groundwork for \nsuccess or failure.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 134, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0135_24ad8ed6", "text": "Since construction is in the middle of a so ftware project, by the time you get to con-\nstruction, the earlier parts of the project ha ve already laid some of the groundwork for \nsuccess or failure. During construction, however, you should at least be able to deter-\nmine how good your situation is and to back up if you see the black clouds of failure \nlooming on the horizon. The rest of this ch apter describes in detail why proper prep-\naration is important and tells you how to determine whether you’re really ready to \nbegin construction. KEY POINT\n3.1 Importance of Prerequisites 25\nDo Prerequisites Apply to Modern Software Projects? The methodology used \nshould be based on choice of \nthe latest and best, and not \nbased on ignorance. It \nshould also be laced liberally \nwith the old and dependable. —Harlan Mills\nSome people have asserted that upstream ac tivities such as architecture, design, and \nproject planning aren’t useful on modern software projects.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 135, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0136_15065b6e", "text": "—Harlan Mills\nSome people have asserted that upstream ac tivities such as architecture, design, and \nproject planning aren’t useful on modern software projects. In the main, such asser-\ntions are not well supported by research, past or present, or by current data. (See the \nrest of this chapter for details.) Opponents of prerequisites typica lly show examples of \nprerequisites that have been done poorly and then point out that such work isn’t \neffective. Upstream activities can be done well, however, and industry data from the \n1970s to the present day indicates that projects will run best if appropriate prepara-\ntion activities are done before construction begins in earnest. The overarching goal of preparation is risk reduction: a good project planner clears \nmajor risks out of the way as early as possibl e so that the bulk of the project can pro-\nceed as smoothly as possible.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 136, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 890}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0137_01c0b3d6", "text": "By far the most common project risks in software devel-\nopment are poor requirements and poor pr oject planning, thus preparation tends to \nfocus on improving requirements and project plans. Preparation for construction is not an exact science, and the specific approach to risk \nreduction must be decided project by projec t. Details can vary greatly among projects. For more on this, see Section 3.2. Causes of Incomplete Preparation\nYou might think that all professional programmers know about the importance of \npreparation and check that the prerequisites have been satisfied before jumping into \nconstruction. Unfortunately, that isn’t so. Further Reading For a \ndescription of a professional \ndevelopment program that \ncultivates these skills, see \nChapter 16 of Professional \nSoftware Development \n(McConnell 2004).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 137, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 823}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0138_137e6cee", "text": "Further Reading For a \ndescription of a professional \ndevelopment program that \ncultivates these skills, see \nChapter 16 of Professional \nSoftware Development \n(McConnell 2004). cc2e.com/0316\nA common cause of incomplete preparation is that the developers who are assigned to \nwork on the upstream activities do not have the expertise to carry out their assignments. The skills needed to plan a project, create a compelling business case, develop compre-\nhensive and accurate requirements, and create high-quality architectures are far from \ntrivial, but most developers have not received training in how to perform these activities. When developers don’t know how to do upstream work, the recommendation to “do \nmore upstream work” sounds like nonsense: If the work isn’t being done well in the first \nplace, doing more of it will not be useful!", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 138, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 846}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0139_3f2890c5", "text": "Explaining how to perform these activities is \nbeyond the scope of this book, but the “Additional Resources” sections at the end of this \nchapter provide numerous options for gaining that expertise. Some programmers do know how to perform upstream activities, but they don’t prepare \nbecause they can’t resist the urge to begin co ding as soon as possible. If you feed your \nKEY POINT\n26\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\nhorse at this trough, I have two suggestions. Suggestion 1: Read the argument in the next \nsection. It may tell you a few things you haven’ t thought of. Suggestion 2: Pay attention to \nthe problems you experience. It takes only a few large programs to learn that you can \navoid a lot of stress by planning ahead. Let your own experience be your guide. A final reason that programmers don’t pr epare is that managers are notoriously \nunsympathetic to programmers who spend time on construction prerequisites.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 139, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0140_e9fa8e9e", "text": "Let your own experience be your guide. A final reason that programmers don’t pr epare is that managers are notoriously \nunsympathetic to programmers who spend time on construction prerequisites. Peo-\nple like Barry Boehm, Grady Booch, and Ka rl Wiegers have been banging the require-\nments and design drums for 25 years, and you’d expect that managers would have \nstarted to understand that software development is more than coding. Further Reading For many \nentertaining variations on \nthis theme, read Gerald \nWeinberg’s classic, The Psy-\nchology of Computer Pro-\ngramming (Weinberg 1998). A few years ago, however, I was working on a Department of Defense project that was \nfocusing on requirements development when the Army general in charge of the \nproject came for a visit. We told him that we were developing requirements and that \nwe were mainly talking to our customer, capturing requirements, and outlining the \ndesign. He insisted on seeing code anyway.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 140, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0141_31457b3e", "text": "We told him that we were developing requirements and that \nwe were mainly talking to our customer, capturing requirements, and outlining the \ndesign. He insisted on seeing code anyway. We told him there was no code, but he \nwalked around a work bay of 100 people, determined to catch someone program-\nming. Frustrated by seeing so many peop le away from their desks or working on \nrequirements and design, the large, round ma n with the loud voice finally pointed to \nthe engineer sitting next to me and bellowed, “What’s he doing? He must be writing \ncode!” In fact, the engineer was working on a document-formatting utility, but the gen-\neral wanted to find code, thought it looked like code, and wanted the engineer to be \nworking on code, so we told him it was code. This phenomenon is known as the WISCA or WIMP syndrome: Why Isn’t Sam Cod-\ning Anything? or Why Isn’t Mary Programming?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 141, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 890}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0142_0574b76f", "text": "This phenomenon is known as the WISCA or WIMP syndrome: Why Isn’t Sam Cod-\ning Anything? or Why Isn’t Mary Programming? If the manager of your project pretends to be a brigadier general and orders you to \nstart coding right away, it’s easy to say, “Yes, Sir!” (What’s the harm? The old guy must \nknow what he’s talking about.) This is a bad response, and you have several better \nalternatives. First, you can flatly refuse to do work in an ineffective order. If your rela-\ntionships with your boss and your bank acco unt are healthy enough for you to be able \nto do this, good luck. A second questionable alternative is pretendi ng to be coding when you’re not. Put an \nold program listing on the corner of your desk. Then go right ahead and develop your \nrequirements and architecture, with or without your boss’s approval. You’ll do the \nproject faster and with higher-quality result s. Some people find this approach ethi-\ncally objectionable, but from your boss’s perspective, ignorance will be bliss.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 142, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0143_03ddc261", "text": "You’ll do the \nproject faster and with higher-quality result s. Some people find this approach ethi-\ncally objectionable, but from your boss’s perspective, ignorance will be bliss. Third, you can educate your boss in the nuances of technical projects. This is a good \napproach because it increases the number of enlightened bosses in the world. The \nnext subsection presents an extended ration ale for taking the time to do prerequisites \nbefore construction. 3.1 Importance of Prerequisites 27\nFinally, you can find another job. Despit e economic ups and downs, good program-\nmers are perennially in short supply (BLS 2002), and life is too short to work in an \nunenlightened programming shop when plen ty of better alternatives are available.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 143, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 744}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0144_a656a523", "text": "Utterly Compelling and Foolproof Ar gument for Doing Prerequisites \nBefore Construction \nSuppose you’ve already been to the mountain of problem definition, walked a mile \nwith the man of requirements, shed your so iled garments at the fountain of architec-\nture, and bathed in the pure waters of preparedness. Then you know that before you \nimplement a system, you need to understand what the system is supposed to do and \nhow it’s supposed to do it. Part of your job as a technical employee is to educate the nontech nical people around \nyou about the development process. This section will help you deal with managers \nand bosses who have not yet seen the light. It’s an extended argument for doing \nrequirements and architecture—getting the critical aspects right—before you begin cod-\ning, testing, and debugging. Learn the argument, and then sit down with your boss \nand have a heart-to-heart talk about the programming process.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 144, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0145_01be5ee8", "text": "Learn the argument, and then sit down with your boss \nand have a heart-to-heart talk about the programming process. Appeal to Logic\nOne of the key ideas in effective programming is that preparation is important. It \nmakes sense that before you start working on a big project, you should plan the \nproject. Big projects require more planning ; small projects require less. From a man-\nagement point of view, planning means determining the amount of time, number of \npeople, and number of computers the project will need. From a technical point of \nview, planning means understanding what yo u want to build so that you don’t waste \nmoney building the wrong thing. Sometimes users aren’t entirely sure what they want \nat first, so it might take more effort than seems ideal to find out what they really want. But that’s cheaper than building the wrong th ing, throwing it away, and starting over. It’s also important to think about how to build the system before you begin to build it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 145, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0146_d03bd3b4", "text": "But that’s cheaper than building the wrong th ing, throwing it away, and starting over. It’s also important to think about how to build the system before you begin to build it. You don’t want to spend a lot of time and money going down blind alleys when \nthere’s no need to, especially when that increases costs. Appeal to Analogy\nBuilding a software system is like any othe r project that takes people and money. If \nyou’re building a house, you make architectural drawings and blueprints before you \nbegin pounding nails. You’ll have the blue prints reviewed and approved before you \npour any concrete. Having a technical plan counts just as much in software. KEY POINT\n28\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\nYou don’t start decorating the Christmas tree un til you’ve put it in the stand. You don’t \nstart a fire until you’ve opened the flue. You don’t go on a long trip with an empty tank \nof gas.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 146, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 925}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0147_6e3bb55c", "text": "You don’t \nstart a fire until you’ve opened the flue. You don’t go on a long trip with an empty tank \nof gas. You don’t get dressed before you take a shower, and you don’t put your shoes \non before your socks. You have to do things in the right order in software, too. Programmers are at the end of the software food chain. The architect consumes the \nrequirements; the designer consumes the architecture; and the coder consumes \nthe design. Compare the software food chain to a real food chain. In an ecologically sound envi-\nronment, seagulls eat fresh salmon. That’s nourishing to them because the salmon ate \nfresh herring, and they in turn ate fresh wate r bugs. The result is a healthy food chain. In programming, if you have healthy food at ea ch stage in the food chain, the result is \nhealthy code written by happy programmers.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 147, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 836}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0148_3dad7a72", "text": "The result is a healthy food chain. In programming, if you have healthy food at ea ch stage in the food chain, the result is \nhealthy code written by happy programmers. In a polluted environment, the water bugs have been swimming in nuclear waste, the \nherring are contaminated by PCBs, and the salmon that eat the herring swam through \noil spills. The seagulls are, unfortunately, at the end of the food chain, so they don’t eat \njust the oil in the bad salmon. They also eat the PCBs and the nuclear waste from the \nherring and the water bugs. In programming, if your requirements are contaminated, \nthey contaminate the architecture, and the architecture in turn contaminates con-\nstruction. This leads to grumpy, malnourished programmers and radioactive, pol-\nluted software that’s riddled with defects.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 148, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 807}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0149_83e86027", "text": "This leads to grumpy, malnourished programmers and radioactive, pol-\nluted software that’s riddled with defects. If you are planning a highly iterative projec t, you will need to identify the critical \nrequirements and architectural elements that apply to each piece you’re constructing \nbefore you begin construction. A builder who is building a housing development \ndoesn’t need to know every detail of every house in the development before begin-\nning construction on the first house. But the builder will survey the site, map out \nsewer and electrical lines, and so on. If th e builder doesn’t prepare well, construction \nmay be delayed when a sewer line needs to be dug under a house that’s already been \nconstructed. Appeal to Data\nStudies over the last 25 years have proven conclusively that it pays to do things right \nthe first time. Unnecessary changes are expensive.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 149, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0150_a32260eb", "text": "Appeal to Data\nStudies over the last 25 years have proven conclusively that it pays to do things right \nthe first time. Unnecessary changes are expensive. 3.1 Importance of Prerequisites 29\nResearchers at Hewlett-Packard, IBM, Hugh es Aircraft, TRW, and other organizations \nhave found that purging an error by the beginning of construction allows rework to be \ndone 10 to 100 times less expensively than when it’s done in the last part of the pro-\ncess, during system test or after release (Fagan 1976; Humphrey, Snyder, and Willis \n1991; Leffingwell 1997; Willis et al. 1998 ; Grady 1999; Shull et al. 2002; Boehm and \nTurner 2004). In general, the principle is to find an error as close as possible to the time at which it \nwas introduced. The longer the defect stays in the software food chain, the more dam-\nage it causes further down the chain. Since requirements are done first, requirements \ndefects have the potential to be in the system longer and to be more expensive.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 150, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0151_ba6a7ad3", "text": "Since requirements are done first, requirements \ndefects have the potential to be in the system longer and to be more expensive. Defects \ninserted into the software upstream also tend to have broader effects than those \ninserted further downstream. That also makes early defects more expensive. Table 3-1 shows the relative expense of fixing defects depending on when they’re \nintroduced and when they’re found. The data in Table 3-1 shows that, for example, an architecture defect that costs $1000 \nto fix when the architecture is being create d can cost $15,000 to fix during system \ntest. Figure 3-1 illustrates the same phenomenon.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 151, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 635}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0152_1e1a5b17", "text": "Figure 3-1 illustrates the same phenomenon. 1\n23\nHARD DATA\n1\n23\nHARD DATA\nTable 3-1\nAverage Cost of Fixing Defects Based on When They’re Introduced and Detected\nTime Detected\nTime Introduced Requirements Architecture Constr uction System Test Post-Release\nRequirements 135 –10 1 0 1 0–100\nArchitecture — 1 10 15 25–100\nConstruction — — 1 10 10–25\nSource: Adapted from “Design and Co de Inspections to Reduce Errors in Program Development” (Fagan 1976), Software Defect Removal \n(Dunn 1984), “Software Process Improvement at Hughes Aircraft” (Humphrey, Snyder, and Willis 1991), “Calculating the Return on \nInvestment from More Effective Requirements Management” (Le ffingwell 1997), “Hughes Aircraft’s Widespread Deployment of a \nContinuously Improving Software Process” (Willis et al. 1998), “An Economic Release Decis ion Model: Insights into Software Proj ect \nManagement” (Grady 1999), “What We Have Learned About Fighting Defects” (Shull et al.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 152, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0153_8586537e", "text": "1998), “An Economic Release Decis ion Model: Insights into Software Proj ect \nManagement” (Grady 1999), “What We Have Learned About Fighting Defects” (Shull et al. 2002), and Balancing Agility and Discipline: \nA Guide for the Perplexed (Boehm and Turner 2004). 30\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\nFigure 3-1 The cost to fix a defect rises dramatically as the time from when it’s introduced \nto when it’s detected increases. This remains true whether the project is highly sequential \n(doing 100 percent of requirements and design up front) or highly iterative (doing 5 percent \nof requirements and design up front).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 153, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 642}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0154_a1faedf6", "text": "This remains true whether the project is highly sequential \n(doing 100 percent of requirements and design up front) or highly iterative (doing 5 percent \nof requirements and design up front). The average project still exerts most of its defect-correction effort on the right side of Fig-\nure 3-1, which means that debugging and associated rework takes about 50 percent of \nthe time spent in a typical software development cycle (Mills 1983; Boehm 1987a; Coo-\nper and Mullen 1993; Fishman 1996; Haley 1996; Wheeler, Brykczynski, and Meeson \n1996; Jones 1998; Shull et al. 2002; Wiegers 2002). Dozens of companies have found \nthat simply focusing on correcting defects earlier rather than later in a project can cut \ndevelopment costs and schedules by factors of two or more (McConnell 2004). This is \na healthy incentive to find and fix your problems as early as you can.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 154, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 870}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0155_a3306666", "text": "This is \na healthy incentive to find and fix your problems as early as you can. Boss-Readiness Test\nWhen you think your boss understands the importance of working on prerequisites \nbefore moving into construction, try the test below to be sure. Which of these statements are self-fulfilling prophecies? ■\nWe’d better start coding right away because we’re going to have a lot of debug-\nging to do. ■\nWe haven’t planned much time for testing because we’re not going to find many \ndefects. Phase in Which a \nDefect Is Introduced\nRequirements\nArchitecture\nConstruction\nSystem TestRequirementsArchitectureConstruction Post-Release\nPhase in Which a Defect Is DetectedCost\n1\n23\nHARD DATA\n3.2 Determine the Kind of Software You’re Working On 31\n■\nWe’ve investigated requirements and design so much that I can’t think of any \nmajor problems we’ll run into during coding or debugging. All of these statements are self-fulfilling prophecies. Aim for the last one.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 155, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0156_8df2941b", "text": "All of these statements are self-fulfilling prophecies. Aim for the last one. If you’re still not convinced that prerequisites apply to your project, the next section \nwill help you decide. 3.2 Determine the Kind of Software You’re Working On\nCapers Jones, Chief Scientist at Software Productivity Research, summarized 20 years \nof software research by pointing out that he and his colleagues have seen 40 different \nmethods for gathering requirements, 50 vari ations in working on software designs, \nand 30 kinds of testing applied to projects in more than 700 different programming \nlanguages (Jones 2003). Different kinds of software projects call for different balances between preparation \nand construction. Every project is unique, bu t projects do tend to fall into general \ndevelopment styles. Table 3-2 shows three of the most common kinds of projects and \nlists the practices that are typically be st suited to each kind of project.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 156, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0157_91d6cba5", "text": "Table 3-2 shows three of the most common kinds of projects and \nlists the practices that are typically be st suited to each kind of project. Table 3-2\nTypical Good Practices for Three Common Kinds of Software Projects \nKind of Software\nBusiness SystemsMission-Critical \nSystemsEmbedded \nLife-Critical Systems\nTypical \napplicationsInternet site \nIntranet site\nInventory \nmanagement\nGames\nManagement \ninformation systems\nPayroll systemEmbedded software\nGames\nInternet site\nPackaged software\nSoftware tools\nWeb servicesAvionics software\nEmbedded software \nMedical devices\nOperating systems\nPackaged software\nLife-cycle \nmodelsAgile development \n(Extreme Program-\nming, Scrum, time-\nbox development, \nand so on)\nEvolutionary \nprototypingStaged delivery \nEvolutionary \ndelivery\nSpiral developmentStaged delivery\nSpiral development\nEvolutionary delivery\n32\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\nOn real projects, you’ll find infinite variations on the three themes presented in this \ntable; however, the generalities in the ta ble are illuminating.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 157, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1064}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0158_ce4afea1", "text": "Business systems projects \ntend to benefit from highly iterative approaches, in which planning, requirements, \nBusiness SystemsMission-Critical \nSystemsEmbedded \nLife-Critical Systems\nPlanning and \nmanagementIncremental project \nplanning\nAs-needed test and \nQA planning\nInformal change \ncontrolBasic up-front \nplanning\nBasic test planning \nAs-needed QA \nplanning\nFormal change \ncontrolExtensive up-front \nplanning \nExtensive test \nplanning \nExtensive QA \nplanning\nRigorous change \ncontrol\nRequirements Informal require-\nments specificationSemiformal require-\nments specification\nAs-needed require-\nments reviewsFormal requirements \nspecification \nFormal requirements \ninspections\nDesign Design and coding \nare combinedArchitectural design \nInformal detailed \ndesign\nAs-needed design \nreviewsArchitectural design \nFormal architecture \ninspections \nFormal detailed \ndesign\nFormal detailed \ndesign inspections\nConstruction Pair programming \nor individual coding\nInformal check-in \nprocedure or no \ncheck-in procedurePair programming \nor individual coding\nInformal check-in \nprocedure\nAs-needed code \nreviewsPair programming or \nindividual coding \nFormal check-in \nprocedure\nFormal code \ninspections\nTesting \nand QADevelopers test \ntheir own code\nTest-first \ndevelopment\nLittle or no testing \nby a separate test \ngroupDevelopers test \ntheir own code \nTest-first \ndevelopment \nSeparate testing \ngroupDevelopers test their \nown code \nTest-first \ndevelopment\nSeparate testing \ngroup \nSeparate QA group\nDeployment Informal deploy-\nment procedureFormal deployment \nprocedureFormal deployment \nprocedureTable 3-2\nTypical Good Practices for Three Common Kinds of Software Projects \nKind of Software\n3.2 Determine the Kind of Software You’re Working On 33\nand architecture are interleaved with constr uction, system testing, and quality-assur-\nance activities.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 158, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1848}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0159_db177181", "text": "Life-critical systems tend to require more sequential approaches—\nrequirements stability is part of what’s needed to ensure ultrahigh levels of reliability. Iterative Approaches’ Effect on Prerequisites\nSome writers have asserted that projects that use iterative techniques don’t need to \nfocus on prerequisites much at all, but that point of view is misinformed. Iterative \napproaches tend to reduce the impact of inadequate upstream work, but they don’t \neliminate it. Consider the examples shown in Table 3-3 of projects that don’t focus on \nprerequisites. One project is conducted sequentially and relies solely on testing to dis-\ncover defects; the other is conducted iteratively and discovers defects as it progresses. The first approach delays most defect correction work to the end of the project, making \nthe costs higher, as noted in Table 3-1. The iterative approach absorbs rework piecemeal \nover the course of the project, which makes the total cost lower.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 159, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0160_43c11029", "text": "The iterative approach absorbs rework piecemeal \nover the course of the project, which makes the total cost lower. The data in this table \nand the next is for purposes of illustration only, but the relative costs of the two general \napproaches are well supported by the rese arch described earlier in this chapter. The iterative project that abbreviates or e liminates prerequisites will differ in two \nways from a sequential project that does the same thing. First, average defect correc-\ntion costs will be lower becaus e defects will tend to be de tected closer to the time \nthey were inserted into the software. Howe ver, the defects will st ill be detected late \nin each iteration, and correcting them will require parts of the software to be \nredesigned, recoded, and retested—which makes the defect-correction cost higher \nthan it needs to be.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 160, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 850}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0161_52a60cd3", "text": "Table 3-3\nEffect of Skipping Prerequisites on Sequential and Iterative Projects\nApproach #1: Sequential \nApproach Without \nPrerequisites\nApproach #2: Iterative \nApproach Without \nPrerequisites\nProject Completion \nStatus Cost of WorkCost of \nRework Cost of WorkCost of \nRework\n20% $100,000 $0 $100,000 $75,000\n40% $100,000 $0 $100,000 $75,000\n60% $100,000 $0 $100,000 $75,000\n80% $100,000 $0 $100,000 $75,000\n100% $100,000 $0 $100,000 $75,000\nEnd-of-Project \nRework $0 $500,000 $0 $0\nTOTAL $500,000 $500,000 $500,000 $375,000\nGRAND TOTAL $1,000,000 $875,000\n34\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\nSecond, with iterative approaches costs wi ll be absorbed piecemeal, throughout the \nproject, rather than being clustered at the end. When all the dust settles, the total cost \nwill be similar but it won’t seem as high b ecause the price will have been paid in small \ninstallments over the course of the project, rather than paid all at once at the end.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 161, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0162_46f9d957", "text": "As Table 3-4 illustrates, a focus on prer equisites can reduce costs regardless of \nwhether you use an iterative or a sequential approach. Iterative approaches are usually \na better option for many reasons, but an iterative approach that ignores prerequisites \ncan end up costing significantly more than a sequential project that pays close atten-\ntion to prerequisites. As Table 3-4 suggested, most projects are neither completely sequential nor com-\npletely iterative. It isn’t practical to specify 100 percent of the requirements or design \nup front, but most projects find value in identifying at least the most critical require-\nments and architectural elements early.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 162, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 673}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0163_2068bf2e", "text": "Cross-Reference For details \non how to adapt your devel-\nopment approach for pro-\ngrams of different sizes, see \nChapter 27, “How Program \nSize Affects Construction.”\nOne common rule of thumb is to plan to specify about 80 percent of the requirements \nup front, allocate time for additional requirem ents to be specified later, and then prac-\ntice systematic change control to accept only the most valuable new requirements as \nthe project progresses. Another alternative is to specify only the most important 20 \npercent of the requirements up front and plan to develop the rest of the software in \nsmall increments, specifying additional requirements and designs as you go. Figures \n3-2 and 3-3 reflect these different approaches.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 163, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 732}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0164_aab5d47f", "text": "Figures \n3-2 and 3-3 reflect these different approaches. Table 3-4\nEffect of Focusing on Prerequisi tes on Sequential and Iterative \nProjects \nApproach #3: Sequential \nApproach with Prerequisites\nApproach #4: Iterative \nApproach with Prerequisites\nProject completion \nstatus Cost of WorkCost of \nRework Cost of WorkCost of \nRework\n20% $100,000 $20,000 $100,000 $10,000\n40% $100,000 $20,000 $100,000 $10,000\n60% $100,000 $20,000 $100,000 $10,000\n80% $100,000 $20,000 $100,000 $10,000\n100% $100,000 $20,000 $100,000 $10,000\nEnd-of-Project \nRework $0 $0 $0 $0\nTOTAL $500,000 $100,000 $500,000 $50,000\nGRAND TOTAL $600,000 $550,000\nKEY POINT\n3.2 Determine the Kind of Software You’re Working On 35\nFigure 3-2 Activities will overlap to some degree on most projects, even those that are \nhighly sequential. Figure 3-3 On other projects, activities will overlap for the duration of the project.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 164, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0165_833df144", "text": "Figure 3-3 On other projects, activities will overlap for the duration of the project. One key \nto successful construction is understanding the degree to which prerequisites have been \ncompleted and adjusting your approach accordingly. Choosing Between Iterative and Sequential Approaches\nThe extent to which prerequisites need to be satisfied up front will vary with the \nproject type indicated in Table 3-2, project formality, technical environment, staff \ncapabilities, and project business goals. You might choose a more sequential (up-\nfront) approach when \n■\nThe requirements are fairly stable. ■\nThe design is straightforward and fairly well understood. ■\nThe development team is familiar with the applications area.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 165, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 723}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0166_302ae131", "text": "■\nThe design is straightforward and fairly well understood. ■\nThe development team is familiar with the applications area. Quality Assurance/System Testing\nRequirements\nArchitecture\nDetailed Design\nConstruction\nTime\nTime\nQuality Assurance/System Testing\nRequirements\nDetailed Design\nArchitecture\nDetailed Design\nConstruction\n36\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\n■\nThe project contains little risk. ■\nLong-term predictability is important. ■\nThe cost of changing requirements, design, and code downstream is likely to be \nhigh. You might choose a more iterat ive (as-you-go) approach when\n■\nThe requirements are not well understood or you expect them to be unstable for \nother reasons. ■\nThe design is complex, challenging, or both. ■\nThe development team is unfamiliar with the applications area. ■\nThe project contains a lot of risk. ■\nLong-term predictability is not important. ■\nThe cost of changing requirements, design, and code downstream is likely to be \nlow.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 166, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0167_df28629e", "text": "■\nThe project contains a lot of risk. ■\nLong-term predictability is not important. ■\nThe cost of changing requirements, design, and code downstream is likely to be \nlow. Software being what it is, iterative appr oaches are useful much more often than \nsequential approaches are. You can adapt the prerequisites to your specific project by \nmaking them more or less formal and more or less complete, as you see fit. For a \ndetailed discussion of differ ent approaches to large and small projects (also known as \nthe different approaches to formal an d informal projects), see Chapter 27. The net impact on construction prerequisite s is that you should first determine what \nconstruction prerequisites are well suited to your project. Some projects spend too lit-\ntle time on prerequisites, which exposes cons truction to an unnece ssarily high rate of \ndestabilizing changes and prevents the project from making consistent progress.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 167, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 932}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0168_78d75ac2", "text": "Some projects spend too lit-\ntle time on prerequisites, which exposes cons truction to an unnece ssarily high rate of \ndestabilizing changes and prevents the project from making consistent progress. Some projects do too much up front; they doggedly adhere to requirements and plans \nthat have been invalidated by downstream discoveries, and that can also impede \nprogress during construction. Now that you’ve studied Table 3-2 and determined what prerequisites are appropriate \nfor your project, the rest of this chapter describes how to determine whether each spe-\ncific construction prerequisite has been “prereq’d” or “prewrecked.”\n3.3 Problem-Definition Prerequisite\nIf the “box” is the boundary \nof constraints and condi-\ntions, then the trick is to find \nthe box.... Don’t think out-\nside the box—find the box. —Andy Hunt and Dave \nThomas\nThe first prerequisite you need to fulfill be fore beginning construction is a clear state-\nment of the problem that the system is su pposed to solve.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 168, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0169_6d1838d8", "text": "—Andy Hunt and Dave \nThomas\nThe first prerequisite you need to fulfill be fore beginning construction is a clear state-\nment of the problem that the system is su pposed to solve. This is sometimes called \n“product vision,” “vision st atement,” “mission statement,” or “product definition.” \nHere it’s called “problem definition.” Since this book is about construction, this sec-\ntion doesn’t tell you how to write a problem definition; it tells you how to recognize \nwhether one has been written at all and whether the one that’s written will form a \ngood foundation for construction. 3.3 Problem-Defini tion Prerequisite 37\nA problem definition defines what the problem is without any reference to possible \nsolutions. It’s a simple statement, maybe on e or two pages, and it should sound like a \nproblem. The statement “We can’t keep up with orders for the Gigatron” sounds like \na problem and is a good problem definition .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 169, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0170_25a465ac", "text": "The statement “We can’t keep up with orders for the Gigatron” sounds like \na problem and is a good problem definition . The statement “We need to optimize our \nautomated data-entry system to keep up with orders for the Gigatron” is a poor prob-\nlem definition. It doesn’t sound like a problem; it sounds like a solution. As shown in Figure 3-4, problem definition comes before detailed requirements work, \nwhich is a more in-depth investigation of the problem. Figure 3-4 The problem definition lays the foundat ion for the rest of the programming \nprocess. The problem definition should be in user language, and the problem should be \ndescribed from a user’s point of view. It us ually should not be stated in technical com-\nputer terms. The best solution might not be a computer program. Suppose you need \na report that shows your annual profit. Yo u already have computerized reports that \nshow quarterly profits.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 170, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0171_ee5d4d93", "text": "The best solution might not be a computer program. Suppose you need \na report that shows your annual profit. Yo u already have computerized reports that \nshow quarterly profits. If you’re locked into the programmer mindset, you’ll reason \nthat adding an annual report to a system th at already does quarterly reports should be \neasy. Then you’ll pay a programmer to write and debug a time-consuming program \nthat calculates annual profits. If you’ re not locked into the programmer mindset, \nyou’ll pay your secretary to create the annual figures by taking one minute to add up \nthe quarterly figures on a pocket calculator. The exception to this rule applies when the problem is with the computer: compile \ntimes are too slow or the programming tools are buggy. Then it’s appropriate to state \nthe problem in computer or programmer terms. As Figure 3-5 suggests, without a good problem definition, you might put effort into \nsolving the wrong problem.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 171, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0172_b11660e6", "text": "Then it’s appropriate to state \nthe problem in computer or programmer terms. As Figure 3-5 suggests, without a good problem definition, you might put effort into \nsolving the wrong problem. Problem DefinitionRequirementsArchitectureConstruction\nSystem testingFuture \nImprovements\n38\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\nFigure 3-5 Be sure you know what you’re aiming at before you shoot. The penalty for failing to define the problem is that you can waste a lot of time solving \nthe wrong problem. This is a double-barreled penalty because you also don’t solve the \nright problem. 3.4 Requirements Prerequisite\nRequirements describe in detail what a soft ware system is supposed to do, and they \nare the first step toward a solution. The requirements activity is also known as \n“requirements development,” “requirements an alysis,” “analysis,” “requirements defi-\nnition,” “software requirements,” “specifi cation,” “functional spec,” and “spec.” \nWhy Have Official Requirements?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 172, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0173_f038530f", "text": "An explicit set of requirements is important for several reasons. Explicit requirements help to ensure that the user rather than the programmer drives \nthe system’s functionality. If the requirements are explicit, the user can review them \nand agree to them. If they’re not, the pr ogrammer usually ends up making require-\nments decisions during programming. Explicit requirements keep you from guessing \nwhat the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the \nsystem before you begin programming. If you have a disagreement with another pro-\ngrammer about what the program is supposed to do, you can resolve it by looking at \nthe written requirements. Paying attention to requirements helps to minimize changes to a system after develop-\nment begins. If you find a coding error duri ng coding, you change a few lines of code \nand work goes on. If you find a requirements error during coding, you have to alter \nthe design to meet the changed requirement.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 173, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0174_17572bca", "text": "If you find a requirements error during coding, you have to alter \nthe design to meet the changed requirement. You might have to throw away part of the \nold design, and because it has to accommoda te code that’s already written, the new \ndesign will take longer than it would have in the first place. You also have to discard \nKEY POINT\nKEY POINT\n3.4 Requirements Prerequisite 39\ncode and test cases affected by the requirement change and write new code and test \ncases. Even code that’s otherwise unaffected must be retested so that you can be sure \nthe changes in other areas haven’t introduced any new errors. As Table 3-1 reported, data from numerous organizations indicates that on large \nprojects an error in requirements detected during the architecture stage is typically 3 \ntimes as expensive to correct as it would be if it were detected during the requirements \nstage.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 174, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 879}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0175_0075ca81", "text": "If detected during coding, it’s 5–10 times as expensive; during system test, 10 \ntimes; and post-release, a whoppi ng 10–100 times as expensive as it would be if it were \ndetected during requirements development. On smaller projects with lower adminis-\ntrative costs, the multiplier post-release is closer to 5–10 than 100 (Boehm and Turner \n2004). In either case, it isn’t money you’d want to have taken out of your salary. Specifying requirements adequately is a key to project success, perhaps even more \nimportant than effective construction techniques. (See Figure 3-6.) Many good books \nhave been written about how to specify requirements well. Consequently, the next few \nsections don’t tell you how to do a good job of specifying requirements, they tell you \nhow to determine whether the requirements have been done well and how to make \nthe best of the requirements you have.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 175, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 884}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0176_6f9562fe", "text": "Figure 3-6 Without good requirements, you can have the right general problem but miss \nthe mark on specific aspects of the problem. The Myth of Stable Requirements\nRequirements are like water. They’re easier to build on \nwhen they’re frozen. —Anonoymous\nStable requirements are the holy grail of software development. With stable require-\nments, a project can proceed from architecture to design to coding to testing in a way \nthat’s orderly, predictable, and calm. This is software heaven! You have predictable \nexpenses, and you never have to worry about a feature costing 100 times as much to \nimplement as it would otherwise because your user didn’t think of it until you were \nfinished debugging. 1\n23\nHARD DATA\n40\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\nIt’s fine to hope that once your customer has accepted a requirements document, no \nchanges will be needed. On a typical project , however, the customer can’t reliably \ndescribe what is needed before the code is written.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 176, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1000}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0177_c2d34319", "text": "On a typical project , however, the customer can’t reliably \ndescribe what is needed before the code is written. The problem isn’t that the custom-\ners are a lower life form. Just as the more you work with the project, the better you \nunderstand it, the more they work with it, the better they understand it. The develop-\nment process helps customers better understa nd their own needs, and this is a major \nsource of requirements changes (Curtis, Krasner, and Iscoe 1988; Jones 1998; Wieg-\ners 2003). A plan to follow the requirements rigidly is actually a plan not to respond \nto your customer. How much change is typical? Studies at IBM and other companies have found that the \naverage project experiences about a 25 percent change in requirements during devel-\nopment (Boehm 1981, Jones 1994, Jones 2000), which accounts for 70 to 85 percent \nof the rework on a typical project (Leffingwell 1997, Wiegers 2003).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 177, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 915}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0178_802cba1d", "text": "Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat \nEarth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, \nevery four years. If you do, go ahead and believe that requirements won’t change on \nyour projects. If, on the other hand, you’ve stopped believing in Santa Claus and the \nTooth Fairy, or at least have stopped admitti ng it, you can take several steps to mini-\nmize the impact of requirements changes. Handling Requirements Changes During Construction\nHere are several things you can do to make the best of changing requirements during \nconstruction:\nUse the requirements checklist at the end of the section to assess the quality of your \nrequirements If your requirements aren’t good enough, stop work, back up, and \nmake them right before you proceed. Sure, it feels like you’re getting behind if you stop \ncoding at this stage.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 178, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 904}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0179_8f8f3282", "text": "Sure, it feels like you’re getting behind if you stop \ncoding at this stage. But if you’re driving fr om Chicago to Los Angeles, is it a waste of \ntime to stop and look at a road map when you see signs for New York? No. If you’re \nnot heading in the right direction, stop and check your course. Make sure everyone knows the cost of requirements changes Clients get excited \nwhen they think of a new feature. In their excitement, their blood thins and runs to \ntheir medulla oblongata and they become giddy, forgetting all the meetings you had to \ndiscuss requirements, the signing ceremony, and the completed requirements docu-\nment. The easiest way to handle such feature-intoxicated people is to say, “Gee, that \n1\n23\nHARD DATA\nKEY POINT\n3.4 Requirements Prerequisite 41\nsounds like a great idea.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 179, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 798}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0180_8482227a", "text": "The easiest way to handle such feature-intoxicated people is to say, “Gee, that \n1\n23\nHARD DATA\nKEY POINT\n3.4 Requirements Prerequisite 41\nsounds like a great idea. Since it’s not in the requirements document, I’ll work up a \nrevised schedule and cost estimate so that you can decide whether you want to do it \nnow or later.” The words “schedule” and “cost” are more sobering than coffee and a \ncold shower, and many “must haves” will quickly turn into “nice to haves.”\nIf your organization isn’t sensitive to the importance of doing requirements first, point \nout that changes at requirements time are much cheaper than changes later.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 180, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 635}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0181_a502273b", "text": "Use this \nchapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before \nConstruction.”\nCross-Reference For details \non handling changes to \ndesign and code, see Section \n28.2, “Configuration \nManagement.”\nSet up a change-control procedure If your client’s excitement persists, consider \nestablishing a formal change-control board to review such proposed changes. It’s all \nright for customers to change their minds an d to realize that they need more capabil-\nities. The problem is their suggesting changes so frequently that you can’t keep up. Having a built-in procedure for controlling changes makes everyone happy. You’re \nhappy because you know that you’ll have to work with changes only at specific times. Your customers are happy because they know that you have a plan for handling their \ninput.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 181, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 825}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0182_5e7ed511", "text": "You’re \nhappy because you know that you’ll have to work with changes only at specific times. Your customers are happy because they know that you have a plan for handling their \ninput. Cross-Reference For details \non iterative development \napproaches, see “Iterate” in \nSection 5.4 and Section 29.3, \n“Incremental Integration \nStrategies.” \nUse development approaches that accommodate changes Some development \napproaches maximize your ability to respon d to changing requirements. An evolution-\nary prototyping approach helps you explore a system’s requirements before you send \nyour forces in to build it. Evolutionary delivery is an approach that delivers the system \nin stages. You can build a little, get a little f eedback from your users, adjust your design \na little, make a few changes, and build a little more. The key is using short develop-\nment cycles so that you can respond to your users quickly.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 182, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 910}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0183_e2a53b53", "text": "The key is using short develop-\nment cycles so that you can respond to your users quickly. Further Reading For details \non development approaches \nthat support flexible require-\nments, see Rapid Develop-\nment (McConnell 1996). Dump the project If the requirements are especially bad or volatile and none of the \nsuggestions above are workable, cancel the project. Even if you can’t really cancel the \nproject, think about what it would be like to cancel it. Think about how much worse it \nwould have to get before you would cancel it. If there’s a case in which you would dump \nit, at least ask yourself how much difference there is between your case and that case.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 183, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 665}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0184_8ffac04a", "text": "If there’s a case in which you would dump \nit, at least ask yourself how much difference there is between your case and that case. Cross-Reference For details \non the differences between \nformal and informal projects \n(often caused by differences \nin project size), see Chapter \n27, “How Program Size \nAffects Construction.”\nKeep your eye on the business case for the project Many requirements issues disap-\npear before your eyes when you refer back to the business reason for doing the project. Requirements that seemed like good ideas wh en considered as “features” can seem like \nterrible ideas when you evaluate the “inc remental business value.” Programmers who \nremember to consider the business impact of their decisions are worth their weight in \ngold—although I’ll be happy to receive my commission for this advice in cash.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 184, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 832}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0185_88aa8f30", "text": "42\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\ncc2e.com/0323\nChecklist: Requirements\nThe requirements checklist contains a list of questions to ask yourself about \nyour project’s requirements. This book do esn’t tell you how to do good require-\nments development, and the list won’t tell you how to do one either. Use the list \nas a sanity check at construction time to determine how solid the ground that \nyou’re standing on is—where you are on the requirements Richter scale. Not all of the checklist questions will apply to your project. If you’re working on \nan informal project, you’ll find some that you don’t even need to think about. You’ll find others that you need to think about but don’t need to answer for-\nmally. If you’re working on a large, formal project, however, you may need to \nconsider every one. Specific Functional Requirements\n❑\nAre all the inputs to the system specified, including their source, accuracy, \nrange of values, and frequency?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 185, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0186_aa25f97d", "text": "Specific Functional Requirements\n❑\nAre all the inputs to the system specified, including their source, accuracy, \nrange of values, and frequency? ❑\nAre all the outputs from the system specified, including their destination, \naccuracy, range of values, frequency, and format? ❑\nAre all output formats specified for Web pages, reports, and so on? ❑\nAre all the external hardware and software interfaces specified? ❑\nAre all the external communication interfaces specified, including hand-\nshaking, error-checking, and communication protocols? ❑\nAre all the tasks the user wants to perform specified? ❑\nIs the data used in each task and the data resulting from each task specified? Specific Nonfunctional (Quality) Requirements\n❑\nIs the expected response time, from the user’s point of view, specified for \nall necessary operations? ❑\nAre other timing considerations specif ied, such as processing time, data-\ntransfer rate, and system throughput? ❑\nIs the level of security specified?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 186, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0187_a4229b84", "text": "❑\nAre other timing considerations specif ied, such as processing time, data-\ntransfer rate, and system throughput? ❑\nIs the level of security specified? ❑\nIs the reliability specified, including th e consequences of software failure, \nthe vital information that needs to be protected from failure, and the strat-\negy for error detection and recovery? ❑\nAre minimum machine memory and free disk space specified? ❑\nIs the maintainability of the system sp ecified, including its ability to adapt \nto changes in specific functionality, changes in the operating environment, \nand changes in its interfaces with other software? ❑\nIs the definition of success included? Of failure? 3.5 Architecture Prerequisite 43\nRequirements Quality\n❑\nAre the requirements written in the user’s language? Do the users think \nso? ❑\nDoes each requirement avoid conflicts with other requirements? ❑\nAre acceptable tradeoffs between competing attributes specified—for \nexample, between robustness and correctness?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 187, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0188_4ac91710", "text": "❑\nDoes each requirement avoid conflicts with other requirements? ❑\nAre acceptable tradeoffs between competing attributes specified—for \nexample, between robustness and correctness? ❑\nDo the requirements avoid specifying the design? ❑\nAre the requirements at a fairly cons istent level of detail? Should any \nrequirement be specified in more deta il? Should any requirement be spec-\nified in less detail? ❑\nAre the requirements clear enough to be turned over to an independent \ngroup for construction and still be understood? Do the developers think \nso? ❑\nIs each item relevant to the problem and its solution? Can each item be \ntraced to its origin in the problem environment? ❑\nIs each requirement testable? Will it be possible for independent testing to \ndetermine whether each requirement has been satisfied? ❑\nAre all possible changes to the requirements specified, including the like-\nlihood of each change?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 188, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 913}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0189_620b109f", "text": "❑\nAre all possible changes to the requirements specified, including the like-\nlihood of each change? Requirements Completeness\n❑\nWhere information isn’t available before development begins, are the \nareas of incompleteness specified? ❑\nAre the requirements complete in the sense that if the product satisfies \nevery requirement, it will be acceptable? ❑\nAre you comfortable with all the requirements? Have you eliminated \nrequirements that are impossible to implement and included just to \nappease your customer or your boss? 3.5 Architecture Prerequisite\nCross-Reference For more \ninformation on design at all \nlevels, see Chapters 5 \nthrough 9. Software architecture is the high-level part of software design, the frame that holds the \nmore detailed parts of the design (Buschma n et al. 1996; Fowler 2002; Bass Clements, \nKazman 2003; Clements et al. 2003).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 189, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 860}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0190_8a19f1f9", "text": "1996; Fowler 2002; Bass Clements, \nKazman 2003; Clements et al. 2003). Archit ecture is also known as “system architec-\nture,” “high-level design,” and “top-level design.” Typically, the architecture is \ndescribed in a single document referred to as the “architecture specification” or “top-\nlevel design.” Some people make a distin ction between architecture and high-level \n44\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\ndesign—architecture refers to design constr aints that apply systemwide, whereas high-\nlevel design refers to design constraints th at apply at the subsys tem or multiple-class \nlevel, but not nece ssarily systemwide. Because this book is about construction, this section doesn’t tell you how to develop \na software architecture; it focuses on how to determine the quality of an existing archi-\ntecture.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 190, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 842}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0191_0ef3f4b8", "text": "Because this book is about construction, this section doesn’t tell you how to develop \na software architecture; it focuses on how to determine the quality of an existing archi-\ntecture. Because architecture is one step closer to construction than requirements, \nhowever, the discussion of architecture is more detailed than the discussion of \nrequirements. Why have architecture as a prerequisite? B ecause the quality of the architecture deter-\nmines the conceptual integrity of the system. That in turn determines the ultimate \nquality of the system. A well-thought-out architecture provides the structure needed to \nmaintain a system’s conceptual integrity from the top levels down to the bottom. It \nprovides guidance to programmers—at a level of detail appropriate to the skills of the \nprogrammers and to the job at hand. It part itions the work so that multiple develop-\ners or multiple development teams can work independently. Good architecture makes construction easy.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 191, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0192_6b7f4b77", "text": "It part itions the work so that multiple develop-\ners or multiple development teams can work independently. Good architecture makes construction easy. Bad architecture makes construction \nalmost impossible. Figure 3-7 illustrates another problem with bad architecture. Figure 3-7 Without good software architecture, you may have the right problem but the \nwrong solution. It may be impossible to have successful construction. Architectural changes are expensive to make during construction or later. The time \nneeded to fix an error in a software architecture is on the same order as that needed to \nfix a requirements error—that is, more than that needed to fix a coding error (Basili \nand Perricone 1984, Willis 1998). Architectur e changes are like requirements changes \nin that seemingly small changes can be far-reaching. Whether the architectural \nchanges arise from the need to fix errors or the need to make improvements, the ear-\nlier you can identify the changes, the better.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 192, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0193_210dc857", "text": "Whether the architectural \nchanges arise from the need to fix errors or the need to make improvements, the ear-\nlier you can identify the changes, the better. KEY POINT\n1\n23\nHARD DATA\n3.5 Architecture Prerequisite 45\nTypical Architectural Components\nCross-Reference For details \non lower-level program \ndesign, see Chapters 5 \nthrough 9. Many components are common to good system architectures. If you’re building the \nwhole system yourself, your work on the architecture will overlap your work on the \nmore detailed design. In such a case, you should at least think about each architec-\ntural component. If you’re working on a system that was architected by someone else, \nyou should be able to find the important components without a bloodhound, a deer-\nstalker cap, and a magnifying glass. In either case, here are the architectural compo-\nnents to consider. Program Organization\nIf you can’t explain some-\nthing to a six-year-old, you \nreally don’t understand it \nyourself.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 193, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0194_21a43c54", "text": "In either case, here are the architectural compo-\nnents to consider. Program Organization\nIf you can’t explain some-\nthing to a six-year-old, you \nreally don’t understand it \nyourself. —Albert Einstein\nA system architecture first needs an overview that describes the system in broad \nterms. Without such an overview, you’ll have a hard time building a coherent picture \nfrom a thousand details or even a dozen indivi dual classes. If the system were a little \n12-piece jigsaw puzzle, your one-year-old co uld solve it between spoonfuls of strained \nasparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it \ntogether, you won’t understand how a class you’re developing contributes to the sys-\ntem. In the architecture, you should find evidence that alternatives to the final organization \nwere considered and find the reasons for choosing the final organization over its alterna-\ntives.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 194, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0195_9f901d95", "text": "In the architecture, you should find evidence that alternatives to the final organization \nwere considered and find the reasons for choosing the final organization over its alterna-\ntives. It’s frustrating to work on a class when it seems as if the class’s role in the system \nhas not been clearly conceived. By describing the organizational alternatives, the architec-\nture provides the rationale for the system organization and shows that each class has \nbeen carefully considered. One review of design practices found that the design rationale \nis at least as important for maintenance as the design itself (Rombach 1990). Cross-Reference For details \non different size building \nblocks in design, see “Levels \nof Design” in Section 5.2. The architecture should define the major building blocks in a program. Depending on \nthe size of the program, each building block might be a single class or it might be a \nsubsystem consisting of many classes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 195, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0196_4c4e5742", "text": "Depending on \nthe size of the program, each building block might be a single class or it might be a \nsubsystem consisting of many classes. Each bu ilding block is a class, or it’s a collec-\ntion of classes or routines that work togeth er on high-level functions such as interact-\ning with the user, displaying Web pages, interpreting commands, encapsulating \nbusiness rules, or accessing data. Every feat ure listed in the requirements should be \ncovered by at least one building block. If a function is claimed by two or more building \nblocks, their claims should cooperate, not conflict. Cross-Reference Minimiz-\ning what each building block \nknows about other building \nblocks is a key part of infor-\nmation hiding. For details, \nsee “Hide Secrets (Informa-\ntion Hiding)” in Section 5.3. What each building block is responsible for should be well defined.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 196, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 858}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0197_4518cf3e", "text": "For details, \nsee “Hide Secrets (Informa-\ntion Hiding)” in Section 5.3. What each building block is responsible for should be well defined. A building block \nshould have one area of responsibility, and it should know as little as possible about \nother building blocks’ areas of responsibility. By minimizing what each building block \nknows about the other building blocks, you localize information about the design into \nsingle building blocks. 46\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\nThe communication rules for each building block should be well defined. The archi-\ntecture should describe which other buil ding blocks the building block can use \ndirectly, which it can use indirectly, and which it shouldn’t use at all. Major Classes\nCross-Reference For details \non class design, see Chapter \n6, “Working Classes.”\nThe architecture should specify the major cla sses to be used.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 197, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 903}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0198_76d5a470", "text": "Major Classes\nCross-Reference For details \non class design, see Chapter \n6, “Working Classes.”\nThe architecture should specify the major cla sses to be used. It should identify the \nresponsibilities of each major class and how the class will interact with other classes. It should include descriptions of the class hierarchies, of state transitions, and of \nobject persistence. If the system is large enough, it should describe how classes are \norganized into subsystems. The architecture should describe other cla ss designs that were considered and give \nreasons for preferring the organization that was chosen. The architecture doesn’t need \nto specify every class in the system. Aim fo r the 80/20 rule: specify the 20 percent of \nthe classes that make up 80 percent of the system’s behavior (Jacobsen, Booch, and \nRumbaugh 1999; Kruchten 2000). Data Design\nCross-Reference For details \non working with variables, \nsee Chapters 10 through 13.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 198, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0199_de4b9e2f", "text": "Data Design\nCross-Reference For details \non working with variables, \nsee Chapters 10 through 13. The architecture should describe the major files and table designs to be used. It \nshould describe alternatives that were co nsidered and justify the choices that were \nmade. If the application maintains a list of customer IDs and the architects have cho-\nsen to represent the list of IDs using a sequential-access list, the document should \nexplain why a sequential-access list is better than a random-access list, stack, or hash \ntable. During construction, such informatio n gives you insight into the minds of the \narchitects. During maintenance, the same insight is an invaluable aid. Without it, \nyou’re watching a foreign movie with no subtitles. Data should normally be accessed directly by only one subsystem or class, except \nthrough access classes or routines that allow access to the data in controlled and \nabstract ways.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 199, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 931}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0200_df2060ce", "text": "Data should normally be accessed directly by only one subsystem or class, except \nthrough access classes or routines that allow access to the data in controlled and \nabstract ways. This is explained in more detail in “Hide Secrets (Information Hiding)” \nin Section 5.3. The architecture should specify the high-level organization and contents of any data-\nbases used. The architecture should explain why a single database is preferable to \nmultiple databases (or vice versa), explain why a database is preferable to flat files, \nidentify possible interactions with other pr ograms that access the same data, explain \nwhat views have been created on the data, and so on. Business Rules\nIf the architecture depends on specific busi ness rules, it should identify them and \ndescribe the impact the rules have on the system’s design.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 200, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 829}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0201_da561688", "text": "Business Rules\nIf the architecture depends on specific busi ness rules, it should identify them and \ndescribe the impact the rules have on the system’s design. For example, suppose the \nsystem is required to follow a business rule that customer information should be no \n3.5 Architecture Prerequisite 47\nmore than 30 seconds out of date. In that case, the impact that rule has on the archi-\ntecture’s approach to keeping customer information up to date and synchronized \nshould be described. User Interface Design\nThe user interface is often specified at requir ements time. If it isn’t, it should be spec-\nified in the software architecture. The arch itecture should specify major elements of \nWeb page formats, GUIs, command line interfaces, and so on. Careful architecture of \nthe user interface makes the difference between a well-liked program and one that’s \nnever used.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 201, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 876}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0202_2bd00637", "text": "Careful architecture of \nthe user interface makes the difference between a well-liked program and one that’s \nnever used. The architecture should be modularized so that a new user interface can be substi-\ntuted without affecting the business rules an d output parts of the program. For exam-\nple, the architecture should make it fairly ea sy to lop off a group of interactive interface \nclasses and plug in a group of command line classes. This ability is often useful, espe-\ncially since command line interfaces are convenient for software testing at the unit or \nsubsystem level. cc2e.com/0393\nThe design of user interfaces deserves it s own book-length discussion but is outside \nthe scope of this book. Resource Management\nThe architecture should describe a plan fo r managing scarce resources such as data-\nbase connections, threads, and handles.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 202, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 851}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0203_2046b065", "text": "Resource Management\nThe architecture should describe a plan fo r managing scarce resources such as data-\nbase connections, threads, and handles. Memory management is another important \narea for the architecture to treat in memory-constrained applications areas such as \ndriver development and embedded systems. The architecture should estimate the \nresources used for nominal and extreme cases. In a simple case, the estimates should \nshow that the resources needed are well within the capabilities of the intended imple-\nmentation environment. In a more complex ca se, the application might be required to \nmore actively manage its own resources. If it is, the resource manager should be archi-\ntected as carefully as any other part of the system. cc2e.com/0330\nSecurity\nFurther Reading For an \nexcellent discussion of soft-\nware security, see Writing \nSecure Code , 2d Ed. (Howard \nand LeBlanc 2003) as well as \nthe January 2002 issue of \nIEEE Software .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 203, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0204_4705d106", "text": "(Howard \nand LeBlanc 2003) as well as \nthe January 2002 issue of \nIEEE Software . The architecture should describe the approach to design-level and code-level security. If a \nthreat model has not previously been built, it should be built at architecture time. Coding \nguidelines should be developed with se curity implications in mind, including \napproaches to handling buffers, rules for hand ling untrusted data (data input from users, \ncookies, configuration data, and other external interfaces), encryption, level of detail con-\ntained in error messages, protecting secret data that’s in memory, and other issues. 48\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\nPerformance\nFurther Reading For addi-\ntional information on design-\ning systems for performance, \nsee Connie Smith’s Perfor-\nmance Engineering of \nSoftware Systems (1990). If performance is a concern, performance goals should be specified in the require-\nments.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 204, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0205_0abb31aa", "text": "If performance is a concern, performance goals should be specified in the require-\nments. Performance goals can include resour ce use, in which case the goals should \nalso specify priorities among resources, including speed vs. memory vs. cost. The architecture should provide estimates and explain why the architects believe the \ngoals are achievable. If certain areas are at risk of failing to meet their goals, the archi-\ntecture should say so. If certain areas requ ire the use of specific algorithms or data \ntypes to meet their performance goals, the architecture should say that. The architec-\nture can also include space and time budgets for each class or object. Scalability\nScalability is the ability of a system to grow to meet future demands. The architecture \nshould describe how the syst em will address growth in number of users, number of \nservers, number of network nodes, number of database records, size of database \nrecords, transaction volume, and so on.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 205, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0206_07abac13", "text": "If th e system is not expected to grow and scal-\nability is not an issue, the architecture should make that assumption explicit. Interoperability\nIf the system is expected to share data or resources with other software or hardware, \nthe architecture should describe how that will be accomplished. Internationalization/Localization\n“Internationalization” is the technical activity of preparing a program to support mul-\ntiple locales. Internationalization is often known as “I18n” because the first and last \ncharacters in “internationalization” are “I” and “N” and because there are 18 letters in \nthe middle of the word. “Localization” (known as “L10n” for the same reason) is the \nactivity of translating a program to support a specific local language. Internationalization issues deserve attention in the architecture for an interactive sys-\ntem. Most interactive system s contain dozens or hundreds of prompts, status dis-\nplays, help messages, error messages, and so on.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 206, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0207_bd5e9335", "text": "Most interactive system s contain dozens or hundreds of prompts, status dis-\nplays, help messages, error messages, and so on. Resources used by the strings should \nbe estimated. If the program is to be used commercially, the architecture should show \nthat the typical string and character-set issues have been considered, including char-\nacter set used (ASCII, DBCS, EBCDIC, MBCS , Unicode, ISO 8859, and so on), kinds \nof strings used (C strings, Visual Basic st rings, and so on), maintaining the strings \nwithout changing code, and translating the strings into foreign languages with mini-\nmal impact on the code and the user inte rface. The architecture can decide to use \nstrings in line in the code where they’re needed, keep the strings in a class and refer-\nence them through the class interface, or store the strings in a resource file. The archi-\ntecture should explain which option was chosen and why.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 207, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 912}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0208_21a987b9", "text": "The archi-\ntecture should explain which option was chosen and why. 3.5 Architecture Prerequisite 49\nInput/Output\nInput/output (I/O) is another area that deserves attention in the architecture. The \narchitecture should specify a look-ahead, look-behind, or just-in-time reading scheme. And it should describe the level at which I/O errors are detected: at the field, record, \nstream, or file level. Error Processing\nError processing is turning out to be one of the thorniest problems of modern com-\nputer science, and you can’t afford to deal wi th it haphazardly. Some people have esti-\nmated that as much as 90 percent of a program’s code is written for exceptional, error-\nprocessing cases or housekeeping, implying that only 10 percent is written for nomi-\nnal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a \nstrategy for handling them consistently sh ould be spelled out in the architecture.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 208, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0209_bb124a53", "text": "With so much code dedicated to handling errors, a \nstrategy for handling them consistently sh ould be spelled out in the architecture. Error handling is often treated as a coding-con vention-level issue, if it’s treated at all. But because it has systemwide implications, it is best treated at the architectural level. Here are some questions to consider:\n■\nIs error processing corrective or merely detective? If corrective, the program can \nattempt to recover from errors. If it’s me rely detective, the program can continue \nprocessing as if nothing had happened, or it can quit. In either case, it should \nnotify the user that it detected an error. ■\nIs error detection active or passive? The system can actively anticipate errors—for \nexample, by checking user input for validi ty—or it can passively respond to them \nonly when it can’t avoid them—for exam ple, when a combination of user input \nproduces a numeric overflow. It can clear the way or clean up the mess.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 209, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0210_814f88a4", "text": "It can clear the way or clean up the mess. Again, in \neither case, the choice has user-interface implications. ■\nHow does the program propagate errors? Once it detects an error, it can imme-\ndiately discard the data that caused the error, it can treat the error as an error \nand enter an error-processing state, or it can wait until all processing is complete \nand notify the user that errors were detected (somewhere). ■\nWhat are the conventions for handling error messages? If the architecture \ndoesn’t specify a single, consistent strategy, the user interface will appear to be a \nconfusing macaroni-and-dried -bean collage of different interfaces in different \nparts of the program. To avoid such an appearance, the architecture should \nestablish conventions for error messages. ■\nHow will exceptions be handled? The architecture should address when the \ncode can throw exceptions, where they will be caught, how they will be logged, \nhow they will be documented, and so on.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 210, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0211_6dc6508d", "text": "■\nHow will exceptions be handled? The architecture should address when the \ncode can throw exceptions, where they will be caught, how they will be logged, \nhow they will be documented, and so on. 1\n23\nHARD DATA\n50\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\nCross-Reference A consis-\ntent method of handling bad \nparameters is another aspect \nof error-processing strategy \nthat should be addressed \narchitecturally. For examples, \nsee Chapter 8, “Defensive \nProgramming.”■\nInside the program, at what level are errors handled? You can handle them at \nthe point of detection, pass them off to an error-handling class, or pass them up \nthe call chain. ■\nWhat is the level of responsibility of ea ch class for validating its input data? Is \neach class responsible for va lidating its own data, or is there a group of classes \nresponsible for validating the system’s da ta? Can classes at any level assume that \nthe data they’re receiving is clean?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 211, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0212_1f0d74b4", "text": "Can classes at any level assume that \nthe data they’re receiving is clean? ■\nDo you want to use your environment’ s built-in exception-handling mechanism \nor build your own? The fact that an environment has a particular error-handling \napproach doesn’t mean that it’s the best approach for your requirements. Fault Tolerance\nFurther Reading For a good \nintroduction to fault toler-\nance, see the July 2001 issue \nof IEEE Software . In addition \nto providing a good intro-\nduction, the articles cite \nmany key books and key \narticles on the topic. The architecture should also indicate the ki nd of fault tolerance expected. Fault toler-\nance is a collection of techniques that increase a system’s reliability by detecting \nerrors, recovering from them if possible, and containing their bad effects if not. For example, a system could make the com putation of the square root of a number \nfault tolerant in any of several ways:\n■\nThe system might back up and try again wh en it detects a fault.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 212, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0213_58701537", "text": "For example, a system could make the com putation of the square root of a number \nfault tolerant in any of several ways:\n■\nThe system might back up and try again wh en it detects a fault. If the first \nanswer is wrong, it would back up to a point at which it knew everything was all \nright and continue from there. ■\nThe system might have auxiliary code to use if it detects a fault in the primary \ncode. In the example, if the first answer appears to be wrong, the system \nswitches over to an alternative square-root routine and uses it instead. ■\nThe system might use a voting algorithm. It might have three square-root classes \nthat each use a different method. Each class computes the square root, and then \nthe system compares the results. Dependin g on the kind of fault tolerance built \ninto the system, it then uses the mean, the median, or the mode of the three \nresults.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 213, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 880}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0214_63227561", "text": "Dependin g on the kind of fault tolerance built \ninto the system, it then uses the mean, the median, or the mode of the three \nresults. ■\nThe system might replace the erroneous value with a phony value that it knows \nto have a benign effect on the rest of the system. Other fault-tolerance approaches include having the system change to a state of par-\ntial operation or a state of degraded function ality when it detects an error. It can shut \nitself down or automatically restart itself . These examples are necessarily simplistic. Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s out-\nside the scope of this book. 3.5 Architecture Prerequisite 51\nArchitectural Feasibility\nThe designers might have concerns about a system’s ability to meet its performance \ntargets, work within resource limitations, or be adequately supported by the imple-\nmentation environments. The architecture should demonstrate that the system is \ntechnically feasible.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 214, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0215_34464634", "text": "The architecture should demonstrate that the system is \ntechnically feasible. If infeasibility in any area could render the project unworkable, \nthe architecture should indicate how those issues have been investigated—through \nproof-of-concept prototypes, research, or ot her means. These risks should be resolved \nbefore full-scale construction begins. Overengineering\nRobustness is the ability of a system to contin ue to run after it detects an error. Often \nan architecture specifies a more robust sy stem than that specified by the require-\nments. One reason is that a system composed of many parts that are minimally robust \nmight be less robust than is required overall. In software, the chain isn’t as strong as \nits weakest link; it’s as weak as all the weak links multiplied together. The architecture \nshould clearly indicate whether programmers should err on the side of overengineer-\ning or on the side of doing the simplest thing that works.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 215, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 955}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0216_70812a2f", "text": "The architecture \nshould clearly indicate whether programmers should err on the side of overengineer-\ning or on the side of doing the simplest thing that works. Specifying an approach to overengineering is particularly important because many \nprogrammers overengineer their classes automa tically, out of a sense of professional \npride. By setting expectations explicitly in the architecture, you can avoid the phe-\nnomenon in which some classes are exceptionally robust and others are barely ade-\nquate. Buy-vs.-Build Decisions\nCross-Reference For a list of \nkinds of commercially avail-\nable software components \nand libraries, see “Code \nLibraries” in Section 30.3. The most radical solution to building software is not to build it at all—to buy it instead \nor to download open-source software for free.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 216, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 806}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0217_b464ae3b", "text": "The most radical solution to building software is not to build it at all—to buy it instead \nor to download open-source software for free. You can buy GUI controls, database \nmanagers, image processors, graphics and charting components, Internet communi-\ncations components, security and encrypti on components, spreadsheet tools, text-\nprocessing tools—the list is nearly endless. One of the greatest advantages of program-\nming in modern GUI environments is the amount of functionality you get automati-\ncally: graphics classes, dia log box managers, keyboard and mouse handlers, code that \nworks automatically with any printer or monitor, and so on. If the architecture isn’t using off-the-shel f components, it should explain the ways \nin which it expects custom-built components to surpass ready-made libraries and \ncomponents.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 217, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 831}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0218_52fc78be", "text": "If the architecture isn’t using off-the-shel f components, it should explain the ways \nin which it expects custom-built components to surpass ready-made libraries and \ncomponents. 52\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\nReuse Decisions\nIf the plan calls for using preexisting software , test cases, data formats, or other mate-\nrials, the architecture should explain how the reused software will be made to con-\nform to the other architectural goals—if it will be made to conform. Change Strategy\nCross-Reference For details \non handling changes sys-\ntematically, se e Section 28.2, \n“Configuration Management.”\nBecause building a software product is a learning process for both the programmers \nand the users, the product is likely to change throughout its development. Changes \narise from volatile data types and file form ats, changed functionality, new features, and \nso on.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 218, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0219_8aac2eda", "text": "Changes \narise from volatile data types and file form ats, changed functionality, new features, and \nso on. The changes can be new capabilities likely to result from planned enhance-\nments, or they can be capabilities that didn ’t make it into the first version of the sys-\ntem. Consequently, one of the major challeng es facing a software architect is making \nthe architecture flexible enough to accommodate likely changes. Design bugs are often subtle \nand occur by evolution with \nearly assumptions being for-\ngotten as new features or \nuses are added to a system. —Fernando J. Corbató\nThe architecture should clearly describe a st rategy for handling changes. The architec-\nture should show that possible enhancements have been considered and that the \nenhancements most likely are also the easies t to implement.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 219, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 817}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0220_834e9a11", "text": "The architec-\nture should show that possible enhancements have been considered and that the \nenhancements most likely are also the easies t to implement. If changes are likely in \ninput or output formats, style of user interaction, or processing requirements, the \narchitecture should show that the changes have all been anticipated and that the \neffects of any single change will be limited to a small number of classes. The architec-\nture’s plan for changes can be as simple as one to put version numbers in data files, \nreserve fields for future use, or design files so that you can add new tables. If a code \ngenerator is being used, the architecture should show that the anticipated changes are \nwithin the capabilities of the code generator. Cross-Reference For a full \nexplanation of delaying \ncommitment, see “Choose \nBinding Time Consciously” in \nSection 5.3. The architecture should indicate the strategies that are used to delay commitment.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 220, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0221_4fa163f2", "text": "The architecture should indicate the strategies that are used to delay commitment. For \nexample, the architecture might specify that a table-driven technique be used rather \nthan hard-coded if tests. It might specify that data for the table is to be kept in an exter-\nnal file rather than coded inside the program, thus allowing changes in the program \nwithout recompiling. General Architectural Quality\nCross-Reference For more \ninformation about how qual-\nity attributes interact, see \nSection 20.1, “Characteristics \nof Software Quality.”\nA good architecture specification is characte rized by discussions of the classes in the \nsystem, of the information that’s hidden in ea ch class, and of the rationales for includ-\ning and excluding all possible design alternatives. The architecture should be a polished conc eptual whole with few ad hoc additions.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 221, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 857}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0222_f2254ad5", "text": "The architecture should be a polished conc eptual whole with few ad hoc additions. The central thesis of the most popul ar software-engineering book ever, The Mythical \nMan-Month , is that the essential problem with large systems is maintaining their con-\nceptual integrity (Brooks 1995). A good architecture should fit the problem. When \nyou look at the architecture, you should be pleased by how natural and easy the solu-\ntion seems. It shouldn’t look as if the pr oblem and the architecture have been forced \ntogether with duct tape. 3.5 Architecture Prerequisite 53\nYou might know of ways in which the arch itecture was changed during its develop-\nment. Each change should fit in cleanly with the overall concept. The architecture \nshouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel, \nboondoggle riders for each re presentative’s home district. The architecture’s objectives should be clearly stated.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 222, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0223_00dd3876", "text": "Congress appropriations bill complete with pork-barrel, \nboondoggle riders for each re presentative’s home district. The architecture’s objectives should be clearly stated. A design for a system with a pri-\nmary goal of modifiability will be different from one with a goal of uncompromised \nperformance, even if both sy stems have the same function. The architecture should describe the motivati ons for all major decisions. Be wary of \n“we’ve always done it that way” justifications. One story goes that Beth wanted to \ncook a pot roast according to an award-winni ng pot roast recipe handed down in her \nhusband’s family. Her husband, Abdul, said that his mother had taught him to sprin-\nkle it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it. Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always \ndone it that way. Let me ask my mother.” He called her, and she said, “I don’t know. I’ve always done it that way.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 223, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0224_e08e873f", "text": "Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always \ndone it that way. Let me ask my mother.” He called her, and she said, “I don’t know. I’ve always done it that way. Let me ask your grandmother.” She called his grand-\nmother, who said, “I don’t know why you do it that way. I did it that way because it \nwas too big to fit in my pan.”\nGood software architecture is largely machine- and language-independent. Admit-\ntedly, you can’t ignore the construction en vironment. By being as independent of the \nenvironment as possible, however, you avoid the temptation to overarchitect the sys-\ntem or to do a job that you can do better during construction. If the purpose of a pro-\ngram is to exercise a specific machine or language, this guideline doesn’t apply. The architecture should tread the line be tween underspecifying and overspecifying \nthe system. No part of the architecture should receive more attention than it deserves, \nor be overdesigned.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 224, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0225_c7a5cfa4", "text": "The architecture should tread the line be tween underspecifying and overspecifying \nthe system. No part of the architecture should receive more attention than it deserves, \nor be overdesigned. Designers shouldn’t pay attention to one part at the expense of \nanother. The architecture should address al l requirements without gold-plating (with-\nout containing elements that are not required). The architecture should explicitly identify risky areas. It should explain why they’re \nrisky and what steps have been taken to minimize the risk. The architecture should contain multiple vi ews. Plans for a house will include eleva-\ntions, floor plan, framing plan , electrical diagrams, and other views of the house. Soft-\nware architecture descriptions also bene fit from providing different views of the \nsystem that flush out errors and inconsistencies and help programmers fully under-\nstand the system’s design (Kruchten 1995). Finally, you shouldn’t be uneasy about any parts of the architecture.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 225, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 997}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0226_579aa221", "text": "Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t con-\ntain anything just to please the boss. It shouldn’t contain anything that’s hard for you \nto understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how \ncan you implement it? 54\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\ncc2e.com/0337\nChecklist: Architecture\nHere’s a list of issues that a good ar chitecture should addr ess. The list isn’t \nintended to be a comprehensive guide to architecture but to be a pragmatic way \nof evaluating the nutritional content of what you get at the programmer’s end of \nthe software food chain. Use this check list as a starting point for your own \nchecklist. As with the requirements checklist, if you’re working on an informal \nproject, you’ll find some items that you don’t even need to think about. If you’re \nworking on a larger project, most of the items will be useful.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 226, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 941}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0227_8d62a1f9", "text": "If you’re \nworking on a larger project, most of the items will be useful. Specific Architectural Topics\n❑\nIs the overall organization of the program clear, including a good architec-\ntural overview and justification? ❑\nAre major building blocks well defined, including their areas of responsi-\nbility and their interfaces to other building blocks? ❑\nAre all the functions listed in the requirements covered sensibly, by neither \ntoo many nor too few building blocks? ❑\nAre the most critical cla sses described and justified? ❑\nIs the data design described and justified? ❑\nIs the database organization and content specified? ❑\nAre all key business rules identified and their impact on the system \ndescribed? ❑\nIs a strategy for the user interface design described? ❑\nIs the user interface modularized so that changes in it won’t affect the rest \nof the program? ❑\nIs a strategy for handling I/O described and justified?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 227, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 919}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0228_fcede531", "text": "❑\nIs the user interface modularized so that changes in it won’t affect the rest \nof the program? ❑\nIs a strategy for handling I/O described and justified? ❑\nAre resource-use estimates and a strategy for resource management \ndescribed and justified for scarce reso urces like threads, database connec-\ntions, handles, network bandwidth, and so on? ❑\nAre the architecture’s security requirements described? ❑\nDoes the architecture set space and speed budgets for each class, sub-\nsystem, or functionality area? ❑\nDoes the architecture describe how scalability will be achieved? ❑\nDoes the architecture address interoperability? ❑\nIs a strategy for internationali zation/localization described? ❑\nIs a coherent error-handling strategy provided? ❑\nIs the approach to fault tolerance defined (if any is needed)? 3.6 Amount of Time to Spen d on Upstream Prerequisites 55\n❑\nHas technical feasibility of all part s of the system been established? ❑\nIs an approach to overengineering specified?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 228, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0229_84049970", "text": "3.6 Amount of Time to Spen d on Upstream Prerequisites 55\n❑\nHas technical feasibility of all part s of the system been established? ❑\nIs an approach to overengineering specified? ❑\nAre necessary buy-vs.-bu ild decisions included? ❑\nDoes the architecture describe how reus ed code will be made to conform \nto other architectural objectives? ❑\nIs the architecture designed to accommodate likely changes? General Architectural Quality\n❑\nDoes the architecture account for all the requirements? ❑\nIs any part overarchitected or underarchitected? Are expectations in this \narea set out explicitly? ❑\nDoes the whole architecture hang together conceptually? ❑\nIs the top-level design independent of the machine and language that will \nbe used to implement it? ❑\nAre the motivations for all major decisions provided? ❑\nAre you, as a programmer who will implement the system, comfortable \nwith the architecture?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 229, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0230_fa9d0168", "text": "❑\nAre the motivations for all major decisions provided? ❑\nAre you, as a programmer who will implement the system, comfortable \nwith the architecture? 3.6 Amount of Time to Spen d on Upstream Prerequisites\nCross-Reference The \namount of time you spend \non prerequisites will depend \non your project type. For \ndetails on adapting prereq-\nuisites to your specific \nproject, see Section 3.2, \n“Determine the Kind of Soft-\nware You’re Working On,” \nearlier in this chapter. The amount of time to spend on problem definition, requirem ents, and software architec-\nture varies according to the needs of your project. Generally, a well-run project devotes \nabout 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to require-\nments, architecture, and up-front planning (McConnell 1998, Kruc hten 2000). These fig-\nures don’t include time for detailed design—that’s part of construction.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 230, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0231_d1d6aee4", "text": "These fig-\nures don’t include time for detailed design—that’s part of construction. If requirements are unstable and you’re working on a large, formal project, you’ll prob-\nably have to work with a requirements analyst to resolve requirements problems that \nare identified early in construction. Allow time to consult with the requirements ana-\nlyst and for the requirements analyst to revise the requirements before you’ll have a \nworkable version of the requirements. If requirements are unstable and you’re working on a small, informal project, you’ll prob-\nably need to resolve requirements issues yo urself. Allow time for defining the require-\nments well enough that their volatility w ill have a minimal impact on construction. 56\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\nCross-Reference For \napproaches to handling \nchanging requirements, see \n“Handling Requirements \nChanges During Construc-\ntion” in Section 3.4, earlier in \nthis chapter.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 231, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0232_e986a52c", "text": "If the requirements are unstable on any project—formal or informal—treat require-\nments work as its own project. Estimate the ti me for the rest of the project after you’ve \nfinished the requirements. This is a sensible approach since no one can reasonably \nexpect you to estimate your schedule before you know what you’re building. It’s as if \nyou were a contractor called to work on a ho use. Your customer says, “What will it cost \nto do the work?” You reasonably ask, “What do you want me to do?” Your customer \nsays, “I can’t tell you, but how much will it cost?” You reasonably thank the customer \nfor wasting your time and go home. With a building, it’s clear that it’s unreasonable for clients to ask for a bid before tell-\ning you what you’re going to build. Your clients wouldn’t want you to show up with \nwood, hammer, and nails and start spending their money before the architect had fin-\nished the blueprints.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 232, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0233_336780cc", "text": "Your clients wouldn’t want you to show up with \nwood, hammer, and nails and start spending their money before the architect had fin-\nished the blueprints. People tend to understand software development less than they \nunderstand two-by-fours and sheetrock, however, so the clients you work with might \nnot immediately understand why you want to plan requirements development as a \nseparate project. You might need to explain your reasoning to them. When allocating time for software architectu re, use an approach similar to the one for \nrequirements development. If the software is a kind that you haven’t worked with \nbefore, allow more time for the uncertainty of designing in a new area. Ensure that the \ntime you need to create a good architecture won’t take away from the time you need \nfor good work in other areas. If necessary, plan the architecture work as a separate \nproject, too.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 233, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0234_4b18416b", "text": "Ensure that the \ntime you need to create a good architecture won’t take away from the time you need \nfor good work in other areas. If necessary, plan the architecture work as a separate \nproject, too. Additional Resources\ncc2e.com/0344\nFollowing are more resources on requirements:\ncc2e.com/0351\nRequirements\nHere are a few books that give much more detail on requirements development: \nWiegers, Karl. Software Requirements , 2d ed. Redmond, WA: Microsoft Press, 2003. This is a practical, practitioner-focused book that describes the nuts and bolts of \nrequirements activities, including requirements elicitation, requirements analysis, \nrequirements specification, requirements validation, and requirements management. Robertson, Suzanne and James Robertson. Mastering the Requirements Process . Read-\ning, MA: Addison-Wesley, 1999. This is a good alternative to Wiegers’ book for the \nmore advanced requirements practitioner. cc2e.com/0358\nGilb, Tom. Competitive Engineering .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 234, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0235_0b16d121", "text": "Read-\ning, MA: Addison-Wesley, 1999. This is a good alternative to Wiegers’ book for the \nmore advanced requirements practitioner. cc2e.com/0358\nGilb, Tom. Competitive Engineering . Reading, MA: Addison-We sley, 2004. This book \ndescribes Gilb’s requirements language, known as “Planguage.” The book covers \nGilb’s specific approach to requirements en gineering, design an d design evaluation, \nand evolutionary project management. This book can be downloaded from Gilb’s \nwebsite at www.gilb.com . Additional Resources 57\nIEEE Std 830-1998. IEEE Recommended Practice for Software Requirements Specifications . Los Alamitos, CA: IEEE Computer Society Press. This document is the IEEE-ANSI \nguide for writing software-requirements speci fications. It describes what should be \nincluded in the specification document and shows several alternative outlines for one. cc2e.com/0365\nAbran, Alain, et al. S webok: Guide to the Software Engineering Body of Knowledge . Los \nAlamitos, CA: IEEE Computer Society Press, 2001.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 235, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1014}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0236_ff31f31e", "text": "cc2e.com/0365\nAbran, Alain, et al. S webok: Guide to the Software Engineering Body of Knowledge . Los \nAlamitos, CA: IEEE Computer Society Press, 2001. This contains a detailed descrip-\ntion of the body of software-requirements knowledge. It can also be downloaded from \nwww.swebok.org . Other good alternatives include the following:\nLauesen, Soren. Software Requirements: Styles and Techniques . Boston, MA: Addison-\nWesley, 2002. Kovitz, Benjamin L. Practical Software Requirements: A Manual of Content and Style . Manning Publications Company, 1998. Cockburn, Alistair. Writing Effective Use Cases . Boston, MA: Addison-Wesley, 2000. cc2e.com/0372\nSoftware Architecture\nNumerous books on software architecture have been published in the past few years. Here are some of the best: \nBass, Len, Paul Clements, and Rick Kazman. Software Architecture in Practice , 2d ed. Boston, MA: Addison-Wesley, 2003. Buschman, Frank, et al. Pattern-Oriented Software Architecture, Volume 1: A System of \nPatterns .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 236, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0237_41949c1d", "text": "Software Architecture in Practice , 2d ed. Boston, MA: Addison-Wesley, 2003. Buschman, Frank, et al. Pattern-Oriented Software Architecture, Volume 1: A System of \nPatterns . New York, NY: John Wiley & Sons, 1996. Clements, Paul, ed. Documenting Software Architectures: Views and Beyond . Boston, MA: \nAddison-Wesley, 2003. Clements, Paul, Rick Kazman, and Mark Klein. Evaluating Software Architectures: Meth-\nods and Case Studies . Boston, MA: Addi son-Wesley, 2002. Fowler, Martin. Patterns of Enterprise Application Architecture . Boston, MA: Addison-\nWesley, 2002. Jacobson, Ivar, Grady Booc h, and James Rumbaugh. The Unified Software Development \nProcess . Reading, MA: Addison-Wesley, 1999. IEEE Std 1471-2000. Recommended Practice for Architectural Description of Software-\nIntensive Systems . Los Alamitos, CA: IEEE Computer So ciety Press. This document is \nthe IEEE-ANSI guide for creating software-architecture specifications.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 237, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0238_6462488a", "text": "Los Alamitos, CA: IEEE Computer So ciety Press. This document is \nthe IEEE-ANSI guide for creating software-architecture specifications. 58\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\ncc2e.com/0379\nGeneral Software-Development Approaches\nMany books are available that map out differ ent approaches to co nducting a software \nproject. Some are more sequential, and some are more iterative. McConnell, Steve. Software Project Survival Guide . Redmond, WA: Microsoft Press, \n1998. This book presents one particular wa y to conduct a project. The approach pre-\nsented emphasizes deliberate up-front planning, requirements development, and \narchitecture work followed by careful proj ect execution. It provides long-range pre-\ndictability of costs and schedu les, high quality, and a moderate amount of flexibility. Kruchten, Philippe. The Rational Unified Process: An Introduction , 2d ed. Reading, MA: \nAddison-Wesley, 2000.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 238, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 937}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0239_2a65d937", "text": "Kruchten, Philippe. The Rational Unified Process: An Introduction , 2d ed. Reading, MA: \nAddison-Wesley, 2000. This bo ok presents a project approach that is “architecture-\ncentric and use-case driven.” Like Software Project Survival Guide , it focuses on up-front \nwork that provides good long-range predictability of costs and schedules, high quality, \nand moderate flexibility. This book’s appr oach requires somewhat more sophisticated \nuse than the approaches described in Software Project Survival Guide and Extreme Pro-\ngramming Explaine d: Embrace Change . Jacobson, Ivar, Grady Booc h, and James Rumbaugh. The Unified Software Development \nProcess . Reading, MA: Addison-Wesley, 1999. This book is a more in-depth treatment \nof the topics covered in The Rational Unified Process: An Introduction , 2d ed. Beck, Kent. Extreme Programming Explained: Embrace Change . Reading, MA: Addison-\nWesley, 2000.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 239, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0240_f707e49c", "text": "Beck, Kent. Extreme Programming Explained: Embrace Change . Reading, MA: Addison-\nWesley, 2000. Beck describes a highly iterat ive approach that focuses on developing \nrequirements and designs iteratively, in conjunction with cons truction. The Extreme \nProgramming approach offers little long-ran ge predictability but provides a high \ndegree of flexibility. Gilb, Tom. Principles of Software Engineering Management . Wokingham, England: \nAddison-Wesley, 1988. Gilb’s approach expl ores critical planni ng, requirements, and \narchitecture issues early in a project and then continuously adapts the project plans as \nthe project progresses. This approach provides a combination of long-range predict-\nability, high quality, and a high degree of flexibility. It requires more sophistication \nthan the approaches described in Software Project Survival Guide and Extreme Program-\nming Explained: Embrace Change . McConnell, Steve. Rapid Development . Redmond, WA: Microsoft Press, 1996.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 240, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0241_6b052892", "text": "McConnell, Steve. Rapid Development . Redmond, WA: Microsoft Press, 1996. This \nbook presents a toolbox approach to proj ect planning. An experienced project plan-\nner can use the tools presented in this book to create a project plan that is highly \nadapted to a project’s unique needs. Boehm, Barry and Richard Turner. Balancing Agility and Discipline: A Guide for the Per-\nplexed . Boston, MA: Addison-Wesley, 2003. This book explores the contrast between \nagile development and plan-driven developmen t styles. Chapter 3 has four especially \nKey Points 59\nrevealing sections: “A Typical Day using PSP/TSP,” “A Typical Day using Extreme Pro-\ngramming,” “A Crisis Day using PSP/TSP,” and “A Crisis Day using Extreme Program-\nming.” Chapter 5 is on using risk to balan ce agility, which provides incisive guidance \nfor selecting between agile and plan-driven me thods. Chapter 6, “Conclusions,” is also \nwell balanced and gives great perspective.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 241, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0242_41638c2f", "text": "Chapter 6, “Conclusions,” is also \nwell balanced and gives great perspective. Appe ndix E is a gold mine of empirical data \non agile practices. Larman, Craig. Agile and Iterative Development: A Manager’s Guide . Boston, MA: Addi-\nson Wesley, 2004. This is a well-researched introduction to flexible, evolutionary \ndevelopment styles. It overviews Scrum, Extreme Programming, the Unified Process, \nand Evo. cc2e.com/0386\nChecklist: Upstream Prerequisites\n❑\nHave you identified the kind of softwa re project you’re working on and tai-\nlored your approach appropriately? ❑\nAre the requirements sufficiently well defined and stable enough to begin \nconstruction? (See the requirements checklist for details.)\n❑\nIs the architecture sufficiently well defined to begin construction? (See the \narchitecture checklist for details.)\n❑\nHave other risks unique to your particular project been addressed, such \nthat construction is not exposed to more risk than necessary?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 242, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0243_24d895c0", "text": "(See the \narchitecture checklist for details.)\n❑\nHave other risks unique to your particular project been addressed, such \nthat construction is not exposed to more risk than necessary? Key Points\n■\nThe overarching goal of preparing for construction is risk reduction. Be sure \nyour preparation activities are reducing risks, not increasing them. ■\nIf you want to develop high-quality softwa re, attention to quality must be part of \nthe software-development process from th e beginning to the end. Attention to \nquality at the beginning has a greater in fluence on product quality than atten-\ntion at the end. ■\nPart of a programmer’s job is to educ ate bosses and coworkers about the soft-\nware-development process, including the importance of adequate preparation \nbefore programming begins. ■\nThe kind of project you’re working on significantly affects construction prereq-\nuisites—many projects should be highly iterative, and some should be more \nsequential.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 243, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0244_3b447004", "text": "■\nThe kind of project you’re working on significantly affects construction prereq-\nuisites—many projects should be highly iterative, and some should be more \nsequential. ■\nIf a good problem definition hasn’t been specified, you might be solving the \nwrong problem during construction. 60\nChapter 3: Measure Tw ice, Cut Once: Upstream Prerequisites\n■\nIf good requirements work hasn’t be en done, you might have missed important \ndetails of the problem. Requirements changes cost 20 to 100 times as much in \nthe stages following construction as they do earlier, so be sure the requirements \nare right before you start programming. ■\nIf a good architectural design hasn’t b een done, you might be solving the right \nproblem the wrong way during construction. The cost of architectural changes \nincreases as more code is written for the wrong architecture, so be sure the archi-\ntecture is right, too.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 244, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 897}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0245_deb326b6", "text": "The cost of architectural changes \nincreases as more code is written for the wrong architecture, so be sure the archi-\ntecture is right, too. ■\nUnderstand what approach has been taken to the construction prerequisites on \nyour project, and choose your construction approach accordingly. 61\nChapter 4\nKey Construction Decisions\ncc2e.com/0489\nContents\n■\n4.1 Choice of Programming Language: page 61\n■\n4.2 Programming Conventions: page 66\n■\n4.3 Your Location on the Technology Wave: page 66\n■\n4.4 Selection of Major Cons truction Practices: page 69\nRelated Topics\n■\nUpstream prerequisites: Chapter 3\n■\nDetermine the kind of software you’re working on: Section 3.2\n■\nHow program size affects construction: Chapter 27\n■\nManaging construction: Chapter 28\n■\nSoftware design: Chapter 5, and Chapters 6 through 9\nOnce you’re sure an appropriate groundwork has been laid for construction, prepara-\ntion turns toward more construction-specifi c decisions.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 245, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 943}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0246_fd3a1884", "text": "Chapter 3, “Measure Twice, \nCut Once: Upstream Prerequisites,” discusse d the software equivalent of blueprints \nand construction permits. You might not have had much control over those prepara-\ntions, so the focus of that chapter was on assessing what you have to work with when \nconstruction begins. This chapter focuses on preparations that individual program-\nmers and technical leads are responsible for, di rectly or indirectly. It discusses the soft-\nware equivalent of how to select specific tools for your tool belt and how to load your \ntruck before you head out to the job site. If you feel you’ve read enough about construction preparations already, you might \nskip ahead to Chapter 5, “Design in Construction.” \n4.1 Choice of Programming Language\nBy relieving the brain of all unnecessary wo rk, a good notation sets it free to con-\ncentrate on more advanced problems, and in effect increases the mental power of \nthe race.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 246, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0247_f235b185", "text": "Before the introduction of th e Arabic notation, multiplication was dif-\nficult, and the division even of integers called into play the highest mathematical \nfaculties. Probably nothing in the modern world would have more astonished a \nGreek mathematician than to learn that ... a huge proportion of the population \n62\nChapter 4: Key Construction Decisions\nof Western Europe could perform the operation of division for the largest num-\nbers. This fact would have seemed to him a sheer impossibility.... Our modern \npower of easy reckoning with decimal fracti ons is the almost miraculous result of \nthe gradual discovery of a perfect notation. —Alfred North Whitehead\nThe programming language in which the syst em will be implemented should be of \ngreat interest to you since you will be immersed in it from the beginning of construc-\ntion to the end. Studies have shown that the programming-language choice affects productivity and \ncode quality in several ways.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 247, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0248_27c1b742", "text": "Studies have shown that the programming-language choice affects productivity and \ncode quality in several ways. Programmers are more productive using a fami liar language than an unfamiliar one. Data from the Cocomo II estimation model shows that programmers working in a lan-\nguage they’ve used for three years or more are about 30 percent more productive than \nprogrammers with equivalent experience wh o are new to a language (Boehm et al. 2000). An earlier study at IBM found that programmers who had extensive experience \nwith a programming language were more than three times as productive as those with \nminimal experience (Walston and Felix 1977). (Cocomo II is more careful to isolate \neffects of individual factors, which accounts for the different results of the two studies.)\nProgrammers working with high-level langua ges achieve better productivity and quality \nthan those working with lower-level languages.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 248, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0249_5866ae46", "text": "Languages such as C++, Java, Smalltalk, \nand Visual Basic have been credited with improving productivity, reliability, simplicity, \nand comprehensibility by factors of 5 to 15 over low-level languages such as assembly \nand C (Brooks 1987, Jones 1998, Boehm 2000). You save time when you don’t need to \nhave an awards ceremony every time a C statement does what it’s supposed to. More-\nover, higher-level languages are more expressive than lower-level languages. Each line of \ncode says more. Table 4-1 shows typical ratios of source statements in several high-level \nlanguages to the equivalent code in C. A higher ratio means that each line of code in the \nlanguage listed accomplishes more th an does each line of code in C.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 249, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 726}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0250_6cbda20e", "text": "A higher ratio means that each line of code in the \nlanguage listed accomplishes more th an does each line of code in C. Table 4-1\nRatio of High-Level-Language St atements to Equivalent C Code\nLanguage\nLevel Relative to C\nC1\nC++ 2.5\nFortran 95 2\nJava 2.5\nPerl 6\nPython 6\nSmalltalk 6\nMicrosoft Visual Basic 4.5\nSource: Adapted from Estimating Software Costs (Jones 1998), Software Cost Estima tion with Cocomo II \n(Boehm 2000), and “An Empirical Comparison of Seven Programming Languages” (Prechelt 2000). 1\n23\nHARD DATA\n4.1 Choice of Programming Language 63\nSome languages are better at expressing programming concepts than others. You can \ndraw a parallel between natural languages such as English and programming lan-\nguages such as Java and C++. In the case of natural languages, the linguists Sapir and \nWhorf hypothesize a relationship between the expressive power of a language and the \nability to think certain thoughts.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 250, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0251_32a8f7b9", "text": "In the case of natural languages, the linguists Sapir and \nWhorf hypothesize a relationship between the expressive power of a language and the \nability to think certain thoughts. The Sapir-Whorf hypothesis says that your ability to \nthink a thought depends on knowing words capable of expressing the thought. If you \ndon’t know the words, you can’t express the thought and you might not even be able \nto formulate it (Whorf 1956). Programmers may be similarly influenced by their languages. The words available in a \nprogramming language for expressing your programming thoughts certainly deter-\nmine how you express your thoughts and might even determine what thoughts you \ncan express. Evidence of the effect of programming languages on programmers’ thinking is com-\nmon. A typical story goes like this: “We were writing a new system in C++, but most of \nour programmers didn’t have much experien ce in C++. They came from Fortran back-\ngrounds.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 251, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0252_6178d228", "text": "A typical story goes like this: “We were writing a new system in C++, but most of \nour programmers didn’t have much experien ce in C++. They came from Fortran back-\ngrounds. They wrote code that compiled in C++, but they were really writing dis-\nguised Fortran. They stretched C++ to emulate Fortran’s bad features (such as gotos \nand global data) and ignored C++’s rich set of object-oriented capabilities.” This phe-\nnomenon has been reported throughout the industry for many years (Hanson 1984, \nYourdon 1986a). Language Descriptions\nThe development histories of some languages are interesting, as are their general capa-\nbilities. Here are descriptions of the most common languages in use today. Ada\nAda is a general-purpose, high-level prog ramming language based on Pascal. It was \ndeveloped under the aegis of the Department of Defense and is especially well suited \nto real-time and embedded systems.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 252, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 908}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0253_51c1be7f", "text": "It was \ndeveloped under the aegis of the Department of Defense and is especially well suited \nto real-time and embedded systems. Ada emphasizes data abstraction and informa-\ntion hiding and forces you to differentiate between the public and private parts of each \nclass and package. “Ada” was chosen as th e name of the language in honor of Ada \nLovelace, a mathematician who is considered to have been the world’s first program-\nmer. Today, Ada is used primarily in military, space, and avionics systems. Assembly Language\nAssembly language, or “assembler,” is a kind of low-level language in which each state-\nment corresponds to a single machine instruction. Because the statements use spe-\ncific machine instructions, an assembly lang uage is specific to a particular processor—\nfor example, specific Intel or Motorola CP Us. Assembler is regarded as the second-\ngeneration language. Most programmers avoid it unless they’re pushing the limits in \nexecution speed or code size.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 253, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0254_7837fef0", "text": "Assembler is regarded as the second-\ngeneration language. Most programmers avoid it unless they’re pushing the limits in \nexecution speed or code size. 64\nChapter 4: Key Construction Decisions\nC\nC is a general-purpose, mid-level language that was originally associated with the \nUNIX operating system. C has some high-level language fe atures, such as structured \ndata, structured control flow, machine indepe ndence, and a rich set of operators. It \nhas also been called a “portable assembly la nguage” because it makes extensive use of \npointers and addresses, has some low-level constructs such as bit manipulation, and \nis weakly typed. C was developed in the 1970s at Bell Labs. It was originally designed for and used on \nthe DEC PDP-11—whose operating system, C compiler, and UNIX application pro-\ngrams were all written in C. In 1988, an AN SI standard was issued to codify C, which \nwas revised in 1999.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 254, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 912}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0255_dec159ab", "text": "In 1988, an AN SI standard was issued to codify C, which \nwas revised in 1999. C was the de facto standard for microcomputer and workstation \nprogramming in the 1980s and 1990s. C++\nC++, an object-oriented language founded on C, was developed at Bell Laboratories in \nthe 1980s. In addition to being compatible with C, C++ provides classes, polymor-\nphism, exception handling, templates, and it provides more robust type checking \nthan C does. It also provides an extensive and powerful standard library. C#\nC# is a general-purpose, object-oriented language and programming environment \ndeveloped by Microsoft with syntax similar to C, C++, and Java, an d it provides exten-\nsive tools that aid development on Microsoft platforms. Cobol\nCobol is an English-like programming language that was originally developed in \n1959–1961 for use by the Department of Defense.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 255, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 864}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0256_eb6a8917", "text": "Cobol\nCobol is an English-like programming language that was originally developed in \n1959–1961 for use by the Department of Defense. Cobol is used primarily for busi-\nness applications and is still one of the mo st widely used languages today, second \nonly to Visual Basic in popularity (Feiman and Driver 2002). Cobol has been updated \nover the years to include mathematical func tions and object-orien ted capabilities. The \nacronym “Cobol” stands for COmmon Business-Oriented Language. Fortran\nFortran was the first high-level computer la nguage, introducing the ideas of variables \nand high-level loops. “Fortran” stands fo r FORmula TRANslation. Fortran was origi-\nnally developed in the 1950s and has seen se veral significant revisions, including For-\ntran 77 in 1977, which added block-structured if-then-else statements and character-\nstring manipulations. Fortran 90 added user-def ined data types, pointers, classes, and \na rich set of operations on arrays.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 256, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0257_cf2d0662", "text": "Fortran 90 added user-def ined data types, pointers, classes, and \na rich set of operations on arrays. Fortran is used mainly in scientific and engineering \napplications. 4.1 Choice of Programming Language 65\nJava\nJava is an object-oriented language with syntax similar to C and C++ that was devel-\noped by Sun Microsystems, Inc. Java was designed to run on any platform by convert-\ning Java source code to byte code, which is then run in each platform within an \nenvironment known as a virtual machine. Java is in widespread use for programming \nWeb applications. JavaScript\nJavaScript is an interpreted scripting language that was originally loosely related to \nJava. It is used primarily for client-side programming such as adding simple functions \nand online applications to Web pages. Perl\nPerl is a string-handling language that is based on C and several UNIX utilities.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 257, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 876}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0258_48cefde0", "text": "Perl\nPerl is a string-handling language that is based on C and several UNIX utilities. Perl is \noften used for system administration tasks, such as creating build scripts, as well as \nfor report generation and processing. It’s also used to create Web applications such as \nSlashdot. The acronym “Perl” stands for Practical Extraction and Report Language. PHP\nPHP is an open-source scripting language with a simple syntax similar to Perl, Bourne \nShell, JavaScript, and C. PHP runs on all major operating systems to execute server-\nside interactive functions. It can be embedded in Web pages to access and present \ndatabase information. The acronym “PHP” originally stood for Personal Home Page \nbut now stands for PHP: Hypertext Processor. Python\nPython is an interpreted, interactive, object-oriented language that runs in numerous \nenvironments. It is used most commonly for writing scripts and small Web applica-\ntions and also contains some support for creating larger programs.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 258, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0259_a4ca2cb1", "text": "It is used most commonly for writing scripts and small Web applica-\ntions and also contains some support for creating larger programs. SQL\nSQL is the de facto standard language for querying, updating, and managing rela-\ntional databases. “SQL” stands for Structured Query Language. Unlike other lan-\nguages listed in this section, SQL is a “declarative language,” meaning that it does not \ndefine a sequence of operations, but rather the result of some operations. Visual Basic\nThe original version of Basic was a high-level language developed at Dartmouth Col-\nlege in the 1960s. The acronym BASIC stands for Beginner’s All-purpose Symbolic \nC04619670.fm Page 65 Tuesday, April 12, 2011 2:25 PM\n66\nChapter 4: Key Construction Decisions\nInstruction Code. Visual Basic is a high-level, object-oriented, visual programming \nversion of Basic developed by Microsoft that was originally designed for creating \nMicrosoft Windows applications.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 259, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0260_f200ffc3", "text": "Visual Basic is a high-level, object-oriented, visual programming \nversion of Basic developed by Microsoft that was originally designed for creating \nMicrosoft Windows applications. It has since been extended to support customiza-\ntion of desktop applications such as Mi crosoft Office, creation of Web programs, \nand other applications. Experts report that by the early 2000s more professional \ndevelopers were working in Visual Basic than in any other language (Feiman and \nDriver 2002). 4.2 Programming Conventions\nCross-Reference For more \ndetails on the power of con-\nventions, see Sections 11.3 \nthrough 11.5. In high-quality software, you can see a rela tionship between the conceptual integrity \nof the architecture and its low-level implementation. The implementation must be \nconsistent with the architecture that guides it and consistent internally.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 260, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 860}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0261_9f7795e9", "text": "The implementation must be \nconsistent with the architecture that guides it and consistent internally. That’s the \npoint of construction guidelin es for variable names, class names, routine names, for-\nmatting conventions, and commenting conventions. In a complex program, architectural guidelines give the program structural balance \nand construction guidelines provide low-level harmony, articulating each class as a \nfaithful part of a comprehensive design. Any large program requires a controlling \nstructure that unifies its programming-language details. Part of the beauty of a large \nstructure is the way in which its detailed part s bear out the implications of its architec-\nture. Without a unifying discipline, your creati on will be a jumble of sloppy variations \nin style. Such variations tax your brain—and only for the sake of understanding cod-\ning-style differences that are essentially arbitrary.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 261, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 913}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0262_c8aa0ca6", "text": "Such variations tax your brain—and only for the sake of understanding cod-\ning-style differences that are essentially arbitrary. One key to successful programming \nis avoiding arbitrary variations so that your brain can be free to focus on the variations \nthat are really needed. For more on this, see “Software’s Primary Technical Imperative: \nManaging Complexity” in Section 5.2. What if you had a great design for a painti ng, but one part was classical, one impres-\nsionist, and one cubist? It wouldn’t have conceptual integrity no matter how closely \nyou followed its grand design. It would look like a collage. A program needs low-level \nintegrity, too. Before construction begins, spell out the programming conventions you’ll use. Cod-\ning-convention details are at such a level of precision that they’re nearly impossible to \nretrofit into software after it’s written. Details of such conventions are provided \nthroughout the book.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 262, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0263_1ed6057d", "text": "Cod-\ning-convention details are at such a level of precision that they’re nearly impossible to \nretrofit into software after it’s written. Details of such conventions are provided \nthroughout the book. 4.3 Your Location on the Technology Wave \nDuring my career I’ve seen the PC’s star ri se while the mainframe’ s star dipped toward \nthe horizon. I’ve seen GUI programs repla ce character-based programs. And I’ve seen \nthe Web ascend while Windows declines. I can only assume that by the time you read \nKEY POINT\n4.3 Your Location on the Technology Wave 67\nthis some new technology will be in ascendance, and Web programming as I know it \ntoday (2004) will be on its way out. These t echnology cycles, or wa ves, imply different \nprogramming practices depending on where you find yourself on the wave. In mature technology environments—the end of the wave, such as Web programming \nin the mid-2000s—we benefit from a rich software development infrastructure.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 263, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0264_912400a4", "text": "In mature technology environments—the end of the wave, such as Web programming \nin the mid-2000s—we benefit from a rich software development infrastructure. Late-\nwave environments provide numerous pr ogramming language choices, comprehen-\nsive error checking for code written in those languages, powerful debugging tools, \nand automatic, reliable performance optimi zation. The compilers are nearly bug-free. The tools are well documented in vendor literature, in third-party books and articles, \nand in extensive Web resources. Tools are integrated, so you can do UI, database, \nreports, and business logic from within a single environment. If you do run into prob-\nlems, you can readily find quirks of the tools described in FAQs. Many consultants \nand training classes are also available. In early-wave environments—Web programming in the mid-1990s, for example—the \nsituation is the opposite. Few programming language choices are available, and those \nlanguages tend to be buggy and poorly documented.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 264, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0265_cc251609", "text": "Few programming language choices are available, and those \nlanguages tend to be buggy and poorly documented. Programmers spend significant \namounts of time simply trying to figure ou t how the language works instead of writing \nnew code. Programmers also spend countless hours working around bugs in the lan-\nguage products, underlying operating system , and other tools. Programming tools in \nearly-wave environments tend to be primit ive. Debuggers might not exist at all, and \ncompiler optimizers are still only a gleam in some programmer’s eye. Vendors revise \ntheir compiler version often, and it seems that each new version breaks significant \nparts of your code. Tools aren’t integrated, and so you tend to work with different \ntools for UI, database, reports, and business logic. The tools tend not to be very com-\npatible, and you can expend a significant amo unt of effort just to keep existing func-\ntionality working against the onslaught of compiler and library releases.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 265, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0266_6567268a", "text": "The tools tend not to be very com-\npatible, and you can expend a significant amo unt of effort just to keep existing func-\ntionality working against the onslaught of compiler and library releases. If you run \ninto trouble, reference literature exists on the Web in some form, but it isn’t always \nreliable and, if the available literature is any guide, every time you encounter a prob-\nlem it seems as though you’re the first one to do so. These comments might seem like a recomme ndation to avoid early-wave program-\nming, but that isn’t their intent. Some of th e most innovative appl ications arise from \nearly-wave programs, like Turbo Pascal, Lo tus 123, Microsoft Word, and the Mosaic \nbrowser. The point is that how you spend your programming days will depend on \nwhere you are on the technology wave. If you’re in the late part of the wave, you can \nplan to spend most of your day steadily writing new functionality.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 266, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0267_e0a03f15", "text": "If you’re in the late part of the wave, you can \nplan to spend most of your day steadily writing new functionality. If you’re in the early \npart of the wave, you can assume that you’ll spend a sizeable portion of your time try-\ning to figure out your programming language’s undocumented features, debugging \nerrors that turn out to be defects in the library code, revising code so that it will work \nwith a new release of some vendor’s library, and so on. When you find yourself working in a primitive environment, realize that the program-\nming practices described in this book can help you even more than they can in mature \n68\nChapter 4: Key Construction Decisions\nenvironments. As David Gries pointed out, your programming tools don’t have to \ndetermine how you think about programming (1981). Gries makes a distinction \nbetween programming in a language vs. programming into a language. Programmers \nwho program “in” a language limit their th oughts to constructs that the language \ndirectly supports.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 267, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0268_3d35f661", "text": "programming into a language. Programmers \nwho program “in” a language limit their th oughts to constructs that the language \ndirectly supports. If the language tools are primitive, the programmer’s thoughts will \nalso be primitive. Programmers who program “into” a language first decide what thoughts they want to \nexpress, and then they determine how to express those thoughts using the tools pro-\nvided by their specific language. Example of Programming into a Language\nIn the early days of Visual Basic, I was fr ustrated because I wanted to keep the busi-\nness logic, the UI, and the database separa te in the product I was developing, but \nthere wasn’t any built-in way to do that in the language. I knew that if I wasn’t careful, \nover time some of my Visual Basic “forms ” would end up containing business logic, \nsome forms would contain database code, and some would contain neither—I would \nend up never being able to remember which code was located in which place.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 268, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0269_c855d44e", "text": "I had \njust completed a C++ project that had done a poor job of separating those issues, and \nI didn’t want to experience déjà vu of those headaches in a different language. Consequently, I adopted a design convention that the .frm file (the form file) was \nallowed only to retrieve data from the database and store data back into the database. It wasn’t allowed to communicate that data directly to other parts of the program. Each form supported an IsFormCompleted() routine, which was used by the calling \nroutine to determine whether the form that had been activated had saved its data. IsFormCompleted() was the only public routine that forms were allowed to have. Forms also weren’t allowed to contain any business logic. All other code had to be \ncontained in an associated .bas file, includ ing validity checks for entries in the form. Visual Basic did not encourage this kind of approach.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 269, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 897}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0270_345e70cc", "text": "All other code had to be \ncontained in an associated .bas file, includ ing validity checks for entries in the form. Visual Basic did not encourage this kind of approach. It encouraged programmers to \nput as much code into the .frm file as possible, and it didn’t make it easy for the .frm \nfile to call back into an associated .bas file. This convention was pretty si mple, but as I got deeper into my project, I found that it \nhelped me avoid numerous cases in which I would have been writing convoluted code \nwithout the convention. I would have been loading forms but keeping them hidden so \nthat I could call the data-validity-checking routines inside them, or I would have been \ncopying code from the forms into other loca tions and then maintaining parallel code \nin multiple places. The IsFormCompleted( ) convention also kept things simple.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 270, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 848}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0271_b8bdfd2a", "text": "The IsFormCompleted( ) convention also kept things simple. Because every form worked exactly the same way, I never had to second-guess the \nsemantics of IsFormCompleted()—it meant the same thing every time it was used. 4.4 Selection of Major Construction Practices 69\nVisual Basic didn’t support th is convention directly, but my use of a simple program-\nming convention—programming into the language—made up for the language’s lack of \nstructure at that time and helped keep the project intellectually manageable. Understanding the distinction between pr ogramming in a language and program-\nming into one is critical to understanding this book. Most of the important program-\nming principles depend not on specific la nguages but on the way you use them. If \nyour language lacks constructs that you want to use or is prone to other kinds of prob-\nlems, try to compensate for them. Invent your own coding conventions, standards, \nclass libraries, and other augmentations.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 271, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0272_0bc3e593", "text": "Invent your own coding conventions, standards, \nclass libraries, and other augmentations. 4.4 Selection of Major Construction Practices\nPart of preparing for construction is decidi ng which of the many available good prac-\ntices you’ll emphasize. Some projects use pair programming and test-first develop-\nment, while others use solo development an d formal inspections. Either combination \nof techniques can work well, depending on specific circumstances of the project. The following checklist summarizes the sp ecific practices you should consciously \ndecide to include or exclude during constr uction. Details of these practices are con-\ntained throughout the book. cc2e.com/0496\nChecklist: Major Construction Practices\nCoding \n❑\nHave you defined how much design will be done up front and how much \nwill be done at the keyboard, while the code is being written? ❑\nHave you defined coding conventions for names, comments, and layout?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 272, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0273_dded1e4a", "text": "❑\nHave you defined coding conventions for names, comments, and layout? ❑\nHave you defined specific coding practices that are implied by the architec-\nture, such as how error conditions will be handled, how security will be \naddressed, what conventions will be us ed for class interfaces, what stan-\ndards will apply to reused code, how much to consider performance while \ncoding, and so on? ❑\nHave you identified your location on the technology wave and adjusted \nyour approach to match? If necessary, have you identified how you will \nprogram into the language rather than being limited by programming in it? Teamwork \n❑\nHave you defined an integration procedure—that is, have you defined the \nspecific steps a programmer must go through before checking code into \nthe master sources? ❑\nWill programmers program in pairs, or individually, or some combination \nof the two?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 273, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 872}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0274_b38984f1", "text": "❑\nWill programmers program in pairs, or individually, or some combination \nof the two? KEY POINT\n70\nChapter 4: Key Construction Decisions\nCross-Reference For more \ndetails on quality assurance, \nsee Chapter 20, “The Soft-\nware-Quality Landscape.”\nQuality Assurance \n❑\nWill programmers write test cases for their code before writing the code \nitself? ❑\nWill programmers write unit tests for their code regardless of whether \nthey write them first or last? ❑\nWill programmers step through their code in the debugger before they \ncheck it in? ❑\nWill programmers integration-test their code before they check it in? ❑\nWill programmers review or inspect each other’s code? Cross-Reference For more \ndetails on tools, see Chapter \n30, “Programming Tools.”\nTools\n❑\nHave you selected a revision control tool? ❑\nHave you selected a language and language version or compiler version? ❑\nHave you selected a framework such as J2EE or Microsoft .NET or explic-\nitly decided not to use a framework?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 274, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0275_8a6a3cd7", "text": "❑\nHave you selected a language and language version or compiler version? ❑\nHave you selected a framework such as J2EE or Microsoft .NET or explic-\nitly decided not to use a framework? ❑\nHave you decided whether to allow use of nonstandard language features? ❑\nHave you identified and acquired other tools you’ll be using—editor, refac-\ntoring tool, debugger, test framework, syntax checker, and so on? Key Points\n■\nEvery programming language has strengths and weaknesses. Be aware of the \nspecific strengths and weaknesses of the language you’re using. ■\nEstablish programming conventions before you begin programming. It’s nearly \nimpossible to change code to match them later. ■\nMore construction practices exist than you can use on any single project. Con-\nsciously choose the practices that are best suited to your project. ■\nAsk yourself whether the programming practices you’re using are a response to \nthe programming language you’re using or controlled by it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 275, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0276_1ae23665", "text": "■\nAsk yourself whether the programming practices you’re using are a response to \nthe programming language you’re using or controlled by it. Remember to pro-\ngram into the language, rather than programming in it. ■\nYour position on the technology wave de termines what approaches will be effec-\ntive—or even possible. Id entify where you are on the technology wave, and \nadjust your plans and expectations accordingly. Part II\nCreating High-Quality Code\nIn this part:\nChapter 5: Design in Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .73\nChapter 6: Working Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .125\nChapter 7: High-Quality Routines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .161\nChapter 8: Defensive Programming. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .187\nChapter 9: The Pseudocode Programming Process. . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 276, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0277_2c59bee2", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .161\nChapter 8: Defensive Programming. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .187\nChapter 9: The Pseudocode Programming Process. . . . . . . . . . . . . . . . . .215\n\n73\nChapter 5\nDesign in Construction\ncc2e.com/0578\nContents\n■\n5.1 Design Challenges: page 74\n■\n5.2 Key Design Concepts: page 77\n■\n5.3 Design Building Blocks: Heuristics: page 87\n■\n5.4 Design Practices: page 110\n■\n5.5 Comments on Popular Methodologies: page 118\nRelated Topics\n■\nSoftware architecture: Section 3.5\n■\nWorking classes: Chapter 6\n■\nCharacteristics of high-quality routines: Chapter 7\n■\nDefensive programming: Chapter 8\n■\nRefactoring: Chapter 24\n■\nHow program size affects construction: Chapter 27\nSome people might argue that design isn’t re ally a construction activity, but on small \nprojects, many activities are thought of as construction, often including design.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 277, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 925}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0278_edd7678b", "text": "On \nsome larger projects, a formal architecture might address only the system-level issues \nand much design work might intentionally be left for construction. On other large \nprojects, the design might be intended to be detailed enough for coding to be fairly \nmechanical, but design is rarely that complete—the programmer usually designs part \nof the program, officially or otherwise. Cross-Reference For details \non the different levels of for-\nmality required on large and \nsmall projects, see Chapter \n27, “How Program Size \nAffects Construction.”\nOn small, informal projects, a lot of design is done while the programmer sits at the \nkeyboard. “Design” might be just writing a class interface in pseudocode before writ-\ning the details. It might be drawing diagrams of a few class relationships before coding \nthem. It might be asking another programm er which design patte rn seems like a bet-\nter choice.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 278, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0279_fcbe0703", "text": "It might be drawing diagrams of a few class relationships before coding \nthem. It might be asking another programm er which design patte rn seems like a bet-\nter choice. Regardless of how it’s done, small projects benefit from careful design just \nas larger projects do, and recognizing design as an explicit activity maximizes the ben-\nefit you will receive from it. Design is a huge topic, so only a few aspects of it are considered in this chapter. A large \npart of good class or routine design is determined by the system architecture, so be \n74\nChapter 5: Design in Construction\nsure that the architecture prerequisite di scussed in Section 3.5 has been satisfied.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 279, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 669}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0280_3d5939b0", "text": "Even more design work is done at the level of individual classes and routines, \ndescribed in Chapter 6, “Working Classes, ” and Chapter 7, “High-Quality Routines.”\nIf you’re already familiar with software de sign topics, you might want to just hit the \nhighlights in the sections ab out design challenges in Section 5.1 and key heuristics in \nSection 5.3. 5.1 Design Challenges\nCross-Reference The differ-\nence between heuristic and \ndeterministic processes is \ndescribed in Chapter 2, \n“Metaphors for a Richer \nUnderstanding of Software \nDevelopment.”\nThe phrase “software design” means the con ception, invention, or contrivance of a \nscheme for turning a specification for computer software into operational software. Design is the activity that links requirements to coding and debugging. A good top-\nlevel design provides a structure that can safely contain multiple lower-level designs. Good design is useful on small projects and indispensable on large projects.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 280, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0281_30ec7475", "text": "A good top-\nlevel design provides a structure that can safely contain multiple lower-level designs. Good design is useful on small projects and indispensable on large projects. Design is also marked by numerous challenges, which are outlined in this section. Design Is a Wicked Problem\nThe picture of the software \ndesigner deriving his design \nin a rational, error-free way \nfrom a statement of require-\nments is quite unrealistic. No \nsystem has ever been devel-\noped in that way, and proba-\nbly none ever will. Even the \nsmall program develop-\nments shown in textbooks \nand papers are unreal. They \nhave been revised and pol-\nished until the author has \nshown us what he wishes he \nhad done, not what actually \ndid happen. —David Parnas and \nPaul Clements\nHorst Rittel and Melvin Webber defined a “wicked” problem as one that could be \nclearly defined only by solving it, or by solving part of it (1973).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 281, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0282_3abe4aa9", "text": "—David Parnas and \nPaul Clements\nHorst Rittel and Melvin Webber defined a “wicked” problem as one that could be \nclearly defined only by solving it, or by solving part of it (1973). This paradox implies, \nessentially, that you have to “solve” the problem once in order to clearly define it and \nthen solve it again to create a solution th at works. This proce ss has been motherhood \nand apple pie in software development for decades (Peters and Tripp 1976). In my part of the world, a dramatic exampl e of such a wicked problem was the design \nof the original Tacoma Narrows bridge. At th e time the bridge was built, the main con-\nsideration in designing a bridge was that it be strong enough to support its planned \nload. In the case of the Tacoma Narrows bridge, wind created an unexpected, side-to-\nside harmonic ripple. One blustery day in 1940, the ripple grew uncontrollably until \nthe bridge collapsed, as shown in Figure 5-1.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 282, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0283_5f3148a5", "text": "One blustery day in 1940, the ripple grew uncontrollably until \nthe bridge collapsed, as shown in Figure 5-1. This is a good example of a wicked proble m because, until the bridge collapsed, its \nengineers didn’t know that aerodynamics need ed to be considered to such an extent. Only by building the bridge (solving the problem) could they learn about the addi-\ntional consideration in the problem that a llowed them to build another bridge that \nstill stands. 5.1 Design Challenges 75\nFigure 5-1 The Tacoma Narrows bridge—an example of a wicked problem. One of the main differences between progra ms you develop in school and those you \ndevelop as a professional is that the design problems solved by school programs are \nrarely, if ever, wicked. Programming assignment s in school are devised to move you in a \nbeeline from beginning to end.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 283, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 844}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0284_113fccb5", "text": "Programming assignment s in school are devised to move you in a \nbeeline from beginning to end. You’d probably want to tar and feather a teacher who gave \nyou a programming assignment, then changed the assignment as soon as you finished \nthe design, and then changed it again just as you were about to turn in the completed pro-\ngram. But that very process is an everyd ay reality in professional programming. Design Is a Sloppy Process (Even If it Produces a Tidy Result)\nThe finished software design should look well organized and clean, but the process \nused to develop the design isn’t nearly as tidy as the end result. Further Reading For a fuller \nexploration of this viewpoint, \nsee “A Rational Design Pro-\ncess: How and Why to Fake \nIt” (Parnas and Clements \n1986). Design is sloppy because you take many false steps and go down many blind alleys—\nyou make a lot of mistakes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 284, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 883}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0285_ee0224e6", "text": "Design is sloppy because you take many false steps and go down many blind alleys—\nyou make a lot of mistakes. Indeed, making mistakes is the point of design—it’s \ncheaper to make mistakes and correct design s than it would be to make the same mis-\ntakes, recognize them after coding, and have to correct full-blown code. Design is \nsloppy because a good solution is often only subtly different from a poor one. Morning News Tribune\n76\nChapter 5: Design in Construction\nCross-Reference For a better \nanswer to this question, see \n“How Much Design is \nEnough?” in Section 5.4 later \nin this chapter. Design is also sloppy because it’s hard to know when your design is “good enough.” \nHow much detail is enough? How much design should be done with a formal design \nnotation, and how much should be left to be done at the keyboard? When are you \ndone?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 285, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 847}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0286_b956dbfd", "text": "How much design should be done with a formal design \nnotation, and how much should be left to be done at the keyboard? When are you \ndone? Since design is open-ended, the most common answer to that question is \n“When you’re out of time.”\nDesign Is About Tradeoffs and Priorities\nIn an ideal world, every system could run instantly, consume zero storage space, use \nzero network bandwidth, never contain any errors, and cost nothing to build. In the real \nworld, a key part of the designer’s job is to weigh competing design characteristics and \nstrike a balance among those characteristics. If a fast response rate is more important \nthan minimizing development time, a design er will choose one design. If minimizing \ndevelopment time is more important, a good designer will craft a different design. Design Involves Restrictions\nThe point of design is partly to cr eate possibilities and partly to restrict possibilities .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 286, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0287_2c01427a", "text": "Design Involves Restrictions\nThe point of design is partly to cr eate possibilities and partly to restrict possibilities . If \npeople had infinite time, resources, and sp ace to build physical structures, you would \nsee incredible sprawling buildings with one room for each shoe and hundreds of rooms. This is how software can turn out without deliberately imposed restrictions. The con-\nstraints of limited resources for constructing buildings force simplifications of the solu-\ntion that ultimately improve the solution. The goal in software design is the same. Design Is Nondeterministic\nIf you send three people away to design the same program, they can easily return with \nthree vastly different designs, each of which could be perfect ly acceptable. There \nmight be more than one way to skin a cat, but there are usually dozens of ways to \ndesign a computer program.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 287, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 872}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0288_448a0898", "text": "There \nmight be more than one way to skin a cat, but there are usually dozens of ways to \ndesign a computer program. Design Is a Heuristic Process\nBecause design is nondeterministic, design t echniques tend to be heuristics—“rules of \nthumb” or “things to try that sometimes wo rk”—rather than repeatable processes that \nare guaranteed to produce predictable results. Design involves trial and error. A \ndesign tool or technique that worked well on one job or on one aspect of a job might \nnot work as well on the next project. No tool is right for everything. Design Is Emergent\ncc2e.com/0539\nA tidy way of summarizing these attributes of design is to say that design is \n“emergent.” Designs don’t spring fully form ed directly from someone’s brain. They \nevolve and improve through design reviews, informal discussions, experience writing \nthe code itself, and experience revising the code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 288, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0289_75283195", "text": "They \nevolve and improve through design reviews, informal discussions, experience writing \nthe code itself, and experience revising the code. KEY POINT\n5.2 Key Design Concepts 77\nFurther Reading Software \nisn’t the only kind of struc-\nture that changes over time. Physical structures evolve, \ntoo—see How Buildings \nLearn (Brand 1995). Virtually all systems undergo some degree of design changes during their initial devel-\nopment, and then they typically change to a greater extent as they’re extended into \nlater versions. The degree to which change is beneficial or acceptable depends on the \nnature of the software being built. 5.2 Key Design Concepts\nGood design depends on understanding a ha ndful of key concepts. This section dis-\ncusses the role of complexity, desirable characterist ics of designs, and levels of design.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 289, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 830}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0290_7c53c854", "text": "5.2 Key Design Concepts\nGood design depends on understanding a ha ndful of key concepts. This section dis-\ncusses the role of complexity, desirable characterist ics of designs, and levels of design. Software’s Primary Technical Imperative: Managing Complexity \nCross-Reference For discus-\nsion of the way complexity \naffects programming issues \nother than design, see \nSection 34.1, “Conquer \nComplexity.”\nTo understand the importance of managing co mplexity, it’s useful to refer to Fred \nBrooks’s landmark paper, “No Silver Bullets : Essence and Accidents of Software Engi-\nneering” (1987). Accidental and Essential Difficulties\nBrooks argues that software development is made difficult because of two different \nclasses of problems—the essential and the accidental . In referring to these two terms, \nBrooks draws on a philosophical tradition going back to Aristotle. In philosophy, the \nessential properties are the properties that a thing must have in order to be that thing.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 290, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0291_ef65e37e", "text": "In philosophy, the \nessential properties are the properties that a thing must have in order to be that thing. A car must have an engine, wheels, and doors to be a car. If it doesn’t have any of those \nessential properties, it isn’t really a car. Accidental properties are the properties a th ing just happens to have, properties that \ndon’t really bear on whether the thing is what it is. A car could have a V8, a turbo-\ncharged 4-cylinder, or some other kind of en gine and be a car regardless of that detail. A car could have two doors or four; it coul d have skinny wheels or mag wheels. All \nthose details are accidental properties. You could also think of accidental properties \nas incidental , discretionary , optional , and happenstance . Cross-Reference Accidental \ndifficulties are more promi-\nnent in early-wave develop-\nment than in late-wave \ndevelopment.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 291, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 867}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0292_0a34e8d7", "text": "Cross-Reference Accidental \ndifficulties are more promi-\nnent in early-wave develop-\nment than in late-wave \ndevelopment. For details, \nsee Section 4.3, “Your Loca-\ntion on the Technology \nWave.”\nBrooks observes that the major accidental di fficulties in software were addressed long \nago. For example, accidental difficulties related to clumsy language syntaxes were \nlargely eliminated in the evolution from a ssembly language to third-generation lan-\nguages and have declined in significance in crementally since then. Accidental difficul-\nties related to noninteractive computers were resolved when time-share operating \nsystems replaced batch-mode systems. In tegrated programming environments fur-\nther eliminated inefficiencies in programmi ng work arising from tools that worked \npoorly together. 78\nChapter 5: Design in Construction\nBrooks argues that progress on software’s remaining essential difficulties is bound to \nbe slower.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 292, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0293_0874bd33", "text": "78\nChapter 5: Design in Construction\nBrooks argues that progress on software’s remaining essential difficulties is bound to \nbe slower. The reason is that, at its essenc e, software development consists of working \nout all the details of a highly intricate, interlocking set of concepts. The essential \ndifficulties arise from the necessity of interfacing with the complex, disorderly real \nworld; accurately and completely identify ing the dependencies and exception cases; \ndesigning solutions that can’t be just appr oximately correct but that must be exactly \ncorrect; and so on. Even if we could invent a programming language that used the \nsame terminology as the real-world problem we’re trying to solve, programming \nwould still be difficult because of the chal lenge in determining precisely how the real \nworld works.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 293, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 827}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0294_46cf637e", "text": "As software addresses ever-lar ger real-world problems, the interactions \namong the real-world entities become increasingly intricate, and that in turn increases \nthe essential difficulty of the software solutions. The root of all these essential difficulties is complexity—both accidental and essential. Importance of Managing Complexity\nThere are two ways of con-\nstructing a software design: \none way is to make it so sim-\nple that there are obviously \nno deficiencies, and the \nother is to make it so compli-\ncated that there are no obvi-\nous deficiencies. —C. A. R. Hoare\nWhen software-project surveys report causes of project failure, they rarely identify \ntechnical reasons as the primary causes of project failure. Projects fail most often \nbecause of poor requirements, poor pl anning, or poor management. But when \nprojects do fail for reasons that are primarily technical, the reason is often uncon-\ntrolled complexity.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 294, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0295_e1245e20", "text": "But when \nprojects do fail for reasons that are primarily technical, the reason is often uncon-\ntrolled complexity. The software is allowed to grow so complex that no one really \nknows what it does. When a project reache s the point at which no one completely \nunderstands the impact that code changes in one area will have on other areas, \nprogress grinds to a halt. Managing complexity is the most important technical topic in software development. In my view, it’s so important that Software’s Primary Technical Imperative has to be \nmanaging complexity . Complexity is not a new feature of softwa re development. Computing pioneer Edsger \nDijkstra pointed out that computing is the only profession in which a single mind is \nobliged to span the distance from a bit to a few hundred megabytes, a ratio of 1 to 10\n9\n, \nor nine orders of magnitude (Dijkstra 1989). This gigantic ratio is staggering.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 295, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 900}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0296_9f43bb9a", "text": "This gigantic ratio is staggering. Dijkstra \nput it this way: “Compared to that number of semantic levels, the average mathemati-\ncal theory is almost flat. By evoking the need for deep conceptual hierarchies, the \nautomatic computer confronts us with a ra dically new intellectual challenge that has \nno precedent in our history.” Of course software has become even more complex \nsince 1989, and Dijkstra’s ratio of 1 to 10\n9 \ncould easily be more like 1 to 10\n15\n today. KEY POINT\n5.2 Key Design Concepts 79\nOne symptom that you have \nbogged down in complexity \noverload is when you find \nyourself doggedly applying a \nmethod that is clearly irrele-\nvant, at least to any outside \nobserver. It is like the \nmechanically inept person \nwhose car breaks down—so \nhe puts water in the battery \nand empties the ashtrays. —P. J .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 296, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 825}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0297_c138e124", "text": "It is like the \nmechanically inept person \nwhose car breaks down—so \nhe puts water in the battery \nand empties the ashtrays. —P. J . P l a u g e r\nDijkstra pointed out that no one’s skull is really big enough to contain a modern com-\nputer program (Dijkstra 1972), which means that we as software developers \nshouldn’t try to cram whole programs into our skulls at once; we should try to orga-\nnize our programs in such a way that we can safely focus on one part of it at a time. The goal is to minimize the amount of a program you have to think about at any one \ntime. You might think of this as mental ju ggling—the more mental balls the program \nrequires you to keep in the air at once, the more likely you’ll drop one of the balls, \nleading to a design or coding error. At the software-architecture level, the complexity of a problem is reduced by dividing \nthe system into subsystems. Humans have an easier time comprehending several sim-\nple pieces of information than one complica ted piece.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 297, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0298_497cff12", "text": "Humans have an easier time comprehending several sim-\nple pieces of information than one complica ted piece. The goal of all software-design \ntechniques is to break a complicated prob lem into simple pieces. The more indepen-\ndent the subsystems are, the more you make it safe to focus on one bit of complexity \nat a time. Carefully defined objects separate concerns so that you can focus on one \nthing at a time. Packages provide the same benefit at a higher level of aggregation. Keeping routines short helps reduce your mental workload. Writing programs in \nterms of the problem domain, rather than in terms of low-level implementation \ndetails, and working at the highest level of abstraction reduce the load on your brain. The bottom line is that programmers wh o compensate for inherent human limita-\ntions write code that’s easier for themselves and others to understand and that has \nfewer errors.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 298, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 905}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0299_c39a900b", "text": "The bottom line is that programmers wh o compensate for inherent human limita-\ntions write code that’s easier for themselves and others to understand and that has \nfewer errors. How to Attack Complexity\nOverly costly, ineffective designs arise from three sources:\n■\nA complex solution to a simple problem\n■\nA simple, incorrect solution to a complex problem\n■\nAn inappropriate, complex solution to a complex problem\nAs Dijkstra pointed out, modern software is inherently complex, and no matter how \nhard you try, you’ll eventually bump into some level of complexity that’s inherent in the \nreal-world problem itself. This suggests a two-prong approach to managing complexity: \n■\nMinimize the amount of essential comple xity that anyone’s brain has to deal \nwith at any one time. ■\nKeep accidental complexity from needlessly proliferating. Once you understand that all other technical goals in software are secondary to man-\naging complexity, many design considerations become straightforward.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 299, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0300_72ca8b30", "text": "Once you understand that all other technical goals in software are secondary to man-\naging complexity, many design considerations become straightforward. KEY POINT\n80\nChapter 5: Design in Construction\nDesirable Characteri stics of a Design\nWhen I am working on a \nproblem I never think about \nbeauty. I think only how to \nsolve the problem. But when \nI have finished, if the solu-\ntion is not beautiful, I know it \nis wrong. —R. Buckminster Fuller\nA high-quality design has seve ral general characteristics. If you could achieve all these \ngoals, your design would be very good ind eed. Some goals contradict other goals, but \nthat’s the challenge of design—creating a good set of tradeoffs from competing \nobjectives. Some characteristics of design quality are also characteristics of a good \nprogram: reliability, performance, and so on . Others are internal characteristics of \nthe design. Cross-Reference These \ncharacteristics are related to \ngeneral software-quality \nattributes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 300, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0301_b2b91224", "text": "Others are internal characteristics of \nthe design. Cross-Reference These \ncharacteristics are related to \ngeneral software-quality \nattributes. For details on \ngeneral attributes, see Sec-\ntion 20.1, “Characteristics of \nSoftware Quality.”\nHere’s a list of internal design characteristics:\nMinimal complexity The primary goal of design shou ld be to minimize complexity \nfor all the reasons just described. Avoid ma king “clever” designs. Clever designs are \nusually hard to understand. Instead make “simple” and “easy-to-understand” designs. If your design doesn’t let you safely igno re most other parts of the program when \nyou’re immersed in one specific part, the design isn’t doing its job. Ease of maintenance Ease of maintenance means designing for the maintenance \nprogrammer. Continually imagine the qu estions a maintenance programmer would \nask about the code you’re writing. Think of the maintenance programmer as your \naudience, and then design the system to be self-explanatory.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 301, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0302_e450e9a6", "text": "Think of the maintenance programmer as your \naudience, and then design the system to be self-explanatory. Loose coupling Loose coupling means de signing so that you hold connections \namong different parts of a program to a mini mum. Use the principles of good abstrac-\ntions in class interfaces, encapsulation, and information hiding to design classes with \nas few interconnections as possible. Mi nimal connectedness minimizes work during \nintegration, testing, and maintenance. Extensibility Extensibility means that you can enhance a system without causing \nviolence to the underlying structure. You can change a piece of a system without \naffecting other pieces. The most likely changes cause the system the least trauma. Reusability Reusability means designing the system so that you can reuse pieces of \nit in other systems. High fan-in High fan-in refers to having a high number of classes that use a given \nclass.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 302, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0303_566eaad0", "text": "Reusability Reusability means designing the system so that you can reuse pieces of \nit in other systems. High fan-in High fan-in refers to having a high number of classes that use a given \nclass. High fan-in implies that a system has been designed to make good use of utility \nclasses at the lower levels in the system. 5.2 Key Design Concepts 81\nLow-to-medium fan-out Low-to-medium fan-out means having a given class use a \nlow-to-medium number of other classes. High fan-out (more than about seven) indi-\ncates that a class uses a large number of other classes and may therefore be overly \ncomplex. Researchers have found that the principle of low fan-out is beneficial \nwhether you’re considering the number of routines called from within a routine or the \nnumber of classes used within a class (Card and Glass 1990; Basili, Briand, and Melo \n1996). Portability Portability means designing the system so that you can easily move it to \nanother environment.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 303, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0304_2cc00b9e", "text": "Portability Portability means designing the system so that you can easily move it to \nanother environment. Leanness Leanness means designing the system so that it has no extra parts (Wirth \n1995, McConnell 1997). Voltaire said that a book is finished not when nothing more \ncan be added but when nothing more can be taken away. In software, this is especially \ntrue because extra code has to be developed, reviewed, tested, and considered when \nthe other code is modified. Future versions of the software must remain backward-\ncompatible with the extra code. The fatal question is “It’s easy, so what will we hurt by \nputting it in?”\nStratification Stratification means trying to keep the levels of decomposition strati-\nfied so that you can view the system at any single level and get a consistent view. Design the system so that you can view it at one level without dipping into other levels.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 304, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 894}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0305_99190c90", "text": "Design the system so that you can view it at one level without dipping into other levels. Cross-Reference For more \non working with old systems, \nsee Section 24.5, “Refactor-\ning Strategies.”\nFor example, if you’re writing a modern system that has to use a lot of older, poorly \ndesigned code, write a layer of the new system that’s responsible for interfacing with \nthe old code. Design the layer so that it hides the poor quality of the old code, present-\ning a consistent set of services to the newer layers. Then have the rest of the system \nuse those classes rather than the old code. The beneficial effects of stratified design in \nsuch a case are (1) it compartmentalizes the messiness of the bad code and (2) if \nyou’re ever allowed to jettison the old code or refactor it, you won’t need to modify any \nnew code except the interface layer.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 305, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 848}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0306_02afcadb", "text": "Cross-Reference An espe-\ncially valuable kind of stan-\ndardization is the use of \ndesign patterns, which are \ndiscussed in “Look for Com-\nmon Design Patterns” in \nSection 5.3. Standard techniques The more a system relies on exotic pieces, the more intimidat-\ning it will be for someone trying to understand it the first time. Try to give the whole \nsystem a familiar feeling by using standardized, common approaches. C05619670.fm Page 81 Tuesday, April 12, 2011 2:30 PM\n82\nChapter 5: Design in Construction\nLevels of Design\nDesign is needed at several different levels of detail in a software system. Some design tech-\nniques apply at all levels, and some apply at only one or two. Figure 5-2 illustrates the levels. Figure 5-2 The levels of design in a program. The system (1) is first organized into sub-\nsystems (2). The subsystems are further divided into classes (3), and the classes are divided \ninto routines and data (4). The inside of each routine is also designed (5).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 306, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0307_bb9985b6", "text": "The subsystems are further divided into classes (3), and the classes are divided \ninto routines and data (4). The inside of each routine is also designed (5). Level 1: Software System\nIn other words—and this is \nthe rock-solid principle on \nwhich the whole of the Cor-\nporation’s Galaxywide suc-\ncess is founded—their \nfundamental design flaws \nare completely hidden by \ntheir superficial design flaws. —Douglas Adams\nThe first level is the entire system. Some programmers jump right from the system \nlevel into designing classes, but it’s usually beneficial to think through higher level \ncombinations of classes, such as subsystems or packages. Level 2: Division into Subsystems or Packages\nThe main product of design at this level is the identification of all major subsystems.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 307, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 780}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0308_6721d290", "text": "Level 2: Division into Subsystems or Packages\nThe main product of design at this level is the identification of all major subsystems. The \nsubsystems can be big: database, user inte rface, business rules, command interpreter, \nDivision into subsystems/packages\n2\nDivision into classes within packages\n3Software system\n1\nDivision into data and routines within classes\n4\nInternal routine design\n5\n5.2 Key Design Concepts 83\nreport engine, and so on. The major design activity at this level is deciding how to parti-\ntion the program into major subsystems and defining how each subsystem is allowed to \nuse each other subsystem. Division at this le vel is typically needed on any project that \ntakes longer than a few weeks. Within each subsystem, different methods of design \nmight be used—choosing the approach that best fits each part of the system. In Figure 5-\n2, design at this level is marked with a 2.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 308, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 906}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0309_7a4f3b13", "text": "Within each subsystem, different methods of design \nmight be used—choosing the approach that best fits each part of the system. In Figure 5-\n2, design at this level is marked with a 2. Of particular importance at this level are the rules about how the various subsystems \ncan communicate. If all subsystems can co mmunicate with all other subsystems, you \nlose the benefit of separating them at all. Make each subsystem meaningful by restrict-\ning communications. Suppose for example that you define a system with six subsystems, as shown in Fig-\nure 5-3. When there are no rules, the second law of thermodynamics will come into \nplay and the entropy of the system will increase. One way in which entropy increases \nis that, without any restrictions on communications among subsystems, communica-\ntion will occur in an unrestricted way, as in Figure 5-4. Figure 5-3 An example of a system with six subsystems. Figure 5-4 An example of what happens with no restrictions on intersubsystem \ncommunications.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 309, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0310_d1f15cde", "text": "Figure 5-3 An example of a system with six subsystems. Figure 5-4 An example of what happens with no restrictions on intersubsystem \ncommunications. User Interface\nData Storage\nApplication \nLevel Classes\nEnterprise-Level \nTools\nBusiness \nRules\nGraphics\nUser Interface\nData Storage\nApplication \nLevel Classes\nEnterprise-Level \nTools\nBusiness \nRules\nGraphics\n84\nChapter 5: Design in Construction\nAs you can see, every subsystem ends up communicating directly with every other \nsubsystem, which raises some important questions:\n■\nHow many different parts of the system does a developer need to understand at \nleast a little bit to change something in the graphics subsystem? ■\nWhat happens when you try to use the business rules in another system? ■\nWhat happens when you want to put a new user interface on the system, per-\nhaps a command-line UI for test purposes? ■\nWhat happens when you want to put data storage on a remote machine?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 310, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0311_e9de93d5", "text": "■\nWhat happens when you want to put a new user interface on the system, per-\nhaps a command-line UI for test purposes? ■\nWhat happens when you want to put data storage on a remote machine? You might think of the lines between subsys tems as being hoses with water running \nthrough them. If you want to reach in and pull out a subsystem, that subsystem is \ngoing to have some hoses attached to it. The more hoses you have to disconnect and \nreconnect, the more wet you’re going to get. You want to architect your system so that \nif you pull out a subsystem to use elsewher e, you won’t have many hoses to reconnect \nand those hoses will reconnect easily. With forethought, all of these issues can be addressed with little extra work. Allow \ncommunication between subsystems only on a “need to know” basis—and it had bet-\nter be a good reason.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 311, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 841}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0312_b638ee7c", "text": "With forethought, all of these issues can be addressed with little extra work. Allow \ncommunication between subsystems only on a “need to know” basis—and it had bet-\nter be a good reason. If in doubt, it’s easier to re strict communication early and relax it \nlater than it is to relax it early and then try to tighten it up after you’ve coded several \nhundred intersubsystem calls. Figure 5-5 shows how a few communication guidelines \ncould change the system depicted in Figure 5-4. Figure 5-5 With a few communication rules, you ca n simplify subsystem interactions sig-\nnificantly. To keep the connections easy to understand and maintain, err on the side of simple \nintersubsystem relations. The simplest relationship is to have one subsystem call rou-\ntines in another. A more involved relationship is to have one subsystem contain \nclasses from another. The most involved re lationship is to have classes in one sub-\nsystem inherit from classes in another.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 312, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0313_bbdc3269", "text": "A more involved relationship is to have one subsystem contain \nclasses from another. The most involved re lationship is to have classes in one sub-\nsystem inherit from classes in another. User Interface\nData Storage\nApplication \nLevel Classes\nEnterprise-Level \nTools\nBusiness \nRules\nGraphics\n5.2 Key Design Concepts 85\nA good general rule is that a system-level di agram like Figure 5-5 should be an acyclic \ngraph. In other words, a program shouldn’t contain any circular relationships in \nwhich Class A uses Class B, Class B uses Class C, and Class C uses Class A. On large programs and families of programs, design at the subsystem level makes a \ndifference. If you believe that your program is small enough to skip subsystem-level \ndesign, at least make the decision to sk ip that level of design a conscious one. Common Subsystems Some kinds of subsystems appear again and again in differ-\nent systems. Here are some of the usual suspects.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 313, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0314_2c0d2947", "text": "Common Subsystems Some kinds of subsystems appear again and again in differ-\nent systems. Here are some of the usual suspects. Cross-Reference For more \non simplifying business logic \nby expressing it in tables, see \nChapter 18, \"Table-Driven \nMethods.\"\nBusiness rules Business rules are the laws, regula tions, policies, and procedures \nthat you encode into a computer system. If you’re writing a payroll system, you \nmight encode rules from the IRS about th e number of allowable withholdings and \nthe estimated tax rate. Additional rules for a payroll system might come from a \nunion contract specifying overtime rates, vacation and holiday pay, and so on.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 314, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 659}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0315_ad7538e5", "text": "Additional rules for a payroll system might come from a \nunion contract specifying overtime rates, vacation and holiday pay, and so on. If \nyou’re writing a program to quote automo bile insurance rates, rules might come \nfrom government regulations on required lia bility coverages, actuarial rate tables, or \nunderwriting restrictions\nUser interface Create a subsystem to isolate user-interface components so that the \nuser interface can evolve without damaging the rest of the program. In most cases, a \nuser-interface subsystem uses several subo rdinate subsystems or classes for the GUI \ninterface, command line interface, menu operations, window management, help sys-\ntem, and so forth. Database access You can hide the implementation de tails of accessing a database so \nthat most of the program doesn’t need to worry about the messy details of manipulat-\ning low-level structures and can deal with the data in terms of how it’s used at the \nbusiness-problem level.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 315, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0316_d9976a5a", "text": "Subsystems that hi de implementation details provide a valu-\nable level of abstraction that reduces a program’s complexity. They centralize data-\nbase operations in one place and reduce the chance of errors in working with the data. They make it easy to change the database design structure without changing most of \nthe program. System dependencies Package operating-system dependencies into a subsystem for \nthe same reason you package hardware dependencies. If you’re developing a pro-\ngram for Microsoft Windows, for example, why limit yourself to the Windows envi-\nronment? Isolate the Windows calls in a Windows-interface subsystem. If you later \nwant to move your program to Mac OS or Linux, all you’ll have to change is the \ninterface subsystem. An interface subsystem can be too extensive for you to imple-\nment on your own, but such subsystems are readily available in any of several com-\nmercial code libraries.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 316, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0317_b5731599", "text": "An interface subsystem can be too extensive for you to imple-\nment on your own, but such subsystems are readily available in any of several com-\nmercial code libraries. 86\nChapter 5: Design in Construction\nLevel 3: Division into Classes\nFurther Reading For a good \ndiscussion of database \ndesign, see Agile Database \nTechniques (Ambler 2003). Design at this level includes identifying al l classes in the system. For example, a data-\nbase-interface subsystem might be further partitioned into data access classes and \npersistence framework classes as well as da tabase metadata. Figure 5-2, Level 3, \nshows how one of Level 2’s subsystems might be divided into classes, and it implies \nthat the other three subsystems shown at Level 2 are also decomposed into classes. Details of the ways in which each class interacts with the rest of the system are also \nspecified as the classes are specified. In pa rticular, the class’s interface is defined.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 317, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0318_1a2d6d9b", "text": "Details of the ways in which each class interacts with the rest of the system are also \nspecified as the classes are specified. In pa rticular, the class’s interface is defined. Overall, the major design activity at this level is making sure that all the subsystems \nhave been decomposed to a level of detail fine enough that you can implement their \nparts as individual classes. Cross-Reference For details \non characteristics of high-\nquality classes, see Chapter \n6, “Working Classes.”\nThe division of subsystems into classes is typically needed on any project that takes \nlonger than a few days. If the project is larg e, the division is clearly distinct from the \nprogram partitioning of Level 2. If the project is very small, you might move directly \nfrom the whole-system view of Level 1 to the classes view of Level 3. Classes vs. Objects A key concept in object-oriented design is the differentiation \nbetween objects and classes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 318, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0319_11ccb56f", "text": "Classes vs. Objects A key concept in object-oriented design is the differentiation \nbetween objects and classes. An object is any specific entity that exists in your pro-\ngram at run time. A class is the static thing you look at in the program listing. An \nobject is the dynamic thing with specific values and attributes you see when you run \nthe program. For example, you could declare a class Person that had attributes of \nname, age, gender, and so on. At run time you would have the objects nancy , hank , \ndiane , tony, and so on—that is, specific instances of the class. If you’re familiar with \ndatabase terms, it’s the same as the distinction between “schema” and “instance.” You \ncould think of the class as the cookie cutter and the object as the cookie. This book \nuses the terms informally and generally refers to classes and objects more or less inter-\nchangeably. Level 4: Division into Routines\nDesign at this level includes dividing each class into routines.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 319, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0320_0d063a20", "text": "Level 4: Division into Routines\nDesign at this level includes dividing each class into routines. The class interface \ndefined at Level 3 will define some of the routines. Design at Level 4 will detail the \nclass’s private routines. When you examine th e details of the routines inside a class, \nyou can see that many routines are simple boxes but a few are composed of hierarchi-\ncally organized routines, which require still more design. The act of fully defining the class’s routines often results in a better understanding of \nthe class’s interface, and that causes corresponding changes to the interface—that is, \nchanges back at Level 3. This level of decomposition and design is of ten left up to the individual programmer, \nand it’s needed on any project that takes more than a few hours. It doesn’t need to be \ndone formally, but it at least needs to be done mentally.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 320, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 876}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0321_31d9e27a", "text": "It doesn’t need to be \ndone formally, but it at least needs to be done mentally. 5.3 Design Building Blocks: Heuristics 87\nLevel 5: Internal Routine Design\nCross-Reference For details \non creating high-quality rou-\ntines, see Chapter 7, “High-\nQuality Routines,” and Chap-\nter 8, “Defensive Program-\nming.”\nDesign at the routine level consists of laying out the detailed functionality of the indi-\nvidual routines. Internal routine design is typically left to the individual programmer \nworking on an individual routine. The design consists of activities such as writing \npseudocode, looking up algorithms in refere nce books, deciding how to organize the \nparagraphs of code in a routine, and wr iting programming-language code. This level \nof design is always done, though someti mes it’s done unconsciously and poorly \nrather than consciously and well. In Figure 5-2, design at this level is marked with a 5.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 321, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0322_41f4b153", "text": "This level \nof design is always done, though someti mes it’s done unconsciously and poorly \nrather than consciously and well. In Figure 5-2, design at this level is marked with a 5. 5.3 Design Building Blocks: Heuristics\nSoftware developers tend to like our answers cut and dried: “Do A, B, and C, and X, Y, \nZ will follow every time.” We take pride in learning arcane sets of steps that produce \ndesired effects, and we become annoyed when instructions don’t work as advertised. This desire for deterministic behavior is highly appropriate to detailed computer pro-\ngramming, where that kind of strict attentio n to detail makes or breaks a program. But \nsoftware design is a much different story. Because design is nondeterministic, skillful a pplication of an effective set of heuristics \nis the core activity in good software desi gn. The following subsections describe a num-\nber of heuristics—ways to think about a design that sometime produce good design \ninsights.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 322, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0323_e5353897", "text": "The following subsections describe a num-\nber of heuristics—ways to think about a design that sometime produce good design \ninsights. You might think of heuristics as the guides for the trials in “trial and error.” \nYou undoubtedly have run across some of these before. Consequently, the following \nsubsections describe each of the heuristics in terms of Software’s Primary Technical \nImperative: managing complexity. Find Real-World Objects\nAsk not first what the system \ndoes; ask WHAT it does it to! —Bertrand Meyer\nThe first and most popular approach to identifying design alternatives is the “by the \nbook” object-oriented approach, which focu ses on identifying real-world and syn-\nthetic objects. The steps in designing with objects are\nCross-Reference For more \ndetails on designing using \nclasses, see Chapter 6, \n“Working Classes.”■\nIdentify the objects and their attributes (methods and data). ■\nDetermine what can be done to each object.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 323, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0324_6b035d3b", "text": "■\nDetermine what can be done to each object. ■\nDetermine what each object is allowed to do to other objects. ■\nDetermine the parts of each object that will be visible to other objects—which \nparts will be public and which will be private. ■\nDefine each object’s public interface. 88\nChapter 5: Design in Construction\nThese steps aren’t necessarily performed in order, and they’re often repeated. Iteration \nis important. Each of these steps is summarized below. Identify the objects and their attributes Computer programs are usually based on \nreal-world entities. For example, you could base a time-billing system on real-world \nemployees, clients, timecards, and bills. Figu re 5-6 shows an object-oriented view of \nsuch a billing system. Figure 5-6 This billing system is composed of four major objects. The objects have been \nsimplified for this example. Identifying the objects’ attributes is no mo re complicated than identifying the objects \nthemselves.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 324, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0325_a0744f72", "text": "The objects have been \nsimplified for this example. Identifying the objects’ attributes is no mo re complicated than identifying the objects \nthemselves. Each object has characteristics that are relevant to the computer program. For example, in the time-billing system, an employee object has a name, a title, and a \nbilling rate. A client object has a name, a bill ing address, and an account balance. A bill \nobject has a billing amount, a client name, a billing date, and so on. Objects in a graphical user interface syst em would include windows, dialog boxes, \nbuttons, fonts, and drawing tools. Furthe r examination of the problem domain might \nproduce better choices for software objects than a one-to-one mapping to real-world \nobjects, but the real-world objects are a good place to start. Determine what can be done to each object A variety of operations can be per-\nformed on each object.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 325, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0326_1d8341ff", "text": "Determine what can be done to each object A variety of operations can be per-\nformed on each object. In the billing system shown in Figure 5-6, an employee object \ncould have a change in title or billing rate, a client object could have its name or billing \naddress changed, and so on. Determine what each ob ject is allowed to do to other objects This step is just what it \nsounds like. The two generic things objects can do to each other are containment and \ninheritance. Which objects can contain which other objects? Which objects can inherit \nEmployee\nname\ntitle\nbillingRate\nbillingEmployee\nbillingRecordsclientToBillclientToBill\nbills\nGetHoursForMonth()\n... Client\nname\nbillingAddress\naccountBalance\ncurrentBillingAmount\nEnterPayment()\n... Timecard\nhours\ndate\nprojectCode11 1\n**\n* 0..1*\n... Bill\nbillDate\nBillForClient()\n... 5.3 Design Building Blocks: Heuristics 89\nfrom which other objects?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 326, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 898}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0327_6b18657e", "text": "Timecard\nhours\ndate\nprojectCode11 1\n**\n* 0..1*\n... Bill\nbillDate\nBillForClient()\n... 5.3 Design Building Blocks: Heuristics 89\nfrom which other objects? In Figure 5-6, a timecard object can contain an employee \nobject and a client object, and a bill can co ntain one or more timecards. In addition, a \nbill can indicate that a client has been bi lled, and a client can enter payments against \na bill. A more complicated system wo uld include additional interactions. Cross-Reference For details \non classes and information \nhiding, see “Hide Secrets \n(Information Hiding)” in \nSection 5.3. Determine the parts of each object th at will be visible to other objects One of the key \ndesign decisions is iden tifying the parts of an object that should be made public and those \nthat should be kept private. This decision has to be made for both data and methods. Define each object’s interfaces Define the formal, syntactic, programming-language-\nlevel interfaces to each object.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 327, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0328_1278af24", "text": "This decision has to be made for both data and methods. Define each object’s interfaces Define the formal, syntactic, programming-language-\nlevel interfaces to each object. The data and methods the object exposes to every other \nobject is called the object’s “public interface. ” The parts of the object that it exposes to \nderived objects via inheritance is called the object’s “protected interface.” Think about \nboth kinds of interfaces. When you finish going through the steps to achieve a top-level object-oriented system \norganization, you’ll iterate in two ways. You’ll iterate on the top-level system organiza-\ntion to get a better organization of classes. You’ll also iterate on each of the classes \nyou’ve defined, driving the design of each class to a more detailed level. Form Consistent Abstractions\nAbstraction is the ability to engage with a concept while safely ignoring some of its \ndetails—handling different details at different levels.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 328, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 955}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0329_ef62441d", "text": "Form Consistent Abstractions\nAbstraction is the ability to engage with a concept while safely ignoring some of its \ndetails—handling different details at different levels. Any time you work with an aggre-\ngate, you’re working with an abstraction. If you refer to an object as a “house” rather \nthan a combination of glass, wood, and nails, you’re making an abstraction. If you \nrefer to a collection of houses as a “t own,” you’re making another abstraction. Base classes are abstractions that allow you to focus on common attributes of a set of \nderived classes and ignore the details of th e specific classes while you’re working on \nthe base class. A good class interface is an abstraction that allows you to focus on the \ninterface without needing to worry about the internal workings of the class.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 329, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 802}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0330_ee76e8e4", "text": "A good class interface is an abstraction that allows you to focus on the \ninterface without needing to worry about the internal workings of the class. The inter-\nface to a well-designed routine provides the same benefit at a lower level of detail, and \nthe interface to a well-designed package or su bsystem provides that benefit at a higher \nlevel of detail. From a complexity point of view, the principa l benefit of abstraction is that it allows \nyou to ignore irrelevant details. Most real-world objects are already abstractions of \nsome kind. As just mentioned, a house is an abstraction of windows, doors, siding, \nwiring, plumbing, insulation, and a particular way of organizing them. A door is in \nturn an abstraction of a particular arrangem ent of a rectangular piece of material with \nhinges and a doorknob. And the doorknob is an abstraction of a particular formation \nof brass, nickel, iron, or steel. 90\nChapter 5: Design in Construction\nPeople use abstraction continuously.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 330, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0331_4ea09c5e", "text": "And the doorknob is an abstraction of a particular formation \nof brass, nickel, iron, or steel. 90\nChapter 5: Design in Construction\nPeople use abstraction continuously. If you had to deal with individual wood fibers, \nvarnish molecules, and steel molecules every time you used your front door, you’d \nhardly make it in or out of your house each day. As Figure 5-7 suggests, abstraction is \na big part of how we deal with complexity in the real world. Figure 5-7 Abstraction allows you to take a simpler view of a complex concept. Cross-Reference For more \ndetails on abstraction in \nclass design, see “Good \nAbstraction” in Section 6.2. Software developers sometimes build syst ems at the wood-fiber, varnish-molecule, \nand steel-molecule level. This makes the systems overly complex and intellectually \nhard to manage. When programmers fail to provide larger programming abstractions, \nthe system itself sometimes fails to make it through the front door.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 331, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0332_8c4a3a4f", "text": "When programmers fail to provide larger programming abstractions, \nthe system itself sometimes fails to make it through the front door. Good programmers create abstractions at th e routine-interface level, class-interface \nlevel, and package-interface level—in other wo rds, the doorknob level, door level, and \nhouse level—and that supports faster and safer programming. Encapsulate Implementation Details\nEncapsulation picks up where abstraction leaves off. Abstraction says, “You’re allowed \nto look at an object at a high level of detail.” Encapsulation says, “Furthermore, you \naren’t allowed to look at an object at any other level of detail.” \nContinuing with the housing-materials analog y: encapsulation is a way of saying that \nyou can look at the outside of the house bu t you can’t get close enough to make out \nthe door’s details.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 332, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 843}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0333_ee86d6ee", "text": "You are allowed to know that there’s a door, and you’re allowed to \nknow whether the door is open or closed, but you’re not allowed to know whether the \ndoor is made of wood, fiberglass, steel, or some other material, and you’re certainly \nnot allowed to look at each individual wood fiber. As Figure 5-8 suggests, encapsulation helps to manage complexity by forbidding you \nto look at the complexity. The section titled “Good Encapsulation” in Section 6.2 pro-\nvides more background on encapsulat ion as it applies to class design. 5.3 Design Building Blocks: Heuristics 91\nFigure 5-8 Encapsulation says that, not only are you allowed to take a simpler view of a \ncomplex concept, you are not allowed to look at any of the details of the complex concept. What you see is what yo u get—it’s all you get! Inherit—When Inheritance Simplifies the Design\nIn designing a software system, you’ll ofte n find objects that are much like other \nobjects, except for a few differences.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 333, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0334_5172a211", "text": "Inherit—When Inheritance Simplifies the Design\nIn designing a software system, you’ll ofte n find objects that are much like other \nobjects, except for a few differences. In an accounting system, for instance, you might \nhave both full-time and part-time employees. Most of the data associated with both \nkinds of employees is the same, but some is different. In object-oriented program-\nming, you can define a general type of employee and then define full-time employees \nas general employees, except for a few differences, and part-time employees also as \ngeneral employees, except for a few differences. When an operation on an employee \ndoesn’t depend on the type of employee, the operation is handled as if the employee \nwere just a general employee. When the operation depends on whether the employee \nis full-time or part-time, the operation is handled differently.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 334, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 872}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0335_4da58403", "text": "When the operation depends on whether the employee \nis full-time or part-time, the operation is handled differently. Defining similarities and differences am ong such objects is called “inheritance” \nbecause the specific part-time and full-time employees inherit characteristics from the \ngeneral-employee type. The benefit of inheritance is that it works synergistically with th e notion of abstrac-\ntion. Abstraction deals with objects at differ ent levels of detail. Recall the door that \nwas a collection of certain kinds of molecule s at one level, a collection of wood fibers \nat the next, and something that keeps burglars out of your house at the next level. Wood has certain properties—for example, yo u can cut it with a saw or glue it with \nwood glue—and two-by-fours or cedar shingles have the general properties of wood as \nwell as some specific properties of their own.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 335, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 883}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0336_e788cf92", "text": "Inheritance simplifies programming because you write a general routine to handle \nanything that depends on a door’s general properties and then write specific routines \nto handle specific operations on specific kinds of doors. Some operations, such as \n\n92\nChapter 5: Design in Construction\nOpen() or Close() , might apply regardless of whether the door is a solid door, interior \ndoor, exterior door, screen door, French door, or sliding glass door. The ability of a \nlanguage to support operations like Open() or Close() without knowing until run time \nwhat kind of door you’re dealing with is called “polymorphism.” Object-oriented lan-\nguages such as C++, Java, and later versions of Microsoft Visual Basic support inherit-\nance and polymorphism. Inheritance is one of object-oriented prog ramming’s most powerful tools. It can pro-\nvide great benefits when used well, and it can do great damage when used naively. For \ndetails, see “Inheritance (“is a” Relationships)” in Section 6.3.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 336, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0337_9add8cf0", "text": "It can pro-\nvide great benefits when used well, and it can do great damage when used naively. For \ndetails, see “Inheritance (“is a” Relationships)” in Section 6.3. Hide Secrets (Information Hiding)\nInformation hiding is part of the foundation of both stru ctured design and object-ori-\nented design. In structured design, the notion of “black boxes” comes from informa-\ntion hiding. In object-oriented design, it gi ves rise to the concepts of encapsulation \nand modularity and it is associated with the concept of abstraction. Information hid-\ning is one of the seminal ideas in softwa re development, and so this subsection \nexplores it in depth. Information hiding first came to public at tention in a paper published by David Par-\nnas in 1972 called “On the Criteria to Be Used in Decomposing Systems Into Mod-\nules.” Information hiding is characterize d by the idea of “secrets,” design and \nimplementation decisions that a software developer hides in one place from the rest of \na program.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 337, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0338_75852af6", "text": "In the 20th Anniversary edition of The Mythical Man Month , Fred Brooks concluded \nthat his criticism of information hiding was one of the few ways in which the first edi-\ntion of his book was wrong. “Parnas was right, and I was wrong about information \nhiding,” he proclaimed (Brooks 1995). Barry Boehm reported that information hiding \nwas a powerful technique for eliminating re work, and he pointed out that it was par-\nticularly effective in incremental, high-change environments (Boehm 1987). Information hiding is a particularly powerf ul heuristic for Software’s Primary Techni-\ncal Imperative because, beginning with its name and throughout its details, it empha-\nsizes hiding complexity . Secrets and the Right to Privacy\nIn information hiding, each class (or package or routine) is characterized by the \ndesign or construction decisions that it hi des from all other classes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 338, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0339_a5987b3d", "text": "Secrets and the Right to Privacy\nIn information hiding, each class (or package or routine) is characterized by the \ndesign or construction decisions that it hi des from all other classes. The secret might \nbe an area that’s likely to change, the format of a file, the way a data type is imple-\nmented, or an area that needs to be walled off from the rest of the program so that \nerrors in that area cause as little damage as possible. The class’s job is to keep this \ninformation hidden and to protect its own right to privacy. Minor changes to a system \n5.3 Design Building Blocks: Heuristics 93\nmight affect several routines within a cla ss, but they should no t ripple beyond the \nclass interface. Strive for class interfaces \nthat are complete and mini-\nmal. —Scott Meyers\nOne key task in designing a class is decidi ng which features should be known outside \nthe class and which should remain secret. A class might use 25 routines and expose \nonly 5 of them, using the other 20 internally.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 339, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0340_78c4ce60", "text": "A class might use 25 routines and expose \nonly 5 of them, using the other 20 internally. A class might use several data types and \nexpose no information about them. This aspect of class design is also known as “visi-\nbility” since it has to do with which features of the class are “visible” or “exposed” out-\nside the class. The interface to a class should reveal as li ttle as possible about its inner workings. As \nshown in Figure 5-9, a class is a lot like an iceberg: seven-eighths is under water, and \nyou can see only the one-eighth that’s above the surface. Figure 5-9 A good class interface is like the tip of an iceberg, leaving most of the class \nunexposed. Designing the class interface is an iterative process just like any other aspect of design. If you don’t get the interface right the first ti me, try a few more times until it stabilizes. If it doesn’t stabilize, you need to try a different approach.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 340, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0341_d0d2cd63", "text": "If you don’t get the interface right the first ti me, try a few more times until it stabilizes. If it doesn’t stabilize, you need to try a different approach. An Example of Information Hiding\nSuppose you have a program in which each object is supposed to have a unique ID \nstored in a member variable called id. One design approach would be to use integers \nfor the IDs and to store the highest ID assi gned so far in a global variable called \ng_maxId . As each new object is allocated, perhaps in each object’s constructor, you \ncould simply use the id = ++g_maxId statement, which would guarantee a unique id, \nand it would add the absolute minimum of co de in each place an object is created. What could go wrong with that? 94\nChapter 5: Design in Construction\nA lot of things could go wrong. What if yo u want to reserve ranges of IDs for special \npurposes? What if you want to use nonsequential IDs to improve security? What if you \nwant to be able to reuse the IDs of objects that have been destroyed?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 341, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1007}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0342_b9026eb5", "text": "What if you want to use nonsequential IDs to improve security? What if you \nwant to be able to reuse the IDs of objects that have been destroyed? What if you want \nto add an assertion that fires when you allocate more IDs than the maximum number \nyou’ve anticipated? If you allocated IDs by spreading id = ++g_maxId statements \nthroughout your program, you would have to change code associated with every one \nof those statements. And, if your program is multithreaded, this approach won’t be \nthread-safe. The way that new IDs are created is a design decision that you should hide. If you use \nthe phrase ++g_maxId throughout your program, you expose the way a new ID is cre-\nated, which is simply by incrementing g_maxId . If instead you put the id = NewId() \nstatement throughout your program, you hide the information about how new IDs are \ncreated.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 342, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 853}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0343_9467ff24", "text": "If instead you put the id = NewId() \nstatement throughout your program, you hide the information about how new IDs are \ncreated. Inside the NewId() routine you might still have just one line of code, return \n( ++g_maxId ) or its equivalent, but if you later decide to reserve certain ranges of IDs \nfor special purposes or to reuse old IDs, you could make those changes within the \nNewId() routine itself—without touching dozens or hundreds of id = NewId() state-\nments. No matter how complicated the revisions inside NewId() might become, they \nwouldn’t affect any other part of the program. Now suppose you discover you need to change the type of the ID from an integer to a \nstring. If you’ve spread variable declarations like int id throughout your program, your \nuse of the NewId() routine won’t help. You’ll still have to go through your program \nand make dozens or hundreds of changes. An additional secret to hide is the ID’s type.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 343, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0344_d1e15815", "text": "You’ll still have to go through your program \nand make dozens or hundreds of changes. An additional secret to hide is the ID’s type. By exposing the fact that IDs are inte-\ngers, you encourage programmers to perform integer operations like >, <, = on them. In C++, you could use a simple typedef to declare your IDs to be of IdType —a user-\ndefined type that resolves to int—rather than directly decl aring them to be of type \nint. Alternatively, in C++ and other languages you could create a simple IdType class. Once again, hiding a design decision makes a huge difference in the amount of code \naffected by a change. Information hiding is useful at all levels of design, from the use of named constants \ninstead of literals, to creation of data ty pes, to class design, routine design, and sub-\nsystem design.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 344, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 812}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0345_8bb6b01a", "text": "Information hiding is useful at all levels of design, from the use of named constants \ninstead of literals, to creation of data ty pes, to class design, routine design, and sub-\nsystem design. Two Categories of Secrets\nSecrets in information hiding fall into two general camps:\n■\nHiding complexity so that your brain does n’t have to deal with it unless you’re \nspecifically concerned with it\n■\nHiding sources of change so that when change occurs, the effects are localized\nKEY POINT\n5.3 Design Building Blocks: Heuristics 95\nSources of complexity include complicated data types, file structures, boolean tests, \ninvolved algorithms, and so on. A comprehensiv e list of sources of change is described \nlater in this chapter. Barriers to Information Hiding\nFurther Reading Parts of \nthis section are adapted \nfrom “Designing Software \nfor Ease of Extension and \nContraction” (Parnas 1979).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 345, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0346_b8d28ef3", "text": "Barriers to Information Hiding\nFurther Reading Parts of \nthis section are adapted \nfrom “Designing Software \nfor Ease of Extension and \nContraction” (Parnas 1979). In a few instances, information hiding is truly impossible, but most of the barriers to \ninformation hiding are mental blocks built up from the habitual use of other techniques. Excessive distribution of information One common barrier to information hiding is \nan excessive distribution of information throughout a system. You might have hard-\ncoded the literal 100 throughout a system. Using 100 as a literal decentralizes refer-\nences to it. It’s better to hide the information in one place, in a constant \nMAX_EMPLOYEES perhaps, whose value is changed in only one place. Another example of excessive information dist ribution is interleavi ng interaction with \nhuman users throughout a system. If the mo de of interaction changes—say, from a \nGUI interface to a command line interface—virtually all the code will have to be mod-\nified.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 346, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0347_3c83ca8f", "text": "If the mo de of interaction changes—say, from a \nGUI interface to a command line interface—virtually all the code will have to be mod-\nified. It’s better to concentrate user interaction in a single class, package, or subsystem \nyou can change without affecting the whole system. Cross-Reference For more \non accessing global data \nthrough class interfaces, see \n“Using Access Routines \nInstead of Global Data” in \nSection 13.3. Yet another example would be a global data element—perhaps an array of employee \ndata with 1000 elements maximum that’s accessed throughout a program. If the pro-\ngram uses the global data directly, info rmation about the data item’s implementa-\ntion—such as the fact that it’s an array and has a maximum of 1000 elements—will be \nspread throughout the program. If the program uses the data only through access rou-\ntines, only the access routines will know the implementation details.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 347, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 913}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0348_9ea0dba0", "text": "If the program uses the data only through access rou-\ntines, only the access routines will know the implementation details. Circular dependencies A more subtle barrier to inform ation hiding is circular depen-\ndencies, as when a routine in class A calls a routine in class B, and a routine in class B \ncalls a routine in class A. Avoid such dependency loops. They make it hard to test a system because you can’t \ntest either class A or class B until at least part of the other is ready. Class data mistaken for global data If you’re a conscientious programmer, one of \nthe barriers to effective information hiding might be thinking of class data as global \ndata and avoiding it because you want to avoid the problems associated with global \ndata. While the road to programming hell is paved with global variables, class data \npresents far fewer risks.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 348, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 851}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0349_6e613b0e", "text": "While the road to programming hell is paved with global variables, class data \npresents far fewer risks. Global data is generally subject to two proble ms: routines operate on global data without \nknowing that other routines are operating on it, and routines are aware that other rou-\ntines are operating on the global data but they don’t know exactly what they’re doing to \nit. Class data isn’t subject to either of these problems. Direct access to the data is \nrestricted to a few routines organized into a si ngle class. The routines are aware that other \nroutines operate on the data, and they know exactly which other routines they are. 96\nChapter 5: Design in Construction\nOf course, this whole discussion assume s that your system makes use of well-\ndesigned, small classes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 349, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 781}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0350_93bc18be", "text": "96\nChapter 5: Design in Construction\nOf course, this whole discussion assume s that your system makes use of well-\ndesigned, small classes. If your program is designed to use huge classes that contain \ndozens of routines each, the distinction betw een class data and global data will begin \nto blur and class data will be subject to many of the same problems as global data. Cross-Reference Code-level \nperformance optimizations \nare discussed in Chapter 25, \n“Code-Tuning Strategies” \nand Chapter 26, “Code-Tun-\ning Techniques.”\nPerceived performance penalties A final barrier to information hiding can be an \nattempt to avoid performance penalties at both the architectural and the coding levels. You don’t need to worry at either level. At the architectural level, the worry is unnec-\nessary because architecting a system for information hiding doesn’t conflict with \narchitecting it for performance. If you keep both information hiding and performance \nin mind, you can achieve both objectives.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 350, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0351_a9ef1191", "text": "If you keep both information hiding and performance \nin mind, you can achieve both objectives. The more common worry is at the coding level. The concern is that accessing data \nitems indirectly incurs run-time performance penalties for additional levels of object \ninstantiations, routine calls, and so on. This concern is premature. Until you can mea-\nsure the system’s performance and pinpoint the bottlenecks, the best way to prepare \nfor code-level performance work is to cr eate a highly modular design. When you \ndetect hot spots later, you ca n optimize individual classes and routines without affect-\ning the rest of the system. Value of Information Hiding\nInformation hiding is one of the few theoretical techniques that has indisputably proven \nits value in practice, which has been true for a long time (Boehm 1987a). Large pro-\ngrams that use information hiding were found years ago to be easier to modify—by a fac-\ntor of 4—than programs that don’t (Korson and Vaishnavi 1986).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 351, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 990}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0352_48188cef", "text": "Large pro-\ngrams that use information hiding were found years ago to be easier to modify—by a fac-\ntor of 4—than programs that don’t (Korson and Vaishnavi 1986). Moreover, information \nhiding is part of the foundation of both structured design and object-oriented design. Information hiding has unique heuristic powe r, a unique ability to inspire effective \ndesign solutions. Traditional object-oriente d design provides the heuristic power of \nmodeling the world in objects, but object thinking wouldn’t help you avoid declaring \nthe ID as an int instead of an IdType . The object-oriented desi gner would ask, “Should \nan ID be treated as an object?” Depending on the project’s coding standards, a “Yes” \nanswer might mean that the programmer has to write a constructor, destructor, copy \noperator, and assignment operator; comment it all; and place it under configuration \ncontrol. Most programmers would decide, “No, it isn’t worth creating a whole class \njust for an ID.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 352, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0353_92537968", "text": "Most programmers would decide, “No, it isn’t worth creating a whole class \njust for an ID. I’ll just use ints.” \nNote what just happened. A useful design al ternative, that of simply hiding the ID’s \ndata type, was not even considered. If, inst ead, the designer had asked, “What about \nthe ID should be hidden?” he might well have decided to hide its type behind a simple \ntype declaration that substitutes IdType for int. The difference between object-oriented \ndesign and information hiding in this exampl e is more subtle than a clash of explicit \nrules and regulations. Object-oriented design would approve of this design decision \nas much as information hiding would. Rather, the difference is one of heuristics—\n1\n23\nHARD DATA\n5.3 Design Building Blocks: Heuristics 97\nthinking about information hiding inspires and promotes design decisions that think-\ning about objects does not. Information hiding can also be useful in de signing a class’s public interface.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 353, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0354_4ef4cf74", "text": "Information hiding can also be useful in de signing a class’s public interface. The gap \nbetween theory and practice in class design is wide, and among many class designers \nthe decision about what to put into a cl ass’s public interface amounts to deciding \nwhat interface would be the most convenient to use, which usually results in exposing \nas much of the class as possible. From what I’ve seen, some programmers would \nrather expose all of a class’s private data th an write 10 extra lines of code to keep the \nclass’s secrets intact. Asking “What does this class need to hide?” cuts to the heart of the interface-design \nissue. If you can put a function or data into the class’s public interface without com-\npromising its secrets, do. Otherwise, don’t. Asking about what needs to be hidden supports good design decisions at all levels. It \npromotes the use of named constants instead of literals at the construction level. It \nhelps in creating good routine and parameter names inside classes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 354, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0355_b2ae33e4", "text": "It \npromotes the use of named constants instead of literals at the construction level. It \nhelps in creating good routine and parameter names inside classes. It guides decisions \nabout class and subsystem decompositions an d interconnections at the system level. Get into the habit of asking “What should I hide?” You’ll be surprised at how many dif-\nficult design issues dissolve before your eyes. Identify Areas Likely to Change\nFurther Reading The \napproach described in this \nsection is adapted from \n“Designing Software for Ease \nof Extension and Contrac-\ntion” (Parnas 1979). A study of great designers found that one a ttribute they had in common was their abil-\nity to anticipate change (Glass 1995). Accommodating changes is one of the most \nchallenging aspects of good program design. The goal is to isolate unstable areas so \nthat the effect of a change will be limited to one routine, class, or package. Here are the \nsteps you should follow in prep aring for such perturbations. 1.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 355, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0356_c24b40c5", "text": "The goal is to isolate unstable areas so \nthat the effect of a change will be limited to one routine, class, or package. Here are the \nsteps you should follow in prep aring for such perturbations. 1. Identify items that seem likely to change. If the requirements have been done \nwell, they include a list of potential changes and the likelihood of each change. In such a case, identifying the likely ch anges is easy. If the requirements don’t \ncover potential changes, see th e discussion that follows of areas that are likely to \nchange on any project. 2. Separate items that are likely to change. Compartmentalize each volatile com-\nponent identified in step 1 into its own class or into a class with other volatile \ncomponents that are likely to change at the same time. 3. Isolate items that seem likely to change. Design the interclass interfaces to be \ninsensitive to the potential changes. Design the interfaces so that changes are \nlimited to the inside of the class and the outside remains unaffected.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 356, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1011}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0357_2e0ad019", "text": "Design the interclass interfaces to be \ninsensitive to the potential changes. Design the interfaces so that changes are \nlimited to the inside of the class and the outside remains unaffected. Any other \nclass using the changed class should be unaware that the change has occurred. The class’s interface shou ld protect its secrets. KEY POINT\n98\nChapter 5: Design in Construction\nHere are a few areas that are likely to change:\nCross-Reference One of the \nmost powerful techniques \nfor anticipating change is to \nuse table-driven methods. For details, see Chapter 18, \n“Table-Driven Methods. ” \nBusiness rules Business rules tend to be the source of frequent software changes. Congress changes the tax structure, a union renegotiates its contract, or an insurance \ncompany changes its rate tables. If you fo llow the principle of information hiding, \nlogic based on these rules won’t be strewn throughout your program.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 357, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0358_b814ab89", "text": "If you fo llow the principle of information hiding, \nlogic based on these rules won’t be strewn throughout your program. The logic will \nstay hidden in a single dark corner of the system until it needs to be changed. Hardware dependencies Examples of hardware dependencies include interfaces to \nscreens, printers, keyboards, mice, disk drives, sound fa cilities, and communications \ndevices. Isolate hardware dependencies in their own subsystem or class. Isolating \nsuch dependencies helps when you move the program to a new hardware environ-\nment. It also helps initially when you’re developing a program for volatile hardware. You can write software that simulates interaction with specific hardware, have the \nhardware-interface subsystem use the simulator as long as the hardware is unstable or \nunavailable, and then unplug the hardware -interface subsystem from the simulator \nand plug the subsystem into the hardware when it’s ready to use.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 358, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0359_46aa8392", "text": "Input and output At a slightly higher level of design than raw hardware interfaces, \ninput/output is a volatile area. If your application creates its own data files, the file for-\nmat will probably change as your applicatio n becomes more sophisticated. User-level \ninput and output formats will also change—t he positioning of fields on the page, the \nnumber of fields on each page, the sequence of fields, and so on. In general, it’s a good \nidea to examine all external interfaces for possible changes. Nonstandard language features Most language implementations contain handy, \nnonstandard extensions. Using the extensions is a double-edged sword because they \nmight not be available in a different envi ronment, whether the different environment \nis different hardware, a different vendor’s implementation of the language, or a new \nversion of the language from the same vendor.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 359, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 883}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0360_b3f4a9f7", "text": "If you use nonstandard extensions to your programming language, hide those exten-\nsions in a class of their own so that you can replace them with your own code when \nyou move to a different environment. Likewise, if you use library routines that aren’t \navailable in all environments, hide the actual library routines behind an interface that \nworks just as well in another environment. Difficult design and construction areas It’s a good idea to hide difficult design and \nconstruction areas because they might be do ne poorly and you might need to do them \nagain. Compartmentalize them and minimize the impact their bad design or construc-\ntion might have on the rest of the system. Status variables Status variables indicate the state of a program and tend to be \nchanged more frequently than most other da ta.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 360, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 813}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0361_fef6358d", "text": "Status variables Status variables indicate the state of a program and tend to be \nchanged more frequently than most other da ta. In a typical scenario, you might origi-\nnally define an error-status variable as a boolean variable and decide later that it \n5.3 Design Building Blocks: Heuristics 99\nwould be better implemented as an enumerated type with the values ErrorType_None , \nErrorType_Warning , and ErrorType_Fatal . You can add at least two levels of flexibility and readability to your use of status vari-\nables:\n■\nDon’t use a boolean variable as a status variable. Use an enumerated type \ninstead. It’s common to add a new state to a status variable, and adding a new \ntype to an enumerated type requires a mere recompilation rather than a major \nrevision of every line of code that checks the variable. ■\nUse access routines rather than checking the variable directly. By checking the \naccess routine rather than the variable, you allow for the possibility of more \nsophisticated state detection.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 361, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0362_d5437108", "text": "■\nUse access routines rather than checking the variable directly. By checking the \naccess routine rather than the variable, you allow for the possibility of more \nsophisticated state detection. For example, if you wanted to check combinations \nof an error-state variable and a current-f unction-state variable, it would be easy \nto do if the test were hidden in a routine and hard to do if it were a complicated \ntest hard-coded throughout the program. Data-size constraints When you declare an array of size 100, you’re exposing infor-\nmation to the world that the world doesn’t n eed to see. Defend your right to privacy! Information hiding isn’t always as complicated as a whole class. Sometimes it’s as sim-\nple as using a named constant such as MAX_EMPLOYEES to hide a 100. Anticipating Different Degrees of Change\nCross-Reference This sec-\ntion’s approach to anticipat-\ning change does not involve \ndesigning ahead or coding \nahead.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 362, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0363_5e3fa10c", "text": "Anticipating Different Degrees of Change\nCross-Reference This sec-\ntion’s approach to anticipat-\ning change does not involve \ndesigning ahead or coding \nahead. For a discussion of \nthose practices, see “A pro-\ngram contains code that \nseems like it might be needed \nsomeday” in Section 24.2. When thinking about potential changes to a system, design the system so that the \neffect or scope of the change is proportional to the chance that the change will occur. If a change is likely, make sure that th e system can accommodate it easily. Only \nextremely unlikely changes should be allowe d to have drastic consequences for more \nthan one class in a system. Good designers also factor in the cost of anticipating \nchange. If a change is not terribly likely bu t easy to plan for, you should think harder \nabout anticipating it than if it isn’t ve ry likely and is difficult to plan for.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 363, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0364_cf9c1b9c", "text": "If a change is not terribly likely bu t easy to plan for, you should think harder \nabout anticipating it than if it isn’t ve ry likely and is difficult to plan for. Further Reading This dis-\ncussion draws on the \napproach described in “On \nthe design and development \nof program families” (Parnas \n1976). A good technique for identifying areas likely to change is first to identify the minimal \nsubset of the program that might be of use to the user. The subset makes up the core \nof the system and is unlikely to change. Next, define minimal increments to the sys-\ntem. They can be so small that they seem tr ivial. As you consider functional changes, \nbe sure also to consider qualitative changes: making the program thread-safe, making \nit localizable, and so on. These areas of potential improvement constitute potential \nchanges to the system; design these areas us ing the principles of information hiding.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 364, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 912}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0365_acb2d6eb", "text": "These areas of potential improvement constitute potential \nchanges to the system; design these areas us ing the principles of information hiding. By identifying the core first, you can see which components are really add-ons and \nthen extrapolate and hide improvements from there. 100\nChapter 5: Design in Construction\nKeep Coupling Loose\nCoupling describes how tightly a class or ro utine is related to other classes or rou-\ntines. The goal is to create classes and routin es with small, direct, visible, and flexible \nrelations to other classes and routines, wh ich is known as “loose coupling.” The con-\ncept of coupling applies equally to classes an d routines, so for the rest of this discus-\nsion I’ll use the word “module” to refer to both classes and routines. Good coupling between modules is loose enou gh that one module can easily be used \nby other modules. Model railroad cars are coupled by opposing hooks that latch \nwhen pushed together.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 365, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0366_2c1c0ef6", "text": "Good coupling between modules is loose enou gh that one module can easily be used \nby other modules. Model railroad cars are coupled by opposing hooks that latch \nwhen pushed together. Connecting two cars is easy—you just push the cars together. Imagine how much more difficult it would be if you had to screw things together, or \nconnect a set of wires, or if you could connect only certain kinds of cars to certain \nother kinds of cars. The coupling of model railroad cars works because it’s as simple \nas possible. In software, make the connect ions among modules as simple as possible. Try to create modules that depend little on other modules. Make them detached, as \nbusiness associates are, rather than attached, as Siamese twins are. A routine like sin() \nis loosely coupled because everything it needs to know is passed in to it with one \nvalue representing an angle in degrees.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 366, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 887}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0367_128c05de", "text": "A routine like sin() \nis loosely coupled because everything it needs to know is passed in to it with one \nvalue representing an angle in degrees. A routine such as InitVars( var 1, var2, var3, ..., \nvarN ) is more tightly coupled because, with al l the variables it must pass, the calling \nmodule practically knows what is happening inside InitVars() . Two classes that \ndepend on each other’s use of the same gl obal data are even more tightly coupled. Coupling Criteria\nHere are several criteria to use in evaluating coupling between modules: \nSize Size refers to the number of connections between modules. With coupling, \nsmall is beautiful because it’s less work to connect other modules to a module that has \na smaller interface. A routine that takes one parameter is more loosely coupled to \nmodules that call it than a routine that ta kes six parameters. A class with four well-\ndefined public methods is more loosely coupled to modules that use it than a class \nthat exposes 37 public methods.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 367, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0368_274be758", "text": "A class with four well-\ndefined public methods is more loosely coupled to modules that use it than a class \nthat exposes 37 public methods. Visibility Visibility refers to the prominen ce of the connection between two mod-\nules. Programming is not like being in the CIA; you don’t get credit for being sneaky. It’s more like advertising; you get lots of credit for making your connections as blatant \nas possible. Passing data in a parameter list is making an obvious connection and is \ntherefore good. Modifying global data so th at another module can use that data is a \nsneaky connection and is therefore bad. Documenting the global-data connection \nmakes it more obvious and is slightly better. Flexibility Flexibility refers to how easily you can change the connections between \nmodules. Ideally, you want something more like the USB connector on your computer \nthan like bare wire and a soldering gun.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 368, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0369_6ab17a1a", "text": "Ideally, you want something more like the USB connector on your computer \nthan like bare wire and a soldering gun. Flexibility is partly a product of the other \n5.3 Design Building Blocks: Heuristics 101\ncoupling characteristics, but it’s a little di fferent too. Suppose you have a routine that \nlooks up the amount of vacation an employee re ceives each year, given a hiring date and \na job classification. Name the routine LookupVacationBenefit() . Suppose in another \nmodule you have an employee object that contains the hiring date and the job classifica-\ntion, among other things, and that module passes the object to LookupVacationBenefit() . From the point of view of the other criteria, the two modules would look loosely cou-\npled. The employee connection between the two modules is visible, and there’s only \none connection.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 369, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 835}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0370_10f9ef73", "text": "From the point of view of the other criteria, the two modules would look loosely cou-\npled. The employee connection between the two modules is visible, and there’s only \none connection. Now suppose that you need to use the LookupVacationBenefit() mod-\nule from a third module that doesn’t have an employee object but that does have a hir-\ning date and a job classification. Suddenly LookupVacationBenefit() looks less friendly, \nunwilling to associate with the new module. For the third module to use LookupVacationBenefit() , it has to know about the \nEmployee class. It could dummy up an employee object with only two fields, but that \nwould require internal knowledge of LookupVacationBenefit() , namely that those are \nthe only fields it uses. Such a solution woul d be a kludge, and an ugly one. The second \noption would be to modify LookupVacationBenefit() so that it would take hiring date \nand job classification instead of employee .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 370, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0371_e27f0499", "text": "Such a solution woul d be a kludge, and an ugly one. The second \noption would be to modify LookupVacationBenefit() so that it would take hiring date \nand job classification instead of employee . In either case, the original module turns out \nto be a lot less flexible than it seemed to be at first. The happy ending to the story is that an unfriendly module can make friends if it’s \nwilling to be flexible—in this case, by changi ng to take hiring da te and job classifica-\ntion specifically instead of employee . In short, the more easily other modules can call a module, the more loosely coupled \nit is, and that’s good because it’s more flex ible and maintainable. In creating a system \nstructure, break up the program along the lines of minimal interconnectedness. If a \nprogram were a piece of wood, you would try to split it with the grain. Kinds of Coupling\nHere are the most common kind s of coupling you’ll encounter.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 371, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0372_8f43c767", "text": "If a \nprogram were a piece of wood, you would try to split it with the grain. Kinds of Coupling\nHere are the most common kind s of coupling you’ll encounter. Simple-data-parameter coupling Two modules are simple-data-parameter coupled if \nall the data passed between them are of prim itive data types and all the data is passed \nthrough parameter lists. This kind of coupling is normal and acceptable. Simple-object coupling A module is simple-object coupled to an object if it instanti-\nates that object. This kind of coupling is fine. Object-parameter coupling Two modules are object-parameter coupled to each \nother if Object1 requires Object2 to pass it an Object3 . This kind of coupling is tighter \nthan Object1 requiring Object2 to pass it only primitive data types because it requires \nObject2 to know about Object3 .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 372, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 825}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0373_3b5a5736", "text": "This kind of coupling is tighter \nthan Object1 requiring Object2 to pass it only primitive data types because it requires \nObject2 to know about Object3 . 102\nChapter 5: Design in Construction\nSemantic coupling The most insidious kind of coup ling occurs when one module \nmakes use not of some syntactic element of another module but of some semantic \nknowledge of another module’s inner workings. Here are some examples:\n■\nModule1 passes a control flag to Module2 that tells Module2 what to do. This \napproach requires Module1 to make assumptions about the internal workings of \nModule2 , namely what Module2 is going to do with the control flag. If Module2 \ndefines a specific data type for the control flag (enumerated type or object), this \nusage is probably OK. ■\nModule2 uses global data after the glob al data has been modified by Module1 .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 373, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 847}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0374_3bf4a73e", "text": "If Module2 \ndefines a specific data type for the control flag (enumerated type or object), this \nusage is probably OK. ■\nModule2 uses global data after the glob al data has been modified by Module1 . This approach requires Module2 to assume that Module1 has modified the data \nin the ways Module2 needs it to be modified, and that Module1 has been called at \nthe right time. ■\nModule1 ’s interface states that its Module1.Initialize() routine should be called \nbefore its Module1.Routine() is called. Module2 knows that Module1.Routine() \ncalls Module1.Initialize() anyway, so it just instantiates Module1 and calls \nModule1.Routine() without calling Module1.Initialize() first. ■\nModule1 passes Object to Module2 . Because Module1 knows that Module2 uses \nonly three of Object ’s seven methods, it initializes Object only partially—with the \nspecific data those three methods need. ■\nModule1 passes BaseObject to Module2 .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 374, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0375_f514ed07", "text": "■\nModule1 passes BaseObject to Module2 . Because Module2 knows that Module1 is \nreally passing it DerivedObject , it casts BaseObject to DerivedObject and calls \nmethods that are specific to DerivedObject . Semantic coupling is dangerous because changing code in the used module can break \ncode in the using module in ways that ar e completely undetectable by the compiler. When code like this breaks, it breaks in su btle ways that seem unrelated to the change \nmade in the used module, which turn s debugging into a Sisyphean task. The point of loose coupling is that an effect ive module provides an additional level of \nabstraction—once you write it, you can take it for granted. It reduces overall program \ncomplexity and allows you to focus on one thing at a time.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 375, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 770}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0376_fb12da70", "text": "It reduces overall program \ncomplexity and allows you to focus on one thing at a time. If using a module requires \nyou to focus on more than one thing at once—knowledge of its internal workings, \nmodification to global data, uncertain func tionality—the abstractive power is lost and \nthe module’s ability to help manage complexity is reduced or eliminated. Classes and routines are first and foremost intellectual tools for reducing complexity. If they’re not making your job simp ler, they’re not doing their jobs. KEY POINT\n5.3 Design Building Blocks: Heuristics 103\nLook for Common Design Patterns\ncc2e.com/0585\nDesign patterns provide the cores of ready-made solutions that can be used to solve \nmany of software’s most co mmon problems. Some software problems require solutions \nthat are derived from first principles. But mo st problems are similar to past problems, \nand those can be solved using similar solutions, or patterns.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 376, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0377_1b16cec4", "text": "Some software problems require solutions \nthat are derived from first principles. But mo st problems are similar to past problems, \nand those can be solved using similar solutions, or patterns. Common patterns include \nAdapter, Bridge, Decorator, Facade, Factory Method, Observor, Singleton, Strategy, and \nTemplate Method. The book Design Patterns by Erich Gamma, Richard Helm, Ralph \nJohnson, and John Vlissides (1995) is the definitive description of design patterns. Patterns provide several benefits that fully custom design doesn’t: \nPatterns reduce complexity by providing ready-made abstractions If you say, “This \ncode uses a Factory Method to create in stances of derived classes,” other program-\nmers on your project will understand that your code involves a fairly rich set of inter-\nrelationships and programming protocols, all of which are invoked when you refer to \nthe design pattern of Factory Method.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 377, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0378_8863527b", "text": "The Factory Method is a pattern that allows you to instantiate any class derived from \na specific base class without needing to ke ep track of the indivi dual derived classes \nanywhere but the Factory Method. For a good discussion of the Factory Method pat-\ntern, see “Replace Constructor with Factory Method” in Refactoring (Fowler 1999). You don’t have to spell out every line of code for other programmers to understand \nthe design approach found in your code. Patterns reduce errors by instituti onalizing details of common solutions Software \ndesign problems contain nuances that emer ge fully only after the problem has been \nsolved once or twice (or three times, or four times, or...). Because patterns represent \nstandardized ways of solv ing common problems, they embody the wisdom accumu-\nlated from years of attempting to solve th ose problems, and they also embody the cor-\nrections to the false attempts that people have made in solving those problems.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 378, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0379_37c391ed", "text": "Using a design pattern is thus conceptually similar to using library code instead of \nwriting your own. Sure, everybody has wri tten a custom Quicksort a few times, but \nwhat are the odds that your custom version wi ll be fully correct on the first try? Simi-\nlarly, numerous design problems are similar enough to past problems that you’re bet-\nter off using a prebuilt design solution than creating a novel solution. Patterns provide heuristic value by suggesting design alternatives A designer who’s \nfamiliar with common patterns can easily run through a list of patterns and ask \n“Which of these patterns fits my design problem?” Cycling through a set of familiar \nalternatives is immeasurably easier than creating a custom design solution out of \nwhole cloth. And the code arising from a familiar pattern will also be easier for readers \nof the code to understand than fully custom code would be.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 379, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0380_c3ecb1a8", "text": "And the code arising from a familiar pattern will also be easier for readers \nof the code to understand than fully custom code would be. 104\nChapter 5: Design in Construction\nPatterns streamline communication by mov ing the design dialog to a higher level In \naddition to their complexity-management benefit, design patterns can accelerate \ndesign discussions by allowing designers to think and discuss at a larger level of gran-\nularity. If you say “I can’t decide whether I should use a Creator or a Factory Method \nin this situation,” you’ve communicated a great deal with just a few words—as long as \nyou and your listener are both familiar wi th those patterns. Imagine how much longer \nit would take you to dive into the details of the code for a Creator pattern and the code \nfor a Factory Method pattern and then co mpare and contrast the two approaches. If you’re not already familiar with design patterns, Table 5-1 summarizes some of the \nmost common patterns to stimulate your interest.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 380, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0381_4fb20929", "text": "If you’re not already familiar with design patterns, Table 5-1 summarizes some of the \nmost common patterns to stimulate your interest. If you haven’t seen design patterns before, yo ur reaction to the descriptions in Table 5-\n1 might be “Sure, I already know most of th ese ideas.” That reaction is a big part of \nwhy design patterns are valuable. Patterns are familiar to most experienced program-\nmers, and assigning recognizable names to them supports efficient and effective com-\nmunication about them. Table 5-1\nPopular Design Patterns\nPattern\nDescription\nAbstract Factory Supports creation of sets of related objects by specifying the kind \nof set but not the kinds of each specific object. Adapter Converts the interface of a class to a different interface. Bridge Builds an interface and an implementation in such a way that \neither can vary without the other varying.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 381, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0382_fb51f47c", "text": "Adapter Converts the interface of a class to a different interface. Bridge Builds an interface and an implementation in such a way that \neither can vary without the other varying. Composite Consists of an object that contains additional objects of its own \ntype so that client code can interact with the top-level object and \nnot concern itself with all the detailed objects. Decorator Attaches responsibilities to an object dynamically , without creating \nspecific subclasses for each possible configurat ion of responsibilities. Facade Provides a consistent interface to code that wouldn’t otherwise \noffer a consistent interface. Factory Method Instantiates classes derived from a specific base class without \nneeding to keep track of the individual derived classes anywhere \nbut the Factory Method. Iterator A server object that provides access to each element in a set \nsequentially.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 382, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0383_b0adf89b", "text": "Iterator A server object that provides access to each element in a set \nsequentially. Observer Keeps multiple objects in sy nch with one another by making an \nobject responsible for notifying the set of related objects about \nchanges to any member of the set. Singleton Provides global access to a class that has one and only one instance. Strategy Defines a set of algorithms or behaviors that are dynamically \ninterchangeable with each other. Template Method Defines the structure of an algorithm but leaves some of the \ndetailed implementati on to subclasses. 5.3 Design Building Blocks: Heuristics 105\nOne potential trap with patterns is force-fitting code to use a pattern. In some cases, shift-\ning code slightly to conform to a well-recognized pattern will improve understandability \nof the code. But if the code has to be shifted too far, forcing it to look like a standard pat-\ntern can sometimes increase complexity.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 383, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0384_1db43c29", "text": "But if the code has to be shifted too far, forcing it to look like a standard pat-\ntern can sometimes increase complexity. Another potential trap with patterns is feature-itis: using a pattern because of a desire \nto try out a pattern rather than because the pattern is an appropriate design solution. Overall, design patterns are a powerful tool for managing complexity. You can read more \ndetailed descriptions in any of the good books that are listed at the end of this chapter. Other Heuristics\nThe preceding sections describe the major soft ware design heuristics. Following are a few \nother heuristics that might not be useful quite as often but are still worth mentioning. Aim for Strong Cohesion\nCohesion arose from structured design and is usually discussed in the same context \nas coupling. Cohesion refers to how closely all the routines in a class or all the code in \na routine support a central purpose—how fo cused the class is.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 384, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0385_b63b1cb6", "text": "Cohesion refers to how closely all the routines in a class or all the code in \na routine support a central purpose—how fo cused the class is. Classes that contain \nstrongly related functionality are described as having strong cohesion, and the heuris-\ntic goal is to make cohesion as strong as possible. Cohesion is a useful tool for manag-\ning complexity because the more that code in a class supports a central purpose, the \nmore easily your brain can reme mber everything the code does. Thinking about cohesion at the routine leve l has been a useful heuristic for decades \nand is still useful today. At the class level, the heuristic of cohesion has largely been \nsubsumed by the broader heuristic of well- defined abstractions, which was discussed \nearlier in this chapter and in Chapter 6. Ab stractions are useful at the routine level, \ntoo, but on a more even footing with cohesion at that level of detail.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 385, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0386_c1b3d6c4", "text": "Ab stractions are useful at the routine level, \ntoo, but on a more even footing with cohesion at that level of detail. Build Hierarchies\nA hierarchy is a tiered information structure in which the most general or abstract rep-\nresentation of concepts is contained at th e top of the hierarchy, with increasingly \ndetailed, specialized represen tations at the hierarchy’s lower levels. In software, \nhierarchies are found in class hierarchies, and, as Level 4 in Figure 5-2 illustrated, in \nroutine-calling hierarchies as well. Hierarchies have been an important tool for managing complex sets of information for \nat least 2000 years. Aristotle used a hierarchy to organize the animal kingdom. Humans frequently use outlines to organi ze complex information (like this book). Researchers have found that people generall y find hierarchies to be a natural way to \norganize complex information. When they draw a complex object such as a house, \nthey draw it hierarchically.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 386, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0387_54619387", "text": "Researchers have found that people generall y find hierarchies to be a natural way to \norganize complex information. When they draw a complex object such as a house, \nthey draw it hierarchically. First they draw the outline of the house, then the windows \n106\nChapter 5: Design in Construction\nand doors, and then more details. They do n’t draw the house brick by brick, shingle \nby shingle, or nail by nail (Simon 1996). Hierarchies are a useful tool for achievin g Software’s Primary Technical Imperative \nbecause they allow you to focus on only the level of detail you’re currently concerned \nwith. The details don’t go away completely; they’re simply pushed to another level so \nthat you can think about them when you want to rather than thinking about all the \ndetails all of the time. Formalize Class Contracts\nCross-Reference For more \non contracts, see “Use asser-\ntions to document and verify \npreconditions and postcon-\nditions” in Section 8.2.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 387, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0388_21017ebb", "text": "Formalize Class Contracts\nCross-Reference For more \non contracts, see “Use asser-\ntions to document and verify \npreconditions and postcon-\nditions” in Section 8.2. At a more detailed level, thinking of each class’s interface as a contract with the rest of \nthe program can yield good insights. Typicall y, the contract is something like “If you \npromise to provide data x, y, and z and you promise they’ll have characteristics a, b, \nand c, I promise to perform operations 1, 2, and 3 within constraints 8, 9, and 10.” The \npromises the clients of the class make to th e class are typically called “preconditions,” \nand the promises the object makes to it s clients are called the “postconditions.” \nContracts are useful for managing complexity because, at least in theory, the object can \nsafely ignore any noncontractual behavior. In practice, this issue is much more difficult. Assign Responsibilities\nAnother heuristic is to think through how responsibilities shou ld be assigned to \nobjects.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 388, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0389_22b7b0e5", "text": "In practice, this issue is much more difficult. Assign Responsibilities\nAnother heuristic is to think through how responsibilities shou ld be assigned to \nobjects. Asking what each object should be responsible for is si milar to asking what \ninformation it should hide, but I think it can produce broader answers, which gives \nthe heuristic unique value. Design for Test\nA thought process that can yield interesting desi gn insights is to ask what the system will \nlook like if you design it to facilitate testing. Do you need to separate the user interface \nfrom the rest of the code so that you can exercise it independently? Do you need to orga-\nnize each subsystem so that it minimizes dependencies on other subsystems? Designing \nfor test tends to result in more formalized class interfaces, which is generally beneficial.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 389, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 827}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0390_4bf2a1a3", "text": "Do you need to orga-\nnize each subsystem so that it minimizes dependencies on other subsystems? Designing \nfor test tends to result in more formalized class interfaces, which is generally beneficial. Avoid Failure\nCivil engineering professor Henry Petroski wrote an interesting book, Design Paradigms: \nCase Histories of Error an d Judgment in Engineering (Petroski 1994), that chronicles the \nhistory of failures in bridge design. Petroski argues that many spectacular bridge failures \nhave occurred because of focusing on prev ious successes and not adequately consider-\ning possible failure modes. He concludes that failures like the Tacoma Narrows bridge \ncould have been avoided if the designers ha d carefully considered the ways the bridge \nmight fail and not just copied the attributes of other successful designs.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 390, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 822}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0391_b8ce8ed9", "text": "5.3 Design Building Blocks: Heuristics 107\nThe high-profile security lapses of vari ous well-known systems the past few years \nmake it hard to disagree that we should fi nd ways to apply Petroski’s design-failure \ninsights to software. Choose Binding Time Consciously\nCross-Reference For more \non binding time, see Section \n10.6, “Binding Time.” \nBinding time refers to the time a specific value is bound to a variable. Code that binds \nearly tends to be simpler, but it also tend s to be less flexible. Sometimes you can get a \ngood design insight from aski ng questions like these: What if I bound these values \nearlier? What if I bound these values later? Wh at if I initialized this table right here in \nthe code? What if I read the value of this variable from the user at run time? Make Central Points of Control\nP.J.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 391, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 822}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0392_54a7937d", "text": "What if I bound these values later? Wh at if I initialized this table right here in \nthe code? What if I read the value of this variable from the user at run time? Make Central Points of Control\nP.J. Plauger says his major concern is “The Principle of One Right Place—there should \nbe One Right Place to look for any nontrivi al piece of code, and One Right Place to \nmake a likely maintenance change” (Plauger 1993). Control can be centralized in \nclasses, routines, preprocessor macros, #include files—even a named constant is an \nexample of a central point of control. The reduced-complexity benefit is that the fewer places you have to look for some-\nthing, the easier and safer it will be to change. Consider Using Brute Force\nWhen in doubt, use brute \nforce. —Butler Lampson\nOne powerful heuristic tool is brute force. Don’t underestimate it. A brute-force solu-\ntion that works is better than an elegant solution that doesn’t work. It can take a long \ntime to get an elegant solution to work.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 392, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0393_5a2f04fd", "text": "Don’t underestimate it. A brute-force solu-\ntion that works is better than an elegant solution that doesn’t work. It can take a long \ntime to get an elegant solution to work. In describing the history of searching algo-\nrithms, for example, Donald Knuth pointed out that even though the first description \nof a binary search algorithm was published in 1946, it took another 16 years for some-\none to publish an algorithm that correctly searched lists of all sizes (Knuth 1998). A \nbinary search is more elegant, but a brute-fo rce, sequential search is often sufficient. Draw a Diagram\nDiagrams are another powerful heuristic tool . A picture is worth 1000 words—kind of. You actually want to leave out most of the 1000 words because one point of using a \npicture is that a picture can represent the problem at a higher level of abstraction. Sometimes you want to deal with the problem in detail, but other times you want to be \nable to work with more generality.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 393, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0394_086c104a", "text": "Sometimes you want to deal with the problem in detail, but other times you want to be \nable to work with more generality. Keep Your Design Modular\nModularity’s goal is to make each routine or class like a “black box”: You know what \ngoes in, and you know what comes out, bu t you don’t know what happens inside. A \n108\nChapter 5: Design in Construction\nblack box has such a simple interface and su ch well-defined functionality that for any \nspecific input you can accurately predict the corresponding output. The concept of modularity is related to in formation hiding, encapsulation, and other \ndesign heuristics. But sometimes thinking ab out how to assemble a system from a set \nof black boxes provides insights that info rmation hiding and encapsulation don’t, so \nthe concept is worth having in your back pocket.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 394, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 818}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0395_f9af5e9f", "text": "Summary of Design Heuristics\nMore alarming, the same \nprogrammer is quite capa-\nble of doing the same task \nhimself in two or three \nways, sometimes uncon-\nsciously, but quite often \nsimply for a change, or to \nprovide elegant variation. —A. R. Brown and W. A.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 395, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 260}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0396_ea6c28d7", "text": "—A. R. Brown and W. A. Sampson\nHere’s a summary of ma jor design heuristics:\n■\nFind Real-World Objects\n■\nForm Consistent Abstractions\n■\nEncapsulate Implementation Details\n■\nInherit When Possible\n■\nHide Secrets (Information Hiding)\n■\nIdentify Areas Likely to Change\n■\nKeep Coupling Loose\n■\nLook for Common Design Patterns\nThe following heuristics are sometimes useful too: \n■\nAim for Strong Cohesion\n■\nBuild Hierarchies\n■\nFormalize Class Contracts\n■\nAssign Responsibilities\n■\nDesign for Test\n■\nAvoid Failure\n■\nChoose Binding Time Consciously\n■\nMake Central Points of Control\n■\nConsider Using Brute Force\n■\nDraw a Diagram\n■\nKeep Your Design Modular\n5.3 Design Building Blocks: Heuristics 109\nGuidelines for Using Heuristics\nApproaches to design in software can learn from approaches to design in other fields. One of the original books on heuristics in problem solving was G. Polya’s How to Solve \nIt (1957). Polya’s generalized problem-solving approach focuses on problem solving \nin mathematics.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 396, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0397_e3d8fdbe", "text": "One of the original books on heuristics in problem solving was G. Polya’s How to Solve \nIt (1957). Polya’s generalized problem-solving approach focuses on problem solving \nin mathematics. Figure 5-10 is a summary of his approach, adapted from a similar \nsummary in his book (emphases his). cc2e.com/0592\nFigure 5-10 G. Polya developed an approach to problem solving in mathematics that’s also \nuseful in solving problems in software design (Polya 1957). 1. Understanding the Problem. You have to understand the problem. What is the unknown? What are the data? What is the condition? Is it possible to satisfy \nthe condition? Is the condition sufficient to determine the unknown? Or is it \ninsufficient? Or redundant? Or contradictory? Draw a figure. Introduce suitable notation. Separate the various parts of the \ncondition. Can you write them down? 2. Devising a Plan. Find the connection between the data and the unknown. You \nmight be obliged to consider auxiliary problems if you can't find an intermediate \nconnection.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 397, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1023}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0398_360c1994", "text": "Can you write them down? 2. Devising a Plan. Find the connection between the data and the unknown. You \nmight be obliged to consider auxiliary problems if you can't find an intermediate \nconnection. You should eventually come up with a plan of the solution. Have you seen the problem before? Or have you seen the same problem in a \nslightly different form? Do you know a related problem? Do you know a theorem that \ncould be useful? Look at the unknown! And try to think of a familiar problem having the same or a \nsimilar unknown. Here is a problem related to yours and solved before. Can you use it? Can you use its result? Can you use its method? Should you introduce some auxiliary \nelement in order to make its use possible? Can you restate the problem? Can you restate it still differently? Go back to \ndefinitions. If you cannot solve the proposed problem, try to solve some related problem first. Can you imagine a more accessible related problem? A more general problem? A \nmore special problem?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 398, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0399_a939014a", "text": "If you cannot solve the proposed problem, try to solve some related problem first. Can you imagine a more accessible related problem? A more general problem? A \nmore special problem? An analogous problem? Can you solve a part of the problem? Keep only a part of the condition, drop the other part; how far is the unknown then \ndetermined, how can it vary? Can you derive something useful from the data? Can \nyou think of other data appropriate for determining the unknown? Can you change \nthe unknown or the data, or both if necessary , so that the new unknown and the new \ndata are nearer to each other? Did you use all the data? Did you use the whole condition? Have you taken into \naccount all essential notions involved in the problem? 3. Carrying out the Plan. Carry out your plan. Carrying out your plan of the solution, check each step . Can you see clearly that the \nstep is correct? Can you prove that it's correct? 4. Looking Back. Examine the solution. Can you check the result ? Can you check the argument?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 399, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1018}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0400_8c4392e4", "text": "Can you see clearly that the \nstep is correct? Can you prove that it's correct? 4. Looking Back. Examine the solution. Can you check the result ? Can you check the argument? Can you derive the result \ndifferently? Can you see it at a glance? Can you use the result, or the method, for some other problem? 110\nChapter 5: Design in Construction\nOne of the most effective guidelines is not to get stuck on a single approach. If dia-\ngramming the design in UML isn’t working, write it in English. Write a short test pro-\ngram. Try a completely different approach . Think of a brute-force solution. Keep \noutlining and sketching with your pencil, and your brain will follow. If all else fails, \nwalk away from the problem. Literally go for a walk, or think about something else \nbefore returning to the problem. If you’ve given it your best and are getting nowhere, \nputting it out of your mind for a time often produces results more quickly than sheer \npersistence can.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 400, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0401_7b92e3b1", "text": "If you’ve given it your best and are getting nowhere, \nputting it out of your mind for a time often produces results more quickly than sheer \npersistence can. You don’t have to solve the whole design problem at once. If you get stuck, remember \nthat a point needs to be decided but recognize that you don’t yet have enough infor-\nmation to resolve that specific issue. Why fight your way through the last 20 percent \nof the design when it will drop into place easily the next time through? Why make bad \ndecisions based on limited experience with the design when you can make good deci-\nsions based on more experience with it late r? Some people are uncomfortable if they \ndon’t come to closure after a design cycle, but after you have created a few designs \nwithout resolving issues prematurely, it will seem natural to leave issues unresolved \nuntil you have more informatio n (Zahniser 1992, Beck 2000).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 401, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 906}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0402_44c00fa7", "text": "5.4 Design Practices\nThe preceding section focused on heuristics related to design attributes—what you \nwant the completed design to look like. This section describes design practice heuris-\ntics, steps you can take that often produce good results. Iterate\nYou might have had an experience in which you learned so much from writing a pro-\ngram that you wished you could write it again, armed with the insights you gained \nfrom writing it the first time. The same ph enomenon applies to design, but the design \ncycles are shorter and the effects downstream are bigger, so you can afford to whirl \nthrough the design loop a few times. Design is an iterative process. You don’t us ually go from point A only to point B; you \ngo from point A to point B and back to point A. As you cycle through candidate designs and try different approaches, you’ll look at \nboth high-level and low-level views.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 402, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 891}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0403_5cdb6167", "text": "As you cycle through candidate designs and try different approaches, you’ll look at \nboth high-level and low-level views. The big picture you get from working with high-\nlevel issues will help you to put the low-le vel details in perspect ive. The details you \nget from working with low-level issues will provide a foundation in solid reality for \nthe high-level decisions. The tug and pull between top-level and bottom-level \nKEY POINT\n5.4 Design Practices 111\nconsiderations is a healthy dynamic; it crea tes a stressed structure that’s more stable \nthan one built wholly from th e top down or the bottom up. Many programmers—many people, for that matter—have trouble ranging between high-\nlevel and low-level considerations. Switching from one view of a system to another is \nmentally strenuous, but it’s essential to crea ting effective designs.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 403, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 849}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0404_5aa00676", "text": "Switching from one view of a system to another is \nmentally strenuous, but it’s essential to crea ting effective designs. For entertaining exer-\ncises to enhance your mental flexibility, read Conceptual Blockbusting (Adams 2001), \ndescribed in the “Additional Resources” section at the end of the chapter. Cross-Reference Refactor-\ning is a safe way to try differ-\nent alternatives in code. For \nmore on this, see Chapter \n24, \"Refactoring.\"\nWhen you come up with a first design attempt that seems good enough, don’t stop! The second attempt is nearly always better than the first, and you learn things on each \nattempt that can improve your overall design . After trying a thousand different mate-\nrials for a light bulb filament with no succe ss, Thomas Edison was reportedly asked if \nhe felt his time had been wasted since he had discovered nothing. “Nonsense,” Edison \nis supposed to have replied.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 404, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0405_0aefab3b", "text": "“Nonsense,” Edison \nis supposed to have replied. “I have discovered a thousand things that don’t work.” In \nmany cases, solving the problem with one approach will produce insights that will \nenable you to solve the problem using another approach that’s even better. Divide and Conquer\nAs Edsger Dijkstra pointed out, no one’s skull is big enough to contain all the details \nof a complex program, and that applies just as well to design. Divide the program into \ndifferent areas of concern, and then tackle each of those areas individually. If you run \ninto a dead end in one of the areas, iterate! Incremental refinement is a powerful tool for managing complexity. As Polya recom-\nmended in mathematical problem solving, understand the problem, devise a plan, \ncarry out the plan, and then look back to see how you did (Polya 1957).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 405, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 832}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0406_b134b399", "text": "As Polya recom-\nmended in mathematical problem solving, understand the problem, devise a plan, \ncarry out the plan, and then look back to see how you did (Polya 1957). Top-Down and Bottom-Up Design Approaches\n“Top down” and “bottom up” might have an old-fashioned sound, but they provide \nvaluable insight into the creation of object-oriented designs. Top- down design begins \nat a high level of abstraction. You define base classes or other nonspecific design ele-\nments. As you develop the design, you increa se the level of detail, identifying derived \nclasses, collaborating classes, and other detailed design elements. Bottom-up design starts with specifics an d works toward generalities. It typically \nbegins by identifying concrete objects and then generalizes aggregations of objects \nand base classes from those specifics.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 406, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 832}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0407_5e8de908", "text": "It typically \nbegins by identifying concrete objects and then generalizes aggregations of objects \nand base classes from those specifics. Some people argue vehemently that starting with generalities and working toward \nspecifics is best, and some argue that you can’t really identify general design principles \nuntil you’ve worked out the significant detail s. Here are the arguments on both sides. 112\nChapter 5: Design in Construction\nArgument for Top Down\nThe guiding principle behind the top-down a pproach is the idea that the human brain \ncan concentrate on only a certain amount of detail at a time. If you start with general \nclasses and decompose them into more specialized classes step by step, your brain \nisn’t forced to deal with too many details at once. The divide-and-conquer process is iterative in a couple of senses. First, it’s iterative \nbecause you usually don’t stop after one level of decomposition. You keep going for \nseveral levels.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 407, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0408_0246aae4", "text": "The divide-and-conquer process is iterative in a couple of senses. First, it’s iterative \nbecause you usually don’t stop after one level of decomposition. You keep going for \nseveral levels. Second, it’s iterative because you don’t usually settle for your first \nattempt. You decompose a program one way. At various points in the decomposition, \nyou’ll have choices about which way to partition the subsystems, lay out the inherit-\nance tree, and form compositions of objects. You make a choice and see what hap-\npens. Then you start over and decompose it another way and see whether that works \nbetter. After several attempts, you’ll have a good idea of what will work and why. How far do you decompose a program? Contin ue decomposing until it seems as if it \nwould be easier to code the next level th an to decompose it. Work until you become \nsomewhat impatient at how obvious and easy the design seems. At that point, you’re \ndone. If it’s not clear, work some more.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 408, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0409_60060f00", "text": "Work until you become \nsomewhat impatient at how obvious and easy the design seems. At that point, you’re \ndone. If it’s not clear, work some more. If the solution is even slightly tricky for you \nnow, it’ll be a bear for anyone who works on it later. Argument for Bottom Up\nSometimes the top-down approach is so abstract that it’s hard to get started. If you \nneed to work with something more tangible, try the bottom-up design approach. Ask \nyourself, “What do I know this system n eeds to do?” Undoubtedly, you can answer \nthat question. You might identify a few low-le vel responsibilities that you can assign to \nconcrete classes. For example, you might know that a system needs to format a partic-\nular report, compute data for that report, center its headings, display the report on the \nscreen, print the report on a printer, and so on. After you identify several low-level \nresponsibilities, you’ll usually start to feel comfortable enough to look at the top again.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 409, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0410_2e715ca0", "text": "After you identify several low-level \nresponsibilities, you’ll usually start to feel comfortable enough to look at the top again. In some other cases, major attributes of the design problem are dictated from the bot-\ntom. You might have to interface with hardware devices whose interface requirements \ndictate large chunks of your design. Here are some things to keep in mind as you do bottom-up composition:\n■\nAsk yourself what you know the system needs to do. ■\nIdentify concrete objects and resp onsibilities from that question. ■\nIdentify common objects, and group them using subsystem organization, pack-\nages, composition within objects, or inheritance, whichever is appropriate. ■\nContinue with the next level up, or go back to the top and try again to work down. 5.4 Design Practices 113\nNo Argument, Really\nThe key difference between top-down and bottom-up strategies is that one is a decom-\nposition strategy and the other is a compos ition strategy.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 410, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0411_5c0b1ed0", "text": "5.4 Design Practices 113\nNo Argument, Really\nThe key difference between top-down and bottom-up strategies is that one is a decom-\nposition strategy and the other is a compos ition strategy. One starts from the general \nproblem and breaks it into manageable pieces; the other starts with manageable \npieces and builds up a general solution. Both approaches have strengths and weak-\nnesses that you’ll want to consider as you apply them to your design problems. The strength of top-down design is that it’s easy. People are good at breaking some-\nthing big into smaller components, and programmers are especially good at it. Another strength of top-down design is that you can defer construction details. Since \nsystems are often perturbed by changes in construction details (for example, changes \nin a file structure or a report format), it’s useful to know early on that those details \nshould be hidden in classes at the bottom of the hierarchy.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 411, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0412_65a408ec", "text": "One strength of the bottom-up approach is th at it typically results in early identifica-\ntion of needed utility functionality, which results in a compact, well-factored design. If \nsimilar systems have already been built, th e bottom-up approach allows you to start \nthe design of the new system by looking at pieces of the old system and asking “What \ncan I reuse?”\nA weakness of the bottom-up composition approach is that it’s hard to use exclusively. Most people are better at taking one big concept and breaking it into smaller concepts \nthan they are at taking small concepts and making one big one. It’s like the old assem-\nble-it-yourself problem: I thought I was done, so why does the box still have parts in it? Fortunately, you don’t have to use the bo ttom-up composition approach exclusively. Another weakness of the bottom-up design strategy is that sometimes you find that \nyou can’t build a program from the pieces you’ve started with.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 412, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0413_aed3d15f", "text": "Another weakness of the bottom-up design strategy is that sometimes you find that \nyou can’t build a program from the pieces you’ve started with. You can’t build an air-\nplane from bricks, and you might have to wo rk at the top before you know what kinds \nof pieces you need at the bottom. To summarize, top down tends to start si mple, but sometimes low-level complexity \nripples back to the top, and those ripples can make things more complex than they \nreally needed to be. Bottom up tends to star t complex, but identifying that complexity \nearly on leads to better design of the higher -level classes—if the complexity doesn’t tor-\npedo the whole system first! In the final analysis, top-down and bottom -up design aren’t competing strategies—\nthey’re mutually beneficial. Design is a he uristic process, which means that no solu-\ntion is guaranteed to work every time. Design contains elements of trial and error. Try \na variety of approaches until you find one that works well.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 413, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0414_6b9f0be5", "text": "Design contains elements of trial and error. Try \na variety of approaches until you find one that works well. 114\nChapter 5: Design in Construction\nExperimental Prototyping\ncc2e.com/0599\nSometimes you can’t really know whether a design will work until you better under-\nstand some implementation detail. You might not know if a particular database orga-\nnization will work until you know whether it will meet your performance goals. You \nmight not know whether a particular subsys tem design will work until you select the \nspecific GUI libraries you’ll be working with. These are examples of the essential \n“wickedness” of software design—you can’ t fully define the design problem until \nyou’ve at least partially solved it. A general technique for addressing these questions at low cost is experimental proto-\ntyping. The word “prototyping” means lots of different things to different people \n(McConnell 1996).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 414, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 913}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0415_4e600933", "text": "A general technique for addressing these questions at low cost is experimental proto-\ntyping. The word “prototyping” means lots of different things to different people \n(McConnell 1996). In this context, prototyping means writing the absolute minimum \namount of throwaway code that’s needed to answer a specific design question. Prototyping works poorly when developer s aren’t disciplined about writing the abso-\nlute minimum of code needed to answer a question. Suppose the design question is, \n“Can the database framework we’ve selected support the transaction volume we \nneed?” You don’t need to write any production code to answer that question. You \ndon’t even need to know the database specifics. You just need to know enough to \napproximate the problem space—number of ta bles, number of entries in the tables, \nand so on.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 415, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 830}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0416_7e7a292f", "text": "You \ndon’t even need to know the database specifics. You just need to know enough to \napproximate the problem space—number of ta bles, number of entries in the tables, \nand so on. You can then write very simple prototyping code that uses tables with \nnames like Table1 , Table2 , and Column1 , and Column2 , populate the tables with junk \ndata, and do your performance testing. Prototyping also works poorly when the design question is not specific enough. A \ndesign question like “Will this database framework work?” does not provide enough \ndirection for prototyping. A design question like “Will this database framework sup-\nport 1,000 transactions per second under a ssumptions X, Y, and Z?” provides a more \nsolid basis for prototyping. A final risk of prototyping arises when developers do not treat the code as throwaway \ncode.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 416, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 834}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0417_fbf237e1", "text": "A final risk of prototyping arises when developers do not treat the code as throwaway \ncode. I have found that it is not possible for people to write the absolute minimum \namount of code to answer a question if they believe that the code will eventually end \nup in the production system. They end up implementing the system instead of proto-\ntyping. By adopting the attitude that once the question is answered the code will be \nthrown away, you can minimize this risk. One way to avoid this problem is to create \nprototypes in a different technology than the production code. You could prototype a \nJava design in Python or mock up a user interface in Microsoft PowerPoint. If you do \ncreate prototypes using the production technology, a practical standard that can help \nis requiring that class names or package names for prototype code be prefixed with \nprototype . That at least makes a programmer think twice before trying to extend pro-\ntotype code (Stephens 2003).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 417, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0418_8ad28743", "text": "That at least makes a programmer think twice before trying to extend pro-\ntotype code (Stephens 2003). 5.4 Design Practices 115\nUsed with discipline, prototyping is the work horse tool a designer has to combat design \nwickedness. Used without discipline, prototyping adds some wickedness of its own. Collaborative Design\nCross-Reference For more \ndetails on collaborative devel-\nopment, see Chapter 21, \n“Collaborative Construction.”\nIn design, two heads are often better than one, whether those two heads are organized \nformally or informally. Collaboration can take any of several forms:\n■\nYou informally walk over to a co-worke r’s desk and ask to bounce some ideas \naround. ■\nYou and your co-worker sit together in a conference room and draw design alter-\nnatives on a whiteboard.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 418, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 784}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0419_0e841716", "text": "■\nYou and your co-worker sit together in a conference room and draw design alter-\nnatives on a whiteboard. ■\nYou and your co-worker sit together at the keyboard and do detailed design in \nthe programming language you’re using— that is, you can use pair programming, \ndescribed in Chapter 21, “Co llaborative Construction.” \n■\nYou schedule a meeting to walk through your design ideas with one or more co-\nworkers. ■\nYou schedule a formal inspection with al l the structure described in Chapter 21. ■\nYou don’t work with anyone who can review your work, so you do some initial \nwork, put it into a drawer, and come back to it a week later. You will have forgot-\nten enough that you should be able to give yourself a fairly good review. ■\nYou ask someone outside your company for help: send questions to a special-\nized forum or newsgroup. If the goal is quality assurance, I tend to recommend the most structured review prac-\ntice, formal inspections, for the reasons desc ribed in Chapter 21.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 419, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0420_12de12d5", "text": "If the goal is quality assurance, I tend to recommend the most structured review prac-\ntice, formal inspections, for the reasons desc ribed in Chapter 21. But if the goal is to \nfoster creativity and to increase the number of design alternatives generated, not just \nto find errors, less structured approaches work better. After you’ve settled on a specific \ndesign, switching to a more formal inspection might be appropriate, depending on \nthe nature of your project. How Much Design Is Enough? We try to solve the problem \nby rushing through the \ndesign process so that \nenough time is left at the \nend of the project to uncover \nthe errors that were made \nbecause we rushed through \nthe design process. —Glenford Myers\nSometimes only the barest sketch of an ar chitecture is mapped out before coding \nbegins. Other times, teams create designs at such a level of detail that coding \nbecomes a mostly mechanical exercise. How much design should you do before you \nbegin coding?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 420, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0421_7369a43e", "text": "Other times, teams create designs at such a level of detail that coding \nbecomes a mostly mechanical exercise. How much design should you do before you \nbegin coding? A related question is how formal to make the design. Do you need formal, polished \ndesign diagrams, or would di gital snapshots of a few draw ings on a whiteboard be \nenough? 116\nChapter 5: Design in Construction\nDeciding how much design to do before beginning full-scale coding and how much \nformality to use in documenting that design is hardly an exact science. The experience \nof the team, expected lifetime of the system , desired level of reliability, and size of \nproject and team should all be considered . Table 5-2 summarizes how each of these \nfactors influence the design approach. Two or more of these factors might come into play on any specific project, and in \nsome cases the factors might provide contradictory advice. For example, you might \nhave a highly experienced team working on sa fety critical software.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 421, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0422_af9c0590", "text": "For example, you might \nhave a highly experienced team working on sa fety critical software. In that case, you’d \nprobably want to err on the side of the higher level of design detail and formality. In \nsuch cases, you’ll need to weigh the significance of each factor and make a judgment \nabout what matters most. If the level of design is left to each indi vidual, then, when the design descends to the \nlevel of a task that you’ve done before or to a simple modification or extension of such \na task, you’re probably ready to stop designing and begin coding.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 422, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 560}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0423_24db8432", "text": "Table 5-2\nDesign Formality and Level of Detail Needed\nFactor\nLevel of Detail Needed \nin Design Before \nConstruction\nDocumentation \nFormality\nDesign/construction team \nhas deep experience in \napplications area.Low Detail Low Formality\nDesign/construction team \nhas deep experience but \nis inexperienced in the \napplications area.Medium Detail Medium Formality\nDesign/construction team \nis inexperienced.Medium to High Detail Low-Medium Formality\nDesign/construction team \nhas moderate-to-high \nturnover.Medium Detail —\nApplication is \nsafety-critical.High Detail High Formality\nApplication is \nmission-critical.Medium Detail Medium-High Formality\nProject is small. Low Detail Low Formality\nProject is large.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 423, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 706}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0424_3182c3d6", "text": "Low Detail Low Formality\nProject is large. Medium Detail Medium Formality\nSoftware is expected to \nhave a short lifetime \n(weeks or months).Low Detail Low Formality\nSoftware is expected to \nhave a long lifetime \n(months or years).Medium Detail Medium Formality\n5.4 Design Practices 117\nIf I can’t decide how deeply to investigate a design before I begin coding, I tend to err \non the side of going into more detail. The biggest design errors arise from cases in \nwhich I thought I went far enou gh, but it later turns out that I didn’t go far enough to \nrealize there were additional design challe nges. In other words, the biggest design \nproblems tend to arise not from areas I knew were difficult and created bad designs \nfor, but from areas I thought were easy and didn’t create any designs for at all. I rarely \nencounter projects that are suffering from having done too much design work.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 424, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 893}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0425_5b1b7951", "text": "I rarely \nencounter projects that are suffering from having done too much design work. I've never met a human \nbeing who would want to \nread 17,000 pages of docu-\nmentation, and if there was, \nI'd kill him to get him out of \nthe gene pool. —Joseph Costello\nOn the other hand, occasionally I have seen projects that are suffering from too much \ndesign documentation . Gresham’s Law states that “programmed activity tends to drive \nout nonprogrammed activity” (Simon 1965). A premature rush to polish a design \ndescription is a good example of that law. I would rather see 80 percent of the design \neffort go into creating and exploring numero us design alternatives and 20 percent go \ninto creating less polished documentation th an to have 20 percent go into creating \nmediocre design alternatives and 80 percent go into polishing documentation of \ndesigns that are not very good.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 425, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 880}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0426_90702bf5", "text": "Capturing Your Design Work\ncc2e.com/0506\nThe traditional approach to capturing design work is to write up the designs in a for-\nmal design document. However, you can capture designs in numerous alternative \nways that work well on small projects, inform al projects, or projects that need a light-\nweight way to record a design:\nThe bad news is that, in our \nopinion, we will never find the \nphilosopher’s stone. We will \nnever find a process that allows \nus to design software in a per-\nfectly rational way. The good \nnews is that we can fake it. —David Parnas and Paul \nClements\nInsert design documentat ion into the code itself Document key design decisions in \ncode comments, typically in the file or cl ass header.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 426, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 718}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0427_a48440e7", "text": "—David Parnas and Paul \nClements\nInsert design documentat ion into the code itself Document key design decisions in \ncode comments, typically in the file or cl ass header. When you couple this approach \nwith a documentation extractor like JavaDoc, this assures that design documentation \nwill be readily available to a programmer working on a section of code, and it \nimproves the chance that programmers will keep the design documentation reason-\nably up to date. Capture design discussions and decisions on a Wiki Have your design discussions \nin writing, on a project Wiki (that is, a coll ection of Web pages that can be edited eas-\nily by anyone on your project using a Web browser). This will capture your design dis-\ncussions and decision automatica lly, albeit with the extra overhead of typing rather \nthan talking. You can also use the Wiki to capture digital pictures to supplement the \ntext discussion, links to websites that su pport the design decision, white papers, and \nother materials.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 427, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0428_06530200", "text": "You can also use the Wiki to capture digital pictures to supplement the \ntext discussion, links to websites that su pport the design decision, white papers, and \nother materials. This technique is especially useful if your development team is geo-\ngraphically distributed. Write e-mail summaries After a design discussion, adopt the practice of designating \nsomeone to write a summary of the discussion—especially what was decided—and send \nit to the project team. Archive a copy of the e-mail in the project’s public e-mail folder. 118\nChapter 5: Design in Construction\nUse a digital camera One common barrier to documenting designs is the tedium of \ncreating design drawings in some popu lar drawing tools. But the documentation \nchoices are not limited to the two options of “capturing the design in a nicely format-\nted, formal notation” vs.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 428, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 845}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0429_b3dd9962", "text": "But the documentation \nchoices are not limited to the two options of “capturing the design in a nicely format-\nted, formal notation” vs. “no design documentation at all.” \nTaking pictures of whiteboard drawings with a digital camera and then embedding \nthose pictures into traditiona l documents can be a low-effort way to get 80 percent of \nthe benefit of saving design drawings by doing about 1 percent of the work required \nif you use a drawing tool. Save design flip charts There’s no law that says your design documentation has to \nfit on standard letter-size paper. If you make your design drawings on large flip chart \npaper, you can simply archive the flip charts in a convenient location—or, better yet, \npost them on the walls around the project area so that people can easily refer to them \nand update them when needed. cc2e.com/0513\nUse CRC (Class, Responsibi lity, Collaborator) cards Another low-tech alternative \nfor documenting designs is to use index card s.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 429, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0430_eb4abaee", "text": "cc2e.com/0513\nUse CRC (Class, Responsibi lity, Collaborator) cards Another low-tech alternative \nfor documenting designs is to use index card s. On each card, designers write a class \nname, responsibilities of the class, and c ollaborators (other classes that cooperate \nwith the class). A design group then works with the cards until they’re satisfied that \nthey’ve created a good design. At that point, you can simply save the cards for future \nreference. Index cards are cheap, unintimidating, and portable, and they encourage \ngroup interaction (Beck 1991). Create UML diagrams at appropriate levels of detail One popular technique for \ndiagramming designs is called Unified Mode ling Language (UML), which is defined \nby the Object Management Group (Fowler 2004). Figure 5-6 earlier in this chapter \nwas one example of a UML class diagram. UML provides a rich set of formalized rep-\nresentations for design entities and relati onships.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 430, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0431_79a37308", "text": "Figure 5-6 earlier in this chapter \nwas one example of a UML class diagram. UML provides a rich set of formalized rep-\nresentations for design entities and relati onships. You can use informal versions of \nUML to explore and discuss design approaches. Start with minimal sketches and add \ndetail only after you’ve zeroed in on a fi nal design solution. Because UML is standard-\nized, it supports common understanding in communicating design ideas and it can \naccelerate the process of considering design alternatives when working in a group. These techniques can work in various combinat ions, so feel free to mix and match these \napproaches on a project-by-project basis or even within different areas of a single project. 5.5 Comments on Popular Methodologies\nThe history of design in software has been marked by fanatic advocates of wildly con-\nflicting design approaches.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 431, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 875}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0432_6d271a5a", "text": "5.5 Comments on Popular Methodologies\nThe history of design in software has been marked by fanatic advocates of wildly con-\nflicting design approaches. When I published the first edition of Code Complete in the \nearly 1990s, design zealots were advocating dotting every design i and crossing every \ndesign t before beginning coding. That reco mmendation didn’t make any sense. Additional Resources 119\nPeople who preach software \ndesign as a disciplined activ-\nity spend considerable \nenergy making us all feel \nguilty. We can never be \nstructured enough or object-\noriented enough to achieve \nnirvana in this lifetime. We \nall truck around a kind of \noriginal sin from having \nlearned Basic at an impres-\nsionable age. But my bet is \nthat most of us are better \ndesigners than the purists \nwill ever acknowledge. —P. J . P l a u g e r\nAs I write this edition in the mid-2000s, some software swamis are arguing for not \ndoing any design at all. “Big Design Up Front is BDUF ,” they say. “BDUF is bad.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 432, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1000}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0433_15451cd6", "text": "—P. J . P l a u g e r\nAs I write this edition in the mid-2000s, some software swamis are arguing for not \ndoing any design at all. “Big Design Up Front is BDUF ,” they say. “BDUF is bad. You’re \nbetter off not doing any design before you begin coding!” \nIn ten years the pendulum has swung from “design everything” to “design nothing.” \nBut the alternative to BDUF isn’t no design up front, it’s a Little Design Up Front \n(LDUF) or Enough Design Up Front— ENUF . How do you tell how much is enough? That’s a judgment call, and no one can make \nthat call perfectly. But while you can’t know the exact right amount of design with any \nconfidence, two amounts of design are guaranteed to be wrong every time: designing \nevery last detail and not designing anything at all. The two positions advocated by \nextremists on both ends of the scale turn out to be the only two positions that are \nalways wrong! As P.J.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 433, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 908}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0434_45dbe8ac", "text": "The two positions advocated by \nextremists on both ends of the scale turn out to be the only two positions that are \nalways wrong! As P.J. Plauger says, “The more dogmatic you are about applying a design method, the \nfewer real-life problems you are going to so lve” (Plauger 1993). Treat design as a \nwicked, sloppy, heuristic proce ss. Don’t settle for the first design that occurs to you. Collaborate. Strive for simplicity. Prototype when you need to. Iterate, iterate, and iter-\nate again. You’ll be happy with your designs. Additional Resources\ncc2e.com/0520\nSoftware design is a rich field with abund ant resources. The challenge is identifying \nwhich resources will be most usef ul. Here are some suggestions. Software Design, General\nWeisfeld, Matt. The Object-Oriented Thought Process , 2d ed. SAMS, 2004. This is an \naccessible book that introduces object-ori ented programming.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 434, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 889}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0435_3244e34a", "text": "Here are some suggestions. Software Design, General\nWeisfeld, Matt. The Object-Oriented Thought Process , 2d ed. SAMS, 2004. This is an \naccessible book that introduces object-ori ented programming. If you’re already famil-\niar with object-oriented programming, you’ll probably want a more advanced book, \nbut if you’re just getting your feet wet in object orientation, this book introduces fun-\ndamental object-oriented concepts, including objects, classes, interfaces, inheritance, \npolymorphism, overloading, abstract classe s, aggregation and association, construc-\ntors/destructors, exceptions, and others. Riel, Arthur J. Object-Oriented Design Heuristics . Reading, MA: Addison-Wesley, 1996. This book is easy to read and focuses on design at the class level. Plauger, P. J. Programming on Purpose: Essays on Software Design . Englewood Cliffs, NJ: \nPTR Prentice Hall, 1993. I picked up as many tips about good software design from \nreading this book as from any other book I’ve read.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 435, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0436_616aef12", "text": "Englewood Cliffs, NJ: \nPTR Prentice Hall, 1993. I picked up as many tips about good software design from \nreading this book as from any other book I’ve read. Plauger is well-versed in a wide-\nvariety of design approaches, he’s pragmatic, and he’s a great writer. 120\nChapter 5: Design in Construction\nMeyer, Bertrand. Object-Oriented Software Construction , 2d ed. New York, NY: Pren-\ntice Hall PTR, 1997. Meyer presents a forc eful advocacy of hard-core object-oriented \nprogramming. Raymond, Eric S. The Art of UNIX Programming . Boston, MA: Addison-Wesley, 2004. This is a well-researched look at software de sign through UNIX-colored glasses. Section \n1.6 is an especially concise 12-page expl anation of 17 key UNIX design principles. Larman, Craig. Applying UML and Patterns: An Introduction to Object-Oriented Analysis \nand Design and the Unified Process , 2d ed. Englewood Cliffs , NJ: Prentice Hall, 2001.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 436, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0437_61767e1c", "text": "Larman, Craig. Applying UML and Patterns: An Introduction to Object-Oriented Analysis \nand Design and the Unified Process , 2d ed. Englewood Cliffs , NJ: Prentice Hall, 2001. This book is a popular introduction to ob ject-oriented design in the context of the \nUnified Process. It also disc usses object-ori ented analysis. Software Design Theory\nParnas, David L., and Paul C. Clements. “A Rational Design Process: How and Why to \nFake It.” IEEE Transactions on Software Engineering SE-12, no. 2 (February 1986): 251–57. This classic article describes the gap betw een how programs are really designed and \nhow you sometimes wish they were designed. The main point is that no one ever \nreally goes through a rational, orderly design process but that aiming for it makes for \nbetter designs in the end. I’m not aware of any comprehensive treatment of information hiding. Most software-\nengineering textbooks discuss it briefly, frequently in the context of object-oriented \ntechniques.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 437, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0438_e25bea3a", "text": "I’m not aware of any comprehensive treatment of information hiding. Most software-\nengineering textbooks discuss it briefly, frequently in the context of object-oriented \ntechniques. The three Parnas papers listed below are the seminal presentations of the \nidea and are probably still the best resources on information hiding. Parnas, David L. “On the Criteria to Be Used in Decomposing Systems into Modules.” \nCommunications of the ACM 5, no. 12 (December 1972): 1053-58. Parnas, David L. “Designing Software fo r Ease of Extension and Contraction.” IEEE \nTransactions on Software Engineering SE-5, no. 2 (March 1979): 128-38. Parnas, David L., Paul C. Clements, and D. M. Weiss. “The Modular Structure of Com-\nplex Systems.” IEEE Transactions on Software Engineering SE-11, no. 3 (March 1985): \n259-66. Design Patterns\nGamma, Erich, et al. Design Patterns . Reading, MA: Addison-We sley, 1995. This book \nby the “Gang of Four” is the seminal book on design patterns. Shalloway, Alan, and James R. Trott.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 438, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0439_01d5a270", "text": "Design Patterns\nGamma, Erich, et al. Design Patterns . Reading, MA: Addison-We sley, 1995. This book \nby the “Gang of Four” is the seminal book on design patterns. Shalloway, Alan, and James R. Trott. Design Patterns Explained . Boston, MA: Addison-\nWesley, 2002. This book contains an easy -to-read introduction to design patterns. Additional Resources 121\nDesign in General\nAdams, James L. Conceptual Blockbusting: A Guide to Better Ideas , 4th ed. Cambridge, \nMA: Perseus Publishing, 2001. Although not specifically about software design, this \nbook was written to teach design to engineering students at Stanford. Even if you \nnever design anything, the book is a fascin ating discussion of creative thought pro-\ncesses. It includes many exercises in the kinds of thinking required for effective \ndesign. It also contains a well-annotated bibl iography on design and creative thinking. If you like problem solving, you’ll like this book. Polya, G. How to Solve It: A New Aspect of Mathematical Method , 2d ed.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 439, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1013}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0440_34988d04", "text": "If you like problem solving, you’ll like this book. Polya, G. How to Solve It: A New Aspect of Mathematical Method , 2d ed. Princeton, NJ: \nPrinceton University Press, 1957. This disc ussion of heuristics and problem solving \nfocuses on mathematics but is applicable to software development. Polya’s book was \nthe first written about the use of heuristics in mathematical problem solving. It draws \na clear distinction between the messy heuris tics used to discover solutions and the \ntidier techniques used to present them once they’ve been discovered. It’s not easy \nreading, but if you’re intere sted in heuristics, you’ll eventually read it whether you \nwant to or not. Polya’s book makes it clear that problem solving isn’t a deterministic \nactivity and that adherence to any single methodology is like walking with your feet in \nchains. At one time, Microsoft gave this book to all its new programmers. Michalewicz, Zbigniew, and David B. Fogel. How to Solve It: Modern Heuristics .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 440, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0441_2e897461", "text": "At one time, Microsoft gave this book to all its new programmers. Michalewicz, Zbigniew, and David B. Fogel. How to Solve It: Modern Heuristics . Berlin: \nSpringer-Verlag, 2000. This is an updated tr eatment of Polya’s book that’s quite a bit \neasier to read and that also contains some nonmathematical examples. Simon, Herbert. The Sciences of the Artificial , 3d ed. Cambridge, MA: MIT Press, 1996. This fascinating book draws a distinction be tween sciences that deal with the natural \nworld (biology, geology, and so on) and sciences that deal with the artificial world cre-\nated by humans (business, architecture, and computer science). It then discusses the \ncharacteristics of the sciences of the artifici al, emphasizing the science of design. It has \nan academic tone and is well worth reading for anyone intent on a career in software \ndevelopment or any other “artificial” field. Glass, Robert L. Software Creativity . Englewood Cliffs, NJ: Pren tice Hall PTR, 1995.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 441, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0442_3446fae9", "text": "Glass, Robert L. Software Creativity . Englewood Cliffs, NJ: Pren tice Hall PTR, 1995. Is \nsoftware development controlled more by th eory or by practice? Is it primarily cre-\native or is it primarily deterministic? What intellectual qualities does a software devel-\noper need? This book contains an interest ing discussion of the nature of software \ndevelopment with a special emphasis on design. Petroski, Henry. Design Paradigms: Case Histories of Error and Judgment in Engineering . Cambridge: Cambridge University Press, 1994 . This book draws heavily from the field of \ncivil engineering (especially bridge design) to explain its main argument that successful \ndesign depends at least as much upon learning from past failures as from past successes. 122\nChapter 5: Design in Construction\nStandards\nIEEE Std 1016-1998, Recommended Practi ce for Software Design Descriptions . This docu-\nment contains the IEEE-ANSI standard for software-design descriptions.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 442, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0443_a72dd7a8", "text": "This docu-\nment contains the IEEE-ANSI standard for software-design descriptions. It describes \nwhat should be included in a software-design document. IEEE Std 1471-2000. Recommended Practice for Architectural Description of Software Inten-\nsive Systems . Los Alamitos, CA: IEEE Computer Society Press. This document is the \nIEEE-ANSI guide for creating software architecture specifications. cc2e.com/0527\nCHECKLIST: Design in Construction\nDesign Practices\n❑\nHave you iterated, selecting the best of several attempts rather than the \nfirst attempt? ❑\nHave you tried decomposing the system in several different ways to see \nwhich way will work best? ❑\nHave you approached the design problem both from the top down and \nfrom the bottom up? ❑\nHave you prototyped risky or unfamiliar parts of the system, creating the \nabsolute minimum amount of throwawa y code needed to answer specific \nquestions? ❑\nHas your design been reviewed, formally or informally, by others?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 443, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0444_1c902ff3", "text": "❑\nHas your design been reviewed, formally or informally, by others? ❑\nHave you driven the design to the point that its implementation seems \nobvious? ❑\nHave you captured your design work using an appropriate technique such \nas a Wiki, e-mail, flip charts, digital photography, UML, CRC cards, or \ncomments in the code itself? Design Goals\n❑\nDoes the design adequately address issues that were identified and \ndeferred at the architectural level? ❑\nIs the design stratified into layers? ❑\nAre you satisfied with the way the program has been decomposed into \nsubsystems, packages, and classes? ❑\nAre you satisfied with the way the classes have been decomposed into \nroutines? ❑\nAre classes designed for minima l interaction with each other? Key Points 123\n❑\nAre classes and subsystems designed so that you can use them in other \nsystems? ❑\nWill the program be easy to maintain? ❑\nIs the design lean? Are all of its parts strictly necessary?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 444, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0445_c9944b1d", "text": "Key Points 123\n❑\nAre classes and subsystems designed so that you can use them in other \nsystems? ❑\nWill the program be easy to maintain? ❑\nIs the design lean? Are all of its parts strictly necessary? ❑\nDoes the design use standard techniques and avoid exotic, hard-to-under-\nstand elements? ❑\nOverall, does the design help mini mize both accidental and essential \ncomplexity? Key Points\n■\nSoftware’s Primary Technical Imperative is managing complexity . This is greatly \naided by a design focus on simplicity. ■\nSimplicity is achieved in two general wa ys: minimizing the amount of essential \ncomplexity that anyone’s brain has to deal with at any one time, and keeping \naccidental complexity from proliferating needlessly. ■\nDesign is heuristic. Dogmatic adherence to any single methodology hurts cre-\nativity and hurts your programs. ■\nGood design is iterative; the more design possibilities you try, the better your \nfinal design will be. ■\nInformation hiding is a particularly va luable concept.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 445, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0446_995213c6", "text": "■\nGood design is iterative; the more design possibilities you try, the better your \nfinal design will be. ■\nInformation hiding is a particularly va luable concept. Asking “What should I \nhide?” settles many difficult design issues. ■\nLots of useful, interesting information on design is available outside this book. The perspectives presented here are just the tip of the iceberg. 125\nChapter 6\nWorking Classes\ncc2e.com/0665\nContents\n■\n6.1 Class Foundations: Abstract Data Types (ADTs): page 126\n■\n6.2 Good Class Interfaces: page 133\n■\n6.3 Design and Implementation Issues: page 143\n■\n6.4 Reasons to Create a Class: page 152\n■\n6.5 Language-Specific Issues: page 156\n■\n6.6 Beyond Classes: Packages: page 156\nRelated Topics\n■\nDesign in construction: Chapter 5\n■\nSoftware architecture: Section 3.5\n■\nHigh-quality routines: Chapter 7\n■\nThe Pseudocode Programming Process: Chapter 9\n■\nRefactoring: Chapter 24\nIn the dawn of computing, programmers thought about programming in terms of \nstatements.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 446, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0447_5688f1b0", "text": "Throughout the 1970s and 1980s, programmers began thinking about \nprograms in terms of routines. In the twenty-first century, programmers think about \nprogramming in terms of classes. A class is a collection of data and routines that share a cohesive , well-defined respon-\nsibility. A class mi ght also be a collection of routines that provides a cohesive set of ser-\nvices even if no common data is involved. A key to being an effective programmer is \nmaximizing the portion of a program that yo u can safely ignore while working on any \none section of code. Classes are the primary tool for accomplishing that objective. This chapter contains a distillation of advice in creating high-quality classes. If you’re \nstill warming up to object-oriented con cepts, this chapter might be too advanced. Make sure you’ve read Chapter 5, “Design in Construction.” Then start with Section \n6.1, “Class Foundations: Abstract Data Ty pes (ADTs),” and ease your way into the \nremaining sections.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 447, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0448_753da177", "text": "Make sure you’ve read Chapter 5, “Design in Construction.” Then start with Section \n6.1, “Class Foundations: Abstract Data Ty pes (ADTs),” and ease your way into the \nremaining sections. If you’re already familiar with class basics, you might skim Section \n6.1 and then dive into the discussion of cla ss interfaces in Section 6.2. The “Additional \nResources” section at the end of this chapter contains pointers to introductory reading, \nadvanced reading, and programming-language-specific resources. KEY POINT\n126\nChapter 6: Working Classes\n6.1 Class Foundations: Ab stract Data Types (ADTs)\nAn abstract data type is a collection of data and operations that work on that data. The \noperations both describe the data to the rest of the program and allow the rest of the \nprogram to change the data. The word “data” in “abstract data type” is used loosely.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 448, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 856}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0449_28952bd4", "text": "The \noperations both describe the data to the rest of the program and allow the rest of the \nprogram to change the data. The word “data” in “abstract data type” is used loosely. An ADT might be a graphics window with all th e operations that affect it, a file and file \noperations, an insurance-rates table and the operations on it, or something else. Cross-Reference Thinking \nabout ADTs first and classes \nsecond is an example of pro-\ngramming into a language \nvs. programming in one. See \nSection 4.3, “Your Location \non the Technology Wave,” \nand Section 34.4, “Program \ninto Your Language, Not in It.”\nUnderstanding ADTs is essential to understanding object-oriented programming. Without understanding ADTs, programmers crea te classes that are “classes” in name \nonly—in reality, they are little more than co nvenient carrying cases for loosely related \ncollections of data and routines.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 449, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 893}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0450_5850fb88", "text": "With an understanding of ADTs, programmers can \ncreate classes that are easier to implement initially and easier to modify over time. Traditionally, programming books wax mathemat ical when they arrive at the topic of \nabstract data types. They tend to make statements like “One can think of an abstract \ndata type as a mathematical model with a coll ection of operations defined on it.” Such \nbooks make it seem as if you’d never actually use an abstract data type except as a \nsleep aid. Such dry explanations of abstract data type s completely miss the point. Abstract data \ntypes are exciting because you can use them to manipulate real-world entities rather \nthan low-level, implementation entities. Inst ead of inserting a node into a linked list, \nyou can add a cell to a spreadsheet, a new type of window to a list of window types, or \nanother passenger car to a train simulation. Tap into the power of being able to work \nin the problem domain rather than at the low-level implementation domain!", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 450, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0451_0400d3e5", "text": "Tap into the power of being able to work \nin the problem domain rather than at the low-level implementation domain! Example of the Need for an ADT\nTo get things started, here’s an example of a case in which an ADT would be useful. We’ll get to the details after we have an example to talk about. Suppose you’re writing a program to control text output to the screen using a variety \nof typefaces, point sizes, and font attributes (such as bold and italic). Part of the pro-\ngram manipulates the text’s fonts. If you use an ADT, you’ll have a group of font rou-\ntines bundled with the data—the typeface na mes, point sizes, and font attributes—they \noperate on. The collection of font routines and data is an ADT. If you’re not using ADTs, you’ll take an ad hoc approach to ma nipulating fonts.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 451, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 793}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0452_a40f696b", "text": "The collection of font routines and data is an ADT. If you’re not using ADTs, you’ll take an ad hoc approach to ma nipulating fonts. For \nexample, if you need to change to a 12-point font size, which happens to be 16 pixels \nhigh, you’ll have code like this:\ncurrentFont.size = 16\n6.1 Class Foundations: Abstract Data Types (ADTs) 127\nIf you’ve built up a collection of library routines, the code might be slightly more \nreadable:\ncurrentFont.size = PointsToPixels( 12 )\nOr you could provide a more specific name for the attribute, something like\ncurrentFont.sizeInPixels = PointsToPixels( 12 )\nBut what you can’t do is have both currentFont.sizeInPixels and currentFont.sizeInPoints , \nbecause, if both the data members are in play, currentFont won’t have any way to know \nwhich of the two it should use. And if you change sizes in several places in the pro-\ngram, you’ll have similar lines spread throughout your program.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 452, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0453_4e59e49c", "text": "And if you change sizes in several places in the pro-\ngram, you’ll have similar lines spread throughout your program. If you need to set a font to bold, you might have code like this that uses a logical or and \na hexidecimal constant 0x02 : \ncurrentFont.attribute = currentFont.attribute or 0x02\nIf you’re lucky, you’ll have something cleaner than that, but the best you’ll get with an \nad hoc approach is something like this:\ncurrentFont.attribute = currentFont.attribute or BOLD\nOr maybe something like this:\ncurrentFont.bold = True\nAs with the font size, the limitation is that the client code is required to control the \ndata members directly, which limits how currentFont can be used. If you program this way, you’re likely to have similar lines in many places in your \nprogram. Benefits of Using ADTs\nThe problem isn’t that the ad hoc approach is bad programming practice.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 453, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 878}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0454_5f40c983", "text": "If you program this way, you’re likely to have similar lines in many places in your \nprogram. Benefits of Using ADTs\nThe problem isn’t that the ad hoc approach is bad programming practice. It’s that you \ncan replace the approach with a better programming practice that produces these \nbenefits:\nYou can hide implementation details Hiding information about the font data type \nmeans that if the data type changes, you ca n change it in one place without affecting \nthe whole program. For example, unless yo u hid the implementation details in an \nADT, changing the data type from the first representation of bold to the second would \nentail changing your program in every place in which bold was set rather than in just \none place. Hiding the information also protects the rest of the program if you decide \nto store data in external storage rather th an in memory or to rewrite all the font-\nmanipulation routines in another language.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 454, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 934}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0455_edf549a6", "text": "128\nChapter 6: Working Classes\nChanges don’t affect the whole program If fonts need to become richer and support \nmore operations (such as switching to small caps, superscripts, strikethrough, and so \non), you can change the program in one place. The change won’t affect the rest of the \nprogram. You can make the interface more informative Code like currentFont.size = 16 is \nambiguous because 16 could be a size in either pixels or points. The context doesn’t \ntell you which is which. Collecting all similar operations into an ADT allows you to \ndefine the entire interface in terms of points, or in terms of pixels, or to clearly differ-\nentiate between the two, which helps avoid confusing them. It’s easier to improve performance If you need to improve font performance, you can \nrecode a few well-defined routines rather than wading through an entire program.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 455, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 866}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0456_255e6682", "text": "It’s easier to improve performance If you need to improve font performance, you can \nrecode a few well-defined routines rather than wading through an entire program. The program is more obviously correct You can replace the more tedious task of ver-\nifying that statements like currentFont.attribute = currentFont.attribute or 0x02 are cor-\nrect with the easier task of verifying that calls to currentFont.SetBoldOn() are correct. With the first statement, you can have the wrong structure name, the wrong field \nname, the wrong operation ( and instead of or), or the wrong\n \nvalue for the attribute \n(0x20 instead of 0x02 ). In the second case, the only thing that could possibly be \nwrong with the call to currentFont.SetBoldOn() is that it’s a call to the wrong routine \nname, so it’s easier to see whether it’s correct.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 456, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 823}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0457_b8bede32", "text": "In the second case, the only thing that could possibly be \nwrong with the call to currentFont.SetBoldOn() is that it’s a call to the wrong routine \nname, so it’s easier to see whether it’s correct. The program becomes more self-documenting You can improve statements like cur-\nrentFont.attribute or 0x02 by replacing 0x02 with BOLD or whatever 0x02 represents, but \nthat doesn’t compare to the readability of a routine call such as currentFont.SetBoldOn() . Woodfield, Dunsmore, and Shen conducted a study in which graduate and senior \nundergraduate computer-science students answered questions about two programs: \none that was divided into eight routines along functional lines, and one that was \ndivided into eight abstract-data-type routin es (1981). Students using the abstract-data-\ntype program scored over 30 percent higher than students using the functional ver-\nsion.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 457, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0458_68f3a8ff", "text": "Students using the abstract-data-\ntype program scored over 30 percent higher than students using the functional ver-\nsion. You don’t have to pass data all over your program In the examples just presented, \nyou have to change currentFont directly or pass it to every routine that works with fonts. If\n. you use an abstract data type, you don’t have to pass currentFont all over the program \nand you don’t have to turn it into global data either. The ADT has a structure that con-\ntains currentFont ’s data. The data is directly accessed only by routines that are part of the \nADT. Routines that aren’t part of the ADT don’t have to worry about the data. You’re able to work with real-world entities rather than with low-level implementation \nstructures You can define operations dealing with fonts so that most of the program \noperates solely in terms of fo nts rather than in terms of array accesses, structure defi-\nnitions, and True and False .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 458, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0459_52a3acc5", "text": "1\n23\nHARD DATA\n6.1 Class Foundations: Abstract Data Types (ADTs) 129\nIn this case, to define an abstract data type, you’d define a few routines to control \nfonts—perhaps like this:\ncurrentFont.SetSizeInPoints( sizeInPoints )\ncurrentFont.SetSizeInPixels( sizeInPixels )\ncurrentFont.SetBoldOn()\ncurrentFont.SetBoldOff()\ncurrentFont.SetItalicOn()\ncurrentFont.SetItalicOff()\ncurrentFont.SetTypeFace( faceName )\nThe code inside these routines would probab ly be short—it would probably be similar \nto the code you saw in the ad hoc approach to the font problem earlier. The difference \nis that you’ve isolated font operations in a set of routines. That provides a better level \nof abstraction for the rest of your program to work with fonts, and it gives you a layer \nof protection against changes in font operations. More Examples of ADTs\nSuppose you’re writing software that controls the cooling system for a nuclear reactor.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 459, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0460_2d147b44", "text": "More Examples of ADTs\nSuppose you’re writing software that controls the cooling system for a nuclear reactor. You can treat the cooling system as an abstract data type by defining the following \noperations for it:\ncoolingSystem.GetTemperature()\ncoolingSystem.SetCirculationRate( rate )\ncoolingSystem.OpenValve( valveNumber )\ncoolingSystem.CloseValve( valveNumber )\nThe specific environment would determine th e code written to implement each of \nthese operations. The rest of the program could deal with the cooling system through \nthese functions and wouldn’t have to worry about internal details of data-structure \nimplementations, data-structure limitations, changes, and so on.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 460, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 681}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0461_bccb2334", "text": "Here are more examples of abstract data types and likely operations on them:\nKEY POINT\nCruise Contro l Blender Fuel Tank\nSet speed Turn on Fill tank\nGet current settings Turn off Drain tank\nResume former speed Set speed Get tank capacity\nDeactivate Start “Insta-Pulverize” Get tank status\nStop “Insta-Pulverize”\nList Stack\nInitialize list Light Initialize stack \nInsert item in list Turn on Push item onto stack\nRemove item from list Turn off Pop item from stack\nRead next item from list Read top of stack\n130\nChapter 6: Working Classes\nYon can derive several guidelines from a st udy of these examples; those guidelines are \ndescribed in the following subsections: \nBuild or use typical low-level data types as ADTs, not as low-level data types Most \ndiscussions of ADTs focus on representing ty pical low-level data types as ADTs. As you \ncan see from the examples, you can represent a stack, a list, and a queue, as well as vir-\ntually any other typical data type, as an ADT.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 461, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0462_6a5666c4", "text": "As you \ncan see from the examples, you can represent a stack, a list, and a queue, as well as vir-\ntually any other typical data type, as an ADT. The question you need to ask is, “What does this stack, list, or queue represent?” If a \nstack represents a set of employees, treat the ADT as employees rather than as a stack. If a list represents a set of billing records, tr eat it as billing records rather than a list. If \na queue represents cells in a spreadsheet, trea t it as a collection of cells rather than a \ngeneric item in a queue. Treat yourself to the highest possible level of abstraction. Treat common objects such as files as ADTs Most languages include a few abstract \ndata types that you’re probably familiar with but might not think of as ADTs. File oper-\nations are a good example.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 462, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 799}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0463_9fcbc97a", "text": "Treat common objects such as files as ADTs Most languages include a few abstract \ndata types that you’re probably familiar with but might not think of as ADTs. File oper-\nations are a good example. While writing to disk, the operating system spares you the \ngrief of positioning the read/write head at a specific physical address, allocating a new \ndisk sector when you exhaust an old one, an d interpreting cryptic error codes. The oper-\nating system provides a first level of abstraction and the ADTs for that level. High-level \nlanguages provide a second level of abstraction and ADTs for that higher level. A high-\nlevel language protects you from the messy details of generating operating-system calls \nand manipulating data buffers. It allows you to treat a chunk of disk space as a “file.”\nYou can layer ADTs similarly. If you want to use an ADT at one level that offers data-\nstructure level operations (like pushing and popping a stack), that’s fine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 463, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0464_908a606d", "text": "If you want to use an ADT at one level that offers data-\nstructure level operations (like pushing and popping a stack), that’s fine. You can cre-\nate another level on top of that one that works at the level of the real-world problem.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 464, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 233}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0465_bb2fbd15", "text": "You can cre-\nate another level on top of that one that works at the level of the real-world problem. Set of Help Screens Menu File\nAdd help topic Start new menu Open file\nRemove help topic Delete menu Read file\nSet current help topic Add menu item Write file\nDisplay help screen Remove menu item Set current file location\nRemove help display Activate menu item Close file\nDisplay help index Deactivate menu item\nBack up to previous screen Display menu Elevator\nHide menu Move up one floor\nPointer Get menu choice Move down one floor\nGet pointer to new memory Move to specific floor\nDispose of memory from \nexisting pointerReport current floor\nReturn to home floor\nChange amount of memory \nallocated\n6.1 Class Foundations: Abstract Data Types (ADTs) 131\nTreat even simple items as ADTs You don’t have to have a formidable data type to \njustify using an abstract data type. One of th e ADTs in the example list is a light that \nsupports only two operations—turning it on and turning it off.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 465, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0466_3ab56982", "text": "One of th e ADTs in the example list is a light that \nsupports only two operations—turning it on and turning it off. You might think that it \nwould be a waste to isolate simple “on” and “off” operations in routines of their own, \nbut even simple operations can benefit from the use of ADTs. Putting the light and its \noperations into an ADT makes the code more self-documenting and easier to change, \nconfines the potential consequences of changes to the TurnLightOn() and TurnLight-\nOff() routines, and reduces the number of data items you have to pass around. Refer to an ADT independently of the medium it’s stored on Suppose you have an \ninsurance-rates table that’s so big that it’s always stored on disk. You might be \ntempted to refer to it as a “rate file” and create access routines such as RateFile.Read() . When you refer to it as a file, however, you’re exposing more information about the \ndata than you need to.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 466, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 925}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0467_c6733a5d", "text": "When you refer to it as a file, however, you’re exposing more information about the \ndata than you need to. If you ever change the program so that the table is in memory \ninstead of on disk, the code that refers to it as a file will be incorrect, misleading, and \nconfusing. Try to make the names of cla sses and access routines independent of how \nthe data is stored, and refer to the abstract data type, like the insurance-rates table, \ninstead. That would give your class and access routine names like rateTable.Read() or \nsimply rates.Read() . Handling Multiple Instances of Da ta with ADTs in Non-Object-\nOriented Environments\nObject-oriented languages provide automatic support for handling multiple instances \nof an ADT. If you’ve worked exclusively in object-oriented environments and you’ve \nnever had to handle the implementation deta ils of multiple instances yourself, count \nyour blessings!", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 467, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 903}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0468_1d0bc401", "text": "If you’ve worked exclusively in object-oriented environments and you’ve \nnever had to handle the implementation deta ils of multiple instances yourself, count \nyour blessings! (You can also move on to the next section, “ADTs and Classes.”)\nIf you’re working in a non-object-oriented environment such as C, you will have to \nbuild support for multiple instances manually. In general, that means including ser-\nvices for the ADT to create and delete instances and designing the ADT’s other ser-\nvices so that they can work with multiple instances.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 468, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 545}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0469_73b1417a", "text": "In general, that means including ser-\nvices for the ADT to create and delete instances and designing the ADT’s other ser-\nvices so that they can work with multiple instances. The font ADT originally offered these services:\ncurrentFont.SetSize( sizeInPoints )\ncurrentFont.SetBoldOn()\ncurrentFont.SetBoldOff()\ncurrentFont.SetItalicOn()\ncurrentFont.SetItalicOff()\ncurrentFont.SetTypeFace( faceName )\n132\nChapter 6: Working Classes\nIn a non-object-oriented environment, these functions would not be attached to a \nclass and would look more like this:\nSetCurrentFontSize( sizeInPoints )\nSetCurrentFontBoldOn()\nSetCurrentFontBoldOff()\nSetCurrentFontItalicOn()\nSetCurrentFontItalicOff()\nSetCurrentFontTypeFace( faceName )\nIf you want to work with more than one font at a time, you’ll need to add services to \ncreate and delete font instances—maybe these:\nCreateFont( fontId )\nDeleteFont( fontId )\nSetCurrentFont( fontId )\nThe notion of a fontId has been added as a way to ke ep track of multiple fonts as \nthey’re created and used.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 469, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1024}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0470_f3db3ab8", "text": "For other operations, you can choose from among three \nways to handle the ADT interface:\n■\nOption 1: Explicitly identify instances each time you use ADT services. In this \ncase, you don’t have the notion of a “current font.” You pass fontId to each rou-\ntine that manipulates fonts. The Font functions keep track of any underlying \ndata, and the client code needs to keep track only of the fontId . This requires \nadding fontId as a parameter to each font routine. ■\nOption 2: Explicitly provide the data used by the ADT services. In this approach, \nyou declare the data that the ADT uses within each routine that uses an ADT ser-\nvice. In other words, you create a Font data type that you pass to each of the ADT \nservice routines. You must design the ADT service routines so that they use the \nFont data that’s passed to them each time they’re called. The client code doesn’t \nneed a font ID if you use this approach because it keeps track of the font data \nitself.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 470, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0471_3bed98fe", "text": "The client code doesn’t \nneed a font ID if you use this approach because it keeps track of the font data \nitself. (Even though the data is available directly from the Font data type, you \nshould access it only with the ADT servi ce routines. This is called keeping the \nstructure “closed.”) \nThe advantage of this approach is that the ADT service routines don’t have to \nlook up font information based on a font ID. The disadvantage is that it exposes \nfont data to the rest of the program, wh ich increases the likelihood that client \ncode will make use of the ADT’s impl ementation details that should have \nremained hidden within the ADT. ■\nOption 3: Use implicit instances (with great care). Design a new service to call to \nmake a specific font instance the current one—something like SetCurrentFont\n( fontId ) . Setting the current font makes all other services use the current font \nwhen they’re called. If you use this approach, you don’t need fontId as a param-\neter to the other services.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 471, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0472_74d2cdf2", "text": "Setting the current font makes all other services use the current font \nwhen they’re called. If you use this approach, you don’t need fontId as a param-\neter to the other services. For simple a pplications, this can streamline use of \n6.2 Good Class Interfaces 133\nmultiple instances. For complex applications, this systemwide dependence on \nstate means that you must keep track of the current font instance throughout \ncode that uses the Font functions. Complexity tends to proliferate, and for appli-\ncations of any size, better alternatives exist. Inside the abstract data type, you’ll have a wealth of options for handling multiple \ninstances, but outside, this sums up the choices if you’re working in a non-object-ori-\nented language. ADTs and Classes\nAbstract data types form the foundation for the concept of classes. In languages that \nsupport classes, you can implement each abst ract data type as its own class. Classes \nusually involve the additional concepts of inheritance and polymorphism.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 472, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0473_d477a68b", "text": "In languages that \nsupport classes, you can implement each abst ract data type as its own class. Classes \nusually involve the additional concepts of inheritance and polymorphism. One way of \nthinking of a class is as an abstract da ta type plus inheritance and polymorphism. 6.2 Good Class Interfaces\nThe first and probably most important step in creating a high-quality class is creating \na good interface. This consists of creating a good abstraction for the interface to repre-\nsent and ensuring that the details re main hidden behind the abstraction. Good Abstraction\nAs “Form Consistent Abstractions” in Sectio n 5.3 described, abstraction is the ability \nto view a complex operation in a simplified form. A class interface provides an abstrac-\ntion of the implementation that’s hidden behind the interface. The class’s interface \nshould offer a group of routines that clearly belong together. You might have a class that implements an employee.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 473, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0474_91858a4f", "text": "The class’s interface \nshould offer a group of routines that clearly belong together. You might have a class that implements an employee. It would contain data describing \nthe employee’s name, address, phone number, and so on. It would offer services to ini-\ntialize and use an employee. Here’s how that might look. C+ + Example of a Class Interface That Presents a Good Abstraction\nCross-Reference Code sam-\nples in this book are format-\nted using a coding \nconvention that emphasizes \nsimilarity of styles across \nmultiple languages. For \ndetails on the convention \n(and discussions about mul-\ntiple coding styles), see \n“Mixed-Language Program-\nming Considerations” in \nSection 11.4.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 474, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 686}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0475_ebd2f4f5", "text": "For \ndetails on the convention \n(and discussions about mul-\ntiple coding styles), see \n“Mixed-Language Program-\nming Considerations” in \nSection 11.4. class Employee {\npublic:\n // public constructors and destructors\n Employee();\n Employee( \n FullName name, \n String address, \n String workPhone, \n String homePhone,\n TaxId taxIdNumber, \n JobClassification jobClass \n );\n virtual ~Employee();\n134\nChapter 6: Working Classes\n // public routines\n FullName GetName() const; \n String GetAddress() const; \n String GetWorkPhone() const; \n String GetHomePhone() const; \n TaxId GetTaxIdNumber() const; \n JobClassification GetJobClassification() const; \n ... private:\n ... };\nInternally, this class might have additional routines and data to support these ser-\nvices, but users of the class don’t need to know anything about them. The class inter-\nface abstraction is great because every routine in the interface is working toward a \nconsistent end.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 475, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0476_d953b728", "text": "The class inter-\nface abstraction is great because every routine in the interface is working toward a \nconsistent end. A class that presents a poor abstraction wo uld be one that contained a collection of \nmiscellaneous functions. Here’s an example:\nC+ + Example of a Class Interface That Presents a Poor Abstraction\nclass Program {\npublic:\n ... // public routines\n void InitializeCommandStack();\n void PushCommand( Command command );\n Command PopCommand(); \n void ShutdownCommandStack();\n void InitializeReportFormatting(); \n void FormatReport( Report report );\n void PrintReport( Report report );\n void InitializeGlobalData(); \n void ShutdownGlobalData(); \n ... private:\n ... };\nSuppose that a class contains routines to work with a command stack, to format \nreports, to print reports, and to initialize global data. It’s hard to see any connection \namong the command stack and report routines or the global data.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 476, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 915}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0477_16813d3c", "text": "It’s hard to see any connection \namong the command stack and report routines or the global data. The class interface \ndoesn’t present a consistent abstraction, so the class has poor cohesion. The routines \nshould be reorganized into more-focused classes, each of which provides a better \nabstraction in its interface. If these routines were part of a Program class, they could be revised to present a con-\nsistent abstraction, like so: \nCODING \nHORROR\n6.2 Good Class Interfaces 135\nC+ + Example of a Class Interface Th at Presents a Better Abstraction\nclass Program {\npublic:\n ... // public routines\n void InitializeUserInterface(); \n void ShutDownUserInterface(); \n void InitializeReports(); \n void ShutDownReports(); \n ... private:\n ... };\nThe cleanup of this interface assumes that some of the original routines were moved \nto other, more appropriate classes and some were converted to private routines used \nby InitializeUserInterface() and the other routines.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 477, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0478_30472d23", "text": "This evaluation of class abstraction is ba sed on the class’s collection of public rou-\ntines—that is, on the class’s interface. The routines inside the class don’t necessarily \npresent good individual abstractions just be cause the overall class does, but they need \nto be designed to present good abstractions too. For guidelines on that, see Section \n7.2, “Design at the Routine Level.”\nThe pursuit of good, abstract interfaces give s rise to several guid elines for creating \nclass interfaces. Present a consistent level of abstraction in the class interface A good way to think \nabout a class is as the mechanism for implem enting the abstract data types described \nin Section 6.1. Each class should implement one and only one ADT. If you find a class \nimplementing more than one ADT, or if you can’t determine what ADT the class \nimplements, it’s time to reorganize the class into one or more well-defined ADTs.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 478, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0479_d3e3b789", "text": "If you find a class \nimplementing more than one ADT, or if you can’t determine what ADT the class \nimplements, it’s time to reorganize the class into one or more well-defined ADTs. Here’s an example of a class that presents an interface that’s inconsistent because its \nlevel of abstraction is not uniform: \nC+ + Example of a Class Interface with Mixed Levels of Abstraction\nclass EmployeeCensus: public ListContainer {\npublic:\n ... // public routines\nThe abstraction of these \nroutines is at the “employee” \nlevel. void AddEmployee( Employee employee ); \n void RemoveEmployee( Employee employee ); \nThe abstraction of these \nroutines is at the “list” level. Employee NextItemInList();\n Employee FirstItem();\n Employee LastItem();\n ... private:\n ... };\nCODING \nHORROR\n136\nChapter 6: Working Classes\nThis class is presenting two ADTs: an Employee and a ListContainer .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 479, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 867}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0480_e0c6e800", "text": "private:\n ... };\nCODING \nHORROR\n136\nChapter 6: Working Classes\nThis class is presenting two ADTs: an Employee and a ListContainer . This sort of mixed \nabstraction commonly arises when a prog rammer uses a container class or other \nlibrary classes for implementation and doesn’t hide the fact that a library class is used. Ask yourself whether the fact that a container class is used should be part of the \nabstraction. Usually that’s an implementation detail that should be hidden from the \nrest of the program, like this:\nC+ + Example of a Class Interface with Consistent Levels of Abstraction\nclass EmployeeCensus {\npublic:\n ... // public routines\nThe abstraction of all these \nroutines is now at the \n“employee” level. void AddEmployee( Employee employee ); \n void RemoveEmployee( Employee employee ); \n Employee NextEmployee();\n Employee FirstEmployee();\n Employee LastEmployee();\n ... private:\nThat the class uses the \nListContainer library is now \nhidden. ListContainer m_EmployeeList; \n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 480, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0481_0f3df575", "text": "private:\nThat the class uses the \nListContainer library is now \nhidden. ListContainer m_EmployeeList; \n ... };\nProgrammers might argue that inheriting from ListContainer is convenient because it \nsupports polymorphism, allowing an external search or sort function that takes a List-\nContainer object. That argument fails the main te st for inheritance, which is, “Is inher-\nitance used only for “is a” re lationships?” To inherit from ListContainer would mean \nthat EmployeeCensus “is a” ListContainer , which obviously isn’t true. If the abstraction \nof the EmployeeCensus object is that it can be searched or sorted, that should be incor-\nporated as an explicit, consistent part of the class interface. If you think of the class’s public routines as an air lock that keeps water from getting \ninto a submarine, inconsistent public routines are leaky panels in the class.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 481, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 872}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0482_99e3a15f", "text": "If you think of the class’s public routines as an air lock that keeps water from getting \ninto a submarine, inconsistent public routines are leaky panels in the class. The leaky \npanels might not let water in as quickly as an open air lock, but if you give them \nenough time, they’ll still sink the boat. In practice, this is what happens when you mix \nlevels of abstraction. As the program is modified, the mixed levels of abstraction make \nthe program harder and harder to understand, and it gradually degrades until it \nbecomes unmaintainable. Be sure you understand what abstraction the class is implementing Some classes are \nsimilar enough that you must be careful to understand which abstraction the class \ninterface should capture. I once worked on a program that needed to allow informa-\ntion to be edited in a table format.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 482, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 833}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0483_5f568caa", "text": "I once worked on a program that needed to allow informa-\ntion to be edited in a table format. We wanted to use a simple grid control, but the grid \ncontrols that were available didn’t allow us to color the data-entry cells, so we decided \nto use a spreadsheet control that did provide that capability. KEY POINT\n6.2 Good Class Interfaces 137\nThe spreadsheet control was far more complicated than the grid control, providing \nabout 150 routines to the grid control’s 15. Since our goal was to use a grid control, \nnot a spreadsheet control, we assigned a pr ogrammer to write a wrapper class to hide \nthe fact that we were using a spreadsheet control as a grid control. The programmer \ngrumbled quite a bit about unnecessary overhead and bureaucracy, went away, and \ncame back a couple days later with a wrapper class that faithfully exposed all 150 rou-\ntines of the spreadsheet control. This was not what was needed.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 483, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0484_9eb0942a", "text": "This was not what was needed. We wanted a grid-control interface that encapsulated \nthe fact that, behind the scenes, we were using a much more complicated spreadsheet \ncontrol. The programmer should have exposed just the 15 grid-control routines plus \na 16th routine that supported cell coloring. By exposing all 150 routines, the program-\nmer created the possibility that, if we ev er wanted to change the underlying imple-\nmentation, we could find ourselves supporting 150 public routines. The programmer \nfailed to achieve the encapsulation we were lo oking for, as well as creating a lot more \nwork for himself than necessary. Depending on specific circumstances, the righ t abstraction might be either a spread-\nsheet control or a grid control. When you have to choose between two similar abstrac-\ntions, make sure you choose the right one. Provide services in pairs with their opposites Most operations have corresponding, \nequal, and opposite operations.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 484, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0485_75579a14", "text": "Provide services in pairs with their opposites Most operations have corresponding, \nequal, and opposite operations. If you have an operation that turns a light on, you’ll \nprobably need one to turn it off. If you have an operation to add an item to a list, you’ll \nprobably need one to delete an item from the list. If you have an operation to activate \na menu item, you’ll probably need one to deac tivate an item. When you design a class, \ncheck each public routine to determine whether you need its complement. Don’t cre-\nate an opposite gratuitously, but do check to see whether you need one. Move unrelated information to another class In some cases, you’ll find that half a \nclass’s routines work with half the class’s data and half the routines work with the \nother half of the data. In such a case, you re ally have two classes masquerading as one. Break them up! Make interfaces programmatic rather than semantic when possible Each interface \nconsists of a programmatic part and a semantic part.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 485, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0486_df59b356", "text": "Break them up! Make interfaces programmatic rather than semantic when possible Each interface \nconsists of a programmatic part and a semantic part. The programmatic part consists of \nthe data types and other attributes of the interface that can be enforced by the compiler. The semantic part of the interface consists of the assumptions about how the interface \nwill be used, which cannot be enforced by the compiler. The semantic interface includes \nconsiderations such as “ RoutineA must be called before RoutineB ” or “ RoutineA will crash \nif dataMember1 isn’t initialized before it’s passed to RoutineA .” The semantic interface \nshould be documented in comments, but try to keep interfaces minimally dependent \non documentation. Any aspect of an interface that can’t be enforced by the compiler is \nan aspect that’s likely to be misused. Look for ways to convert semantic interface ele-\nments to programmatic interface elements by using Asserts or other techniques.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 486, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0487_e9d9798b", "text": "Look for ways to convert semantic interface ele-\nments to programmatic interface elements by using Asserts or other techniques. 138\nChapter 6: Working Classes\nCross-Reference For more \nsuggestions about how to \npreserve code quality as \ncode is modified, see Chap-\nter 24, “Refactoring.” \nBeware of erosion of the interface’s abstraction under modification As a class is \nmodified and extended, you often discover ad ditional functionality that’s needed, that \ndoesn’t quite fit with the original class interface, but that seems too hard to implement \nany other way. For example, in the Employee class, you might find that the class \nevolves to look like this:\nC+ + Example of a Class Interface That’s Eroding Under Maintenance\nclass Employee {\npublic:\n ... // public routines\n FullName GetName() const; \n Address GetAddress() const; \n PhoneNumber GetWorkPhone() const; \n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 487, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 875}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0488_c7bda228", "text": "// public routines\n FullName GetName() const; \n Address GetAddress() const; \n PhoneNumber GetWorkPhone() const; \n ... bool IsJobClassificationValid( JobClassification jobClass ); \n bool IsZipCodeValid( Address address ); \n bool IsPhoneNumberValid( PhoneNumber phoneNumber ); \n SqlQuery GetQueryToCreateNewEmployee() const; \n SqlQuery GetQueryToModifyEmployee() const; \n SqlQuery GetQueryToRetrieveEmployee() const; \n ... private:\n ... };\nWhat started out as a clean abstraction in an earlier code sample has evolved into a \nhodgepodge of functions that are only loosely related. There’s no logical connection \nbetween employees and routines that check ZIP Codes, phone numbers, or job classi-\nfications. The routines that expose SQL qu ery details are at a much lower level of \nabstraction than the Employee class, and they break the Employee abstraction.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 488, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 855}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0489_b95ffd82", "text": "The routines that expose SQL qu ery details are at a much lower level of \nabstraction than the Employee class, and they break the Employee abstraction. Don’t add public members that are incon sistent with the interface abstraction Each \ntime you add a routine to a class interface, ask “Is this routine consistent with the \nabstraction provided by the existing interface?” If not, find a different way to make the \nmodification and preserve the integrity of the abstraction. Consider abstraction and cohesion together The ideas of abstraction and cohesion \nare closely related—a class interface that presents a good abstraction usually has \nstrong cohesion. Classes with strong cohe sion tend to present good abstractions, \nalthough that relationship is not as strong. I have found that focusing on the abstraction presented by the class interface tends to \nprovide more insight into cla ss design than focusing on cl ass cohesion.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 489, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 931}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0490_797f535c", "text": "I have found that focusing on the abstraction presented by the class interface tends to \nprovide more insight into cla ss design than focusing on cl ass cohesion. If you see that \na class has weak cohesion and aren’t sure how to correct it, ask yourself whether the \nclass presents a consistent abstraction instead. CODING \nHORROR\n6.2 Good Class Interfaces 139\nGood Encapsulation\nCross-Reference For more \non encapsulation, see \n“Encapsulate Implementa-\ntion Details” in Section 5.3. As Section 5.3 discussed, encapsulation is a stronger concept than abstraction. Abstraction helps to manage complexity by providing models that allow you to ignore \nimplementation details. Encapsulation is the enforcer that prevents you from looking \nat the details even if you want to. The two concepts are related because, without encapsulation, abstraction tends to \nbreak down. In my experience, either you have both abstraction and encapsulation or \nyou have neither. There is no middle ground.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 490, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0491_438364e0", "text": "In my experience, either you have both abstraction and encapsulation or \nyou have neither. There is no middle ground. The single most important \nfactor that distinguishes a \nwell-designed module from \na poorly designed one is the \ndegree to which the module \nhides its internal data and \nother implementation details \nfrom other modules. —Joshua Bloch\nMinimize accessibility of classes and members Minimizing accessibility is one of \nseveral rules that are designed to encour age encapsulation. If you’re wondering \nwhether a specific routine should be public, private, or protected, one school of \nthought is that you should favor the strictest level of privacy that’s workable (Meyers \n1998, Bloch 2001). I think that’s a fine guideline, but I think the more important \nguideline is, “What best preserves the integr ity of the interface abstraction?” If expos-\ning the routine is consistent with the abstract ion, it’s probably fine to expose it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 491, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0492_226b05f8", "text": "If \nyou’re not sure, hiding more is generally better than hiding less. Don’t expose member data in public Exposing member data is a violation of encap-\nsulation and limits your control over the ab straction. As Arthur Riel points out, a Point \nclass that exposes \nfloat x;\nfloat y;\nfloat z;\nis violating encapsulation because client code is free to monkey around with Point ’s \ndata and Point won’t necessarily even know when its values have been changed (Riel \n1996). However, a Point class that exposes \nfloat GetX();\nfloat GetY();\nfloat GetZ();\nvoid SetX( float x );\nvoid SetY( float y );\nvoid SetZ( float z );\nis maintaining perfect encapsulation. You have no idea whether the underlying imple-\nmentation is in terms of floats x, y, and z, whether Point is storing those items as dou-\nbles and converting them to floats, or whether Point is storing them on the moon and \nretrieving them from a satellite in outer space.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 492, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0493_84d7d7a7", "text": "Avoid putting private implementati on details into a class’s interface With true \nencapsulation, programmers would not be able to see implementation details at all. They would be hidden both figuratively an d literally. In popular languages, including \n140\nChapter 6: Working Classes\nC++, however, the structure of the language requires programmers to disclose imple-\nmentation details in the class interface. Here’s an example:\nC+ + Example of Exposing a Cl ass’s Implementation Details\nclass Employee {\npublic:\n ... Employee( \n FullName name,\n String address,\n String workPhone,\n String homePhone,\n TaxId taxIdNumber,\n JobClassification jobClass \n );\n ... FullName GetName() const; \n String GetAddress() const; \n ... private:\nHere are the exposed \nimplementation details. String m_Name;\n String m_Address;\n int m_jobClass;\n ... };\nIncluding private declarations in the class header file might seem like a small trans-\ngression, but it encourages other prog rammers to examine the implementation \ndetails.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 493, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0494_22efe478", "text": "};\nIncluding private declarations in the class header file might seem like a small trans-\ngression, but it encourages other prog rammers to examine the implementation \ndetails. In this case, the client code is intended to use the Address type for addresses \nbut the header file exposes the implementation detail that addresses are stored as \nStrings . Scott Meyers describes a common way to address this issue in Item 34 of Effective C++ , \n2d ed. (Meyers 1998). You separate the class interface from the class implementation. Within the class declaration, include a poin ter to the class’s implementation but don’t \ninclude any other implementation details. C+ + Example of Hiding a Cl ass’s Implementation Details\nclass Employee {\npublic:\n ... Employee( ... );\n ... FullName GetName() const; \n String GetAddress() const; \n ... private:\nHere the implementation \ndetails are hidden behind \nthe pointer.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 494, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0495_14548dc4", "text": "Employee( ... );\n ... FullName GetName() const; \n String GetAddress() const; \n ... private:\nHere the implementation \ndetails are hidden behind \nthe pointer. EmployeeImplementation *m_implementation;\n};\n6.2 Good Class Interfaces 141\nNow you can put implementation details inside the EmployeeImplementation class, \nwhich should be visible only to the Employee class and not to the code that uses the \nEmployee class. If you’ve already written lots of code that doesn’t use this approach for your project, \nyou might decide it isn’t worth the effort to convert a mountain of existing code to use \nthis approach. But when you read code that exposes its implementation details, you \ncan resist the urge to comb through the private section of the class interface looking \nfor implementation clues. Don’t make assumptions about the class’s users A class should be designed and \nimplemented to adhere to the contract implied by the class interface.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 495, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0496_d2440d6b", "text": "Don’t make assumptions about the class’s users A class should be designed and \nimplemented to adhere to the contract implied by the class interface. It shouldn’t \nmake any assumptions about how that interface will or won’t be used, other than \nwhat’s documented in the interface. Commen ts like the following one are an indica-\ntion that a class is more aware of its users than it should be:\n-- initialize x, y, and z to 1.0 because DerivedClass blows \n-- up if they're initialized to 0.0\nAvoid friend classes In a few circumstances such as the State pattern, friend classes \ncan be used in a disciplined way that contributes to managing complexity (Gamma et al. 1995). But, in general, friend classes viol ate encapsulation. They expand the amount of \ncode you have to think about at any one time, thereby increasing complexity. Don’t put a routine into the public interface just because it uses only public routines\nThe fact that a routine uses only public ro utines is not a significant consideration.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 496, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0497_2bf379b1", "text": "Don’t put a routine into the public interface just because it uses only public routines\nThe fact that a routine uses only public ro utines is not a significant consideration. Instead, ask whether exposing the routine would be consistent with the abstraction \npresented by the interface. Favor read-time convenience to write-time convenience Code is read far more times \nthan it’s written, even during initial development. Favoring a technique that speeds \nwrite-time convenience at the expense of read-time convenience is a false economy. This is especially applicable to creation of class interfaces. Even if a routine doesn’t \nquite fit the interface’s abstraction, someti mes it’s tempting to add a routine to an \ninterface that would be convenient for the part icular client of a class that you’re work-\ning on at the time. But adding that routine is the first step down a slippery slope, and \nit’s better not to take even the first step.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 497, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0498_ec50b715", "text": "But adding that routine is the first step down a slippery slope, and \nit’s better not to take even the first step. It ain’t abstract if you have to \nlook at the underlying imple-\nmentation to understand \nwhat’s going on. —P. J . P l a u g e r\nBe very, very wary of semantic violations of encapsulation At one time I thought \nthat when I learned how to avoid syntax errors I would be home free. I soon discov-\nered that learning how to avoid syntax errors had merely bought me a ticket to a \nwhole new theater of coding errors, most of which were more difficult to diagnose and \ncorrect than the syntax errors. The difficulty of semantic enca psulation compared to syntacti c encapsulation is similar. Syntactically, it’s relatively easy to avoid poking your nose into the internal workings of \nanother class just by declaring the class’s internal routines and data private . Achieving \n142\nChapter 6: Working Classes\nsemantic encapsulation is another matter entirely.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 498, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0499_ae99341c", "text": "Achieving \n142\nChapter 6: Working Classes\nsemantic encapsulation is another matter entirely. Here are some examples of the ways \nthat a user of a class can br eak encapsulation semantically:\n■\nNot calling Class A’s InitializeOperations() routine because you know that Class \nA’s PerformFirstOperation() routine calls it automatically. ■\nNot calling the database.Connect() routine before you call employee.Retrieve( \ndatabase ) because you know that the employee.Retrieve() function will connect \nto the database if there isn’t already a connection. ■\nNot calling Class A’s Terminate() routine because you know that Class A’s Per-\nformFinalOperation() routine has already called it. ■\nUsing a pointer or reference to ObjectB created by ObjectA even after ObjectA has \ngone out of scope, because you know that ObjectA keeps ObjectB in static storage \nand ObjectB will still be valid.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 499, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 881}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0500_0fa9bedc", "text": "■\nUsing a pointer or reference to ObjectB created by ObjectA even after ObjectA has \ngone out of scope, because you know that ObjectA keeps ObjectB in static storage \nand ObjectB will still be valid. ■\nUsing Class B’s MAXIMUM_ELEMENTS constant instead of using \nClassA.MAXIMUM_ELEMENTS , because you know that they’re both equal to \nthe same value. The problem with each of these examples is that they make the client code dependent \nnot on the class’s public interface, but on its private implementation. Anytime you \nfind yourself looking at a cl ass’s implementation to figure out how to use the class, \nyou’re not programming to the interface; you’re programming through the interface to \nthe implementation. If you’re programming through the interface, encapsulation is \nbroken, and once encapsulation starts to br eak down, abstraction won’t be far behind.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 500, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 862}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0501_5cd3b750", "text": "If you’re programming through the interface, encapsulation is \nbroken, and once encapsulation starts to br eak down, abstraction won’t be far behind. If you can’t figure out how to use a class ba sed solely on its interface documentation, \nthe right response is not to pull up the source code and look at the implementation. That’s good initiative but bad judgment. The right response is to contact the author of \nthe class and say “I can’t figure out how to use this class.” The right response on the \nclass-author’s part is not to answer your question face to face. The right response for \nthe class author is to check out the class-in terface file, modify the class-interface doc-\numentation, check the file back in, and then say “See if you can understand how it \nworks now.” You want this dialog to occur in th e interface code itself so that it will be \npreserved for future programmers.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 501, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 893}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0502_802a328f", "text": "You don’t want the dialog to occur solely in your \nown mind, which will bake subtle semantic dependencies into the client code that \nuses the class. And you don’t want the dialog to occur interpersonally so that it bene-\nfits only your code but no one else’s. Watch for coupling that’s too tight “Coupling” refers to how tight the connection is \nbetween two classes. In general, the looser the connection, the better. Several general \nguidelines flow from this concept: \n■\nMinimize accessibility of classes and members. ■\nAvoid friend classes, because they’re tightly coupled. KEY POINT\n6.3 Design and Implementation Issues 143\n■\nMake data private rather than protected in a base class to make derived classes \nless tightly coupled to the base class. ■\nAvoid exposing member data in a class’s public interface. ■\nBe wary of semantic violations of encapsulation. ■\nObserve the “Law of Demeter” (discussed in Section 6.3 of this chapter). Coupling goes hand in glove with abstra ction and encapsulat ion.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 502, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0503_bf06aa8f", "text": "■\nBe wary of semantic violations of encapsulation. ■\nObserve the “Law of Demeter” (discussed in Section 6.3 of this chapter). Coupling goes hand in glove with abstra ction and encapsulat ion. Tight coupling \noccurs when an abstraction is leaky, or when encapsulation is broken. If a class offers \nan incomplete set of services, other routines might find they need to read or write its \ninternal data directly. That opens up the cla ss, making it a glass box instead of a black \nbox, and it virtually eliminat es the class’s encapsulation. 6.3 Design and Implementation Issues\nDefining good class interfaces goes a lon g way toward creating a high-quality pro-\ngram. The internal class design and implemen tation are also important. This section \ndiscusses issues related to containment, inheritance, member functions and data, \nclass coupling, constructors, and value-vs.-reference objects.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 503, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 890}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0504_b90fa2a8", "text": "This section \ndiscusses issues related to containment, inheritance, member functions and data, \nclass coupling, constructors, and value-vs.-reference objects. Containment (“has a” Relationships)\nContainment is the simple idea that a cl ass contains a primitive data element or \nobject. A lot more is written about inheri tance than about containment, but that’s \nbecause inheritance is more tricky and error-prone, not because it’s better. Contain-\nment is the work-horse technique in object-oriented programming. Implement “has a” through containment One way of thinking of containment is as a \n“has a” relationship. For example, an empl oyee “has a” name, “has a” phone number, \n“has a” tax ID, and so on. You can usually accomplish this by making the name, phone \nnumber, and tax ID member data of the Employee class. Implement “has a” through private inheritance as a last resort In some instances \nyou might find that you can’t achieve containment through making one object a mem-\nber of another.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 504, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0505_611ed3d2", "text": "Implement “has a” through private inheritance as a last resort In some instances \nyou might find that you can’t achieve containment through making one object a mem-\nber of another. In that case, some experts suggest privately inheriting from the con-\ntained object (Meyers 1998, Sutter 2000). The main reason you would do that is to set \nup the containing class to access protecte d member functions or protected member \ndata of the class that’s contained. In practice, this approach creates an overly cozy rela-\ntionship with the ancestor class and violates encapsulation. It tends to point to design \nerrors that should be resolved some way other than through private inheritance. Be critical of classes that contain more than about seven data members The number \n“7±2” has been found to be a number of di screte items a person can remember while \nperforming other tasks (Miller 1956).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 505, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 887}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0506_5151c576", "text": "If a class contains more than about seven data \nKEY POINT\n144\nChapter 6: Working Classes\nmembers, consider whether the class should be decomposed into multiple smaller \nclasses (Riel 1996). You might err more towa rd the high end of 7±2 if the data mem-\nbers are primitive data types like integers and strings, more toward the lower end of \n7±2 if the data members are complex objects. Inheritance (“is a” Relationships) \nInheritance is the idea that one class is a specialization of another class. The purpose of \ninheritance is to create simpler code by de fining a base class that specifies common ele-\nments of two or more derived classes. The co mmon elements can be routine interfaces, \nimplementations, data members, or data types. Inheritance helps avoid the need to \nrepeat code and data in multiple location s by centralizing it within a base class. When you decide to use inheritance, you have to make several decisions:\n■\nFor each member routine, will the routine be visible to derived classes?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 506, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0507_a5b67733", "text": "When you decide to use inheritance, you have to make several decisions:\n■\nFor each member routine, will the routine be visible to derived classes? Will it \nhave a default implementation? Will the default implementation be overridable? ■\nFor each data member (including vari ables, named constants, enumerations, \nand so on), will the data member be visible to de rived classes? The following subsections explain the in s and outs of making these decisions:\nThe single most important \nrule in object-oriented pro-\ngramming with C++ is this: \npublic inheritance means \n“is a.” Commit this rule to \nmemory. —Scott Meyers\nImplement “is a” through public inheritance When a programmer decides to create \na new class by inheriting from an existing class, that programmer is saying that the \nnew class “is a” more specialized version of the older class. The base class sets expec-\ntations about how the derived class will operate and imposes constraints on how the \nderived class can operate (Meyers 1998).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 507, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0508_ff4ac5ba", "text": "The base class sets expec-\ntations about how the derived class will operate and imposes constraints on how the \nderived class can operate (Meyers 1998). If the derived class isn’t going to adhere completely to the same interface contract \ndefined by the base class, inheritance is not the right implementation technique. Con-\nsider containment or making a change further up the inheritance hierarchy. Design and document for inheritance or prohibit it Inheritance adds complexity to a \nprogram, and, as such, it’s a dangerous t echnique. As Java guru Joshua Bloch says, \n“Design and document for inheritance, or proh ibit it.” If a class isn’t designed to be \ninherited from, make its members non- virtual in C++, final in Java, or non- overridable \nin Microsoft Visual Basic so th at you can’t inherit from it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 508, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 811}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0509_2cb58d41", "text": "Adhere to the Liskov Substitution Principle (LSP) In one of object-oriented pro-\ngramming’s seminal papers, Barbara Liskov argued that you shouldn’t inherit from a \nbase class unless the derived cl ass truly “is a” more specifi c version of the base class \n(Liskov 1988). Andy Hunt and Dave Thom as summarize LSP like this: “Subclasses \nmust be usable through the base class interface without the need for the user to know \nthe difference” (Hunt and Thomas 2000). 6.3 Design and Implementation Issues 145\nIn other words, all the routines defined in the base class should mean the same thing \nwhen they’re used in each of the derived classes. If you have a base class of Account and derived classes of CheckingAccount , SavingsAc-\ncount , and AutoLoanAccount , a programmer should be able to invoke any of the rou-\ntines derived from Account on any of Account ’s subtypes without caring about which \nsubtype a specific account object is.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 509, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0510_2429dd13", "text": "If a program has been written so that the Li skov Substitution Principle is true, inher-\nitance is a powerful tool for reducing complexity because a programmer can focus on \nthe generic attributes of an object without worrying about the details. If a programmer \nmust be constantly thinking about semantic differences in subc lass implementations, \nthen inheritance is increasing complexity rather than reducing it. Suppose a program-\nmer has to think this: “If I call the InterestRate() routine on CheckingAccount or Sav-\ningsAccount , it returns the interest the bank pays, but if I call InterestRate() on \nAutoLoanAccount I have to change the sign because it returns the interest the con-\nsumer pays to the bank.” According to LSP, AutoLoanAccount should not inherit from \nthe Account base class in this example because the semantics of the InterestRate() rou-\ntine are not the same as the semantics of the base class’s InterestRate() routine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 510, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0511_c3b04e0a", "text": "Be sure to inherit only what you want to inherit A derived class can inherit member \nroutine interfaces, implementations, or bo th. Table 6-1 shows the variations of how \nroutines can be implemented and overridden. As the table suggests, inherited routines come in three basic flavors:\n■\nAn abstract overridable routine means that the derived class inherits the routine’s \ninterface but not its implementation. ■\nAn overridable routine means that the derived class inherits the routine’s inter-\nface and a default implementation and it is allowed to override the default \nimplementation. ■\nA non-overridable routine means that the derived class inherits the routine’s inter-\nface and its default implementation and it is not allowed to override the rou-\ntine’s implementation.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 511, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 776}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0512_a7b259fb", "text": "■\nA non-overridable routine means that the derived class inherits the routine’s inter-\nface and its default implementation and it is not allowed to override the rou-\ntine’s implementation. Table 6-1\nVariations on Inherited Routines \nOverridable\nNot Overridable\nImplementation: Default \nProvidedOverridable Routine Non-Overridable Routine\nImplementation: No Default \nProvidedAbstract Overridable \nRoutineNot used (doesn’t make sense to \nleave a routine undefined and \nnot allow it to be overridden)\n146\nChapter 6: Working Classes\nWhen you choose to implement a new class through inheritance, think through the \nkind of inheritance you want for each memb er routine. Beware of inheriting imple-\nmentation just because you’re inheriting an interface, and beware of inheriting an \ninterface just because you want to inherit an implementation. If you want to use a \nclass’s implementation but not its interface, use containment rather than inheritance.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 512, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0513_89be5a6e", "text": "If you want to use a \nclass’s implementation but not its interface, use containment rather than inheritance. Don’t “override” a non-overridable member function Both C++ and Java allow a pro-\ngrammer to override a non-overridable memb er routine—kind of. If a function is pri-\nvate in the base class, a derived class can create a function with the same name. To the \nprogrammer reading the code in the derived class, such a function can create confu-\nsion because it looks like it should be poly morphic, but it isn’t; it just has the same \nname. Another way to state this guideline is, “Don’t reuse names of non-overridable \nbase-class routines in derived classes.”\nMove common interfaces, data, and behavior as high as possible in the inheritance \ntree The higher you move interfaces, data, and behavior, the more easily derived \nclasses can use them. How high is too high? Let abstraction be your guide. If you find \nthat moving a routine higher would break the higher object’s abstraction, don’t do it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 513, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0514_13d7e726", "text": "How high is too high? Let abstraction be your guide. If you find \nthat moving a routine higher would break the higher object’s abstraction, don’t do it. Be suspicious of classes of which there is only one instance A single instance might \nindicate that the design confuses objects with classes. Consider whether you could \njust create an object instead of a new clas s. Can the variation of the derived class be \nrepresented in data rather than as a distinct class? The Singleton pattern is one nota-\nble exception to this guideline. Be suspicious of base classes of which there is only one derived class When I see a \nbase class that has only one derived class, I suspect that some programmer has been \n“designing ahead”—trying to anticipate fu ture needs, usually without fully under-\nstanding what those future needs are.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 514, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 824}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0515_bf6def32", "text": "The best way to prepare for future work is not to \ndesign extra layers of base classes that “m ight be needed someday”; it’s to make cur-\nrent work as clear, straightforward, and si mple as possible. That means not creating \nany more inheritance structure than is absolutely necessary. Be suspicious of classes that override a routine and do nothing inside the derived \nroutine This typically indicates an error in the design of the base class. For instance, \nsuppose you have a class Cat and a routine Scratch() and suppose that you eventually \nfind out that some cats are declawed and ca n’t scratch. You might be tempted to create \na class derived from Cat named ScratchlessCat and override the Scratch() routine to do \nnothing. This approach presents several problems:\n■\nIt violates the abstraction (inter face contract) presented in the Cat class by \nchanging the semantics of its interface. ■\nThis approach quickly gets out of control when you extend it to other derived \nclasses.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 515, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0516_471c305c", "text": "■\nThis approach quickly gets out of control when you extend it to other derived \nclasses. What happens when you find a ca t without a tail? Or a cat that doesn’t \ncatch mice? Or a cat that doesn’t drink milk? Eventually you’ll end up with \nderived classes like ScratchlessTaillessMicelessMilklessCat . 6.3 Design and Implementation Issues 147\n■\nOver time, this approach gives rise to code that’s confusing to maintain because \nthe interfaces and behavior of the ances tor classes imply littl e or nothing about \nthe behavior of their descendants. The place to fix this problem is not in the base class, but in the original Cat class. Cre-\nate a Claws class and contain that within the Cats class. The root problem was the \nassumption that all cats scratch, so fix th at problem at the source, rather than just \nbandaging it at the destination. Avoid deep inheritance trees Object-oriented programming provides a large number \nof techniques for managing complexity.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 516, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0517_10d026e8", "text": "Avoid deep inheritance trees Object-oriented programming provides a large number \nof techniques for managing complexity. But every powerful tool has its hazards, and \nsome object-oriented techniques have a tendency to increase complexity rather than \nreduce it. In his excellent book Object-Oriented Design Heuristics (1996), Arthur Riel suggests \nlimiting inheritance hierarchies to a maxi mum of six levels. Riel bases his recommen-\ndation on the “magic number 7±2,” but I thin k that’s grossly optimistic. In my experi-\nence most people have trouble juggling more than two or three levels of inheritance in \ntheir brains at once. The “magic number 7±2” is probably better applied as a limit to \nthe total number of subclasses of a base class rather than the number of levels in an \ninheritance tree. Deep inheritance trees have been found to be significantly associated with increased \nfault rates (Basili, Briand, and Melo 1996).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 517, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0518_79dd1c81", "text": "Deep inheritance trees have been found to be significantly associated with increased \nfault rates (Basili, Briand, and Melo 1996). Anyone who has ever tried to debug a com-\nplex inheritance hierarchy knows why. Deep inheritance trees increase complexity, \nwhich is exactly the opposite of what inheritance should be used to accomplish. Keep \nthe primary technical mission in mind. Make sure you’re using inheritance to avoid \nduplicating code and to minimize complexity . Prefer polymorphism to extensive type checking Frequently repeated case statements \nsometimes suggest that inherita nce might be a better design choice, although this is \nnot always true. Here is a classic example of code that cries out for a more object-ori-\nented approach: \nC+ + Example of a Case Statement That Probably Should Be Replaced \nby Polymorphism\nswitch ( shape.type ) {\n case Shape_Circle:\n shape.DrawCircle();\n break;\n case Shape_Square:\n shape.DrawSquare();\n break;\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 518, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 958}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0519_3cc0c2d1", "text": "}\n148\nChapter 6: Working Classes\nIn this example, the calls to shape.DrawCircle() and shape.DrawSquare() should be \nreplaced by a single routine named shape.Draw() , which can be called regardless of \nwhether the shape is a circle or a square. On the other hand, sometimes case statements are used to separate truly different \nkinds of objects or behavior. Here is an example of a case statement that is appropriate \nin an object-oriented program:\nC+ + Example of a Case Statement That Probably Should Not Be Replaced \nby Polymorphism\nswitch ( ui.Command() ) {\n case Command_OpenFile:\n OpenFile();\n break;\n case Command_Print:\n Print(); \n break;\n case Command_Save:\n Save(); \n break;\n case Command_Exit:\n ShutDown();\n break;\n ... }\nIn this case, it would be possible to create a base class with derived classes and a poly-\nmorphic DoCommand() routine for each command (as in the Command pattern).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 519, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 896}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0520_e8bdf90d", "text": "}\nIn this case, it would be possible to create a base class with derived classes and a poly-\nmorphic DoCommand() routine for each command (as in the Command pattern). But \nin a simple case like this one, the meaning of DoCommand() would be so diluted as to \nbe meaningless, and the case statement is the more understandable solution. Make all data private, not protected As Joshua Bloch says, “Inheritance breaks \nencapsulation” (2001). When you inherit from an object, you obtain privileged access \nto that object’s protected routines and data . If the derived class really needs access to \nthe base class’s attributes, provide protected accessor functions instead. Multiple Inheritance\nThe one indisputable fact \nabout multiple inheritance in \nC++ is that it opens up a \nPandora’s box of complexi-\nties that simply do not exist \nunder single inheritance. —Scott Meyers\nInheritance is a power tool. It’s like using a chain saw to cut down a tree instead of a \nmanual crosscut saw.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 520, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0521_6b4aff93", "text": "—Scott Meyers\nInheritance is a power tool. It’s like using a chain saw to cut down a tree instead of a \nmanual crosscut saw. It can be incredibly us eful when used with care, but it’s danger-\nous in the hands of someone who doesn’t observe proper precautions. 6.3 Design and Implementation Issues 149\nIf inheritance is a chain saw, multiple in heritance is a 1950s-era chain saw with no \nblade guard, no automatic shutoff, and a fi nicky engine. There are times when such a \ntool is valuable; mostly, however, you’re better off leaving the tool in the garage where \nit can’t do any damage. Although some experts recommend broad use of multiple inheritance (Meyer 1997), \nin my experience multiple inheritance is usef ul primarily for defining “mixins,” simple \nclasses that are used to add a set of proper ties to an object. Mixins are called mixins \nbecause they allow properties to be “mixed in” to derived classes. Mixins might be \nclasses like Displayable , Persistant , Serializable , or Sortable .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 521, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0522_01dc23bc", "text": "Mixins are called mixins \nbecause they allow properties to be “mixed in” to derived classes. Mixins might be \nclasses like Displayable , Persistant , Serializable , or Sortable . Mixins are nearly always \nabstract and aren’t meant to be instan tiated independently of other objects. Mixins require the use of multiple inheritance, but they aren’t subject to the classic \ndiamond-inheritance problem associated with multiple inheritance as long as all mix-\nins are truly independent of each other. They also make the design more comprehen-\nsible by “chunking” attributes together. A programmer will have an easier time \nunderstanding that an object uses the mixins Displayable and Persistent than under-\nstanding that an object uses the 11 more-specific routines that would otherwise be \nneeded to implement those two properties. Java and Visual Basic recognize the value of mixins by allowing multiple inheritance \nof interfaces but only single-class inherita nce.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 522, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0523_9ad25c4a", "text": "Java and Visual Basic recognize the value of mixins by allowing multiple inheritance \nof interfaces but only single-class inherita nce. C++ supports multiple inheritance of \nboth interface and implementation. Programmers should use multiple inheritance \nonly after carefully considering the alternatives and weighing the impact on system \ncomplexity and comprehensibility. Why Are There So Many Rules for Inheritance? This section has presented numerous rules for staying out of trouble with inheritance. The underlying message of all these rules is that inheritance tends to work against the pri-\nmary technical imperative you have as a programmer, which is to manage complexity . For the \nsake of controlling complexity, you should maintain a heavy bias against inheritance.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 523, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 776}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0524_660dd0d7", "text": "For the \nsake of controlling complexity, you should maintain a heavy bias against inheritance. Here’s a summary of when to use inheritance and when to use containment: \nCross-Reference For more \non complexity, see “Soft-\nware’s Primary Technical \nImperative: Managing Com-\nplexity” in Section 5.2.■\nIf multiple classes share common data but not behavior, create a common object \nthat those classes can contain. ■\nIf multiple classes share common behavior but not data, derive them from a \ncommon base class that defines the common routines. ■\nIf multiple classes shar e common data and behavior, inherit from a common \nbase class that defines the common data and routines. ■\nInherit when you want the base class to control your interface; contain when \nyou want to control your interface.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 524, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 788}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0525_abe0c081", "text": "■\nInherit when you want the base class to control your interface; contain when \nyou want to control your interface. KEY POINT\n150\nChapter 6: Working Classes\nMember Functions and Data\nCross-Reference For more \ndiscussion of routines in \ngeneral, see Chapter 7, \n“High-Quality Routines.”\nHere are a few guidelines for implementing member functions and member data \neffectively. Keep the number of routines in a class as small as possible A study of C++ programs \nfound that higher numbers of routines per class were associated with higher fault \nrates (Basili, Briand, and Melo 1996). However, other competing factors were found to \nbe more significant, including deep inheritance trees, large number of routines called \nwithin a class, and strong coupling between classes. Evaluate the tradeoff between \nminimizing the number of routines and these other factors.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 525, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 861}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0526_b5978f5f", "text": "Evaluate the tradeoff between \nminimizing the number of routines and these other factors. Disallow implicitly generated member functions and operators you don’t want\nSometimes you’ll find that you want to di sallow certain functions—perhaps you want \nto disallow assignment, or you don’t want to allow an object to be constructed. You \nmight think that, since the compiler genera tes operators automatically, you’re stuck \nallowing access. But in such cases you ca n disallow those uses by declaring the con-\nstructor, assignment operator, or other function or operator private , which will pre-\nvent clients from accessing it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 526, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 627}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0527_7a5d9b47", "text": "But in such cases you ca n disallow those uses by declaring the con-\nstructor, assignment operator, or other function or operator private , which will pre-\nvent clients from accessing it. (Making the constructor private is a standard technique \nfor defining a singleton class, which is discussed later in this chapter.)\nMinimize the number of different routines called by a class One study found that \nthe number of faults in a cla ss was statistically correlated with the total number of rou-\ntines that were called from within a class (Basili, Briand, and Melo 1996). The same \nstudy found that the more classes a class used , the higher its fault rate tended to be. These concepts are sometimes called “fan out.”\nFurther Reading Good \naccounts of the Law of \nDemeter can be found in \nPragmatic Programmer \n(Hunt and Thomas 2000), \nApplying UML and Patterns \n(Larman 2001), and Funda-\nmentals of Object-Oriented \nDesign in UML (Page-Jones \n2000).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 527, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0528_57496005", "text": "Minimize indirect routine calls to other classes Direct connections are hazardous \nenough. Indirect connections—such as account.ContactPerson().DaytimeContact-\nInfo().PhoneNumber() —tend to be even more hazardou s. Researchers have formulated \na rule called the “Law of Demeter” (Liebe rherr and Holland 1989), which essentially \nstates that Object A can call any of its own routines. If Object A instantiates an Object \nB, it can call any of Object B’s routines. Bu t it should avoid calling routines on objects \nprovided by Object B. In the account example above, that means account.ContactPer-\nson() is OK but account.ContactPerson().DaytimeContactInfo() is not. This is a simplified explanation. See the addi tional resources at the end of this chapter \nfor more details.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 528, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 775}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0529_6a75f7b2", "text": "This is a simplified explanation. See the addi tional resources at the end of this chapter \nfor more details. In general, minimize the extent to which a class collaborates with other classes Try \nto minimize all of the following:\n■\nNumber of kinds of objects instantiated\n■\nNumber of different direct routine calls on instantiated objects \n■\nNumber of routine calls on objects returned by other instantiated objects\n6.3 Design and Implementation Issues 151\nConstructors\nFollowing are some guidelines that apply specifically to constructors. Guidelines for \nconstructors are pretty similar across langua ges (C++, Java, and Visual Basic, anyway). Destructors vary more, so you should check out the materials listed in this chapter’s \n“Additional Resources” section for information on destructors. Initialize all member data in all constructors, if possible Initializing all data mem-\nbers in all constructors is an inexpensive defensive programming practice.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 529, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 957}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0530_6657fa8f", "text": "Initialize all member data in all constructors, if possible Initializing all data mem-\nbers in all constructors is an inexpensive defensive programming practice. Further Reading The code \nto do this in C++ would be \nsimilar. For details, see More \nEffective C++ , Item 26 (Mey-\ners 1998). Enforce the singleton property by using a private constructor If you want to define a \nclass that allows only one object to be inst antiated, you can enforce this by hiding all \nthe constructors of the class and then providing a static GetInstance() routine to access \nthe class’s single instance. Here’s an example of how that would work: \nJava Example of Enforcing a Singleton with a Private Constructor\npublic class MaxId {\n // constructors and destructors\nHere is the private \nconstructor. private MaxId() {\n ... }\n ... // public routines\nHere is the public routine \nthat provides access to the \nsingle instance. public static MaxId GetInstance() {\n return m_instance;\n }\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 530, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0531_3dc45613", "text": "private MaxId() {\n ... }\n ... // public routines\nHere is the public routine \nthat provides access to the \nsingle instance. public static MaxId GetInstance() {\n return m_instance;\n }\n ... // private members\nHere is the single instance. private static final MaxId m_instance = new MaxId();\n ... }\nThe private constructor is called only when the static object m_instance is initialized. In this approach, if you want to reference the MaxId singleton, you would simply refer \nto MaxId.GetInstance() . Prefer deep copies to shallow copies until proven otherwise One of the major deci-\nsions you’ll make about complex objects is wh ether to implement deep copies or shal-\nlow copies of the object. A deep copy of an object is a member-wise copy of the \nobject’s member data; a shallow copy typically just points to or refers to a single refer-\nence copy, although the specific meanings of “deep” and “shallow” vary. The motivation for creating shallow copies is typically to improve performance.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 531, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0532_74a350d4", "text": "The motivation for creating shallow copies is typically to improve performance. Although creating multiple copies of large objects might be aesthetically offensive, it \nrarely causes any measurable performance impact. A small number of objects might \ncause performance issues, but programmers are notoriously poor at guessing which \ncode really causes problems. (For details, see Chapter 25, “Code-Tuning Strategies.”) \n152\nChapter 6: Working Classes\nBecause it’s a poor tradeoff to add complexity for dubious performance gains, a good \napproach to deep vs. shallow copies is to prefer deep copies until proven otherwise. Deep copies are simpler to code and maintain than shallow copies. In addition to the \ncode either kind of object would contain, shallow copies add code to count references, \nensure safe object copies, safe comparisons, safe deletes, and so on. This code can be \nerror-prone, and you should avoid it unless there’s a compelling reason to create it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 532, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0533_cd6e8a08", "text": "This code can be \nerror-prone, and you should avoid it unless there’s a compelling reason to create it. If you find that you do need to use a shallow-copy approach, Scott Meyers’s More \nEffective C++ , Item 29 (1996) contains an excellent discussion of the issues in C++. Martin Fowler’s Refactoring (1999) describes the specific steps needed to convert \nfrom shallow copies to deep copies and fr om deep copies to shallow copies. (Fowler \ncalls them reference obje cts and value objects.)\n6.4 Reasons to Create a Class\nCross-Reference Reasons \nfor creating classes and \nroutines overlap. See \nSection 7.1. If you believe everything you read, you might get the idea that the only reason to cre-\nate a class is to model real-world objects. In practice, classes get created for many more \nreasons than that. Here’s a list of good reasons to create a class. Cross-Reference For more \non identifying real-world \nobjects, see “Find Real-\nWorld Objects” in Section \n5.3.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 533, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0534_272ed0f5", "text": "Here’s a list of good reasons to create a class. Cross-Reference For more \non identifying real-world \nobjects, see “Find Real-\nWorld Objects” in Section \n5.3. Model real-world objects Modeling real-world objects might not be the only reason \nto create a class, but it’s still a good reas on! Create a class for each real-world object \ntype that your program models. Put the data needed for the object into the class, and \nthen build service routines that model the be havior of the object. See the discussion of \nADTs in Section 6.1 for examples. Model abstract objects Another good reason to create a class is to model an abstract \nobject —an object that isn’t a concrete, real-wor ld object but that provides an abstrac-\ntion of other concrete objects. A good example is the classic Shape object. Circle and \nSquare really exist, but Shape is an abstraction of other specific shapes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 534, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 885}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0535_e7a7c386", "text": "A good example is the classic Shape object. Circle and \nSquare really exist, but Shape is an abstraction of other specific shapes. On programming projects, the abstractions are not ready-made the way Shape is, so \nwe have to work harder to come up with clean abstractions. The process of distilling \nabstract concepts from real-world entities is non-deterministic, and different designers \nwill abstract out different generalities. If we didn’t know about geometric shapes like \ncircles, squares and triangles, for exampl e, we might come up with more unusual \nshapes like squash shape, rutabaga shape, and Pontiac Aztek shape. Coming up with \nappropriate abstract objects is one of the major challenges in object-oriented design. Reduce complexity The single most important reason to create a class is to reduce a \nprogram’s complexity. Create a class to hide information so that you won’t need to \nthink about it. Sure, you’ll need to think abou t it when you write the class.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 535, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0536_e463973c", "text": "Create a class to hide information so that you won’t need to \nthink about it. Sure, you’ll need to think abou t it when you write the class. But after it’s \nwritten, you should be able to forget the details and use the class without any knowl-\nedge of its internal workings. Other reason s to create classes—mi nimizing code size, \nKEY POINT\n6.4 Reasons to Create a Class 153\nimproving maintainability, and improving correctness—are also good reasons, but \nwithout the abstractive power of classes, complex programs would be impossible to \nmanage intellectually. Isolate complexity Complexity in all forms—complicated algorithms, large data sets, \nintricate communications protoc ols, and so on—is prone to errors. If an error does \noccur, it will be easier to find if it isn’t spread through the code but is localized within \na class. Changes arising from fixing the error won’t affect other code because only one \nclass will have to be fixed—ot her code won’t be touched.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 536, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0537_5802a88c", "text": "Changes arising from fixing the error won’t affect other code because only one \nclass will have to be fixed—ot her code won’t be touched. If you find a better, simpler, \nor more reliable algorithm, it will be easier to replace the old algorithm if it has been \nisolated into a class. During development, it will be easier to try several designs and \nkeep the one that works best. Hide implementation details The desire to hide implementation details is a wonder-\nful reason to create a class whether the details are as complicated as a convoluted data-\nbase access or as mundane as whether a speci fic data member is stored as a number \nor a string. Limit effects of changes Isolate areas that are likely to change so that the effects of \nchanges are limited to the scope of a single cl ass or a few classes. Design so that areas \nthat are most likely to change are the easiest to change. Areas likely to change include \nhardware dependencies, input/output, complex data types, and business rules.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 537, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 997}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0538_7afec84c", "text": "Design so that areas \nthat are most likely to change are the easiest to change. Areas likely to change include \nhardware dependencies, input/output, complex data types, and business rules. The \nsubsection titled “Hide Secrets (Information Hiding)” in Section 5.3 described several \ncommon sources of change. Cross-Reference For a dis-\ncussion of problems associ-\nated with using global data, \nsee Section 13.3, “Global \nData.” \nHide global data If you need to use global data, you can hide its implementation \ndetails behind a class interface. Working wi th global data through access routines pro-\nvides several benefits compared to working with global data directly. You can change \nthe structure of the data without changing your program. You can monitor accesses to \nthe data. The discipline of using access rout ines also encourages you to think about \nwhether the data is really global; it often becomes apparent that the “global data” is \nreally just object data.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 538, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0539_cdc06ea9", "text": "The discipline of using access rout ines also encourages you to think about \nwhether the data is really global; it often becomes apparent that the “global data” is \nreally just object data. Streamline parameter passing If you’re passing a parameter among several routines, \nthat might indicate a need to factor those ro utines into a class that share the parameter \nas object data. Streamlining parameter passing isn’t a goal, per se, but passing lots of \ndata around suggests that a different class organization might work better. Cross-Reference For details \non information hiding, see \n“Hide Secrets (Information \nHiding)” in Section 5.3. Make central points of control It’s a good idea to control each task in one place. Control assumes many forms. Knowledge of the number of entries in a table is one \nform. Control of devices—files, database co nnections, printers, and so on—is another. Using one class to read from and write to a database is a form of centralized control.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 539, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0540_38a66173", "text": "Control of devices—files, database co nnections, printers, and so on—is another. Using one class to read from and write to a database is a form of centralized control. If the database needs to be converted to a flat file or to in-memory data, the changes \nwill affect only one class. 154\nChapter 6: Working Classes\nThe idea of centralized control is similar to information hiding, but it has unique heu-\nristic power that makes it worth adding to your programming toolbox. Facilitate reusable code Code put into well-factored classes can be reused in other \nprograms more easily than the same code embedded in one larger class. Even if a sec-\ntion of code is called from only one pl ace in the program and is understandable as \npart of a larger class, it makes sense to put it into its own class if that piece of code \nmight be used in another program. NASA’s Software Engineering Laboratory studied ten projects that pursued reuse \naggressively (McGarry, Waligora, and McDerm ott 1989).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 540, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0541_cc195076", "text": "NASA’s Software Engineering Laboratory studied ten projects that pursued reuse \naggressively (McGarry, Waligora, and McDerm ott 1989). In both the object-oriented \nand the functionally oriented approaches, the initial projects weren’t able to take \nmuch of their code from previous projects because previous projects hadn’t estab-\nlished a sufficient code base. Subsequently, the projects that used functional design \nwere able to take about 35 percent of their code from previous projects. Projects that \nused an object-oriented approach were able to take more than 70 percent of their code \nfrom previous projects. If you can avoid writ ing 70 percent of your code by planning \nahead, do it! Cross-Reference For more \non implementing the mini-\nmum amount of functional-\nity required, see “A program \ncontains code that seems \nlike it might be needed \nsomeday” in Section 24.2.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 541, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 878}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0542_c6b68727", "text": "Cross-Reference For more \non implementing the mini-\nmum amount of functional-\nity required, see “A program \ncontains code that seems \nlike it might be needed \nsomeday” in Section 24.2. Notably, the core of NASA’s approach to creating reusable classes does not involve \n“designing for reuse.” NASA identifies reuse candidates at the ends of their projects. They then perform the work needed to make the classes reusable as a special project \nat the end of the main project or as the firs t step in a new project. This approach helps \nprevent “gold-plating”—creation of function ality that isn’t required and that unneces-\nsarily adds complexity. Plan for a family of programs If you expect a program to be modified, it’s a good \nidea to isolate the parts that you expect to change by putting them into their own \nclasses. You can then modify the classes with out affecting the rest of the program, or \nyou can put in completely new classes instead.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 542, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0543_f4856ded", "text": "You can then modify the classes with out affecting the rest of the program, or \nyou can put in completely new classes instead. Thinking through not just what one \nprogram will look like but what the whole family of programs might look like is a \npowerful heuristic for anticipating entire categories of changes (Parnas 1976). Several years ago I managed a team that wrote a series of programs used by our clients \nto sell insurance. We had to tailor each program to the specific client’s insurance rates, \nquote-report format, and so on. But many parts of the programs were similar: the \nclasses that input information about potentia l customers, that stored information in a \ncustomer database, that looked up rates, th at computed total rates for a group, and so \non. The team factored the program so that each part that varied from client to client \nwas in its own class.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 543, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 874}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0544_65ccc34b", "text": "The team factored the program so that each part that varied from client to client \nwas in its own class. The initial programming might have taken three months or so, \nbut when we got a new client, we merely wrote a handful of new classes for the new \nclient and dropped them into the rest of the code. A few days’ work and—voila!—cus-\ntom software! 1\n23\nHARD DATA\n6.4 Reasons to Create a Class 155\nPackage related operations In cases in which you can’t hide information, share data, \nor plan for flexibility, you can still package sets of operations into sensible groups, \nsuch as trig functions, statistical function s, string-manipulation routines, bit-manipu-\nlation routines, graphics routines, and so on. Classes are one means of combining \nrelated operations. You could also use packag es, namespaces, or header files, depend-\ning on the language you’re working in.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 544, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 871}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0545_8419eede", "text": "Classes are one means of combining \nrelated operations. You could also use packag es, namespaces, or header files, depend-\ning on the language you’re working in. Accomplish a specific refactoring Many of the specific refactorings described in \nChapter 24, “Refactoring,” result in new classes—including converting one class to \ntwo, hiding a delegate, removing a middle man, and introducing an extension class. These new classes could be motivated by a desire to better accomplish any of the \nobjectives described throughout this section. Classes to Avoid\nWhile classes in general are good, you can run into a few gotchas. Here are some \nclasses to avoid. Avoid creating god classes Avoid creating omniscient classes that are all-knowing \nand all-powerful.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 545, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 756}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0546_c8d4fc71", "text": "Here are some \nclasses to avoid. Avoid creating god classes Avoid creating omniscient classes that are all-knowing \nand all-powerful. If a class spends its time retrieving data from other classes using \nGet() and Set() routines (that is, digging into their business and telling them what to \ndo), ask whether that functionality might be tter be organized into those other classes \nrather than into the god class (Riel 1996). Cross-Reference This kind of \nclass is usually called a struc-\nture. For more on structures, \nsee Section 13.1, “Struc-\ntures.”\nEliminate irrelevant classes If a class consists only of data but no behavior, ask your-\nself whether it’s really a class and consider demoting it so that its member data just \nbecomes attributes of one or more other classes. Avoid classes named after verbs A class that has only behavior but no data is gener-\nally not really a class. Consider turning a class like DatabaseInitialization() or String-\nBuilder() into a routine on some other class.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 546, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1000}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0547_5cac8cec", "text": "Consider turning a class like DatabaseInitialization() or String-\nBuilder() into a routine on some other class. Summary of Reasons to Create a Class\nHere’s a summary list of the valid reasons to create a class: \n■\nModel real-world objects\n■\nModel abstract objects\n■\nReduce complexity \n■\nIsolate complexity\n■\nHide implementation details\n■\nLimit effects of changes\n■\nHide global data\n156\nChapter 6: Working Classes\n■\nStreamline parameter passing\n■\nMake central points of control\n■\nFacilitate reusable code\n■\nPlan for a family of programs\n■\nPackage related operations\n■\nAccomplish a specific refactoring \n6.5 Language-Specific Issues\nApproaches to classes in different progra mming languages vary in interesting ways. Consider how you override a member routine to achieve polymorphism in a derived \nclass. In Java, all routines are overridable by default and a routine must be declared \nfinal to prevent a derived class from overriding it. In C++, routines are not overridable \nby default.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 547, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0548_40f60a44", "text": "In Java, all routines are overridable by default and a routine must be declared \nfinal to prevent a derived class from overriding it. In C++, routines are not overridable \nby default. A routine must be declared virtual in the base class to be overridable. In \nVisual Basic, a routine must be declared overridable in the base class and the derived \nclass should use the overrides keyword.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 548, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 387}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0549_e599cc64", "text": "In \nVisual Basic, a routine must be declared overridable in the base class and the derived \nclass should use the overrides keyword. Here are some of the class-related areas that vary significantly depending on the \nlanguage:\n■\nBehavior of overridden constructors and destructors in an inheritance tree\n■\nBehavior of constructors and destruct ors under exception-handling conditions\n■\nImportance of default constructors (constructors with no arguments) \n■\nTime at which a destructor or finalizer is called\n■\nWisdom of overriding the language’s bu ilt-in operators, in cluding assignment \nand equality \n■\nHow memory is handled as objects are created and destroyed or as they are \ndeclared and go out of scope\nDetailed discussions of these issues are beyond the scope of this book, but the “Addi-\ntional Resources” section points to good language-specific resources.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 549, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 863}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0550_14d182c9", "text": "6.6 Beyond Classes: Packages\nCross-Reference For more \non the distinction between \nclasses and packages, see \n“Levels of Design” in \nSection 5.2. Classes are currently the best way for programmers to achieve modularity. But modular-\nity is a big topic, and it extends beyond cla sses. Over the past seve ral decades, software \ndevelopment has advanced in large part by increasing the granularity of the aggrega-\ntions that we have to work with. The first aggregation we had was the statement, which \n6.6 Beyond Classes: Packages 157\nat the time seemed like a big step up from machine instructions. Then came subrou-\ntines, and later came classes. It’s evident that we could better support th e goals of abstraction and encapsulation if \nwe had good tools for aggregating groups of objects. Ada supported the notion of \npackages more than a decade ago, and Java supports packages today.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 550, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 885}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0551_00404d36", "text": "Ada supported the notion of \npackages more than a decade ago, and Java supports packages today. If you’re pro-\ngramming in a language that doesn’t support packages directly, you can create your \nown poor-programmer’s version of a pack age and enforce it through programming \nstandards that include the following:\n■\nNaming conventions that differentiate which classes are public and which are \nfor the package’s private use\n■\nNaming conventions, code-organization conventions (project structure), or \nboth that identify which package each class belongs to\n■\nRules that define which packages are allowed to use which other packages, \nincluding whether the usage can be inheritance, containment, or both\nThese workarounds are good examples of the distinction between programming in a \nlanguage vs. programming into a language.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 551, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 823}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0552_e9c40c88", "text": "programming into a language. For more on this distinction, see Section \n34.4, “Program into Your Language, Not in It.”\ncc2e.com/0672\nCross-Reference This is a \nchecklist of considerations \nabout the quality of the \nclass. For a list of the steps \nused to build a class, see the \nchecklist “The Pseudocode \nProgramming Process” in \nChapter 9, page 233. CHECKLIST: Class Quality\nAbstract Data Types\n❑\nHave you thought of the classes in your program as abstract data types \nand evaluated their interfaces from that point of view? Abstraction\n❑\nDoes the class have a central purpose? ❑\nIs the class well named, and does it s name describe it s central purpose? ❑\nDoes the class’s interface present a consistent abstraction? ❑\nDoes the class’s interface make obvi ous how you should use the class? ❑\nIs the class’s interface abstract enough that you don’t have to think about \nhow its services are implemented? Can you treat the class as a black box?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 552, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0553_244d3621", "text": "❑\nIs the class’s interface abstract enough that you don’t have to think about \nhow its services are implemented? Can you treat the class as a black box? ❑\nAre the class’s services complete enou gh that other classes don’t have to \nmeddle with its internal data? ❑\nHas unrelated information been moved out of the class? ❑\nHave you thought about subdividing the class into component classes, \nand have you subdivided it as much as you can? ❑\nAre you preserving the integrity of the class’s interface as you modify the \nclass? 158\nChapter 6: Working Classes\nEncapsulation\n❑\nDoes the class minimize ac cessibility to its members? ❑\nDoes the class avoid exposing member data? ❑\nDoes the class hide its implementation details from other classes as much \nas the programming language permits? ❑\nDoes the class avoid making assumpti ons about its users, including its \nderived classes? ❑\nIs the class independent of other classes? Is it loosely coupled?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 553, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0554_84b26357", "text": "❑\nDoes the class avoid making assumpti ons about its users, including its \nderived classes? ❑\nIs the class independent of other classes? Is it loosely coupled? Inheritance\n❑\nIs inheritance used only to model “is a” relationships—that is, do derived \nclasses adhere to the Liskov Substitution Principle? ❑\nDoes the class documentation desc ribe the inheritance strategy? ❑\nDo derived classes avoid “overrid ing” non-overridable routines? ❑\nAre common interfaces, data, and behavior as high as possible in the \ninheritance tree? ❑\nAre inheritance trees fairly shallow? ❑\nAre all data members in the base class private rather than protected? Other Implementation Issues\n❑\nDoes the class contain about seven data members or fewer? ❑\nDoes the class minimize direct and indi rect routine calls to other classes? ❑\nDoes the class collaborate with other classes only to the extent absolutely \nnecessary? ❑\nIs all member data initialized in the constructor?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 554, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0555_9d814582", "text": "❑\nDoes the class collaborate with other classes only to the extent absolutely \nnecessary? ❑\nIs all member data initialized in the constructor? ❑\nIs the class designed to be used as deep copies rather than shallow copies \nunless there’s a measured reason to create shallow copies? Language-Specific Issues\n❑\nHave you investigated the language-spe cific issues for classes in your spe-\ncific programming language? Additional Resources 159\nAdditional Resources\nClasses in General\ncc2e.com/0679\nMeyer, Bertrand. Object-Oriented Software Construction , 2d ed. New York, NY: Prentice \nHall PTR, 1997. This book contains an in-depth discussion of abstract data types and \nexplains how they form the basis for classe s. Chapters 14–16 discuss inheritance in \ndepth. Meyer provides an argument in favo r of multiple inheritance in Chapter 15. Riel, Arthur J. Object-Oriented Design Heuristics . Reading, MA: Addison-Wesley, 1996.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 555, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 920}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0556_af43537e", "text": "Meyer provides an argument in favo r of multiple inheritance in Chapter 15. Riel, Arthur J. Object-Oriented Design Heuristics . Reading, MA: Addison-Wesley, 1996. This book contains numerous suggestions fo r improving program design, mostly at the \nclass level. I avoided the book for several ye ars because it appeared to be too big—talk \nabout people in glass houses! However, the body of the book is only about 200 pages \nlong. Riel’s writing is accessible and enjoya ble. The content is focused and practical. C++\ncc2e.com/0686\nMeyers, Scott. Effective C++: 50 Specific Ways to Improve Your Programs and Designs , 2d \ned. Reading, MA: Addison-Wesley, 1998. Meyers, Scott, 1996, More Effective C++: 35 New Ways to Improve Your Programs and \nDesigns . Reading, MA: Addison-Wesley, 1996. Bo th of Meyers’ books are canonical ref-\nerences for C++ programmers. The books are entertaining and help to instill a lan-\nguage-lawyer’s appreciation for the nuances of C++. Java\ncc2e.com/0693\nBloch, Joshua.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 556, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0557_841352e5", "text": "The books are entertaining and help to instill a lan-\nguage-lawyer’s appreciation for the nuances of C++. Java\ncc2e.com/0693\nBloch, Joshua. Effective Java Programming Language Guide . Boston, MA: Addison-\nWesley, 2001. Bloch’s book provides much g ood Java-specific advice as well as intro-\nducing more general, good object-oriented practices. Visual Basic\ncc2e.com/0600\nThe following books are good refere nces on classes in Visual Basic:\nFoxall, James. Practical Standards for Microsoft Visual Basic .NET . Redmond, WA: \nMicrosoft Press, 2003. Cornell, Gary, and Jonathan Morrison. Programming VB .NET: A Guide for Experienced \nProgrammers . Berkeley, CA: Apress, 2002. Barwell, Fred, et al. Professional VB.NET , 2d ed. Wrox, 2002. 160\nChapter 6: Working Classes\nKey Points\n■\nClass interfaces should provide a consistent abstraction. Many problems arise \nfrom violating this single principle. ■\nA class interface should hi de something—a system inte rface, a design decision, \nor an implementation detail.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 557, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1008}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0558_9f768ee2", "text": "Many problems arise \nfrom violating this single principle. ■\nA class interface should hi de something—a system inte rface, a design decision, \nor an implementation detail. ■\nContainment is usually preferable to in heritance unless you’re modeling an “is \na” relationship. ■\nInheritance is a useful tool, but it adds complexity, which is counter to Soft-\nware’s Primary Technical Imperative of managing complexity. ■\nClasses are your primary tool for managi ng complexity. Give their design as \nmuch attention as needed to accomplish that objective.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 558, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 548}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0559_73470ffd", "text": "■\nClasses are your primary tool for managi ng complexity. Give their design as \nmuch attention as needed to accomplish that objective. 161\nChapter 7\nHigh-Quality Routines\ncc2e.com/0778\nContents\n■\n7.1 Valid Reasons to Create a Routine: page 164\n■\n7.2 Design at the Routine Level: page 168\n■\n7.3 Good Routine Names: page 171\n■\n7.4 How Long Can a Routine Be?: page 173\n■\n7.5 How to Use Routine Parameters: page 174\n■\n7.6 Special Considerations in the Use of Functions: page 181\n■\n7.7 Macro Routines and Inline Routines: page 182\nRelated Topics\n■\nSteps in routine construction: Section 9.3\n■\nWorking classes: Chapter 6 \n■\nGeneral design techniques: Chapter 5\n■\nSoftware architecture: Section 3.5\nChapter 6 described the details of creating classes. This ch apter zooms in on routines, \non the characteristics that make the difference between a good routine and a bad one.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 559, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 867}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0560_561f8ee6", "text": "This ch apter zooms in on routines, \non the characteristics that make the difference between a good routine and a bad one. If you’d rather read about issues that affect the design of routines before wading into \nthe nitty-gritty details, be sure to read Ch apter 5, “Design in Construction,” first and \ncome back to this chapter later. Some import ant attributes of high-quality routines are \nalso discussed in Chapter 8, “Defensive Programming.” If you’re more interested in \nreading about steps to create routines and classes, Chapter 9, “The Pseudocode Pro-\ngramming Process,” might be a better place to start. Before jumping into the details of high-quality routines, it will be useful to nail down \ntwo basic terms. What is a “routine”? A routine is an individual method or procedure \ninvocable for a single purpose. Examples incl ude a function in C++, a method in Java, \na function or sub procedure in Microsoft Visu al Basic. For some uses, macros in C and \nC++ can also be thought of as routines.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 560, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0561_06397584", "text": "Examples incl ude a function in C++, a method in Java, \na function or sub procedure in Microsoft Visu al Basic. For some uses, macros in C and \nC++ can also be thought of as routines. Yo u can apply many of the techniques for cre-\nating a high-quality routine to these variants. What is a high-quality routine? That’s a harder question. Perhaps the easiest answer is \nto show what a high-quality routine is not.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 561, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 411}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0562_f5103a6f", "text": "What is a high-quality routine? That’s a harder question. Perhaps the easiest answer is \nto show what a high-quality routine is not. Here’s an example of a low-quality routine:\n162\nChapter 7: High-Q uality Routines\nC+ + Example of a Low-Quality Routine\nvoid HandleStuff( CORP_DATA & inputRec, int crntQtr, EMP_DATA empRec, \n double & estimRevenue, double ytdRevenue, int screenX, int screenY,\n COLOR_TYPE & newColor, COLOR_TYPE & prevColor, StatusType & status, \n int expenseType )\n{\nint i;\nfor ( i = 0; i < 100; i++ ) {\n inputRec.revenue[i] = 0;\n inputRec.expense[i] = corpExpense[ crntQtr ][ i ];\n }\nUpdateCorpDatabase( empRec );\nestimRevenue = ytdRevenue * 4.0 / (double) crntQtr;\nnewColor = prevColor;\nstatus = SUCCESS;\nif ( expenseType == 1 ) {\n for ( i = 0; i < 12; i++ )\n profit[i] = revenue[i] - expense.type1[i];\n }\nelse if ( expenseType == 2 ) {\n profit[i] = revenue[i] - expense.type2[i];\n }\nelse if ( expenseType == 3 )\n profit[i] = revenue[i] - expense.type3[i];\n }\nWhat’s wrong with this routine?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 562, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1010}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0563_7675b65e", "text": "Here’s a hint : you should be able to find at least 10 \ndifferent problems with it. Once you’ve come up with your own list, look at the fol-\nlowing list:\n■\nThe routine has a bad name. HandleStuff() tells you nothing about what the rou-\ntine does. ■\nThe routine isn’t documented. (The subj ect of documentation extends beyond \nthe boundaries of individual routines and is discussed in Chapter 32, “Self-Doc-\numenting Code.”)\n■\nThe routine has a bad layout. The physical organization of the code on the page \ngives few hints about its logical organization. Layout strategies are used haphaz-\nardly, with different styles in different parts of the routine. Compare the styles \nwhere expenseType == 2 and expenseType == 3 . (Layout is discussed in Chapter 31, \n“Layout and Style.”)\n■\nThe routine’s input variable, inputRec, is changed. If it’s an input variable, its \nvalue should not be modified (and in C++ it should be declared const ).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 563, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0564_25c9b859", "text": "If it’s an input variable, its \nvalue should not be modified (and in C++ it should be declared const ). If the \nvalue of the variable is supposed to be modified, the variable should not be \ncalled inputRec . ■\nThe routine reads and writes global variables—it reads from corpExpense and \nwrites to profit . It should communicate with other routines more directly than \nby reading and writing global variables. CODING \nHORROR\n163 A Low-Quality Routine\n■\nThe routine doesn’t have a single purpose. It initializes some variables, writes to \na database, does some calculations—none of which seem to be related to each \nother in any way. A routine should ha ve a single, clearly defined purpose. ■\nThe routine doesn’t defend itself against bad data. If crntQtr equals 0, the expres-\nsion ytdRevenue * 4.0 / (double) crntQtr causes a divide-by-zero error. ■\nThe routine uses several magic numbers: 100, 4.0, 12, 2, and 3.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 564, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0565_51fedf37", "text": "If crntQtr equals 0, the expres-\nsion ytdRevenue * 4.0 / (double) crntQtr causes a divide-by-zero error. ■\nThe routine uses several magic numbers: 100, 4.0, 12, 2, and 3. Magic numbers \nare discussed in Section 12.1, “Numbers in General.”\n■\nSome of the routine’s parameters are unused: screenX and screenY are not refer-\nenced within the routine. ■\nOne of the routine’s parameters is passed incorrectly: prevColor is labeled as a \nreference parameter (\n&\n) even though it isn’t assigned a value within the routine. ■\nThe routine has too many parameters. The upper limit for an understandable \nnumber of parameters is about 7; this routine has 11. The parameters are laid \nout in such an unreadable way that most people wouldn’t try to examine them \nclosely or even count them. ■\nThe routine’s parameters are poorly ordered and are not documented. (Parameter \nordering is discussed in this chapter.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 565, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 897}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0566_a28229ee", "text": "■\nThe routine’s parameters are poorly ordered and are not documented. (Parameter \nordering is discussed in this chapter. Documentation is discussed in Chapter 32.)\ncc2e.com/0799\nCross-Reference The class is \nalso a good contender for \nthe single greatest invention \nin computer science. For \ndetails on how to use classes \neffectively, see Chapter 6, \n“Working Classes.”\nAside from the computer itself, the routine is the single greatest invention in computer \nscience. The routine makes programs easier to read and easier to understand than any \nother feature of any programming language, and it’s a crime to abuse this senior \nstatesman of computer science with code like that in the example just shown. The routine is also the greatest technique ever invented for saving space and improv-\ning performance. Imagine how much larger your code would be if you had to repeat \nthe code for every call to a routine instead of branching to the routine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 566, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0567_a50f4484", "text": "Imagine how much larger your code would be if you had to repeat \nthe code for every call to a routine instead of branching to the routine. Imagine how \nhard it would be to make performance improvements in the same code used in a \ndozen places instead of making them all in one routine. The routine makes modern \nprogramming possible. “OK,” you say, “I already know that routines are great, and I program with them all the \ntime. This discussion seems ki nd of remedial, so what do you want me to do about it?”\nI want you to understand that many valid reasons to create a routine exist and that \nthere are right ways and wrong ways to go about it. As an undergraduate computer-sci-\nence student, I thought that the main reason to create a routine was to avoid duplicate \ncode. The introductory textbook I used said that routines were good because the \navoidance of duplication made a program easier to develop, debug, document, and \nmaintain. Period.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 567, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0568_3c972a8c", "text": "The introductory textbook I used said that routines were good because the \navoidance of duplication made a program easier to develop, debug, document, and \nmaintain. Period. Aside from syntactic details about how to use parameters and local \nvariables, that was the extent of the textbook’s coverage. It was not a good or complete \nexplanation of the theory an d practice of routines. The following sections contain a \nmuch better explanation. 164\nChapter 7: High-Q uality Routines\n7.1 Valid Reasons to Create a Routine\nHere’s a list of valid reasons to create a routine. The reasons overlap somewhat, and \nthey’re not intended to make an orthogonal set. Reduce complexity The single most important reason to create a routine is to reduce \na program’s complexity. Create a routine to hide information so that you won’t need \nto think about it. Sure, you’ll need to thin k about it when you write the routine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 568, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 908}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0569_86b7294a", "text": "Create a routine to hide information so that you won’t need \nto think about it. Sure, you’ll need to thin k about it when you write the routine. But \nafter it’s written, you should be able to forget the details and use the routine without \nany knowledge of its internal workings. Other reasons to create routines—minimizing \ncode size, improving maintainability, and improving correctness—are also good rea-\nsons, but without the abstractive power of routines, complex programs would be \nimpossible to manage intellectually. One indication that a routine needs to be broken out of another routine is deep nest-\ning of an inner loop or a conditional. Reduce the containing routine’s complexity by \npulling the nested part out and putting it into its own routine. Introduce an intermediate, understandable abstraction Putting a section of code \ninto a well-named routine is one of the best ways to document its purpose.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 569, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0570_9894ce5c", "text": "Introduce an intermediate, understandable abstraction Putting a section of code \ninto a well-named routine is one of the best ways to document its purpose. Instead of \nreading a series of statements like\nif ( node <> NULL ) then\nwhile ( node.next <> NULL ) do\nnode = node.next\nleafName = node.name\nend while\nelse\nleafName = \"\"\nend if\nyou can read a statement like this: \nleafName = GetLeafName( node )\nThe new routine is so short that nearly all it needs for documentation is a good name. The name introduces a higher level of abstra ction than the original eight lines of code, \nwhich makes the code more readable and easier to understand, and it reduces com-\nplexity within the routine that originally contained the code. Avoid duplicate code Undoubtedly the most popular reas on for creating a routine is \nto avoid duplicate code. Indeed, creation of similar code in two routines implies an \nerror in decomposition.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 570, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0571_df788dcc", "text": "Avoid duplicate code Undoubtedly the most popular reas on for creating a routine is \nto avoid duplicate code. Indeed, creation of similar code in two routines implies an \nerror in decomposition. Pull the duplicate code from both routines, put a generic ver-\nsion of the common code into a base class, and then move the two specialized rou-\ntines into subclasses. Alternatively, you could migrate the common code into its own \nroutine, and then let both call the part that was put into the new routine. With code in \none place, you save the space that would ha ve been used by duplicated code. Modifi-\ncations will be easier because you’ll need to modify the code in only one location. The \nKEY POINT\n7.1 Valid Reasons to Create a Routine 165\ncode will be more reliable because you’ll ha ve to check only one place to ensure that \nthe code is right.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 571, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 848}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0572_75cf5d1b", "text": "The \nKEY POINT\n7.1 Valid Reasons to Create a Routine 165\ncode will be more reliable because you’ll ha ve to check only one place to ensure that \nthe code is right. Modifications will be mo re reliable because you’ll avoid making suc-\ncessive and slightly different modificati ons under the mistaken assumption that \nyou’ve made identical ones. Support subclassing You need less new code to override a short, well-factored rou-\ntine than a long, poorly factored routine. You’ll also reduce the chance of error in sub-\nclass implementations if you keep overrideable routines simple. Hide sequences It’s a good idea to hide the order in which events happen to be pro-\ncessed. For example, if the program typically gets data from the user and then gets \nauxiliary data from a file, neither the routine that gets the user data nor the routine \nthat gets the file data should depend on the other routine’s being performed first.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 572, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0573_a230f182", "text": "Another example of a sequence might be found when you have two lines of code that \nread the top of a stack and decrement a stackTop variable. Put those two lines of code \ninto a PopStack() routine to hide the assumption about the order in which the two \noperations must be performed. Hiding that assumption will be better than baking it \ninto code from one end of the system to the other. Hide pointer operations Pointer operations tend to be hard to read and error prone. By isolating them in routines, you can concentrate on the intent of the operation \nrather than on the mechanics of pointer mani pulation. Also, if the operations are done \nin only one place, you can be more certain that the code is correct. If you find a better \ndata type than pointers, you can change the program without traumatizing the code \nthat would have used the pointers. Improve portability Use of routines isolates nonportabl e capabilities, explicitly identi-\nfying and isolating future portability work.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 573, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0574_d6f9a6b2", "text": "Improve portability Use of routines isolates nonportabl e capabilities, explicitly identi-\nfying and isolating future portability work. Nonportable capabilities include nonstandard \nlanguage features, hardware dependencies, operating-system dependencies, and so on. Simplify complicated boolean tests Understanding complicated boolean tests in \ndetail is rarely necessary for understandin g program flow. Putting such a test into a \nfunction makes the code more readable beca use (1) the details of the test are out of \nthe way and (2) a descriptive function name summarizes the purpose of the test. Giving the test a function of its own emphasizes its significance. It encourages extra \neffort to make the details of the test readable inside its function. The result is that both \nthe main flow of the code and the test itself become clearer. Simplifying a boolean test \nis an example of reducing complexity, which was discussed earlier.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 574, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0575_4f011b1c", "text": "The result is that both \nthe main flow of the code and the test itself become clearer. Simplifying a boolean test \nis an example of reducing complexity, which was discussed earlier. Improve performance You can optimize the code in on e place instead of in several \nplaces. Having code in one place will make it easier to profile to find inefficiencies. Centralizing code into a routine means that a single optimization benefits all the code \nthat uses that routine, whether it uses it directly or indirectly. Having code in one \nplace makes it practical to recode the routin e with a more efficient algorithm or in a \nfaster, more efficient language. 166\nChapter 7: High-Q uality Routines\nCross-Reference For details \non information hiding, see \n“Hide Secrets (Information \nHiding)” in Section 5.3. To ensure all routines are small? No. With so many good reasons for putting code \ninto a routine, this one is unnecessary. In fact, some jobs are performed better in a sin-\ngle large routine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 575, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 990}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0576_76121363", "text": "To ensure all routines are small? No. With so many good reasons for putting code \ninto a routine, this one is unnecessary. In fact, some jobs are performed better in a sin-\ngle large routine. (The best length for a rout ine is discussed in Section 7.4, “How Long \nCan a Routine Be?”)\nOperations That Seem Too Simple to Put Into Routines \nOne of the strongest mental blocks to creati ng effective routines is a reluctance to cre-\nate a simple routine for a simple purpose. Constructing a whole routine to contain two \nor three lines of code might seem like ov erkill, but experience shows how helpful a \ngood small routine can be. Small routines offer several advantages. One is that they improve readability. I once \nhad the following single line of code in about a dozen places in a program:\nPseudocode Example of a Calculation\npoints = deviceUnits * ( POINTS_PER_INCH / DeviceUnitsPerInch() )\nThis is not the most complicated line of code you’ll ever read.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 576, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 958}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0577_147518d5", "text": "Most people would \neventually figure out that it converts a measurement in device units to a measurement \nin points. They would see that each of th e dozen lines did the same thing. It could \nhave been clearer, however, so I created a well-named routine to do the conversion in \none place:\nPseudocode Example of a Calculation Converted to a Function\nFunction DeviceUnitsToPoints ( deviceUnits Integer ): Integer\nDeviceUnitsToPoints = deviceUnits *\n( POINTS_PER_INCH / DeviceUnitsPerInch() )\nEnd Function\nWhen the routine was substituted for the inline code, the dozen lines of code all \nlooked more or less like this one:\nPseudocode Example of a Function Call to a Calculation Function\npoints = DeviceUnitsToPoints( deviceUnits )\nThis line is more readable—even approaching self-documenting. This example hints at another reason to put small operations in to functions: small \noperations tend to turn into larger operations.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 577, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0578_9a772a6f", "text": "This example hints at another reason to put small operations in to functions: small \noperations tend to turn into larger operations. I didn’t know it when I wrote the rou-\ntine, but under certain conditions an d when certain devices were active, Device-\nUnitsPerlnch() returned 0. That meant I had to account for division by zero, which \ntook three more lines of code:\nKEY POINT\n7.1 Valid Reasons to Create a Routine 167\nPseudocode Example of a Calculation That Expands Under Maintenance\nFunction DeviceUnitsToPoints( deviceUnits: Integer ) Integer;\nif ( DeviceUnitsPerInch() <> 0 )\nDeviceUnitsToPoints = deviceUnits *\n( POINTS_PER_INCH / DeviceUnitsPerInch() )\nelse\nDeviceUnitsToPoints = 0\nend if\nEnd Function\nIf that original line of code had still been in a dozen places, the test would have been \nrepeated a dozen times, for a total of 36 ne w lines of code. A simple routine reduced \nthe 36 new lines to 3.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 578, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0579_f4978596", "text": "A simple routine reduced \nthe 36 new lines to 3. Summary of Reasons to Create a Routine\nHere’s a summary list of the valid reasons for creating a routine: \n■\nReduce complexity\n■\nIntroduce an intermediate, understandable abstraction\n■\nAvoid duplicate code\n■\nSupport subclassing\n■\nHide sequences\n■\nHide pointer operations\n■\nImprove portability\n■\nSimplify complicated boolean tests\n■\nImprove performance\nIn addition, many of the reasons to create a class are also good reasons to create a rou-\ntine: \n■\nIsolate complexity\n■\nHide implementation details\n■\nLimit effects of changes\n■\nHide global data\n■\nMake central points of control\n■\nFacilitate reusable code\n■\nAccomplish a specific refactoring \n168\nChapter 7: High-Q uality Routines\n7.2 Design at the Routine Level\nThe idea of cohesion was introduced in a paper by Wayne Stevens, Glenford Myers, \nand Larry Constantine (1974).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 579, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 873}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0580_bc91893f", "text": "Other more modern concepts, including abstraction \nand encapsulation, tend to yield more insi ght at the class level (and have, in fact, \nlargely superceded cohesion at the class leve l), but cohesion is still alive and well as \nthe workhorse design heuristic at the individual-routine level. Cross-Reference For a dis-\ncussion of cohesion in gen-\neral, see “Aim for Strong \nCohesion” in Section 5.3. For routines, cohesion refers to how closely the operations in a routine are related. Some programmers prefer the term “strength”: how strongly related are the opera-\ntions in a routine? A function like Cosine() is perfectly cohesive because the whole rou-\ntine is dedicated to performing one function. A function like CosineAndTan() has lower \ncohesion because it tries to do more than on e thing. The goal is to have each routine \ndo one thing well and not do anything else. The payoff is higher reliability.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 580, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0581_d87b19a4", "text": "The goal is to have each routine \ndo one thing well and not do anything else. The payoff is higher reliability. One study of 450 routines found that 50 percent of the \nhighly cohesive routines were fault free, wh ereas only 18 percent of routines with low \ncohesion were fault free (Card, Church, an d Agresti 1986). Another study of a differ-\nent 450 routines (which is just an unusual coincidence) found that routines with the \nhighest coupling-to-cohesion ra tios had 7 times as many errors as those with the low-\nest coupling-to-cohesion ratios and were 20 times as costly to fix (Selby and Basili \n1991). Discussions about cohesion typically refer to several levels of cohesion. Understand-\ning the concepts is more important than remembering specific terms. Use the con-\ncepts as aids in thinking about how to make routines as cohesive as possible. Functional cohesion is the strongest and best kind of cohesion, occurring when a rou-\ntine performs one and only one operation.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 581, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0582_7f21a42e", "text": "Functional cohesion is the strongest and best kind of cohesion, occurring when a rou-\ntine performs one and only one operation. Examples of highly cohesive routines \ninclude sin() , GetCustomerName() , EraseFile() , CalculateLoanPayment() , and AgeFrom-\nBirthdate() . Of course, this evaluation of their cohesion assumes that the routines do \nwhat their names say they do—if they do anything else, they are less cohesive and \npoorly named. Several other kinds of cohesion are normally considered to be less than ideal:\n■\nSequential cohesion exists when a routine contains operations that must be per-\nformed in a specific order, that share data from step to step, and that don’t make \nup a complete function when done together. An example of sequential cohesion is a ro utine that, given a birth date, calculates \nan employee’s age and time to retirement. If the routine calculates the age and \nthen uses that result to calculate the employee’s time to retirement, it has \nsequential cohesion.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 582, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0583_a6d8f687", "text": "If the routine calculates the age and \nthen uses that result to calculate the employee’s time to retirement, it has \nsequential cohesion. If the routine calculates the age and then calculates the \ntime to retirement in a completely sepa rate computation that happens to use the \nsame birth-date data, it has only communicational cohesion. 1\n23\nHARD DATA\n7.2 Design at the Routine Level 169\nHow would you make the routine functionally cohesive? You’d create separate \nroutines to compute an employee’s age given a birth date and compute time to \nretirement given a birth date. The time-to-retirement routine could call the age \nroutine. They’d both have functional co hesion. Other routines could call either \nroutine or both routines. ■\nCommunicational cohesion occurs when operations in a routine make use of the \nsame data and aren’t related in any other way.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 583, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 861}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0584_e82efd61", "text": "Other routines could call either \nroutine or both routines. ■\nCommunicational cohesion occurs when operations in a routine make use of the \nsame data and aren’t related in any other way. If a routine prints a summary \nreport and then reinitializes the summar y data passed into it, the routine has \ncommunicational cohesion: the two operatio ns are related only by the fact that \nthey use the same data. To give this routine better cohesion, th e summary data should be reinitialized \nclose to where it’s created, which should n’t be in the report-printing routine. Split the operations into individual routines. The first prints the report. The sec-\nond reinitializes the data, close to the code that creates or modifies the data. Call \nboth routines from the higher-level ro utine that originally called the communi-\ncationally cohesive routine. ■\nTemporal cohesion occurs when operations are combined into a routine because \nthey are all done at the same time.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 584, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0585_806663f6", "text": "■\nTemporal cohesion occurs when operations are combined into a routine because \nthey are all done at the same time. Typical examples would be Startup() , Com-\npleteNewEmployee() , and Shutdown() . Some programmers consider temporal \ncohesion to be unacceptable because it ’s sometimes associated with bad pro-\ngramming practices such as having a hodgepodge of code in a Startup() routine. To avoid this problem, think of temporal routines as organizers of other events. The Startup() routine, for example, might read a configuration file, initialize a \nscratch file, set up a memory manager, an d show an initial screen. To make it \nmost effective, have the temporally cohesive routine call other routines to per-\nform specific activities rather than perfor ming the operations directly itself. That \nway, it will be clear that the point of the routine is to orchestrate activities rather \nthan to do them directly.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 585, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 915}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0586_fa8f3132", "text": "That \nway, it will be clear that the point of the routine is to orchestrate activities rather \nthan to do them directly. This example raises the issue of choosing a name that describes the routine at \nthe right level of abstraction. You could decide to name the routine ReadConfig-\nFileInitScratchFileEtc() , which would imply that the routine had only coinciden-\ntal cohesion. If you name it Startup() , however, it would be clear that it had a \nsingle purpose and clear that it had functional cohesion. The remaining kinds of cohesion are gene rally unacceptable. They result in code \nthat’s poorly organized, hard to debug, and hard to modify. If a routine has bad cohe-\nsion, it’s better to put effort into a rewrite to have better cohesion than investing in a \npinpoint diagnosis of the problem.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 586, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 800}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0587_06755834", "text": "If a routine has bad cohe-\nsion, it’s better to put effort into a rewrite to have better cohesion than investing in a \npinpoint diagnosis of the problem. Knowing what to avoid can be useful, however, so \nhere are the unacceptable kinds of cohesion:\n170\nChapter 7: High-Q uality Routines\n■\nProcedural cohesion occurs when operations in a ro utine are done in a specified \norder. An example is a routine that gets an employee name, then an address, and \nthen a phone number. The order of these operations is important only because \nit matches the order in which the user is asked for the data on the input screen. Another routine gets the rest of the employee data. The routine has procedural \ncohesion because it puts a set of operations in a specified order and the opera-\ntions don’t need to be combined for any other reason. To achieve better cohesion, put the separate operations into their own routines.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 587, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0588_96d8b1b7", "text": "To achieve better cohesion, put the separate operations into their own routines. Make sure that the calling routine has a single, complete job: GetEmployee() \nrather than GetFirstPartOfEmployeeData() . You’ll probably need to modify the \nroutines that get the rest of the data too. It’s common to modify two or more \noriginal routines before you achieve functional cohesion in any of them. ■\nLogical cohesion occurs when several operations are stuffed into the same routine \nand one of the operations is selected by a control flag that’s passed in. It’s called \nlogical cohesion because the control flow or “logic” of the routine is the only \nthing that ties the operations together—they’re all in a big if statement or case \nstatement together. It isn’t because the operations are logically related in any \nother sense.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 588, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 820}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0589_b3d61214", "text": "It isn’t because the operations are logically related in any \nother sense. Considering that the defining attribute of logical cohesion is that \nthe operations are unrelated, a better name might “illogical cohesion.” \nOne example would be an InputAll() routine that inputs customer names, \nemployee timecard information, or inventory data depending on a flag passed to \nthe routine. Other examples would be ComputeAll() , EditAll() , PrintAll() , and \nSaveAll() . The main problem with such routin es is that you shouldn’t need to \npass in a flag to control another routine’ s processing. Instead of having a routine \nthat does one of three distinct operations , depending on a flag passed to it, it’s \ncleaner to have three routines, each of wh ich does one distinct operation. If the \noperations use some of the same code or share data, the code should be moved \ninto a lower-level routine and the routines should be packaged into a class.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 589, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0590_b79e18d8", "text": "If the \noperations use some of the same code or share data, the code should be moved \ninto a lower-level routine and the routines should be packaged into a class. Cross-Reference Although \nthe routine might have bet-\nter cohesion, a higher-level \ndesign issue is whether the \nsystem should be using a \ncase statement instead of \npolymorphism. For more on \nthis issue, see “Replace con-\nditionals with polymorphism \n(especially repeated case \nstatements)” in Section 24.3\nIt’s usually all right, however, to create a logically cohesive routine if its code con-\nsists solely of a series of if or case statements and calls to other routines. In such \na case, if the routine’s only function is to dispatch commands and it doesn’t do \nany of the processing itself, that’s usua lly a good design. The technical term for \nthis kind of routine is “event handler.” An event handler is often used in interac-\ntive environments such as the Apple Ma cintosh, Microsoft Windows, and other \nGUI environments.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 590, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0591_182ef622", "text": "■\nCoincidental cohesion occurs when the operations in a routine have no discernible \nrelationship to each other. Other good names are “no cohesion” or “chaotic cohe-\nsion.” The low-quality C++ routine at the beginning of this chapter had coinciden-\ntal cohesion. It’s hard to convert coinci dental cohesion to any better kind of \ncohesion—you usually need to do a d eeper redesign and reimplementation. 7.3 Good Routine Names 171\nNone of these terms are magical or sacred. Learn the ideas rather than the terminol-\nogy. It’s nearly always possible to write routines with functional cohesion, so focus \nyour attention on functional cohesion for maximum benefit. 7.3 Good Routine Names\nCross-Reference For details \non naming variables, see \nChapter 11, “The Power of \nVariable Names.”\nA good name for a routine clearly describes everything the routine does.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 591, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 855}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0592_94bff717", "text": "7.3 Good Routine Names\nCross-Reference For details \non naming variables, see \nChapter 11, “The Power of \nVariable Names.”\nA good name for a routine clearly describes everything the routine does. Here are \nguidelines for creating effective routine names:\nDescribe everything the routine does In the routine’s name, describe all the outputs \nand side effects. If a routine computes report totals and opens an output file, Compute-\nReportTotals() is not an adequate name for the routine. ComputeReportTotalsAndOpen-\nOutputFile() is an adequate name but is too long and silly. If you have routines with \nside effects, you’ll have many long, silly names. The cure is not to use less-descriptive \nroutine names; the cure is to program so that you cause things to happen directly \nrather than with side effects. Avoid meaningless, vague, or wishy-washy verbs Some verbs are elastic, stretched to \ncover just about any meaning.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 592, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 919}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0593_f46e351a", "text": "Avoid meaningless, vague, or wishy-washy verbs Some verbs are elastic, stretched to \ncover just about any meaning. Routine names like HandleCalculation() , PerformSer-\nvices() , OutputUser() , ProcessInput() , and DealWithOutput() don’t tell you what the rou-\ntines do. At the most, these names tell you that the routines have something to do \nwith calculations, services, users, input, and output. The exception would be when \nthe verb “handle” was used in the specif ic technical sense of handling an event. Sometimes the only problem with a routine is that its name is wishy-washy; the rou-\ntine itself might actually be well designed. If HandleOutput() is replaced with For-\nmatAndPrintOutput() , you have a pretty good idea of what the routine does. In other cases, the verb is vague because the operations performed by the routine are \nvague. The routine suffers from a weakness of purpose, and the weak name is a symp-\ntom.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 593, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0594_4b9dd54b", "text": "In other cases, the verb is vague because the operations performed by the routine are \nvague. The routine suffers from a weakness of purpose, and the weak name is a symp-\ntom. If that’s the case, the best solution is to restructure the routine and any related \nroutines so that they all have stronger purposes and stronger names that accurately \ndescribe them. Don’t differentiate routine names solely by number One developer wrote all his \ncode in one big function. Then he took every 15 lines and created functions named \nPart1 , Part2 , and so on. After that, he created one high-level function that called each \npart. This method of creating and naming ro utines is especially egregious (and rare, I \nhope). But programmers sometimes use numbers to differentiate routines with names \nlike OutputUser , OutputUser1 , and OutputUser2 . The numerals at the ends of these \nnames provide no indication of the differen t abstractions the routines represent, and \nthe routines are thus poorly named.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 594, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0595_adcb9267", "text": "The numerals at the ends of these \nnames provide no indication of the differen t abstractions the routines represent, and \nthe routines are thus poorly named. Make names of routines as long as necessary Research shows that the optimum \naverage length for a variable name is 9 to 15 characters. Routines tend to be more com-\nKEY POINT\nKEY POINT\nCODING \nHORROR\n172\nChapter 7: High-Q uality Routines\nplicated than variables, and good names for them tend to be longer. On the other \nhand, routine names are often attached to object names, which essentially provides \npart of the name for free. Overall, the emphasis when creating a routine name should \nbe to make the name as clear as possible, which means you should make its name as \nlong or short as needed to make it understandable. Cross-Reference For the \ndistinction between proce-\ndures and functions, see \nSection 7.6, “Special Consid-\nerations in the Use of Func-\ntions,” later in this chapter.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 595, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0596_6bd883c5", "text": "Cross-Reference For the \ndistinction between proce-\ndures and functions, see \nSection 7.6, “Special Consid-\nerations in the Use of Func-\ntions,” later in this chapter. To name a function, use a description of the return value A function returns a value, \nand the function should be named for the value it returns. For example, cos() , \ncustomerId.Next() , printer.IsReady() , and pen.CurrentColor() are all good function \nnames that indicate precisely what the functions return. To name a procedure, use a strong verb followed by an object A procedure with \nfunctional cohesion usually performs an operation on an object. The name should \nreflect what the procedure does, and an operation on an object implies a verb-plus-\nobject name. PrintDocument() , CalcMonthlyRevenues() , CheckOrderlnfo() , and Repagi-\nnateDocument() are samples of good procedure names.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 596, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 860}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0597_0ad1f0d8", "text": "PrintDocument() , CalcMonthlyRevenues() , CheckOrderlnfo() , and Repagi-\nnateDocument() are samples of good procedure names. In object-oriented languages, you don’t need to include the name of the object in the \nprocedure name because the object itself is included in the call. You invoke routines \nwith statements like document.Print() , orderInfo.Check() , and monthlyRevenues.Calc() . Names like document.PrintDocument() are redundant and can become inaccurate \nwhen they’re carried through to derived classes. If Check is a class derived from Docu-\nment , check.Print() seems clearly to be printing a check, whereas check.PrintDocument() \nsounds like it might be printing a checkbook register or monthly statement, but it \ndoesn’t sound like it’s printing a check. Cross-Reference For a simi-\nlar list of opposites in vari-\nable names, see “Common \nOpposites in Variable \nNames” in Section 11.1.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 597, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0598_cabc89b3", "text": "Cross-Reference For a simi-\nlar list of opposites in vari-\nable names, see “Common \nOpposites in Variable \nNames” in Section 11.1. Use opposites precisely Using naming conventions for opposites helps consistency, \nwhich helps readability. Opposite-pairs like first/last are commonly understood. Opposite-pairs like FileOpen() and _lclose() are not symmetrical and are confusing. Here are some common opposites:\nEstablish conventions for common operations In some systems, it’s important to dis-\ntinguish among different kinds of operations . A naming convention is often the easiest \nand most reliable way of indicating these distinctions. The code on one of my projects assigned ea ch object a unique identifier.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 598, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 713}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0599_0a83f3cf", "text": "A naming convention is often the easiest \nand most reliable way of indicating these distinctions. The code on one of my projects assigned ea ch object a unique identifier. We neglected \nto establish a convention for naming the routines that would return the object identi-\nfier, so we had routine names like these:\nadd/remove increment/decrement open/close\nbegin/end insert/delete show/hide\ncreate/destroy lock/unlock source/target\nfirst/last min/max start/stop\nget/put next/previous up/down\nget/set old/new\n7.4 How Long Can a Routine Be? 173\nemployee.id.Get()\ndependent.GetId()\nsupervisor()\ncandidate.id()\nThe Employee class exposed its id object, which in turn exposed its Get() routine. The \nDependent class exposed a GetId() routine. The Supervisor class made the id its default \nreturn value. The Candidate class made use of the fact that the id object’s default \nreturn value was the id, and exposed the id object.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 599, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 920}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0600_83712cfe", "text": "The Supervisor class made the id its default \nreturn value. The Candidate class made use of the fact that the id object’s default \nreturn value was the id, and exposed the id object. By the middle of the project, no one \ncould remember which of these routines was supposed to be used on which object, \nbut by that time too much code had been written to go back and make everything con-\nsistent. Consequently, every person on the team had to devote an unnecessary \namount of gray matter to remembering the inconsequential detail of which syntax \nwas used on which class to retrieve the id. A naming convention for retrieving ids \nwould have eliminated this annoyance. 7.4 How Long Can a Routine Be? On their way to America, the Pilgrims argued about the best maximum length for a \nroutine. After arguing about it for the entire trip, they arrived at Plymouth Rock and \nstarted to draft the Mayflower Compact.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 600, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0601_cb42ed7d", "text": "After arguing about it for the entire trip, they arrived at Plymouth Rock and \nstarted to draft the Mayflower Compact. They still hadn’t settled the maximum-length \nquestion, and since they couldn’t disembark until they’d signed the compact, they \ngave up and didn’t include it. The result has been an interminable debate ever since \nabout how long a routine can be. The theoretical best maximum length is often described as one screen or one or two \npages of program listing, approximately 50 to 150 lines. In this spirit, IBM once lim-\nited routines to 50 lines, and TRW limite d them to two pages (McCabe 1976). Modern \nprograms tend to have volumes of extremely short routines mixed in with a few longer \nroutines. Long routines are far from extinc t, however. Shortly before finishing this \nbook, I visited two client sites within a mont h.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 601, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 845}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0602_7d4307fa", "text": "Long routines are far from extinc t, however. Shortly before finishing this \nbook, I visited two client sites within a mont h. Programmers at one site were wrestling \nwith a routine that was about 4,000 lines of code long, and programmers at the other \nsite were trying to tame a routine that was more than 12,000 lines long! A mountain of research on routine length has accumulated over the years, some of \nwhich is applicable to modern programs, and some of which isn’t: \n■\nA study by Basili and Perricone found that routine size was inversely correlated \nwith errors: as the size of routines incr eased (up to 200 lines of code), the num-\nber of errors per line of code d ecreased (Basili and Perricone 1984). ■\nAnother study found that routine size was not correlated with errors, even \nthough structural complexity and amount of data were correlated with errors \n(Shen et al. 1985).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 602, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 887}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0603_251118d0", "text": "■\nAnother study found that routine size was not correlated with errors, even \nthough structural complexity and amount of data were correlated with errors \n(Shen et al. 1985). 1\n23\nHARD DATA\n174\nChapter 7: High-Q uality Routines\n■\nA 1986 study found that small routines (32 lines of code or fewer) were not cor-\nrelated with lower cost or fault rate (C ard, Church, and Agresti 1986; Card and \nGlass 1990). The evidence suggested that la rger routines (65 lines of code or \nmore) were cheaper to develop per line of code. ■\nAn empirical study of 450 routines found that small routines (those with fewer \nthan 143 source statements, including comments) had 23 percent more errors \nper line of code than larger routines but were 2.4 times less expensive to fix than \nlarger routines (Selby and Basili 1991). ■\nAnother study found that code needed to be changed least when routines aver-\naged 100 to 150 lines of code (Lind and Vairavan 1989).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 603, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0604_5b68a9d4", "text": "■\nAnother study found that code needed to be changed least when routines aver-\naged 100 to 150 lines of code (Lind and Vairavan 1989). ■\nA study at IBM found that the most error-prone routines were those that were \nlarger than 500 lines of code. Beyond 500 lines, the error rate tended to be pro-\nportional to the size of the routine (Jones 1986a). Where does all this leave the question of routine length in object-oriented programs? A large percentage of routines in object-oriented programs will be accessor routines, \nwhich will be very short. From time to time, a complex algorithm will lead to a longer \nroutine, and in those circumstances, the routine should be allowed to grow organi-\ncally up to 100–200 lines. (A line is a noncomment, nonblank line of source code.) \nDecades of evidence say that routines of such length are no more error prone than \nshorter routines.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 604, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0605_3b1b275d", "text": "(A line is a noncomment, nonblank line of source code.) \nDecades of evidence say that routines of such length are no more error prone than \nshorter routines. Let issues such as the ro utine’s cohesion, depth of nesting, number \nof variables, number of decision points , number of comments needed to explain the \nroutine, and other complexity-related considerations dictate the length of the routine \nrather than imposing a length restriction per se. That said, if you want to write routines lon ger than about 200 lines, be careful. None \nof the studies that reported decreased cost, decreased error rates, or both with larger \nroutines distinguished among sizes larger than 200 lines, and you’re bound to run \ninto an upper limit of understandability as you pass 200 lines of code. 7.5 How to Use Routine Parameters\nInterfaces between routines are some of the most error-prone areas of a program.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 605, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 897}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0606_c3a050ae", "text": "7.5 How to Use Routine Parameters\nInterfaces between routines are some of the most error-prone areas of a program. One \noften-cited study by Basili and Perricone (1984) found that 39 percent of all errors \nwere internal interface errors—errors in communication between routines. Here are a \nfew guidelines for minimizing interface problems:\nCross-Reference For details \non documenting routine \nparameters, see “Comment-\ning Routines” in Section 32.5. For details on formatting \nparameters, see Section \n31.7, “Laying Out Routines.”\nPut parameters in input-modify-output order Instead of ordering parameters ran-\ndomly or alphabetically, list the parameters that are input-only first, input-and-output \nsecond, and output-only third. This ordering implies the sequence of operations hap-\npening within the routine-inputting data, changing it, and sending back a result.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 606, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 868}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0607_1260f568", "text": "This ordering implies the sequence of operations hap-\npening within the routine-inputting data, changing it, and sending back a result. Here \nare examples of parameter lists in Ada:\n1\n23\nHARD DATA\n7.5 How to Use Routine Parameters 175\nAda Example of Parameters in Input-Modify-Output Order\nprocedure InvertMatrix(\nAda uses in and out key-\nwords to make input and \noutput parameters clear. originalMatrix: in Matrix;\nresultMatrix: out Matrix\n);\n... procedure ChangeSentenceCase(\ndesiredCase: in StringCase;\nsentence: in out Sentence\n);\n... procedure PrintPageNumber(\npageNumber: in Integer;\nstatus: out StatusType\n);\nThis ordering convention conflicts with th e C-library convention of putting the mod-\nified parameter first. The input-modify-out put convention makes more sense to me, \nbut if you consistently order parameters in some way, you will still do the readers of \nyour code a service.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 607, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 894}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0608_9bce4ef7", "text": "The input-modify-out put convention makes more sense to me, \nbut if you consistently order parameters in some way, you will still do the readers of \nyour code a service. Consider creating your own in and out keywords Other modern languages don’t \nsupport the in and out keywords like Ada does. In thos e languages, you might still be \nable to use the preprocessor to create your own in and out keywords:\nC+ + Example of Defining Your Own In and Out Keywords\n#define IN\n#define OUT\nvoid InvertMatrix(\nIN Matrix originalMatrix,\nOUT Matrix *resultMatrix\n);\n... void ChangeSentenceCase(\nIN StringCase desiredCase,\nIN OUT Sentence *sentenceToEdit\n);\n... void PrintPageNumber(\nIN int pageNumber,\nOUT StatusType &status\n);\nIn this case, the IN and OUT macro-keywords are used for documentation purposes. To make the value of a parameter changeable by the called routine, the parameter still \nneeds to be passed as a pointer or as a reference parameter.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 608, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0609_887d2a7c", "text": "To make the value of a parameter changeable by the called routine, the parameter still \nneeds to be passed as a pointer or as a reference parameter. 176\nChapter 7: High-Q uality Routines\nBefore adopting this technique, be sure to consider a pair of significant drawbacks. Defin-\ning your own IN and OUT keywords extends the C++ language in a way that will be unfa-\nmiliar to most people reading your code. If you extend the language this way, be sure to \ndo it consistently, preferably projectw ide. A second limitation is that the IN and OUT key-\nwords won’t be enforceable by the compiler, which means that you could potentially \nlabel a parameter as IN and then modify it inside the routine anyway. That could lull a \nreader of your code into assuming code is correct when it isn’t. Using C++’s const key-\nword will normally be the preferable me ans of identifying inpu t-only parameters.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 609, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 891}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0610_be164a93", "text": "That could lull a \nreader of your code into assuming code is correct when it isn’t. Using C++’s const key-\nword will normally be the preferable me ans of identifying inpu t-only parameters. If several routines use similar parameters, put the similar parameters in a consistent \norder The order of routine parameters can be a mnemonic, and inconsistent order \ncan make parameters hard to remember. For example, in C, the fprintf() routine is the \nsame as the printf() routine except that it adds a file as the first argument. A similar \nroutine, fputs() , is the same as puts() except that it adds a file as the last argument. This \nis an aggravating, pointless difference that makes the parameters of these routines \nharder to remember than they need to be. On the other hand, the routine strncpy() in C takes the arguments target string, source \nstring, and maximum number of bytes, in that order, and the routine memcpy() takes \nthe same arguments in the same order.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 610, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0611_f772b9b9", "text": "The similarity between the two routines helps \nin remembering the parameters in either routine. Use all the parameters If you pass a parameter to a routine, use it. If you aren’t using \nit, remove the parameter from the routine in terface. Unused parameters are correlated \nwith an increased error rate. In one study, 46 percent of routines with no unused vari-\nables had no errors, and only 17 to 29 percent of routines with more than one unref-\nerenced variable had no errors (Card, Church, and Agresti 1986). This rule to remove unused parameters has on e exception. If you’re compiling part of \nyour program conditionally, you might compile out parts of a routine that use a cer-\ntain parameter. Be nervous about this practice, but if you’re convinced it works, that’s \nOK too. In general, if you have a good re ason not to use a parameter, go ahead and \nleave it in place. If you don’t have a good reason, make the effort to clean up the code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 611, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0612_e5ba886b", "text": "In general, if you have a good re ason not to use a parameter, go ahead and \nleave it in place. If you don’t have a good reason, make the effort to clean up the code. Put status or error variables last By convention, status variables and variables that \nindicate an error has occurred go last in the parameter list. They are incidental to the \nmain purpose of the routine, and they are output-only parameters, so it’s a sensible \nconvention. Don’t use routine paramete rs as working variables It’s dangerous to use the param-\neters passed to a routine as working variables. Use local variables instead. For exam-\nple, in the following Java fragment, the variable inputVal is improperly used to store \nintermediate results of a computation:\n1\n23\nHARD DATA\n7.5 How to Use Routine Parameters 177\nJava Example of Improper Use of Input Parameters\nint Sample( int inputVal ) {\ninputVal = inputVal * CurrentMultiplier( inputVal );\ninputVal = inputVal + CurrentAdder( inputVal );\n...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 612, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0613_a7419993", "text": "At this point, inputVal no \nlonger contains the value \nthat was input. return inputVal;\n}\nIn this code fragment, inputVal is misleading because by the time execution reaches the \nlast line, inputVal no longer contains the input value; it contains a computed value based \nin part on the input value, and it is therefore misnamed. If you later need to modify the \nroutine to use the original input value in some other place, you’ll probably use inputVal \nand assume that it contains the original input value when it actually doesn’t. How do you solve the problem? Can you solve it by renaming inputVal ? Probably not. You could name it something like workingVal , but that’s an incomplete solution because \nthe name fails to indicate that the variable’s original value comes from outside the rou-\ntine. You could name it something ridiculous like inputValThatBecomesWorkingVal or \ngive up completely and name it x or val, but all these approaches are weak.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 613, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0614_2edba285", "text": "You could name it something ridiculous like inputValThatBecomesWorkingVal or \ngive up completely and name it x or val, but all these approaches are weak. A better approach is to avoid current and future problems by using working variables \nexplicitly. The following code frag ment demonstrates the technique: \nJava Example of Good Use of Input Parameters\nint Sample( int inputVal ) {\nint workingVal = inputVal;\nworkingVal = workingVal * CurrentMultiplier( workingVal );\nworkingVal = workingVal + CurrentAdder( workingVal );\n... If you need to use the origi-\nnal value of inputVal here \nor somewhere else, it’s still \navailable. ... return workingVal;\n}\nIntroducing the new variable workingVal clarifies the role of inputVal and eliminates \nthe chance of erroneously using inputVal at the wrong time. (Don’t take this reasoning \nas a justification for literally naming a variable inputVal or workingVal .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 614, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 903}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0615_6553ed60", "text": "(Don’t take this reasoning \nas a justification for literally naming a variable inputVal or workingVal . In general, \ninputVal and workingVal are terrible names for variables, and these names are used in \nthis example only to make the variables’ roles clear.)\nAssigning the input value to a working variable emphasizes where the value comes \nfrom. It eliminates the possibility that a variable from the parameter list will be modi-\nfied accidentally. In C++, this practice can be enforced by the compiler using the key-\nword const . If you designate a parameter as const , you’re not allowed to modify its value \nwithin a routine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 615, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 629}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0616_6f2d0547", "text": "In C++, this practice can be enforced by the compiler using the key-\nword const . If you designate a parameter as const , you’re not allowed to modify its value \nwithin a routine. 178\nChapter 7: High-Q uality Routines\nCross-Reference For details \non interface assumptions, \nsee the introduction to \nChapter 8, “Defensive Pro-\ngramming.” For details on \ndocumentation, see Chapter \n32, “Self-Documenting \nCode.”\nDocument interface assumptions about parameters If you assume the data being \npassed to your routine has certain characte ristics, document the assumptions as you \nmake them. It’s not a waste of effort to document your assumptions both in the rou-\ntine itself and in the place where the routine is called. Don’t wait until you’ve written \nthe routine to go back and write the comments—you won’t remember all your assump-\ntions. Even better than commenting your assumptions, use assertions to put them \ninto code. What kinds of interface assumptions ab out parameters should you document?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 616, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0617_e427daa9", "text": "Even better than commenting your assumptions, use assertions to put them \ninto code. What kinds of interface assumptions ab out parameters should you document? ■\nWhether parameters are input-only, modified, or output-only\n■\nUnits of numeric parameters (inches, feet, meters, and so on)\n■\nMeanings of status codes and error values if enumerated types aren’t used \n■\nRanges of expected values\n■\nSpecific values that should never appear\nLimit the number of a routine’s parameters to about seven Seven is a magic number \nfor people’s comprehension. Psychological research has found that people generally \ncannot keep track of more than about seven chunks of information at once (Miller \n1956). This discovery has been applied to an enormous number of disciplines, and it \nseems safe to conjecture that most people can’t keep track of more than about seven \nroutine parameters at once. In practice, how much you can limit the number of parameters depends on how your \nlanguage handles complex data types.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 617, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0618_42bc33e6", "text": "In practice, how much you can limit the number of parameters depends on how your \nlanguage handles complex data types. If you program in a modern language that sup-\nports structured data, you can pass a compos ite data type containing 13 fields and \nthink of it as one mental “chunk” of data. If you program in a more primitive language, \nyou might need to pass all 13 fields individually. Cross-Reference For details \non how to think about inter-\nfaces, see “Good Abstrac-\ntion” in Section 6.2. If you find yourself consistently passing more than a few arguments, the coupling \namong your routines is too tight. Design the routine or group of routines to reduce the \ncoupling. If you are passing the same data to many different routines, group the rou-\ntines into a class and treat the frequently used data as class data.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 618, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 822}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0619_592cb769", "text": "If you are passing the same data to many different routines, group the rou-\ntines into a class and treat the frequently used data as class data. Consider an input, modify, and outp ut naming convention for parameters If you \nfind that it’s important to distinguish among input, modify, and output parameters, \nestablish a naming convention that identifies them. You could prefix them with i_, \nm_, and o_. If you’re feeling verbose, you could prefix them with Input_ , Modify_ , and \nOutput_ . 1\n23\nHARD DATA\n7.5 How to Use Routine Parameters 179\nPass the variables or objects that the routine needs to maintain its interface \nabstraction There are two competing schools of thought about how to pass members \nof an object to a routine. Suppose you have an object that exposes data through 10 \naccess routines and the called routine needs three of those data elements to do its job.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 619, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 881}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0620_9eb291c4", "text": "Suppose you have an object that exposes data through 10 \naccess routines and the called routine needs three of those data elements to do its job. Proponents of the first school of thought ar gue that only the three specific elements \nneeded by the routine should be passed. They argue that doing this will keep the con-\nnections between routines to a minimum; reduce coupling; and make them easier to \nunderstand, reuse, and so on. They say that passing the whole object to a routine vio-\nlates the principle of encapsulation by pote ntially exposing all 10 access routines to \nthe routine that’s called. Proponents of the second school argue that the whole object should be passed. They \nargue that the interface can remain more stab le if the called routine has the flexibility \nto use additional members of the object without changing the routine’s interface. They argue that passing three specific elem ents violates encapsulation by exposing \nwhich specific data elemen ts the routine is using.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 620, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0621_9970edbe", "text": "They argue that passing three specific elem ents violates encapsulation by exposing \nwhich specific data elemen ts the routine is using. I think both these rules are simplistic and miss the most important consideration: \nwhat abstraction is presente d by the routine’s interface? If the abstraction is that the rou-\ntine expects you to have three specific data elements, and it is only a coincidence that \nthose three elements happen to be provided by the same object, then you should pass \nthe three specific data elements individually. However, if the abstraction is that you \nwill always have that particular object in hand and the routine will do something or \nother with that object, then you truly do break the abstraction when you expose the \nthree specific data elements.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 621, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 779}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0622_f0a39950", "text": "If you’re passing the whole object and you find yourself creating the object, populat-\ning it with the three elements needed by the called routine, and then pulling those ele-\nments out of the object after the routine is ca lled, that’s an indication that you should \nbe passing the three specific elements rather than the whole object. (In general, code \nthat “sets up” for a call to a routine or “takes down” after a call to a routine is an indi-\ncation that the routine is not well designed.)\nIf you find yourself frequently changing th e parameter list to the routine, with the \nparameters coming from the same object ea ch time, that’s an indication that you \nshould be passing the whole object rather than specific elements. 180\nChapter 7: High-Q uality Routines\nUse named parameters In some languages, you can exp licitly associate formal param-\neters with actual parameters. This makes parameter usage more self-documenting and \nhelps avoid errors from mismatching parameters.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 622, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0623_1aea3d2d", "text": "This makes parameter usage more self-documenting and \nhelps avoid errors from mismatching parameters. Here’s an example in Visual Basic:\nVisual Basic Example of Explicitly Identifying Parameters\nPrivate Function Distance3d( _\nHere’s where the formal \nparameters are declared. ByVal xDistance As Coordinate, _\nByVal yDistance As Coordinate, _\nByVal zDistance As Coordinate _\n)\n... End Function\n... Private Function Velocity( _\nByVal latitude as Coordinate, _\nByVal longitude as Coordinate, _\nByVal elevation as Coordinate _\n)\n... Here’s where the actual \nparameters are mapped to \nthe formal parameters. Distance = Distance3d( xDistance := latitude, yDistance := longitude, _\nzDistance := elevation )\n... End Function\nThis technique is especially useful when yo u have longer-than-average lists of identi-\ncally typed arguments, which increases the chances that you can insert a parameter \nmismatch without the compiler detecting it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 623, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 932}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0624_cedaad0b", "text": "Explicitly associating parameters may be \noverkill in many environments , but in safety-criti cal or other high-reliability environ-\nments the extra assurance that parameters match up the way you expect can be \nworthwhile. Make sure actual parameters match formal parameters Formal parameters, also \nknown as “dummy parameters,” are the variables declared in a routine definition. Actual parameters are the variables, constant s, or expressions used in the actual rou-\ntine calls. A common mistake is to put the wrong type of variable in a routine call—for example, \nusing an integer when a floating point is needed. (This is a problem only in weakly \ntyped languages like C when you’re not usin g full compiler warnings. Strongly typed \nlanguages such as C++ and Java don’t have this problem.) When arguments are input \nonly, this is seldom a problem; usually the compiler converts the actual type to the for-\nmal type before passing it to the routine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 624, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0625_51a4d4b4", "text": "If it is a problem, usually your compiler gives \nyou a warning. But in some cases, particularly when the argument is used for both \ninput and output, you can get stung by passing the wrong type of argument. Develop the habit of checking types of argu ments in parameter li sts and heeding com-\npiler warnings about mismatched parameter types. 7.6 Special Considerations in the Use of Functions 181\n7.6 Special Considerations in the Use of Functions\nModern languages such as C++, Java, and Visual Basic support both functions and proce-\ndures. A function is a routine that returns a va lue; a procedure is a routine that does not. In C++, all routines are typically called “functions”; however, a function with a void return \ntype is semantically a procedure. The distin ction between functions and procedures is as \nmuch a semantic distinction as a syntactic one, and semantics should be your guide.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 625, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0626_dfec6f59", "text": "The distin ction between functions and procedures is as \nmuch a semantic distinction as a syntactic one, and semantics should be your guide. When to Use a Function and When to Use a Procedure \nPurists argue that a function should return on ly one value, just as a mathematical func-\ntion does. This means that a function would take only input parameters and return its \nonly value through the function itself. The function would always be named for the value \nit returned, as sin() , CustomerID() , and ScreenHeight() are. A procedure, on the other \nhand, could take input, modify, and output pa rameters—as many of each as it wanted to. A common programming practice is to have a function that operates as a procedure and \nreturns a status value. Logically, it works as a procedure, but because it returns a value, \nit’s officially a function.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 626, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 844}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0627_7eb25d24", "text": "Logically, it works as a procedure, but because it returns a value, \nit’s officially a function. For example, you might have a routine called FormatOutput() \nused with a report object in statements like this one:\nif ( report.FormatOutput( formattedReport ) = Success ) then ... In this example, report.FormatOutput() operates as a procedure in that it has an output \nparameter, formattedReport , but it is technically a function because the routine itself \nreturns a value. Is this a valid way to use a function? In defense of this approach, you \ncould maintain that the function return value has nothing to do with the main purpose \nof the routine, formatting output, or with the routine name, report.FormatOutput(). In \nthat sense it operates more as a procedure does even if it is technically a function. The \nuse of the return value to indicate the success or failure of the procedure is not con-\nfusing if the technique is used consistently.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 627, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0628_249b0924", "text": "The \nuse of the return value to indicate the success or failure of the procedure is not con-\nfusing if the technique is used consistently. The alternative is to create a procedure that has a status variable as an explicit param-\neter, which promotes code like this fragment:\nreport.FormatOutput( formattedReport, outputStatus )\nif ( outputStatus = Success ) then ... I prefer the second style of coding, not because I’m hard-nosed about the difference \nbetween functions and procedures but because it makes a clear separation between \nthe routine call and the test of the status value. To combine the call and the test into \none line of code increases the density of the statement and, correspondingly, its com-\nplexity. The following use of a function is fine too:\noutputStatus = report.FormatOutput( formattedReport )\nif ( outputStatus = Success ) then ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 628, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 858}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0629_7facfe65", "text": "The following use of a function is fine too:\noutputStatus = report.FormatOutput( formattedReport )\nif ( outputStatus = Success ) then ... 182\nChapter 7: High-Q uality Routines\nIn short, use a function if the primary purpose of the routine is to return the value \nindicated by the function name. Otherwise, use a procedure. Setting the Function ’s Return Value\nUsing a function creates the risk that the function will return an incorrect return \nvalue. This usually happens when the func tion has several possible paths and one of \nthe paths doesn’t set a return value. To reduce this risk, do the following: \nCheck all possible return paths When creating a function, mentally execute each \npath to be sure that the function returns a value under all possible circumstances. It’s \ngood practice to initialize the return value at the beginning of the function to a default \nvalue—this provides a safety net in the event that the correct return value is not set.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 629, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0630_1422b9d0", "text": "It’s \ngood practice to initialize the return value at the beginning of the function to a default \nvalue—this provides a safety net in the event that the correct return value is not set. Don’t return references or pointers to local data As soon as the routine ends and the \nlocal data goes out of scope, the reference or pointer to the local data will be invalid. If \nan object needs to return information about its internal data, it should save the informa-\ntion as class member data. It should then provide accessor functions that return the val-\nues of the member data items rather than references or pointers to local data. 7.7 Macro Routines and Inline Routines\nCross-Reference Even if \nyour language doesn’t have \na macro preprocessor, you \ncan build your own. For \ndetails, see Section 30.5, \n“Building Your Own Pro-\ngramming Tools.”\nRoutines created with preprocessor macros call for a few unique considerations. The \nfollowing rules and examples pertain to using the preprocessor in C++.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 630, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0631_e3f29fc4", "text": "The \nfollowing rules and examples pertain to using the preprocessor in C++. If you’re using \na different language or preprocessor, adapt the rules to your situation. Fully parenthesize macro expressions Because macros and their arguments are \nexpanded into code, be careful that they expand the way you want them to. One com-\nmon problem lies in creating a macro like this one:\nC+ + Example of a Macro That Doesn’t Expand Properly\n#define Cube( a ) a*a*a\nIf you pass this macro nonatomic values for a, it won’t do the multiplication properly. If you use the expression Cube( x+1 ) , it expands to x+1 * x + 1 * x + 1 , which, because \nof the precedence of the multiplication and addition operators, is not what you want. A better, but still not perfect, version of the macro looks like this:\nC+ + Example of a Macro That Still Doesn’t Expand Properly \n#define Cube( a ) (a)*(a)*(a)\nKEY POINT\n7.7 Macro Routines and Inline Routines 183\nThis is close, but still no cigar.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 631, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0632_ef84f044", "text": "If you use Cube() in an expression that has operators \nwith higher precedence than multiplication, the (a)*(a)*(a) will be torn apart. To pre-\nvent that, enclose the whole expression in parentheses:\nC+ + Example of a Macro That Works \n#define Cube( a ) ((a)*(a)*(a))\nSurround multiple-statement macros with curly braces A macro can have multiple \nstatements, which is a problem if you treat it as if it were a single statement. Here’s an \nexample of a macro that’s headed for trouble:\nC+ + Example of a Nonworking Macro with Multiple Statements\n#define LookupEntry( key, index ) \\\nindex = (key - 10) / 5; \\\nindex = min( index, MAX_INDEX ); \\\nindex = max( index, MIN_INDEX );\n... for ( entryCount = 0; entryCount < numEntries; entryCount++ )\nLookupEntry( entryCount, tableIndex[ entryCount ] );\nThis macro is headed for trouble because it doesn’t work as a regular function would.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 632, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 879}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0633_86fb9b31", "text": "for ( entryCount = 0; entryCount < numEntries; entryCount++ )\nLookupEntry( entryCount, tableIndex[ entryCount ] );\nThis macro is headed for trouble because it doesn’t work as a regular function would. As it’s shown, the only part of the macro that’s executed in the for loop is the first line \nof the macro:\nindex = (key - 10) / 5;\nTo avoid this problem, surround the macro with curly braces: \nC+ + Example of a Macro with Mu ltiple Statements That Works\n#define LookupEntry( key, index ) { \\\nindex = (key - 10) / 5; \\\nindex = min( index, MAX_INDEX ); \\\nindex = max( index, MIN_INDEX ); \\\n}\nThe practice of using macros as substitutes for function calls is generally considered \nrisky and hard to understand—bad programming practice—so use this technique only \nif your specific circumstances require it. Name macros that expand to code like routines so that they can be replaced by routines \nif necessary The convention in C++ for naming macros is to use all capital letters.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 633, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0634_490b03e2", "text": "Name macros that expand to code like routines so that they can be replaced by routines \nif necessary The convention in C++ for naming macros is to use all capital letters. If \nthe macro can be replaced by a routine, however, name it using the naming conven-\ntion for routines instead. That way you can replace macros with routines and vice \nversa without changing anything but the routine involved. CODING \nHORROR\n184\nChapter 7: High-Q uality Routines\nFollowing this recommendation entail s some risk. If you commonly use ++ and -- as \nside effects (as part of other statements), you’ll get burned when you use macros that \nyou think are routines. Considering the other problems with side effects, this is yet \nanother reason to avoid using side effects.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 634, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 754}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0635_b6b1a0ab", "text": "Considering the other problems with side effects, this is yet \nanother reason to avoid using side effects. Limitations on the Use of Macro Routines\nModern languages like C++ provide numerous alternatives to the use of macros:\n■\nconst for declaring constant values\n■\ninline for defining functions that will be compiled as inline code\n■\ntemplate for defining standard operations like min, max, and so on in a type-safe \nway\n■\nenum for defining enumerated types\n■\ntypedef for defining simple type substitutions\nAs Bjarne Stroustrup, designer of C++ poin ts out, “Almost every macro demonstrates \na flaw in the programming language, in the program, or in the programmer.... When \nyou use macros, you should expect inferior service from tools such as debuggers, \ncross-reference tools, and profilers” (Stroustrup 1997). Macros are useful for support-\ning conditional compilation—see Section 8.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 635, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0636_a6d14d52", "text": "Macros are useful for support-\ning conditional compilation—see Section 8. 6, “Debugging Aids”—but careful program-\nmers generally use a macro as an alternative to a routine only as a last resort. Inline Routines\nC++ supports an inline keyword. An inline routine allows the programmer to treat the \ncode as a routine at code-writing time, bu t the compiler will generally convert each \ninstance of the routine into inline code at compile time. The theory is that inline can \nhelp produce highly efficient code that avoids routine-call overhead. Use inline routines sparingly Inline routines violate encapsulation because C++ \nrequires the programmer to put the code for the implementation of the inline routine \nin the header file, which exposes it to every programmer who uses the header file. Inline routines require a routine’s full code to be generated every time the routine is \ninvoked, which for an inline routine of any si ze will increase code size. That can create \nproblems of its own.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 636, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0637_74b47cc9", "text": "Inline routines require a routine’s full code to be generated every time the routine is \ninvoked, which for an inline routine of any si ze will increase code size. That can create \nproblems of its own. KEY POINT\n7.7 Macro Routines and Inline Routines 185\nThe bottom line on inlining for performance reasons is the same as the bottom line on \nany other coding technique that’s motivate d by performance: profile the code and \nmeasure the improvement. If the anticipa ted performance gain doesn’t justify the \nbother of profiling the code to verify the improvement, it doesn’t justify the erosion in \ncode quality either. cc2e.com/0792\nCross-Reference This is a \nchecklist of considerations \nabout the quality of the rou-\ntine. For a list of the steps \nused to build a routine, see \nthe checklist “The Pseudo-\ncode Programming Process” \nin Chapter 9, page 215. CHECKLIST: High-Quality Routines\nBig-Picture Issues\n❑\nIs the reason for creating the routine sufficient?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 637, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0638_2c78a462", "text": "CHECKLIST: High-Quality Routines\nBig-Picture Issues\n❑\nIs the reason for creating the routine sufficient? ❑\nHave all parts of the routine that would benefit from being put into rou-\ntines of their own been put into routines of their own? ❑\nIs the routine’s name a strong, clear verb-plus-object name for a procedure \nor a description of the return value for a function? ❑\nDoes the routine’s name describe everything the routine does? ❑\nHave you established naming conventions for common operations? ❑\nDoes the routine have strong, functi onal cohesion—doing one and only \none thing and doing it well? ❑\nDo the routines have loose couplin g—are the routine’s connections to \nother routines small, intimate, visible, and flexible? ❑\nIs the length of the routine determined naturally by its function and logic, \nrather than by an artificial coding standard? Parameter-Passing Issues\n❑\nDoes the routine’s parameter list, taken as a whole, present a consistent \ninterface abstraction?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 638, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0639_a1ef5a66", "text": "Parameter-Passing Issues\n❑\nDoes the routine’s parameter list, taken as a whole, present a consistent \ninterface abstraction? ❑\nAre the routine’s parameters in a sensible order, including matching the \norder of parameters in similar routines? ❑\nAre interface assumptions documented? ❑\nDoes the routine have seven or fewer parameters? ❑\nIs each input parameter used? ❑\nIs each output parameter used? ❑\nDoes the routine avoid using input parameters as working variables? ❑\nIf the routine is a function, does it return a valid value under all possible \ncircumstances? 186\nChapter 7: High-Q uality Routines\nKey Points\n■\nThe most important reason for creating a routine is to improve the intellectual \nmanageability of a program, and you can create a routine for many other good \nreasons. Saving space is a minor reason; improved readability, reliability, and \nmodifiability are better reasons. ■\nSometimes the operation that most benefits from being put into a routine of its \nown is a simple one.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 639, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0640_1a699176", "text": "■\nSometimes the operation that most benefits from being put into a routine of its \nown is a simple one. ■\nYou can classify routines into various ki nds of cohesion, but you can make most \nroutines functionally cohesive, which is best. ■\nThe name of a routine is an indication of its quality. If the name is bad and it’s \naccurate, the routine might be poorly designed. If the name is bad and it’s inac-\ncurate, it’s not telling you what the prog ram does. Either way, a bad name means \nthat the program needs to be changed. ■\nFunctions should be used only when the primary purpose of the function is to \nreturn the specific value described by the function’s name. ■\nCareful programmers use macro routines with care and only as a last resort.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 640, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 741}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0641_4c6ce85f", "text": "■\nCareful programmers use macro routines with care and only as a last resort. 187\nChapter 8\nDefensive Programming\ncc2e.com/0861\nContents\n■\n8.1 Protecting Your Program from Invalid Inputs: page 188\n■\n8.2 Assertions: page 189\n■\n8.3 Error-Handling Techniques: page 194\n■\n8.4 Exceptions: page 198\n■\n8.5 Barricade Your Program to Contain the Damage Caused by Errors: page 203\n■\n8.6 Debugging Aids: page 205\n■\n8.7 Determining How Much Defensive Programming to Leave in Production \nCode: page 209\n■\n8.8 Being Defensive About Defensive Programming: page 210\nRelated Topics\n■\nInformation hiding: \"Hide Secrets (Inf ormation Hiding)\" in Section 5.3\n■\nDesign for change: \"Identify Areas Likely to Change\" in Section 5.3\n■\nSoftware architecture: Section 3.5\n■\nDesign in Construction: Chapter 5\n■\nDebugging: Chapter 23\nDefensive programming doesn’t mean being defensive about your programming—“It \ndoes so work!” The idea is based on defensive driving.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 641, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0642_16cb01e4", "text": "In defensive driving, you adopt \nthe mind-set that you’re never sure what the other drivers are going to do. That way, \nyou make sure that if they do something dangerous you won’t be hurt. You take \nresponsibility for protecting yourself even when it might be the other driver’s fault. In \ndefensive programming, the main idea is that if a routine is passed bad data, it won’t \nbe hurt, even if the bad data is another rout ine’s fault. More generally, it’s the recogni-\ntion that programs will have problems and modifications, and that a smart program-\nmer will develop code accordingly. This chapter describes how to protect yourself from the cold, cruel world of invalid \ndata, events that can “never” happen, and other programmers’ mistakes. If you’re an \nexperienced programmer, you might skip the next section on handling input data and \nbegin with Section 8.2, which reviews the use of assertions.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 642, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 904}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0643_971d333c", "text": "If you’re an \nexperienced programmer, you might skip the next section on handling input data and \nbegin with Section 8.2, which reviews the use of assertions. KEY POINT\n188\nChapter 8: Defensive Programming\n8.1 Protecting Your Prog ram from Invalid Inputs\nIn school you might have heard the expression, “Garbage in, garbage out.” That expres-\nsion is essentially software development’s ve rsion of caveat emptor: let the user beware. For production software, garbage in, garbage out isn’t good enough. A good program \nnever puts out garbage, regardless of what it takes in. A good program uses “garbage in, \nnothing out,” “garbage in, error message out,” or “no garbage allowed in” instead. By \ntoday’s standards, “garbage in, garbage out” is the mark of a sloppy, nonsecure program.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 643, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 782}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0644_3913966d", "text": "By \ntoday’s standards, “garbage in, garbage out” is the mark of a sloppy, nonsecure program. There are three general ways to handle garbage in: \nCheck the values of all data from external sources When getting data from a file, a \nuser, the network, or some other external interface, check to be sure that the data falls \nwithin the allowable range. Make sure that numeric values are within tolerances and \nthat strings are short enough to handle. If a string is intended to represent a restricted \nrange of values (such as a financial transact ion ID or something similar), be sure that \nthe string is valid for its intended purpose; otherwise reject it. If you’re working on a \nsecure application, be especially leery of data that might attack your system: \nattempted buffer overflows, injected SQ L commands, injected HTML or XML code, \ninteger overflows, data passed to system calls, and so on.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 644, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 897}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0645_707b9c0e", "text": "Check the values of all routine input parameters Checking the values of routine \ninput parameters is essentially the same as checking data that comes from an external \nsource, except that the data comes from another routine instead of from an external \ninterface. The discussion in Section 8.5, “Barricade Your Program to Contain the Dam-\nage Caused by Errors,” provides a practical way to determine which routines need to \ncheck their inputs. Decide how to handle bad inputs Once you’ve detected an invalid parameter, what \ndo you do with it? Depending on the situat ion, you might choose any of a dozen dif-\nferent approaches, which are described in de tail in Section 8.3, “Error-Handling Tech-\nniques,” later in this chapter. Defensive programming is useful as an adjunct to the other quality-improvement tech-\nniques described in this book. The best form of defensive coding is not inserting \nerrors in the first place.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 645, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0646_ade1980e", "text": "Defensive programming is useful as an adjunct to the other quality-improvement tech-\nniques described in this book. The best form of defensive coding is not inserting \nerrors in the first place. Using iterative design, writing pseudocode before code, writ-\ning test cases before writing the code, and having low-level design inspections are all \nactivities that help to prevent inserting defe cts. They should thus be given a higher pri-\nority than defensive programming. Fortunately, you can use defensive programming \nin combination with the other techniques. As Figure 8-1 suggests, protecting yourself from seemingly small problems can make \nmore of a difference than you might think. The rest of this chapter describes specific \noptions for checking data from external sources, checking input parameters, and han-\ndling bad inputs.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 646, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 836}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0647_b0b17f1c", "text": "The rest of this chapter describes specific \noptions for checking data from external sources, checking input parameters, and han-\ndling bad inputs. KEY POINT\n8.2 Assertions 189\nFigure 8-1 Part of the Interstate-90 floating bridge in Seattle sank during a storm because \nthe flotation tanks were left uncovered, they filled with water, and the bridge became too \nheavy to float. During construction, protecting yourself against the small stuff matters more \nthan you might think. 8.2 Assertions\nAn assertion is code that’s used during development—usually a routine or macro—that \nallows a program to check itself as it runs. When an assertion is true, that means \neverything is operating as expected. When it’s false, that means it has detected an \nunexpected error in the code. For example, if the system assumes that a customer-\ninformation file will never have more than 50,000 records, the program might contain \nan assertion that the number of records is less than or equal to 50,000.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 647, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0648_3227967d", "text": "As long as the \nnumber of records is less than or equal to 50,000, the assertion will be silent. If it \nencounters more than 50,000 records, however, it will loudly “assert” that an error is \nin the program. Assertions are especially useful in large, complicated programs and in high-reliability \nprograms. They enable programmers to more quickly flush out mismatched interface \nassumptions, errors that creep in when code is modified, and so on. An assertion usually takes two arguments: a boolean expression that describes the \nassumption that’s supposed to be true, and a me ssage to display if it isn’t. Here’s what a \nJava assertion would look like if the variable denominator were expected to be nonzero:\nMike Siegel/The Seattle Times\nKEY POINT\n190\nChapter 8: Defensive Programming\nJava Example of an Assertion\nassert denominator != 0 : \"denominator is unexpectedly equal to 0.\";\nThis assertion asserts that denominator is not equal to 0.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 648, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0649_d3faf984", "text": "The first argument, denomi-\nnator != 0 , is a boolean expressi on that evaluates to true or false. The second argument \nis a message to print if the first argument is false—that is, if the assertion is false. Use assertions to document assumptions made in the code and to flush out unex-\npected conditions.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 649, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 306}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0650_c58b249c", "text": "Use assertions to document assumptions made in the code and to flush out unex-\npected conditions. Assertions can be used to check assumptions like these:\n■\nThat an input parameter’s value falls wi thin its expected range (or an output \nparameter’s value does)\n■\nThat a file or stream is open (or closed) when a routine begins executing (or \nwhen it ends executing)\n■\nThat a file or stream is at the beginning (or end) when a routine begins execut-\ning (or when it ends executing)\n■\nThat a file or stream is open for read-o nly, write-only, or both read and write\n■\nThat the value of an input-only variable is not changed by a routine \n■\nThat a pointer is non-null \n■\nThat an array or other container passed into a routine can contain at least X \nnumber of data elements\n■\nThat a table has been initialized to contain real values\n■\nThat a container is empty (or full) when a routine begins executing (or when it \nfinishes)\n■\nThat the results from a highly optimized, complicated routine match the results \nfrom a slower but clearly written routine\nOf course, these are just the basics, and your own routines will contain many more \nspecific assumptions that you can document using assertions.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 650, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1191}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0651_8988813e", "text": "Normally, you don’t want users to see assertion messages in production code; assertions \nare primarily for use during development an d maintenance. Assertions are normally \ncompiled into the code at development time and compiled out of the code for produc-\ntion. During development, assertions flush out contradictory assumptions, unexpected \nconditions, bad values passed to routines, and so on. During production, they can be \ncompiled out of the code so that the assert ions don’t degrade system performance. 8.2 Assertions 191\nBuilding Your Own Assertion Mechanism\nCross-Reference Building \nyour own assertion routine is \na good example of program-\nming “into” a language \nrather than just program-\nming “in” a language. For \nmore details on this distinc-\ntion, see Section 34.4, \"Pro-\ngram into Your Language, \nNot in It.\"\nMany languages have built-in support fo r assertions, including C++, Java, and \nMicrosoft Visual Basic.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 651, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 931}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0652_24a61cfb", "text": "If your language doesn’t directly support assertion routines, \nthey are easy to write. The standard C++ assert macro doesn’t provide for text mes-\nsages. Here’s an example of an improved ASSERT implemented as a C++ macro:\nC+ + Example of an Assertion Macro\n#define ASSERT( condition, message ) { \\\nif ( !(condition) ) { \\\nLogError( \"Assertion failed: \", \\\n#condition, message ); \\\nexit( EXIT_FAILURE ); \\\n}\\\n}\nGuidelines for Using Assertions\nHere are some guidelines for using assertions:\nUse error-handling code for conditions yo u expect to occur; use assertions for \nconditions that should never occur Assertions check for conditions that should \nnever occur. Error-handling code checks for off-nominal circumstances that might not \noccur very often, but that have been anticipated by the programmer who wrote the \ncode and that need to be handled by the production code. Error handling typically \nchecks for bad input data; assertions check for bugs in the code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 652, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0653_85d637fe", "text": "Error handling typically \nchecks for bad input data; assertions check for bugs in the code. If error-handling code is used to address an anomalous condition, the error handling \nwill enable the program to respond to the error gracefully. If an asse rtion is fired for an \nanomalous condition, the corrective action is not merely to handle an error grace-\nfully—the corrective action is to change the program’s source code, recompile, and \nrelease a new version of the software. A good way to think of assertions is as executable documentation—you can’t rely on \nthem to make the code work, but they can document assumptions more actively than \nprogram-language comments can. Avoid putting executable code into assertions Putting code into an assertion raises \nthe possibility that the compiler will elimin ate the code when you turn off the asser-\ntions.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 653, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 854}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0654_c0313647", "text": "Avoid putting executable code into assertions Putting code into an assertion raises \nthe possibility that the compiler will elimin ate the code when you turn off the asser-\ntions. Suppose you have an assertion like this:\n192\nChapter 8: Defensive Programming\nCross-Reference You could \nview this as one of many \nproblems associated with \nputting multiple statements \non one line. For more exam-\nples, see \"Using Only One \nStatement per Line\" in \nSection 31.5. Visual Basic Example of a Dangerous Use of an Assertion\nDebug.Assert( PerformAction() ) ' Couldn't perform action\nThe problem with this code is that, if yo u don’t compile the assertions, you don’t com-\npile the code that performs the action. Put executable statements on their own lines, \nassign the results to status variables, and te st the status variables instead.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 654, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 828}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0655_9ad803a0", "text": "Put executable statements on their own lines, \nassign the results to status variables, and te st the status variables instead. Here’s an \nexample of a safe use of an assertion:\nVisual Basic Example of a Safe Use of an Assertion\nactionPerformed = PerformAction()\nDebug.Assert( actionPerformed ) ' Couldn't perform action\nFurther Reading For much \nmore on preconditions and \npostconditions, see Object-\nOriented Software Construc-\ntion (Meyer 1997). Use assertions to document and veri fy preconditions and postconditions Precondi-\ntions and postconditions are part of an ap proach to program design and development \nknown as “design by contract” (Meyer 19 97). When preconditions and postcondi-\ntions are used, each routine or class forms a contract with the rest of the program. Preconditions are the properties that the client code of a routine or class promises will \nbe true before it calls the routine or instantiates the object. Preconditions are the client \ncode’s obligations to the code it calls.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 655, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0656_849f1e16", "text": "Preconditions are the client \ncode’s obligations to the code it calls. Postconditions are the properties that the routine or class promises will be true when it \nconcludes executing. Postconditions are th e routine’s or class’s obligations to the \ncode that uses it. Assertions are a useful tool for document ing preconditions and postconditions. Com-\nments could be used to document precondi tions and postconditions, but, unlike com-\nments, assertions can check dynami cally whether the preconditions and \npostconditions are true. In the following example, assertions are used to document the preconditions and \npostcondition of the Velocity routine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 656, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 652}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0657_a943e017", "text": "In the following example, assertions are used to document the preconditions and \npostcondition of the Velocity routine. Visual Basic Example of Using Asserti ons to Document Preconditions and \nPostconditions\nPrivate Function Velocity ( _\nByVal latitude As Single, _\nByVal longitude As Single, _\nByVal elevation As Single _\n) As Single\n' Preconditions\nDebug.Assert ( -90 <= latitude And latitude <= 90 )\nDebug.Assert ( 0 <= longitude And longitude < 360 )\nDebug.Assert ( -500 <= elevation And elevation <= 75000 )\n8.2 Assertions 193\n... ' Postconditions\nDebug.Assert ( 0 <= returnVelocity And returnVelocity <= 600 )\n' return value\nVelocity = returnVelocity\nEnd Function\nIf the variables latitude , longitude , and elevation were coming from an external source, \ninvalid values should be check ed and handled by error-hand ling code rather than by \nassertions.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 657, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 859}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0658_620f0035", "text": "If the variables ar e coming from a trusted, internal source, however, and \nthe routine’s design is based on the assumption that these values will be within their \nvalid ranges, then assertions are appropriate. Cross-Reference For more \non robustness, see \"Robust-\nness vs. Correctness\" in Sec-\ntion 8.3, later in this chapter. For highly robust code, assert and then handle the error anyway For any given \nerror condition, a routine will generally use either an assertion or error-handling code, \nbut not both. Some experts argue that only one kind is needed (Meyer 1997). But real-world programs and projects tend to be too messy to rely solely on assertions. On a large, long-lasting system, different pa rts might be designed by different design-\ners over a period of 5–10 years or more. Th e designers will be separated in time, across \nnumerous versions. Their designs will focus on different technologies at different \npoints in the system’s development.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 658, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0659_c02ac50f", "text": "Th e designers will be separated in time, across \nnumerous versions. Their designs will focus on different technologies at different \npoints in the system’s development. The designers will be separated geographically, \nespecially if parts of the system are acquir ed from external sources. Programmers will \nhave worked to different coding standards at different points in the system’s lifetime. On a large development team, some programme rs will inevitably be more conscien-\ntious than others and some parts of the code will be reviewed more rigorously than \nother parts of the code. Some programmers wi ll unit test their code more thoroughly \nthan others. With test teams working across different geographic regions and subject \nto business pressures that result in test co verage that varies with each release, you \ncan’t count on comprehensive, system-level regression testing, either. In such circumstances, both assertions an d error-handling code might be used to \naddress the same error.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 659, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 997}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0660_18b6d869", "text": "In such circumstances, both assertions an d error-handling code might be used to \naddress the same error. In the source co de for Microsoft Word, for example, condi-\ntions that should always be true are asserted, but such errors are also handled by \nerror-handling code in case the assertion fails. For extremely large, complex, long-\nlived applications like Word, assertions are valuable because they help to flush out as \nmany development-time errors as possible. But the application is so complex (mil-\nlions of lines of code) and has gone through so many generations of modification that \nit isn’t realistic to assume that every conceivable error will be detected and corrected \nbefore the software ships, and so errors mu st be handled in the production version of \nthe system as well.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 660, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 790}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0661_6a660050", "text": "194\nChapter 8: Defensive Programming\nHere’s an example of how that might work in the Velocity example: \nVisual Basic Example of Using Asserti ons to Document Preconditions and \nPostconditions\nPrivate Function Velocity ( _\nByRef latitude As Single, _\nByRef longitude As Single, _\nByRef elevation As Single _\n) As Single\n' Preconditions\nHere is the assertion code. Debug.Assert ( -90 <= latitude And latitude <= 90 )\nDebug.Assert ( 0 <= longitude And longitude < 360 )\nDebug.Assert ( -500 <= elevation And elevation <= 75000 )\n... ' Sanitize input data. Values should be within the ranges asserted above,\n' but if a value is not within its valid range, it will be changed to the\n' closest legal value\nHere is the code that handles \nbad input data at run time. If ( latitude < -90 ) Then\nlatitude = -90\nElseIf ( latitude > 90 ) Then\nlatitude = 90\nEnd If\nIf ( longitude < 0 ) Then\nlongitude = 0\nElseIf ( longitude > 360 ) Then\n...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 661, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0662_51cc971f", "text": "If ( latitude < -90 ) Then\nlatitude = -90\nElseIf ( latitude > 90 ) Then\nlatitude = 90\nEnd If\nIf ( longitude < 0 ) Then\nlongitude = 0\nElseIf ( longitude > 360 ) Then\n... 8.3 Error-Handling Techniques\nAssertions are used to handle errors that should never occur in the code. How do \nyou handle errors that you do expect to occur? Depending on the specific circum-\nstances, you might want to return a neutra l value, substitute the next piece of valid \ndata, return the same answer as the previous time, substitute the closest legal value, \nlog a warning message to a file, return an error code, call an error-processing routine \nor object, display an error message, or shut down—or you might want to use a com-\nbination of these responses. Here are some more details on these options:\nReturn a neutral value Sometimes the best response to bad data is to continue oper-\nating and simply return a value that’s known to be harmless. A numeric computation \nmight return 0.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 662, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 966}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0663_a0a3d90d", "text": "A numeric computation \nmight return 0. A string operation might return an empty string, or a pointer opera-\ntion might return an empty pointer. A draw ing routine that gets a bad input value for \ncolor in a video game might use the default background or foreground color. A draw-\ning routine that displays x-ray data for cancer patients, however, would not want to \ndisplay a “neutral value.” In that case, yo u’d be better off shutting down the program \nthan displaying incorrect patient data. 8.3 Error-Handling Techniques 195\nSubstitute the next piece of valid data When processing a stream of data, some cir-\ncumstances call for simply returning the next valid data. If you’re reading records \nfrom a database and encounter a corrupted record, you might simply continue read-\ning until you find a valid record. If you’re taking readings from a thermometer 100 \ntimes per second and you don’t get a valid reading one time, you might simply wait \nanother 1/100th of a second and take the next reading.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 663, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0664_4f37bf9f", "text": "If you’re taking readings from a thermometer 100 \ntimes per second and you don’t get a valid reading one time, you might simply wait \nanother 1/100th of a second and take the next reading. Return the same answer as the previous time If the thermometer-reading software \ndoesn’t get a reading one time, it might simply return the same value as last time. Depending on the application, temperatures might not be very likely to change much in \n1/100th of a second. In a video game, if you detect a request to paint part of the screen \nan invalid color, you might simply return the same color used previously. But if you’re \nauthorizing transactions at a cash machine, you probably wouldn’t want to use the \n“same answer as last time”—that would be the previous user’s bank account number! Substitute the closest legal value In some cases, you might choose to return the clos-\nest legal value, as in the Velocity example earlier.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 664, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 925}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0665_19ad9854", "text": "Substitute the closest legal value In some cases, you might choose to return the clos-\nest legal value, as in the Velocity example earlier. This is often a reasonable approach \nwhen taking readings from a calibrated instrument. The thermometer might be cali-\nbrated between 0 and 100 degrees Celsius, for example. If you detect a reading less \nthan 0, you can substitute 0, which is the closest legal value. If you detect a value \ngreater than 100, you can substitute 100. For a string operation, if a string length is \nreported to be less than 0, you could substitute 0. My car uses this approach to error \nhandling whenever I back up. Since my sp eedometer doesn’t show negative speeds, \nwhen I back up it simply shows a speed of 0—the closest legal value. Log a warning message to a file When bad data is detected , you might choose to log \na warning message to a file and then conti nue on.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 665, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 894}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0666_54084d13", "text": "Log a warning message to a file When bad data is detected , you might choose to log \na warning message to a file and then conti nue on. This approach can be used in con-\njunction with other techniques like substitu ting the closest legal value or substituting \nthe next piece of valid data. If you use a lo g, consider whether you can safely make it \npublicly available or whether you need to encrypt it or protect it some other way. Return an error code You could decide that only certa in parts of a system will han-\ndle errors. Other parts will not handle errors locally; they will simply report that an \nerror has been detected and trust that some other routine higher up in the calling hier-\narchy will handle the error.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 666, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 725}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0667_8fa474b9", "text": "Other parts will not handle errors locally; they will simply report that an \nerror has been detected and trust that some other routine higher up in the calling hier-\narchy will handle the error. The specific me chanism for notifying the rest of the sys-\ntem that an error has occurred could be any of the following:\n■\nSet the value of a status variable \n■\nReturn status as the function’s return value\n■\nThrow an exception by using the lang uage’s built-in exception mechanism\nIn this case, the specific error-reporting mechanism is less important than the deci-\nsion about which parts of the system will ha ndle errors directly and which will just \nreport that they’ve occurred. If security is an issue, be sure that calling routines always \ncheck return codes. 196\nChapter 8: Defensive Programming\nCall an error-processing routine/object Another approach is to centralize error han-\ndling in a global error-handling routine or error-handling object.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 667, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0668_d2df5e40", "text": "196\nChapter 8: Defensive Programming\nCall an error-processing routine/object Another approach is to centralize error han-\ndling in a global error-handling routine or error-handling object. The advantage of this \napproach is that error-processing responsi bility can be central ized, which can make \ndebugging easier. The tradeoff is that the whole program will know about this central \ncapability and will be coupled to it. If you ev er want to reuse any of the code from the \nsystem in another system, you’ll have to drag the error-handling machinery along \nwith the code you reuse. This approach has an important security im plication. If your code has encountered a \nbuffer overrun, it’s possible that an atta cker has compromised the address of the han-\ndler routine or object. Thus, once a buffer overrun has occurred while an application \nis running, it is no longer safe to use this approach.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 668, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0669_71434ff7", "text": "Thus, once a buffer overrun has occurred while an application \nis running, it is no longer safe to use this approach. Display an error message wherever the error is encountered This approach mini-\nmizes error-handling overhead; however, it does have the potential to spread user \ninterface messages through the entire applic ation, which can create challenges when \nyou need to create a consistent user interfa ce, when you try to clearly separate the UI \nfrom the rest of the system, or when you try to localize the software into a different \nlanguage. Also, beware of telling a potential attacker of the system too much. Attackers \nsometimes use error messages to discover how to attack a system. Handle the error in whatever way works best locally Some designs call for handling \nall errors locally—the decision of which specific error-handling method to use is left \nup to the programmer designing and implem enting the part of the system that \nencounters the error.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 669, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0670_d2cf8131", "text": "This approach provides individual developers with great flexibility, but it creates a sig-\nnificant risk that the overall performance of the system will not satisfy its require-\nments for correctness or robustness (more on this in a moment). Depending on how \ndevelopers end up handling specific errors , this approach also has the potential to \nspread user interface code throughout th e system, which exposes the program to all \nthe problems associated with displaying error messages. Shut down Some systems shut down whenever they detect an error. This approach \nis useful in safety-critical applications. For example, if the software that controls radi-\nation equipment for treating cancer patients receives bad input data for the radiation \ndosage, what is its best error-handling resp onse? Should it use the same value as last \ntime? Should it use the closest legal value? Sh ould it use a neutral value? In this case, \nshutting down is the best option.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 670, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0671_54a06d80", "text": "Should it use the same value as last \ntime? Should it use the closest legal value? Sh ould it use a neutral value? In this case, \nshutting down is the best option. We’d much prefer to reboot the machine than to run \nthe risk of delivering the wrong dosage. A similar approach can be used to improv e the security of Microsoft Windows. By \ndefault, Windows continues to operate even when its security log is full. But you can \nconfigure Windows to halt the server if th e security log becomes full, which can be \nappropriate in a security-critical environment. 8.3 Error-Handling Techniques 197\nRobustness vs. Correctness\nAs the video game and x-ray examples show us, the style of error processing that is \nmost appropriate depends on the kind of software the error occurs in. These exam-\nples also illustrate that error processing generally favors more correctness or more \nrobustness.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 671, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 885}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0672_57f28632", "text": "These exam-\nples also illustrate that error processing generally favors more correctness or more \nrobustness. Developers tend to use these terms informally, but, strictly speaking, \nthese terms are at opposite ends of the scale from each other. Correctness means never \nreturning an inaccurate result; returning no result is better than returning an inaccu-\nrate result. Robustness means always trying to do something that will allow the soft-\nware to keep operating, even if that leads to results that are inaccurate sometimes. Safety-critical applications tend to favor correctness to robustness. It is better to return \nno result than to return a wrong result. The radiation machine is a good example of \nthis principle. Consumer applications tend to favor robustness to correctness. Any result whatsoever is \nusually better than the software shutting down. The word processor I’m using occasion-\nally displays a fraction of a line of text at the bottom of the screen.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 672, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0673_47b7fb6d", "text": "Any result whatsoever is \nusually better than the software shutting down. The word processor I’m using occasion-\nally displays a fraction of a line of text at the bottom of the screen. If it detects that con-\ndition, do I want the word processor to shut down? No. I know that the next time I hit \nPage Up or Page Down, the screen will refresh and the display will be back to normal. High-Level Design Implicat ions of Error Processing \nWith so many options, you need to be carefu l to handle invalid parameters in consistent \nways throughout the program. The way in which errors are handled affects the software’s \nability to meet requirem ents related to correctness, ro bustness, and othe r nonfunctional \nattributes. Deciding on a general approach to bad parameters is an architectural or high-\nlevel design decision and should be addressed at one of those levels. Once you decide on the approach, make sure you follow it consistently.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 673, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0674_3b46b56b", "text": "Once you decide on the approach, make sure you follow it consistently. If you decide \nto have high-level code handle errors and low-level code merely report errors, make \nsure the high-level code actually handle s the errors! Some languages give you the \noption of ignoring the fact that a function is returning an error code—in C++, you’re \nnot required to do anything with a functi on’s return value—but don’t ignore error \ninformation! Test the function return value. If you don’t expect the function ever to \nproduce an error, check it anyway. The whole point of defensive programming is \nguarding against errors you don’t expect. This guideline holds true for system func tions as well as for your own functions. Unless you’ve set an architectural guideline of not checking system calls for errors, \ncheck for error codes after each call. If yo u detect an error, include the error number \nand the description of the error.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 674, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0675_7c8a5d71", "text": "If yo u detect an error, include the error number \nand the description of the error. KEY POINT\n198\nChapter 8: Defensive Programming\n8.4 Exceptions\nExceptions are a specific means by which code can pass along errors or exceptional \nevents to the code that called it. If code in one routine encounters an unexpected con-\ndition that it doesn’t know how to handle, it throws an exception, essentially throwing \nup its hands and yelling, “I don’t know what to do about this—I sure hope somebody \nelse knows how to handle it!” Code that ha s no sense of the context of an error can \nreturn control to other parts of the system th at might have a better ability to interpret \nthe error and do something useful about it. Exceptions can also be used to straighten out tangled logic within a single stretch of \ncode, such as the “Rewrite with try-finally ” example in Section 17.3. The basic structure \nof an exception is that a routine uses throw to throw an exception object.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 675, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0676_8c7839fa", "text": "The basic structure \nof an exception is that a routine uses throw to throw an exception object. Code in some \nother routine up the calling hierarchy will catch the exception within a try-catch block. Popular languages vary in how they implement exceptions.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 676, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 256}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0677_71d588e1", "text": "Code in some \nother routine up the calling hierarchy will catch the exception within a try-catch block. Popular languages vary in how they implement exceptions. Table 8-1 summarizes the \nmajor differences in three of them:\nTable 8-1\nPopular-Language Support for Exceptions \nException \nAttribute\nC++\nJava\nVisual Basic\nTry-catch support yes yes yes\nTry-catch-finally \nsupportno yes yes\nWhat can be \nthrownException object or \nobject derived from \nException class; object \npointer; object refer-\nence; data type like \nstring or intException object or \nobject derived from \nException classException object or \nobject derived from \nException class\nEffect of uncaught \nexceptionInvokes std::unex-\npected() , which by \ndefault invokes \nstd::terminate() , \nwhich by default \ninvokes abort()Terminates thread \nof execution if \nexception is a \n“checked excep-\ntion”; no effect if \nexception is a \n“runtime \nexception”Terminates \nprogram\nExceptions thrown \nmust be defined \nin class interfaceNo Yes No\nExceptions caught \nmust be defined \nin class interfaceNo Yes No\n8.4 Exceptions 199\nPrograms that use excep-\ntions as part of their normal \nprocessing suffer from all \nthe readability and maintain-\nability problems of classic \nspaghetti code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 677, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1232}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0678_e43e53b8", "text": "—Andy Hunt and Dave \nThomas\nExceptions have an attribute in common with inheritance: used judiciously, they can \nreduce complexity. Used imprudently, they can make code almost impossible to fol-\nlow. This section contains suggestions fo r realizing the benefits of exceptions and \navoiding the difficulties of ten associated with them. Use exceptions to notify other parts of the program about errors that should not be \nignored The overriding benefit of exceptions is their ability to signal error condi-\ntions in such a way that they cannot be ig nored (Meyers 1996). Other approaches to \nhandling errors create the possibility that an error condition can propagate through a \ncode base undetected. Exceptions eliminate that possibility. Throw an exception only for condit ions that are truly exceptional Exceptions \nshould be reserved for conditions that are truly exceptional—in other words, for con-\nditions that cannot be addressed by other coding practices.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 678, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0679_a6c12d66", "text": "Exceptions are used in \nsimilar circumstances to assertions—for events that are not just infrequent but for \nevents that should never occur. Exceptions represent a tradeoff between a po werful way to handle unexpected condi-\ntions on the one hand and increased complexity on the other. Exceptions weaken \nencapsulation by requiring the code that calls a routine to know which exceptions \nmight be thrown inside the code that’s called. That increases code complexity, which \nworks against what Chapter 5, “Design in Construction,” refers to as Software’s Pri-\nmary Technical Imperative : Managing Complexity. Don’t use an exception to pass the buck If an error condition can be handled locally, \nhandle it locally. Don’t throw an uncaught ex ception in a section of code if you can \nhandle the error locally.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 679, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 807}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0680_cd520055", "text": "Don’t use an exception to pass the buck If an error condition can be handled locally, \nhandle it locally. Don’t throw an uncaught ex ception in a section of code if you can \nhandle the error locally. Avoid throwing exceptions in constructors and destructors unless you catch them in the \nsame place The rules for how exceptions are processed become very complicated \nvery quickly when exceptions are thrown in constructors and destructors. In C++, for \nexample, destructors aren’t called unless an object is fully constructed, which means \nif code within a constructor throws an exception, the destructor won’t be called, \nthereby setting up a possible resource leak (Meyers 1996, Stroustrup 1997). Similarly \ncomplicated rules apply to exceptions within destructors. Language lawyers might say that remembering rules like these is “trivial,” but pro-\ngrammers who are mere mortals will have trouble remembering them.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 680, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0681_beacc365", "text": "Language lawyers might say that remembering rules like these is “trivial,” but pro-\ngrammers who are mere mortals will have trouble remembering them. It’s better pro-\ngramming practice simply to avoid the ex tra complexity such code creates by not \nwriting that kind of code in the first place. Cross-Reference For more \non maintaining consistent \ninterface abstractions, see \n\"Good Abstraction\" in \nSection 6.2. Throw exceptions at the right level of abstraction A routine should present a consis-\ntent abstraction in its interface, and so sh ould a class. The exceptions thrown are part \nof the routine interface, just like specific data types are. 200\nChapter 8: Defensive Programming\nWhen you choose to pass an exception to the caller, make sure the exception’s level of \nabstraction is consistent with the routine interface’s abstraction. Here’s an example of \nwhat not to do:\nBad Java Example of a Class that Throws an Exception at an Inconsistent Level \nof Abstraction\nclass Employee {\n...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 681, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0682_d2e42666", "text": "Here’s an example of \nwhat not to do:\nBad Java Example of a Class that Throws an Exception at an Inconsistent Level \nof Abstraction\nclass Employee {\n... Here is the declaration of the \nexception that’s at an incon-\nsistent level of abstraction. public TaxId GetTaxId() throws EOFException {\n... }\n... }\nThe GetTaxId() code passes the lower-level EOFException exception back to its caller. It \ndoesn’t take ownership of the exception itse lf; it exposes some details about how it’s \nimplemented by passing the lower-level exception to its caller. This effectively couples \nthe routine’s client’s code not to the Employee class’s code but to the code below the \nEmployee class that throws the EOFException exception. Encapsulation is broken, and \nintellectual manageability starts to decline.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 682, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 790}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0683_5bbbb465", "text": "Encapsulation is broken, and \nintellectual manageability starts to decline. Instead, the GetTaxId() code should pass back an exception that’s consistent with the \nclass interface of which it’s a part, like this:\nGood Java Example of a Class that Thro ws an Exception at a Consistent Level \nof Abstraction\nclass Employee {\n... Here is the declaration of \nthe exception that contrib-\nutes to a consistent level \nof abstraction. public TaxId GetTaxId() throws EmployeeDataNotAvailable {\n... }\n... }\nThe exception-handling code inside GetTaxId() will probably just map the \nio_disk_not_ready exception onto the EmployeeDataNotAvailable exception, which is \nfine because that’s sufficient to preserve the interface abstraction. Include in the exception message all in formation that led to the exception Every \nexception occurs in specific circumstances that are detected at the time the code \nthrows the exception. This information is invaluable to the person who reads the \nexception message.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 683, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0684_521e98a2", "text": "This information is invaluable to the person who reads the \nexception message. Be sure the message contains the information needed to under-\nstand why the exception was thrown. If the exception was thrown because of an array \nCODING \nHORROR\n8.4 Exceptions 201\nindex error, be sure the exception message includes the upper and lower array limits \nand the value of the illegal index. Avoid empty catch blocks Sometimes it’s tempting to pass off an exception that you \ndon’t know what to do with, like this:\nBad Java Example of Ignoring an Exception\ntry {\n... // lots of code\n... } catch ( AnException exception ) {\n}\nSuch an approach says that either the code within the try block is wrong because it \nraises an exception for no reason, or the code within the catch block is wrong because \nit doesn’t handle a valid exception. Determin e which is the root cause of the problem, \nand then fix either the try block or the catch block.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 684, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0685_e27d76e3", "text": "Determin e which is the root cause of the problem, \nand then fix either the try block or the catch block. You might occasionally find rare circumstances in which an exception at a lower level \nreally doesn’t represent an exception at the le vel of abstraction of the calling routine. If \nthat’s the case, at least document why an empty catch block is appropriate. You could \n“document” that case with comments or by logging a message to a file, as follows:\nGood Java Example of Ignoring an Exception\ntry {\n... // lots of code\n... } catch ( AnException exception ) {\nLogError( \"Unexpected exception\" );\n}\nKnow the exceptions your library code throws If you’re working in a language that \ndoesn’t require a routine or class to define the exceptions it throws, be sure you know \nwhat exceptions are thrown by any library code you use. Failing to catch an exception \ngenerated by library code will crash your program just as fast as failing to catch an \nexception you generated yourself.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 685, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0686_8502f3dd", "text": "Failing to catch an exception \ngenerated by library code will crash your program just as fast as failing to catch an \nexception you generated yourself. If the librar y code doesn’t document the exceptions it \nthrows, create prototyping code to exercise the libraries and flush out the exceptions. Consider building a centra lized exception reporter One approach to ensuring con-\nsistency in exception handling is to use a centralized exception reporter. The central-\nized exception reporter provides a central repository for knowledge about what kinds \nof exceptions there are, how each exception should be handled, formatting of excep-\ntion messages, and so on.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 686, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 662}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0687_a3f431f0", "text": "CODING \nHORROR\n202\nChapter 8: Defensive Programming\nHere is an example of a simple exception handler that simply prints a diagnostic \nmessage: \nVisual Basic Example of a Centralized Exception Reporter, Part 1\nFurther Reading For a more \ndetailed explanation of this \ntechnique, see Practical \nStandards for Microsoft \nVisual Basic .NET (Foxall \n2003). Sub ReportException( _\nByVal className, _\nByVal thisException As Exception _\n)\nDim message As String\nDim caption As String\nmessage = \"Exception: \" & thisException.Message & \".\" & ControlChars.CrLf & _\n\"Class: \" & className & ControlChars.CrLf & _\n\"Routine: \" & thisException.TargetSite.Name & ControlChars.CrLf\ncaption = \"Exception\"\nMessageBox.Show( message, caption, MessageBoxButtons.OK, _\nMessageBoxIcon.Exclamation )\nEnd Sub\nYou would use this generic exception handler with code like this: \nVisual Basic Example of a Centralized Exception Reporter, Part 2\nTry\n...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 687, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 920}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0688_ea5a1d73", "text": "Catch exceptionObject As Exception\nReportException( CLASS_NAME, exceptionObject )\nEnd Try\nThe code in this version of ReportException() is simple. In a real application, you \ncould make the code as simple or as elab orate as needed to meet your exception-\nhandling needs. If you do decide to build a centralized exception reporter, be sure to consider the gen-\neral issues involved in centralized error handling, which are discussed in \"Call an \nerror-processing routine/object\" in Section 8.3. Standardize your project’s use of exceptions To keep exception handling as intel-\nlectually manageable as possible, you can standardize your use of exceptions in sev-\neral ways:\n■\nIf you’re working in a language like C++ that allows you to throw a variety of \nkinds of objects, data, and pointers, st andardize on what specifically you will \nthrow. For compatibility with other languages, consider throwing only objects \nderived from the Exception base class.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 688, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0689_0ae73386", "text": "For compatibility with other languages, consider throwing only objects \nderived from the Exception base class. 8.5 Barricade Your Program to Cont ain the Damage Caused by Errors 203\n■\nConsider creating your own project-specific exception class, which can serve as \nthe base class for all exceptions thrown on your project. This supports centraliz-\ning and standardizing logging, error reporting, and so on. ■\nDefine the specific circumstances under which code is allowed to use throw-\ncatch syntax to perform error processing locally. ■\nDefine the specific circumstances under which code is allowed to throw an \nexception that won’t be handled locally. ■\nDetermine whether a centralized exception reporter will be used. ■\nDefine whether exceptions are allowed in constructors and destructors. Cross-Reference For numer-\nous alternative error-han-\ndling approaches, see \nSection 8.3, \"Error-Handling \nTechniques,” earlier in this \nchapter.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 689, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0690_17890114", "text": "Cross-Reference For numer-\nous alternative error-han-\ndling approaches, see \nSection 8.3, \"Error-Handling \nTechniques,” earlier in this \nchapter. Consider alternatives to exceptions Several programming languages have sup-\nported exceptions for 5–10 years or more, but little conventional wisdom has emerged \nabout how to use them safely. Some programmers use exceptions to handle errors just because their language pro-\nvides that particular error-handling mechan ism. You should always consider the full \nset of error-handling alternatives: handling the error locally, propagating the error by \nusing an error code, logging debug information to a file, shutting down the system, or \nusing some other approach. Handling errors with exceptions just because your lan-\nguage provides exception handling is a classic example of programming in a language \nrather than programming into a language.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 690, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 891}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0691_60b51fe5", "text": "Handling errors with exceptions just because your lan-\nguage provides exception handling is a classic example of programming in a language \nrather than programming into a language. (For details on that distinction, see Section \n4.3, “Your Location on the Technology Wave,” and Section 34.4, \"Program into Your \nLanguage, Not in It.\"\nFinally, consider whether your program really needs to handle exceptions, period. As \nBjarne Stroustrup points out, sometimes the best response to a serious run-time error \nis to release all acquired resources and abort. Let the user rerun the program with \nproper input (Stroustrup 1997). 8.5 Barricade Your Program to Contain the Damage Caused \nby Errors \nBarricades are a damage-containment strategy. The reason is similar to that for having \nisolated compartments in the hull of a ship. If the ship runs into an iceberg and pops \nopen the hull, that compartment is shut off an d the rest of the ship isn’t affected. They \nare also similar to firewalls in a building.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 691, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0692_ea4160d7", "text": "If the ship runs into an iceberg and pops \nopen the hull, that compartment is shut off an d the rest of the ship isn’t affected. They \nare also similar to firewalls in a building. A building’s firewalls prevent fire from spread-\ning from one part of a building to another part. (Barricades used to be called “firewalls,” \nbut the term “firewall” now commonly refers to blocking hostile network traffic.)\nOne way to barricade for defensive programming purposes is to designate certain \ninterfaces as boundaries to “safe” areas. Check data crossing the boundaries of a safe \n204\nChapter 8: Defensive Programming\narea for validity, and respond sensibly if the data isn’t valid. Figure 8-2 illustrates \nthis concept. Figure 8-2 Defining some parts of the software that work with dirty data and some that \nwork with clean data can be an effective way to relieve the majority of the code of the \nresponsibility for checking for bad data. This same approach can be used at the class level.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 692, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0693_dec5ac1c", "text": "This same approach can be used at the class level. The class’s public methods assume \nthe data is unsafe, and they are responsibl e for checking the data and sanitizing it. Once the data has been accepted by the cla ss’s public methods, the class’s private \nmethods can assume the data is safe. Another way of thinking about this approach is as an operating-room technique. Data \nis sterilized before it’s allowed to enter the operating room. Anything that’s in the \noperating room is assumed to be safe. The ke y design decision is deciding what to put \nin the operating room, what to keep out, and where to put the doors—which routines \nare considered to be inside the safety zone , which are outside, and which sanitize the \ndata. The easiest way to do this is usually by sanitizing external data as it arrives, but \ndata often needs to be sanitized at more than one level, so multiple levels of steriliza-\ntion are sometimes required.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 693, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0694_9c753a4a", "text": "Convert input data to the proper type at input time Input typically arrives in the \nform of a string or number. Sometimes the value will map onto a boolean type like \n“yes” or “no.” Sometimes the value will map onto an enumerated type like Color_Red , \nColor_Green , and Color_Blue . Carrying data of questionable type for any length of time \nin a program increases complexity and increases the chance that someone can crash \nyour program by inputting a color like “Yes.” Convert input data to the proper form as \nsoon as possible after it’s input.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 694, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 548}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0695_7fde096b", "text": "Internal \nClass 11\nInternal \nClass 9\nInternal \nClass 7\nInternal \nClass 5\nInternal \nClass 3\nInternal \nClass 1\nInternal \nClass n\nInternal \nClass 10\nInternal \nClass 8\nInternal \nClass 6\nInternal \nClass 4\nInternal \nClass 2\nValidation \nClass 1\nValidation \nClass 2\nValidation \nClass n\nGraphical \nUser Interface\nCommand \nLine Interface\nReal-time \nData Feed\nExternal \nFiles\nOther external \nobjects\nData here is \nassumed to be dirty \nand untrusted.These classes are responsible \nfor cleaning the data. They \nmake up the barricade.These classses can \nassume data is clean \nand trusted. 8.6 Debugging Aids 205\nRelationship Between Ba rricades and Assertions\nThe use of barricades makes the distinctio n between assertions and error handling \nclean-cut. Routines that are outside the barr icade should use error handling because it \nisn’t safe to make any assumptions about the data.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 695, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 870}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0696_2b26bf08", "text": "Routines that are outside the barr icade should use error handling because it \nisn’t safe to make any assumptions about the data. Routines inside the barricade \nshould use assertions, because the data passe d to them is supposed to be sanitized \nbefore it’s passed across the barricade. If one of the routines inside the barricade \ndetects bad data, that’s an error in the program rather than an error in the data. The use of barricades also illustrates the va lue of deciding at the architectural level \nhow to handle errors. Deciding which code is inside and which is outside the barri-\ncade is an architecture-level decision. 8.6 Debugging Aids\nAnother key aspect of defensive programming is the use of debugging aids, which can \nbe a powerful ally in quickly detecting errors. Don’t Automatically Apply Prod uction Constraints to the \nDevelopment Version\nFurther Reading For more \non using debug code to sup-\nport defensive program-\nming, see Writing Solid Code \n(Maguire 1993).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 696, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0697_30d5dd54", "text": "A common programmer blind spot is the assumption that limitations of the produc-\ntion software apply to the development ve rsion. The production version has to run \nfast. The development version might be able to run slow. The production version has \nto be stingy with resources. The development version might be allowed to use \nresources extravagantly. The production version shouldn’t expose dangerous opera-\ntions to the user. The development version can have extra operations that you can use \nwithout a safety net. One program I worked on made extensive us e of a quadruply linked list. The linked-\nlist code was error prone, and the linked list tended to get corrupted. I added a menu \noption to check the integrity of the linked list. In debug mode, Microsoft Word contains code in the idle loop that checks the integ-\nrity of the Document object every few seconds. This helps to detect data corruption \nquickly, and it makes for easier error diagnosis.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 697, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0698_87531917", "text": "This helps to detect data corruption \nquickly, and it makes for easier error diagnosis. Be willing to trade speed and resource usage during development in exchange for \nbuilt-in tools that can make development go more smoothly. KEY POINT\n206\nChapter 8: Defensive Programming\nIntroduce Debugging Aids Early\nThe earlier you introduce debugging aids, th e more they’ll help. Typically, you won’t \ngo to the effort of writing a debugging aid until after you’ve been bitten by a problem \nseveral times. If you write the aid after the first time, however, or use one from a previ-\nous project, it will help throughout the project. Use Offensive Programming\nCross-Reference For more \ndetails on handling unantici-\npated cases, see \"Tips for \nUsing case Statements\" in \nSection 15.2. Exceptional cases should be handled in a way that makes them obvious during \ndevelopment and recoverable when production code is running.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 698, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 913}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0699_5b777dea", "text": "Exceptional cases should be handled in a way that makes them obvious during \ndevelopment and recoverable when production code is running. Michael Howard \nand David LeBlanc refer to this approach as “offensive programming” (Howard and \nLeBlanc 2003). Suppose you have a case statement that you expect to handle only five kinds of \nevents. During development, the default case should be used to generate a warning \nthat says “Hey! There’s another case he re! Fix the program!” During production, \nhowever, the default case should do so mething more graceful , like writing a mes-\nsage to an error-log file. A dead program normally \ndoes a lot less damage than \na crippled one. —Andy Hunt and \nDave Thoma s\nHere are some ways you can program offensively:\n■\nMake sure assert s abort the program. Don’t allow programmers to get into the \nhabit of just hitting the Enter key to bypass a known problem. Make the prob-\nlem painful enough that it will be fixed.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 699, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0700_6d179a4b", "text": "Don’t allow programmers to get into the \nhabit of just hitting the Enter key to bypass a known problem. Make the prob-\nlem painful enough that it will be fixed. ■\nCompletely fill any memory allocated so that you can detect memory allocation \nerrors. ■\nCompletely fill any files or streams allocated to flush out any file-format errors. ■\nBe sure the code in each case statement’s default or else clause fails hard (aborts \nthe program) or is otherwise impossible to overlook. ■\nFill an object with junk data just before it’s deleted. ■\nSet up the program to e-mail error log files to yourself so that you can see the \nkinds of errors that are occurring in the released software, if that’s appropriate \nfor the kind of software you’re developing. Sometimes the best defense is a good offens e. Fail hard during development so that \nyou can fail softer during production. Plan to Remove Debugging Aids\nIf you’re writing code for your own use, it might be fine to leave all the debugging code \nin the program.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 700, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0701_33ad8707", "text": "Plan to Remove Debugging Aids\nIf you’re writing code for your own use, it might be fine to leave all the debugging code \nin the program. If you’re writing code for commercial use, the performance penalty in \nsize and speed can be prohibitive. Plan to avoid shuffling debugging code in and out \nof a program. Here are several ways to do that:\n8.6 Debugging Aids 207\nCross-Reference For details \non version control, see Sec-\ntion 28.2, \"Configuration \nManagement.\"\nUse version-control tools and build tools like ant and make Version-control tools \ncan build different versions of a program from the same source files. In development \nmode, you can set the build tool to include all the debug code. In production mode, \nyou can set it to exclude any debug code you don’t want in the commercial version. Use a built-in preprocessor If your programming environment has a preprocessor—\nas C++ does, for example—you can include or exclude debug code at the flick of a com-\npiler switch.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 701, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0702_997a29cb", "text": "Use a built-in preprocessor If your programming environment has a preprocessor—\nas C++ does, for example—you can include or exclude debug code at the flick of a com-\npiler switch. You can use the preprocessor directly or by writing a macro that works \nwith preprocessor definitions. Here’s an example of writing code using the preproces-\nsor directly:\nC+ + Example of Using the Preprocesso r Directly to Control Debug Code\nTo include the debugging \ncode, use #define to define \nthe symbol DEBUG . To \nexclude the debugging code, \ndon’t define DEBUG . #define DEBUG\n... #if defined( DEBUG )\n// debugging code\n... #endif\nThis theme has several variations. Rather than just defining DEBUG , you can assign it \na value and then test for the value rather than testing whether it’s defined. That way \nyou can differentiate between different levels of debug code. You might have some \ndebug code that you want in your program all the time, so you surround that by a \nstatement like #if DEBUG > 0 .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 702, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 990}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0703_943df8a3", "text": "You might have some \ndebug code that you want in your program all the time, so you surround that by a \nstatement like #if DEBUG > 0 . Other debug code might be for specific purposes only, \nso you can surround it by a statement like #if DEBUG == POINTER_ERROR . In other \nplaces, you might want to set debug leve ls, so you could have statements like #if \nDEBUG > LEVEL_A . If you don’t like having #if defined() s spread throughout your code, you can write a \npreprocessor macro to accomplish the same task. Here’s an example:\nC+ + Example of Using a Preprocessor Macro to Control Debug Code \n#define DEBUG\n#if defined( DEBUG )\n#define DebugCode( code_fragment ) { code_fragment }\n#else\n#define DebugCode( code_fragment )\n#endif\n... DebugCode(\nThis code is included or \nexcluded, depending on \nwhether DEBUG has been \ndefined. statement 1;\nstatement 2;\n... statement n;\n);\n...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 703, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 876}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0704_795d3f47", "text": "DebugCode(\nThis code is included or \nexcluded, depending on \nwhether DEBUG has been \ndefined. statement 1;\nstatement 2;\n... statement n;\n);\n... 208\nChapter 8: Defensive Programming\nAs in the first example of using the prepro cessor, this technique can be altered in a \nvariety of ways that make it more sophisticated than completely including all debug \ncode or completely excluding all of it. Cross-Reference For more \ninformation on preproces-\nsors and for direction to \nsources of information on \nwriting one of your own, see \n“Macro Preprocessors” in \nSection 30.3. Write your own preprocessor If a language doesn’t include a preprocessor, it’s fairly \neasy to write one for including and exclud ing debug code. Establish a convention for \ndesignating debug code, and write your precompiler to follow that convention. For \nexample, in Java you could write a precompiler to respond to the keywords // #BEGIN \nDEBUG and // #END DEBUG .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 704, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 937}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0705_f12944d2", "text": "For \nexample, in Java you could write a precompiler to respond to the keywords // #BEGIN \nDEBUG and // #END DEBUG . Write a script to call the preprocessor, and then com-\npile the processed code. You’ll save time in the long run, and you won’t mistakenly \ncompile the unpreprocessed code. Cross-Reference For details \non stubs, see “Building Scaf-\nfolding to Test Individual \nRoutines” in Section 22.5. Use debugging stubs In many instances, you can call a routine to do debugging \nchecks. During development, the routine might perform several operations before con-\ntrol returns to the caller. For production code, you can replace the complicated routine \nwith a stub routine that merely returns control immediately to the caller or that per-\nforms a couple of quick operations before returning control. This approach incurs only \na small performance penalty, and it’s a quicker solution than writing your own prepro-\ncessor.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 705, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0706_3997dd08", "text": "This approach incurs only \na small performance penalty, and it’s a quicker solution than writing your own prepro-\ncessor. Keep both the development and produc tion versions of the routines so that you \ncan switch back and forth during future development and production. You might start with a routine designed to check pointers that are passed to it: \nC+ + Example of a Routine That Uses a Debugging Stub\nvoid DoSomething(\nSOME_TYPE *pointer;\n... ){\n// check parameters passed in\nThis line calls the routine to \ncheck the pointer. CheckPointer( pointer );\n... }\nDuring development, the CheckPointer() routine would perform full checking on the \npointer. It would be slow but effective, and it could look like this: \nC+ + Example of a Routine for Checking Pointers During Development\nThis routine checks any \npointer that’s passed to it. It \ncan be used during develop-\nment to perform as many \nchecks as you can bear.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 706, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0707_78f752f2", "text": "It \ncan be used during develop-\nment to perform as many \nchecks as you can bear. void CheckPointer( void *pointer ) {\n// perform check 1--maybe check that it's not NULL\n// perform check 2--maybe check that its dogtag is legitimate\n// perform check 3--maybe check that what it points to isn't corrupted\n... // perform check n--... }\n8.7 Determining How Much Defensive Programming to Leave in Production Code 209\nWhen the code is ready for production, yo u might not want all the overhead associ-\nated with this pointer checking. You coul d swap out the preceding routine and swap \nin this routine:\nC+ + Example of a Routine for Checking Pointers During Production\nThis routine just returns \nimmediately to the caller. void CheckPointer( void *pointer ) {\n// no code; just return to caller\n}\nThis is not an exhaustive survey of all the ways you can plan to remove debugging \naids, but it should be enough to give you an idea for some things that will work in your \nenvironment.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 707, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0708_ea8e3965", "text": "8.7 Determining How Much Defensive Programming to \nLeave in Production Code \nOne of the paradoxes of defensive programmin g is that during development, you’d like \nan error to be noticeable—you’d rather have it be obnoxious than risk overlooking it. But \nduring production, you’d rather have the error be as unobtrusive as possible, to have the \nprogram recover or fail gracefully. Here are some guidelines for deciding which defen-\nsive programming tools to leave in your production code and which to leave out:\nLeave in code that checks for important errors Decide which areas of the program \ncan afford to have undetected errors and which areas cannot. For example, if you were \nwriting a spreadsheet program, you could af ford to have undetected errors in the \nscreen-update area of the program because the main penalty for an error is only a \nmessy screen.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 708, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 861}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0709_35a71f80", "text": "You could not afford to have undetected errors in the calculation engine \nbecause such errors might result in subtly incorrect results in someone’s spreadsheet. Most users would rather suffer a messy screen than incorrect tax calculations and an \naudit by the IRS. Remove code that checks for trivial errors If an error has truly trivial consequences, \nremove code that checks for it. In the prev ious example, you might remove the code \nthat checks the spreadsheet screen update. “Remove” doesn’t mean physically remove \nthe code. It means use version control, prec ompiler switches, or some other technique \nto compile the program without that particular code. If space isn’t a problem, you \ncould leave in the error-checking code but have it log messages to an error-log file \nunobtrusively. Remove code that re sults in hard crashes As I mentioned, during development, \nwhen your program detects an error, you’d like the error to be as noticeable as possi-\nble so that you can fix it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 709, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0710_3fa8b1a4", "text": "Remove code that re sults in hard crashes As I mentioned, during development, \nwhen your program detects an error, you’d like the error to be as noticeable as possi-\nble so that you can fix it. Often, the best way to accomplish that goal is to have the pro-\ngram print a debugging message and crash when it detects an error. This is useful \neven for minor errors. 210\nChapter 8: Defensive Programming\nDuring production, your users need a chance to save their work before the program \ncrashes and they are probably willing to tole rate a few anomalies in exchange for keep-\ning the program going long enough for them to do that. Users don’t appreciate any-\nthing that results in the loss of their work, regardless of how much it helps debugging \nand ultimately improves the quality of the program. If your program contains debug-\nging code that could cause a loss of data , take it out of the production version.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 710, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0711_478932e5", "text": "If your program contains debug-\nging code that could cause a loss of data , take it out of the production version. Leave in code that helps the program crash gracefully If your program contains \ndebugging code that detects potentially fatal errors, leave the code in that allows the \nprogram to crash gracefully. In the Mars Pathfinder, for example, engineers left some \nof the debug code in by design. An error o ccurred after the Pathfinder had landed. By \nusing the debug aids that had been left in, engineers at JPL were able to diagnose the \nproblem and upload revised code to the Pathfinder, and the Pathfinder completed its \nmission perfectly (March 1999). Log errors for your technical support personnel Consider leaving debugging aids in \nthe production code but changing their beha vior so that it’s appropriate for the pro-\nduction version.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 711, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 851}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0712_6a8dc36f", "text": "Log errors for your technical support personnel Consider leaving debugging aids in \nthe production code but changing their beha vior so that it’s appropriate for the pro-\nduction version. If you’ve loaded your code with assertions that halt the program dur-\ning development, you might consider changing the assertion routine to log messages \nto a file during production rather than eliminating them altogether. Make sure that the error messages you leave in are friendly If you leave internal \nerror messages in the program, verify that they’re in language that’s friendly to the \nuser. In one of my early programs, I got a call from a user who reported that she’d got-\nten a message that read “You’ve got a bad pointer allocation, Dog Breath!” Fortunately \nfor me, she had a sense of humor. A common and effective approach is to notify the \nuser of an “internal error” and list an e-mail address or phone number the user can \nuse to report it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 712, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0713_ba89be13", "text": "A common and effective approach is to notify the \nuser of an “internal error” and list an e-mail address or phone number the user can \nuse to report it. 8.8 Being Defensive About Defensive Programming\nToo much of anything is bad, \nbut too much whiskey is just \nenough. —Mark Twain\nToo much defensive programming creates problems of its own. If you check data \npassed as parameters in every conceivable way in every conceivable place, your pro-\ngram will be fat and slow. What’s worse, the additional code needed for defensive pro-\ngramming adds complexity to the so ftware. Code installed for defensive \nprogramming is not immune to defects, and you’re just as likely to find a defect in \ndefensive-programming code as in any other code—more likely, if you write the code \ncasually. Think about where you need to be defensive, and set your defensive-pro-\ngramming priorities accordingly.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 713, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 887}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0714_27dbaa96", "text": "Think about where you need to be defensive, and set your defensive-pro-\ngramming priorities accordingly. 8.8 Being Defensive About Defensive Programming 211\ncc2e.com/0868\nCHECKLIST: Defensive Programming\nGeneral\n❑\nDoes the routine protect itself from bad input data? ❑\nHave you used assertions to document assumptions, including precondi-\ntions and postconditions? ❑\nHave assertions been used only to do cument conditions that should never \noccur? ❑\nDoes the architecture or high-level design specify a specific set of error-\nhandling techniques? ❑\nDoes the architecture or high-level design specify whether error handling \nshould favor robustness or correctness? ❑\nHave barricades been created to contain the damaging effect of errors and \nreduce the amount of code that has to be concerned about error process-\ning? ❑\nHave debugging aids been used in the code? ❑\nHave debugging aids been installed in such a way that they can be acti-\nvated or deactivated without a great deal of fuss?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 714, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0715_1b046b27", "text": "❑\nHave debugging aids been used in the code? ❑\nHave debugging aids been installed in such a way that they can be acti-\nvated or deactivated without a great deal of fuss? ❑\nIs the amount of defensive programming code appropriate—neither too \nmuch nor too little? ❑\nHave you used offensive-programming techniques to make errors difficult \nto overlook during development? Exceptions\n❑\nHas your project defined a standardized approach to exception handling? ❑\nHave you considered alternatives to using an exception? ❑\nIs the error handled locally rather than throwing a nonlocal exception, if \npossible? ❑\nDoes the code avoid throwing exceptions in constructors and destructors? ❑\nAre all exceptions at the appropriate levels of abstraction for the routines \nthat throw them? ❑\nDoes each exception include all relevant exception background informa-\ntion? ❑\nIs the code free of empty catch blocks?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 715, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0716_018797d5", "text": "❑\nDoes each exception include all relevant exception background informa-\ntion? ❑\nIs the code free of empty catch blocks? (Or if an empty catch block truly is \nappropriate, is it documented?)\n212\nChapter 8: Defensive Programming\nSecurity Issues\n❑\nDoes the code that checks for bad input data check for attempted buffer \noverflows, SQL injection, HTML injection, integer overflows, and other \nmalicious inputs? ❑\nAre all error-return codes checked? ❑\nAre all exceptions caught? ❑\nDo error messages avoid providing information that would help an \nattacker break into the system? Additional Resources\ncc2e.com/0875\nTake a look at the following defensive-programming resources:\nSecurity\nHoward, Michael, and David LeBlanc. Writing Secure Code , 2d ed. Redmond, WA: \nMicrosoft Press, 2003. Howard and LeBlanc co ver the security implications of trusting \ninput.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 716, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 855}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0717_cd698ab0", "text": "Writing Secure Code , 2d ed. Redmond, WA: \nMicrosoft Press, 2003. Howard and LeBlanc co ver the security implications of trusting \ninput. The book is eye-opening in that it illustrates just how many ways a program can \nbe breached—some of which have to do with construction practices and many of which \ndon’t. The book spans a full range of requ irements, design, code, and test issues. Assertions\nMaguire, Steve. Writing Solid Code . Redmond, WA: Microsoft Press, 1993. Chapter 2 \ncontains an excellent discussion on the use of assertions, including several interesting \nexamples of assertions in we ll-known Microsoft products. Stroustrup, Bjarne. The C++ Programming Language , 3d ed. Reading, MA: Addison-\nWesley, 1997. Section 24.3.7.2 describes several variations on the theme of imple-\nmenting assertions in C++, including the relationship between assertions and precon-\nditions and postconditions. Meyer, Bertrand. Object-Oriented Software Construction , 2d ed. New York, NY: Prentice \nHall PTR, 1997.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 717, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1009}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0718_e093d1d5", "text": "Meyer, Bertrand. Object-Oriented Software Construction , 2d ed. New York, NY: Prentice \nHall PTR, 1997. This book contains the de finitive discussion of preconditions and \npostconditions. Exceptions\nMeyer, Bertrand. Object-Oriented Software Construction , 2d ed. New York, NY: Prentice \nHall PTR, 1997. Chapter 12 contains a deta iled discussion of exception handling. Key Points 213\nStroustrup, Bjarne. The C++ Programming Language , 3d ed. Reading, MA: Addison-\nWesley, 1997. Chapter 14 contains a detailed discussion of exception handling in C++. Section 14.11 contains an excellent summary of 21 tips for handling C++ exceptions. Meyers, Scott. More Effective C++: 35 New Ways to Improve Your Programs and Designs . Reading, MA: Addison-Wesley, 1996. Item s 9–15 describe numerous nuances of \nexception handling in C++. Arnold, Ken, James Gosling, and David Holmes. The Java Programming Language , 3d \ned. Boston, MA: Addison-Wesley, 2000. Chapte r 8 contains a discussion of exception \nhandling in Java.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 718, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1008}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0719_8834067d", "text": "Arnold, Ken, James Gosling, and David Holmes. The Java Programming Language , 3d \ned. Boston, MA: Addison-Wesley, 2000. Chapte r 8 contains a discussion of exception \nhandling in Java. Bloch, Joshua. Effective Java Programming Language Guide . Boston, MA: Addison-Wes-\nley, 2001. Items 39–47 describe nuances of exception handling in Java. Foxall, James. Practical Standards for Microsoft Visual Basic .NET . Redmond, WA: \nMicrosoft Press, 2003. Chapter 10 describe s exception handling in Visual Basic. Key Points\n■\nProduction code should handle errors in a more sophisticated way than “gar-\nbage in, garbage out.”\n■\nDefensive-programming techniques make erro rs easier to find, easier to fix, and \nless damaging to production code. ■\nAssertions can help detect errors early, especially in large systems, high-reliabil-\nity systems, and fast-changing code bases. ■\nThe decision about how to handle bad inputs is a key error-handling decision \nand a key high-level design decision.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 719, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0720_afabe5b1", "text": "■\nThe decision about how to handle bad inputs is a key error-handling decision \nand a key high-level design decision. ■\nExceptions provide a means of handling errors that operates in a different \ndimension from the normal flow of the co de. They are a valuable addition to the \nprogrammer’s intellectual toolbox when used with care, and they should be \nweighed against other error-processing techniques. ■\nConstraints that apply to the production system do not necessarily apply to the \ndevelopment version. You can use that to your advantage, adding code to the \ndevelopment version that helps to flush out errors quickly.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 720, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 623}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0721_c6d8e638", "text": "You can use that to your advantage, adding code to the \ndevelopment version that helps to flush out errors quickly. 215\nChapter 9\nThe Pseudocode \nProgramming Process\ncc2e.com/0936\nContents\n■\n9.1 Summary of Steps in Building Classes and Routines: page 216\n■\n9.2 Pseudocode for Pros: page 218\n■\n9.3 Constructing Routines by Using the PPP: page 220\n■\n9.4 Alternatives to the PPP: page 232\nRelated Topics\n■\nCreating high-quality classes: Chapter 6\n■\nCharacteristics of high-quality routines: Chapter 7\n■\nDesign in Construction: Chapter 5\n■\nCommenting style: Chapter 32\nAlthough you could view this whole book as an extended description of the program-\nming process for creating classes and routines, this chapter puts the steps in context. This chapter focuses on programming in th e small—on the specific steps for building \nan individual class and its routines, the steps that are critical on projects of all sizes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 721, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 913}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0722_cda47464", "text": "This chapter focuses on programming in th e small—on the specific steps for building \nan individual class and its routines, the steps that are critical on projects of all sizes. The chapter also describes the Pseudo code Programming Process (PPP), which \nreduces the work required during design and documentation and improves the qual-\nity of both. If you’re an expert programmer, you might just skim this chapter, but look at the sum-\nmary of steps and review the tips for cons tructing routines using the Pseudocode Pro-\ngramming Process in Section 9.3. Few pr ogrammers exploit the full power of the \nprocess, and it offers many benefits. The PPP is not the only procedure for creating classes and routines. Section 9.4, at the \nend of this chapter, describe s the most popular al ternatives, including test-first devel-\nopment and design by contract.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 722, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 854}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0723_c04c87d6", "text": "Section 9.4, at the \nend of this chapter, describe s the most popular al ternatives, including test-first devel-\nopment and design by contract. 216\nChapter 9: The Pseudocode Programming Process\n9.1 Summary of Steps in Building Classes and Routines\nClass construction can be a pproached from numerous directions, but usually it’s an \niterative process of creating a general desi gn for the class, enumerating specific rou-\ntines within the class, constructing specifi c routines, and checking class construction \nas a whole. As Figure 9-1 suggests, class creation can be a messy process for all the rea-\nsons that design is a messy process (reasons that are described in Section 5.1, “Design \nChallenges”). Figure 9-1 Details of class construction vary, but th e activities generally occur in the order \nshown here. Steps in Creating a Class\nThe key steps in constructing a class are:\nCreate a general design for the class Class design includes numerous specific issues.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 723, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0724_f6df08a2", "text": "Steps in Creating a Class\nThe key steps in constructing a class are:\nCreate a general design for the class Class design includes numerous specific issues. Define the class’s specific responsibilities, define what “secrets” the class will hide, and \ndefine exactly what abstraction the class interface will capture. Determine whether the \nclass will be derived from another class and whether other classes will be allowed to \nderive from it. Identify the class’s key public methods, and identify and design any non-\ntrivial data members used by the class. Iter ate through these topics as many times as \nneeded to create a straightforward design for the routine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 724, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 661}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0725_b8640a71", "text": "Iter ate through these topics as many times as \nneeded to create a straightforward design for the routine. These considerations and \nmany others are discussed in more detail in Chapter 6, “Working Classes.” \nBegin\nDone\nCreate a \ngeneral design \nfor the class\nReview and \ntest the class as \na whole\nConstruct the \nroutines within \nthe class\n9.1 Summary of Steps in Building Classes and Routines 217\nConstruct each routine within the class Once you’ve identified the class’s major rou-\ntines in the first step, you must construct ea ch specific routine. Construction of each \nroutine typically unearths the need for additional routines, both minor and major, and \nissues arising from creating those additional routines ofte n ripple back to the overall \nclass design. Review and test the class as a whole Normally, each routine is tested as it’s created.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 725, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 852}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0726_c1e06b30", "text": "Review and test the class as a whole Normally, each routine is tested as it’s created. After the class as a whole becomes operational, the class as a whole should be \nreviewed and tested for any issues that can’ t be tested at the individual-routine level. Steps in Building a Routine\nMany of a class’s routines will be simple and straightforward to implement: accessor \nroutines, pass-throughs to other objects’ routines, and the like. Implementation of \nother routines will be more complicated, an d creation of those routines benefits from \na systematic approach. The major activities involved in creating a routine—designing \nthe routine, checking the design, coding th e routine, and checking the code—are typi-\ncally performed in the order shown in Figure 9-2. Figure 9-2 These are the major activities that go in to constructing a routine. They’re usu-\nally performed in the order shown.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 726, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 894}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0727_77107e81", "text": "Figure 9-2 These are the major activities that go in to constructing a routine. They’re usu-\nally performed in the order shown. Experts have developed numerous approaches to creating routines, and my favorite \napproach is the Pseudocode Programming Pr ocess, described in the next section. Begin\nRepeat if \nnecessary\nDone\nDesign the \nroutine\nCheck the \ndesign\nReview and \ntest the code\nCode the \nroutine\n218\nChapter 9: The Pseudocode Programming Process\n9.2 Pseudocode for Pros\nThe term “pseudocode” refers to an informal, English-like notation for describing how \nan algorithm, a routine, a class, or a program will work. The Pseudocode Program-\nming Process defines a specific approach to using pseudocode to streamline the cre-\nation of code within routines. Because pseudocode resembles English, it’s natural to assume that any English-like \ndescription that collects your thoughts will have roughly the same effect as any other.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 727, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0728_e64a8d2f", "text": "Because pseudocode resembles English, it’s natural to assume that any English-like \ndescription that collects your thoughts will have roughly the same effect as any other. In practice, you’ll find that some styles of pseudocode are more useful than others. Here are guidelines for using pseudocode effectively:\n■\nUse English-like statements that precisely describe specific operations. ■\nAvoid syntactic elements from the target programming language. Pseudocode \nallows you to design at a slightly higher level than the code itself. When you use \nprogramming-language constructs, you sink to a lower level, eliminating the \nmain benefit of design at a higher le vel, and you saddle yourself with unneces-\nsary syntactic restrictions. Cross-Reference For details \non commenting at the level \nof intent, see “Kinds of Com-\nments” in Section 32.4.■\nWrite pseudocode at the level of intent . Describe the meaning of the approach \nrather than how the approach will be implemented in the target language.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 728, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0729_9a4cedcd", "text": "Describe the meaning of the approach \nrather than how the approach will be implemented in the target language. ■\nWrite pseudocode at a low enough level th at generating code from it will be \nnearly automatic. If the pseudocode is at too high a level, it can gloss over prob-\nlematic details in the code. Refine the pseudocode in more and more detail until \nit seems as if it would be easier to simply write the code. Once the pseudocode is written, you build the code around it and the pseudocode \nturns into programming-language comments. This eliminates most commenting \neffort. If the pseudocode follows the guid elines, the comments will be complete and \nmeaningful.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 729, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 670}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0730_8cf51ddc", "text": "This eliminates most commenting \neffort. If the pseudocode follows the guid elines, the comments will be complete and \nmeaningful. Here’s an example of a design in pseudocode that violates virtually all the principles \njust described:\nExample of Bad Pseudocode \nincrement resource number by 1\nallocate a dlg struct using malloc\nif malloc() returns NULL then return 1\ninvoke OSrsrc_init to initialize a resource for the operating system\n*hRsrcPtr = resource number\nreturn 0\nWhat is the intent of this block of pseudocode ? Because it’s poorly written, it’s hard to \ntell. This so-called pseudocode is bad because it includes target language coding \ndetails, such as *hRsrcPtr (in specific C-language pointer notation) and malloc() (a spe-\nCODING \nHORROR\n9.2 Pseudocode for Pros 219\ncific C-language function). This pseudocode block focuses on how the code will be \nwritten rather than on the meaning of the design. It gets into coding details—whether \nthe routine returns a 1 or a 0.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 730, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0731_0f9e859d", "text": "This pseudocode block focuses on how the code will be \nwritten rather than on the meaning of the design. It gets into coding details—whether \nthe routine returns a 1 or a 0. If you think about this pseudocode from the standpoint \nof whether it will turn into good comment s, you’ll begin to understand that it isn’t \nmuch help. Here’s a design for the same operation in a much-improved pseudocode: \nExample of Good Pseudocode\nKeep track of current number of resources in use\nIf another resource is available\n Allocate a dialog box structure\n If a dialog box structure could be allocated\n Note that one more resource is in use\n Initialize the resource\n Store the resource number at the location provided by the caller\n Endif\nEndif\nReturn true if a new resource was created; else return false\nThis pseudocode is better than the first because it’s written entirely in English; it \ndoesn’t use any syntactic elements of the target language.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 731, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0732_60ffcd36", "text": "In the first example, the \npseudocode could have been implemented on ly in C. In the second example, the \npseudocode doesn’t restrict the choice of la nguages. The second block of pseudocode \nis also written at the level of intent. What does the second block of pseudocode mean? It is probably easier for you to understand than the first block. Even though it’s written in clear English, the second block of ps eudocode is precise \nand detailed enough that it can easily be used as a basis for programming-language \ncode. When the pseudocode statements are converted to comments, they’ll be a good \nexplanation of the code’s intent. Here are the benefits you can expect from using this style of pseudocode:\n■\nPseudocode makes reviews easier. You can review detailed designs without \nexamining source code. Pseudocode makes low-level design reviews easier and \nreduces the need to review the code itself. ■\nPseudocode supports the idea of iterative refinement.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 732, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0733_e90688f1", "text": "Pseudocode makes low-level design reviews easier and \nreduces the need to review the code itself. ■\nPseudocode supports the idea of iterative refinement. You start with a high-level \ndesign, refine the design to pseudocode, and then refine the pseudocode to \nsource code. This successive refinement in small steps allows you to check your \ndesign as you drive it to lower levels of detail. The result is that you catch high-\nlevel errors at the highest level, mid-level errors at the middle level, and low-level \nerrors at the lowest level—before any of them becomes a problem or contami-\nnates work at more detailed levels. 220\nChapter 9: The Pseudocode Programming Process\nFurther Reading For more \ninformation on the advan-\ntages of making changes at \nthe least-value stage, see \nAndy Grove’s High Output \nManagement (Grove 1983).■\nPseudocode makes changes easier. A few lines of pseudocode are easier to change \nthan a page of code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 733, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0734_a488ed67", "text": "A few lines of pseudocode are easier to change \nthan a page of code. Would you rather change a line on a blueprint or rip out a \nwall and nail in the two-by-fours somewher e else? The effects aren’t as physically \ndramatic in software, but the principle of changing the product when it’s most \nmalleable is the same. One of the keys to th e success of a project is to catch errors \nat the “least-value stage,” the stage at which the least effort has been invested. Much less has been invested at the pseudocode stage than after full coding, test-\ning, and debugging, so it makes economic sense to catch the errors early. ■\nPseudocode minimizes commenting effort. In the typical coding scenario, you \nwrite the code and add comments afterward. In the PPP, the pseudocode state-\nments become the comments, so it actually takes more work to remove the com-\nments than to leave them in. ■\nPseudocode is easier to maintain than other forms of design documentation.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 734, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0735_db5c1518", "text": "■\nPseudocode is easier to maintain than other forms of design documentation. With other approaches, design is se parated from the code, and when one \nchanges, the two fall out of agreement. With the PPP, the pseudocode state-\nments become comments in the code. As long as the inline comments are main-\ntained, the pseudocode’s documentatio n of the design will be accurate. As a tool for detailed design, pseudocode is hard to beat. One survey found that pro-\ngrammers prefer pseudocode for the way it eases construction in a programming lan-\nguage, for its ability to help them detect insufficiently detailed designs, and for the \nease of documentation and ease of modifi cation it provides (Ramsey, Atwood, and \nVan Doren 1983). Pseudocode isn’t the only tool for detailed design, but pseudocode \nand the PPP are useful tools to have in your programmer’s toolbox. Try them. The \nnext section shows you how.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 735, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 908}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0736_8053d57c", "text": "Pseudocode isn’t the only tool for detailed design, but pseudocode \nand the PPP are useful tools to have in your programmer’s toolbox. Try them. The \nnext section shows you how. 9.3 Constructing Routines by Using the PPP\nThis section describes the activities involved in constructing a routine, namely these:\n■\nDesign the routine. ■\nCode the routine. ■\nCheck the code. ■\nClean up loose ends. ■\nRepeat as needed. Design the Routine\nCross-Reference For details \non other aspects of design, \nsee Chapters 5 through 8. Once you’ve identified a class’s routines, the first step in constructing any of the class’s \nmore complicated routines is to design it. Suppose that you want to write a routine to \nKEY POINT\n9.3 Constructing Routines by Using the PPP 221\noutput an error message depending on an er ror code, and suppose that you call the rou-\ntine ReportErrorMessage() .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 736, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 869}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0737_24463ea8", "text": "Here’s an informal spec for ReportErrorMessage() :\nReportErrorMessage() takes an error code as an input argument and outputs \nan error message corresponding to the code. It’s responsible for handling \ninvalid codes. If the program is operating interactively, ReportErrorMessage() \ndisplays the message to the user. If it’s operating in command-line mode, \nReportErrorMessage() logs the message to a messag e file. After outputting the \nmessage, ReportErrorMessage() returns a status value, indicating whether it \nsucceeded or failed. The rest of the chapter uses this routine as a running example. The rest of this section \ndescribes how to design the routine. Cross-Reference For details \non checking prerequisites, \nsee Chapter 3, “Measure \nTwice, Cut Once: Upstream \nPrerequisites,” and Chapter 4, \n“Key Construction Decisions.”\nCheck the prerequisites Before doing any work on the routine itself, check to see that \nthe job of the routine is well defined and fits cleanly into the overall design.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 737, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1000}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0738_465b7869", "text": "Check to \nbe sure that the routine is actually called for, at the very least indirectly, by the \nproject’s requirements. Define the problem the routine will solve State the problem the routine will solve in \nenough detail to allow creation of the routin e. If the high-level design is sufficiently \ndetailed, the job might already be done. The hi gh-level design should at least indicate \nthe following:\n■\nThe information the routine will hide \n■\nInputs to the routine\n■\nOutputs from the routine\nCross-Reference For details \non preconditions and post-\nconditions, see “Use asser-\ntions to document and verify \npreconditions and postcon-\nditions” in Section 8.2.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 738, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 661}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0739_8704df5d", "text": "■\nPreconditions that are guaranteed to be true before the routine is called (input \nvalues within certain ranges, streams initialized, files opened or closed, buffers \nfilled or flushed, etc.)\n■\nPostconditions that the routine guarantees will be true before it passes control \nback to the caller (output values within specified ranges, stream s initialized, files \nopened or closed, buffers filled or flushed, etc.)\nHere’s how these concerns are addressed in the ReportErrorMessage() example:\n■\nThe routine hides two facts: the error message text and the current processing \nmethod (interactive or command line). ■\nThere are no preconditions guaranteed to the routine. ■\nThe input to the routine is an error code. ■\nTwo kinds of output are called for: the first is the error message, and the second \nis the status that ReportErrorMessage() returns to the calling routine. ■\nThe routine guarantees that the status value will have a value of either Success or \nFailure .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 739, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0740_bbe9e1a6", "text": "■\nThe routine guarantees that the status value will have a value of either Success or \nFailure . 222\nChapter 9: The Pseudocode Programming Process\nCross-Reference For details \non naming routines, see Sec-\ntion 7.3, “Good Routine \nNames.”\nName the routine Naming the routine might seem trivial, but good routine names \nare one sign of a superior program and they’r e not easy to come up with. In general, a \nroutine should have a clear, unambiguous na me. If you have trouble creating a good \nname, that usually indicates that the purpose of the routine isn’t clear. A vague, wishy-\nwashy name is like a politician on the campai gn trail. It sounds as if it’s saying some-\nthing, but when you take a hard look, you can’t figure out what it means. If you can \nmake the name clearer, do so. If the wi shy-washy name results from a wishy-washy \ndesign, pay attention to the warning sign. Back up and improve the design. In the example, ReportErrorMessage() is unambiguous. It is a good name.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 740, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0741_0d6e832d", "text": "If the wi shy-washy name results from a wishy-washy \ndesign, pay attention to the warning sign. Back up and improve the design. In the example, ReportErrorMessage() is unambiguous. It is a good name. Further Reading For a dif-\nferent approach to construc-\ntion that focuses on writing \ntest cases first, see Test-\nDriven Development: By \nExample (Beck 2003). Decide how to test the routine As you’re writing the routine, think about how you \ncan test it. This is useful for you when you do unit testing and for the tester who tests \nyour routine independently. In the example, the input is simple, so you might plan to test ReportErrorMessage() \nwith all valid error codes an d a variety of invalid codes. Research functionality available in the standard libraries The single biggest way to \nimprove both the quality of your code and your productivity is to reuse good code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 741, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 874}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0742_21c61a63", "text": "Research functionality available in the standard libraries The single biggest way to \nimprove both the quality of your code and your productivity is to reuse good code. If \nyou find yourself grappling to design a routine that seems overly complicated, ask \nwhether some or all of the routine’s functi onality might already be available in the \nlibrary code of the language, platform, or tools you’re using. Ask whether the code \nmight be available in librar y code maintained by your company. Many algorithms \nhave already been invented, tested, discu ssed in the trade literature, reviewed, and \nimproved. Rather than spending your ti me inventing something when someone has \nalready written a Ph.D. dissertation on it, ta ke a few minutes to look through the code \nthat’s already been written and make sure you’re not doing more work than necessary. Think about error handling Think about all the things that could possibly go wrong \nin the routine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 742, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0743_bef0e6e7", "text": "Think about error handling Think about all the things that could possibly go wrong \nin the routine. Think about bad input values, invalid values returned from other rou-\ntines, and so on. Routines can handle errors numerous ways , and you should choose consciously how \nto handle errors. If the program’s architecture defines the program’s error-handling \nstrategy, you can simply plan to follow that strategy. In other cases, you have to decide \nwhat approach will work best for the specific routine. Think about efficiency Depending on your situation, you can address efficiency in \none of two ways. In the first situation, in the vast majority of systems, efficiency isn’t \ncritical. In such a case, see that the routine’s interface is well abstracted and its code is \nreadable so that you can improve it later if you need to.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 743, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 829}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0744_3aca6d64", "text": "In such a case, see that the routine’s interface is well abstracted and its code is \nreadable so that you can improve it later if you need to. If you have good encapsula-\ntion, you can replace a slow, resource-hogging, high-level language implementation \nwith a better algorithm or a fast, lean, low-level language implementation, and you \nwon’t affect any other routines. 9.3 Constructing Routines by Using the PPP 223\nCross-Reference For details \non efficiency, see Chapter 25, \n“Code-Tuning Strategies,” \nand Chapter 26, “Code-\nTuning Techniques.”\nIn the second situation—in the minority of systems—performance is critical. The per-\nformance issue might be related to scarce database connections, limited memory, few \navailable handles, ambitious timing constraints, or some other scarce resource. The \narchitecture should indicate how many resour ces each routine (or class) is allowed to \nuse and how fast it should perform its operations.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 744, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0745_bf4370d8", "text": "The \narchitecture should indicate how many resour ces each routine (or class) is allowed to \nuse and how fast it should perform its operations. Design your routine so that it will meet its resource and speed goals. If either \nresources or speed seems more critical, design so that you trade resources for speed or \nvice versa. It’s acceptable during initial construction of the routine to tune it enough to \nmeet its resource and speed budgets. Aside from taking the approaches suggested for these two general situations, it’s usu-\nally a waste of effort to work on efficiency at the level of individual routines. The big \noptimizations come from refi ning the high-level design, not the individual routines. You generally use micro-optimizations only when the high-level design turns out not \nto support the system’s performance goals, and you won’t know that until the whole \nprogram is done. Don’t waste time scraping for incremental improvements until you \nknow they’re needed.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 745, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0746_25a001e4", "text": "Don’t waste time scraping for incremental improvements until you \nknow they’re needed. Research the algorithms and data types If functionality isn’t available in the avail-\nable libraries, it might still be described in an algorithms book. Before you launch into \nwriting complicated code from scratch, check an algorithms book to see what’s \nalready available. If you use a predefined algorithm, be sure to adapt it correctly to \nyour programming language. Write the pseudocode You might not have much in writing after you finish the pre-\nceding steps. The main purpose of the steps is to establish a mental orientation that’s \nuseful when you actually write the routine. Cross-Reference This discus-\nsion assumes that good \ndesign techniques are used to \ncreate the pseudocode ver-\nsion of the routine. For details \non design, see Chapter 5, \n“Design in Construction.”\nWith the preliminary steps completed, you can begin to write the routine as high-level \npseudocode.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 746, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0747_855ca26a", "text": "For details \non design, see Chapter 5, \n“Design in Construction.”\nWith the preliminary steps completed, you can begin to write the routine as high-level \npseudocode. Go ahead and use your programmi ng editor or your integrated environ-\nment to write the pseudocode—the pseudoco de will be used shortly as the basis for \nprogramming-language code. Start with the general and work toward something more specific. The most general \npart of a routine is a header comment describing what the routine is supposed to do, \nso first write a concise statement of the purpose of the routine. Writing the statement \nwill help you clarify your understanding of the routine. Trouble in writing the general \ncomment is a warning that you need to understand the routine’s role in the program \nbetter. In general, if it’s hard to summarize the routine’s role, you should probably \nassume that something is wrong.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 747, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0748_b670bfed", "text": "In general, if it’s hard to summarize the routine’s role, you should probably \nassume that something is wrong. Here’s an example of a concise header comment \ndescribing a routine:\n224\nChapter 9: The Pseudocode Programming Process\nExample of a Header Comment for a Routine\nThis routine outputs an error message based on an error code\nsupplied by the calling routine. The way it outputs the message\ndepends on the current processing state, which it retrieves\non its own. It returns a value indicating success or failure. After you’ve written the general comment, fill in high-level pseudocode for the routine. Here’s the pseudocode for this example:\nExample of Pseudocode for a Routine\nThis routine outputs an error message based on an error code\nsupplied by the calling routine. The way it outputs the message\ndepends on the current processing state, which it retrieves\non its own. It returns a value indicating success or failure.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 748, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0749_9413d2bc", "text": "The way it outputs the message\ndepends on the current processing state, which it retrieves\non its own. It returns a value indicating success or failure. set the default status to \"fail\"\nlook up the message based on the error code \nif the error code is valid\n if doing interactive processing, display the error message \n interactively and declare success\n if doing command line processing, log the error message to the \n command line and declare success\nif the error code isn't valid, notify the user that an internal error \nhas been detected\nreturn status information\nAgain, note that the pseudocode is written at a fairly high level. It certainly isn’t writ-\nten in a programming language . Instead, it expresses in precise English what the \nroutine needs to do. Cross-Reference For details \non effective use of variables, \nsee Chapters 10 through 13. Think about the data You can design the routine’s data at several different points in \nthe process.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 749, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0750_5b57becf", "text": "Cross-Reference For details \non effective use of variables, \nsee Chapters 10 through 13. Think about the data You can design the routine’s data at several different points in \nthe process. In this example, the data is simple and data manipulation isn’t a prominent \npart of the routine. If data manipulation is a prominent part of the routine, it’s worth-\nwhile to think about the major pieces of data before you think about the routine’s logic. Definitions of key data types are useful to have when you design the logic of a routine. Cross-Reference For details \non review techniques, see \nChapter 21, “Collaborative \nConstruction.”\nCheck the pseudocode Once you’ve written the pseudocode and designed the data, \ntake a minute to review the pseudocode you’ve written. Back away from it, and think \nabout how you would explain it to someone else. Ask someone else to look at it or listen to you explain it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 750, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 906}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0751_a7113e46", "text": "Back away from it, and think \nabout how you would explain it to someone else. Ask someone else to look at it or listen to you explain it. You might think that it’s silly \nto have someone look at 11 lines of pseudo code, but you’ll be surprised. Pseudocode \ncan make your assumptions and high-level mistakes more obvious than program-\nming-language code does. People are also more willing to review a few lines of \npseudocode than they are to review 35 lines of C++ or Java. 9.3 Constructing Routines by Using the PPP 225\nMake sure you have an easy and comfortabl e understanding of what the routine does \nand how it does it. If you don’t understand it conceptually, at the pseudocode level, \nwhat chance do you have of understanding it at the programming-language level? And \nif you don’t understand it, who else will?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 751, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 818}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0752_1d828cb8", "text": "If you don’t understand it conceptually, at the pseudocode level, \nwhat chance do you have of understanding it at the programming-language level? And \nif you don’t understand it, who else will? Cross-Reference For more \non iteration, see Section \n34.8, “Iterate, Repeatedly, \nAgain and Again.”\nTry a few ideas in pseudocode, and keep the best (iterate) Try as many ideas as you \ncan in pseudocode before you start coding. Once you start coding, you get emotionally \ninvolved with your code and it becomes harder to throw away a bad design and start over. The general idea is to iterate the routine in pseudocode until the pseudocode state-\nments become simple enough that you can fill in code below each statement and leave \nthe original pseudocode as documentation. Some of the pseudocode from your first \nattempt might be high-level enough that yo u need to decompose it further. Be sure \nyou do decompose it further.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 752, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 919}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0753_b3a1070b", "text": "Some of the pseudocode from your first \nattempt might be high-level enough that yo u need to decompose it further. Be sure \nyou do decompose it further. If you’re not sure how to code something, keep working \nwith the pseudocode until you are sure. Keep refining and decomposing the \npseudocode until it seems like a waste of ti me to write it instead of the actual code. Code the Routine\nOnce you’ve designed the routine, construct it. You can perform construction steps in \na nearly standard order, but feel free to vary them as you need to. Figure 9-3 shows the \nsteps in constructing a routine. Figure 9-3 You’ll perform all of these steps as you design a routine but not necessarily in \nany particular order.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 753, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 713}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0754_4f84c919", "text": "Figure 9-3 shows the \nsteps in constructing a routine. Figure 9-3 You’ll perform all of these steps as you design a routine but not necessarily in \nany particular order. Start with pseudocode\nWrite the routine declaration\nWrite the first and last statements, and turn \nthe pseudocode into high-level comments\nFill in the code below each commentRepeat as needed\nClean up leftovers\nDone\nCheck the code\n226\nChapter 9: The Pseudocode Programming Process\nWrite the routine declaration Write the routine interface statement—the function \ndeclaration in C++, method declaration in Java, function or sub procedure declaration \nin Microsoft Visual Basic, or whatever your language calls for. Turn the original header \ncomment into a programming-language comment. Leave it in position above the \npseudocode you’ve already written.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 754, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 820}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0755_cd9862a6", "text": "Turn the original header \ncomment into a programming-language comment. Leave it in position above the \npseudocode you’ve already written. Here are the example routine’s interface state-\nment and header in C++:\nC+ + Example of a Routine Interface and Header Added to Pseudocode\nHere’s the header comment \nthat’s been turned into a \nC++-style comment. /* This routine outputs an error message based on an error code\nsupplied by the calling routine. The way it outputs the message\ndepends on the current processing state, which it retrieves \non its own. It returns a value indicating success or failure. */\nHere’s the interface \nstatement.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 755, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 636}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0756_213a2077", "text": "The way it outputs the message\ndepends on the current processing state, which it retrieves \non its own. It returns a value indicating success or failure. */\nHere’s the interface \nstatement. Status ReportErrorMessage(\n ErrorCode errorToReport\n )\nset the default status to \"fail\"\nlook up the message based on the error code \nif the error code is valid\n if doing interactive processing, display the error message \n interactively and declare success\n if doing command line processing, log the error message to the \n command line and declare success\nif the error code isn't valid, notify the user that an \ninternal error has been detected\nreturn status information\nThis is a good time to make notes about any interface assumptions. In this case, the \ninterface variable errorToReport is straightforward and typed for its specific purpose, \nso it doesn’t need to be documented. Turn the pseudocode into high-level comments Keep the ball rolling by writing the \nfirst and last statements: { and } in C++.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 756, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 997}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0757_e128ec4d", "text": "Turn the pseudocode into high-level comments Keep the ball rolling by writing the \nfirst and last statements: { and } in C++. Then turn the pseudocode into comments. Here’s how it would look in the example:\nC+ + Example of Writing the First and Last Statements Around Pseudocode \n/* This routine outputs an error message based on an error code\nsupplied by the calling routine. The way it outputs the message\ndepends on the current processing state, which it retrieves\non its own. It returns a value indicating success or failure. */\nStatus ReportErrorMessage(\n ErrorCode errorToReport\n ) {\nC09619670.fm Page 226 Tuesday, April 12, 2011 2:33 PM\n9.3 Constructing Routines by Using the PPP 227\nThe pseudocode statements \nfrom here down have been \nturned into C++ comments.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 757, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 769}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0758_58053d05", "text": "// set the default status to \"fail\"\n // look up the message based on the error code\n // if the error code is valid\n // if doing interactive processing, display the error message \n // interactively and declare success\n // if doing command line processing, log the error message to the \n // command line and declare success\n // if the error code isn't valid, notify the user that an \n // internal error has been detected\n // return status information\n}\nAt this point, the character of the routine is evident. The design work is complete, and \nyou can sense how the routine works even without seeing any code. You should feel that \nconverting the pseudocode to programming-lan guage code will be mechanical, natural, \nand easy. If you don’t, continue designing in pseudocode until the design feels solid. Cross-Reference This is a \ncase where the writing meta-\nphor works well—in the \nsmall.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 758, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0759_05858976", "text": "If you don’t, continue designing in pseudocode until the design feels solid. Cross-Reference This is a \ncase where the writing meta-\nphor works well—in the \nsmall. For criticism of apply-\ning the writing metaphor in \nthe large, see “Software Pen-\nmanship: Writing Code” in \nSection 2.3. Fill in the code below each comment Fill in the code below each line of pseudocode \ncomment. The process is a lot like writing a te rm paper. First you write an outline, and \nthen you write a paragraph for each point in the outline. Each pseudocode comment \ndescribes a block or paragraph of code. Like the lengths of literary paragraphs, the \nlengths of code paragraphs vary according to the thought being expressed, and the \nquality of the paragraphs depends on the vi vidness and focus of the thoughts in them.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 759, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 800}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0760_c5068916", "text": "In this example, the first two pseudocode comments give rise to two lines of code: \nC+ + Example of Expressing Pseudocode Comments as Code\n/* This routine outputs an error message based on an error code\nsupplied by the calling routine. The way it outputs the message\ndepends on the current processing state, which it retrieves\non its own. It returns a value indicating success or failure. */\nStatus ReportErrorMessage(\n ErrorCode errorToReport\n ) {\n // set the default status to \"fail\"\nHere’s the code that’s been \nfilled in. Status errorMessageStatus = Status_Failure;\n \n // look up the message based on the error code\nHere’s the new variable \nerrorMessage .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 760, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 659}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0761_38434192", "text": "Status errorMessageStatus = Status_Failure;\n \n // look up the message based on the error code\nHere’s the new variable \nerrorMessage . Message errorMessage = LookupErrorMessage( errorToReport );\n // if the error code is valid\n // if doing interactive processing, display the error message \n // interactively and declare success\n // if doing command line processing, log the error message to the \n // command line and declare success\n228\nChapter 9: The Pseudocode Programming Process\n // if the error code isn't valid, notify the user that an \n // internal error has been detected\n // return status information\n}\nThis is a start on the code. The variable errorMessage is used, so it needs to be declared. If you were commenting after the fact, two lines of comments for two lines of code \nwould nearly always be overkill. In this a pproach, however, it’s the semantic content \nof the comments that’s important, not ho w many lines of code they comment.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 761, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0762_aa369845", "text": "In this a pproach, however, it’s the semantic content \nof the comments that’s important, not ho w many lines of code they comment. The \ncomments are already there, and they explain the intent of the code, so leave them in. The code below each of the remaining comments needs to be filled in:\nC+ + Example of a Complete Routine Created with the Pseudocode \nProgramming Process\n/* This routine outputs an error message based on an error code\nsupplied by the calling routine. The way it outputs the message\ndepends on the current processing state, which it retrieves\non its own. It returns a value indicating success or failure. */\nStatus ReportErrorMessage(\n ErrorCode errorToReport\n ) {\n // set the default status to \"fail\"\n Status errorMessageStatus = Status_Failure;\n // look up the message based on the error code\n Message errorMessage = LookupErrorMessage( errorToReport );\n // if the error code is valid\nThe code for each comment \nhas been filled in from here \ndown.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 762, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0763_c6e760f0", "text": "if ( errorMessage.ValidCode() ) {\n // determine the processing method\n ProcessingMethod errorProcessingMethod = CurrentProcessingMethod();\n // if doing interactive processing, display the error message \n // interactively and declare success\n if ( errorProcessingMethod == ProcessingMethod_Interactive ) {\n DisplayInteractiveMessage( errorMessage.Text() );\n errorMessageStatus = Status_Success;\n }\n // if doing command line processing, log the error message to the \n // command line and declare success\nThis code is a good candidate \nfor being further decom-\nposed into a new routine: \nDisplayCommandLine-\nMessage() .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 763, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 616}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0764_455cc64e", "text": "else if ( errorProcessingMethod == ProcessingMethod_CommandLine ) {\n CommandLine messageLog;\n if ( messageLog.Status() == CommandLineStatus_Ok ) { \n messageLog.AddToMessageQueue( errorMessage.Text() );\n messageLog.FlushMessageQueue();\n errorMessageStatus = Status_Success;\n } \n9.3 Constructing Routines by Using the PPP 229\nThis code and comment are \nnew and are the result of \nfleshing out the if test. else {\n // can't do anything because the routine is already error processing\n }\nThis code and comment are \nalso new. else {\n // can't do anything because the routine is already error processing\n }\n }\n // if the error code isn't valid, notify the user that an \n // internal error has been detected\n else {\n DisplayInteractiveMessage( \n \"Internal Error: Invalid error code in ReportErrorMessage()\" \n );\n }\n // return status information\n return errorMessageStatus;\n}\nEach comment has given rise to one or more lines of code. Each block of code forms a \ncomplete thought based on the comment.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 764, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0765_1faa8164", "text": "Each block of code forms a \ncomplete thought based on the comment. The comments have been retained to provide \na higher-level explanation of the code. All variables have been declared and defined \nclose to the point they’re first used. Each comment should normally expand to about 2 \nto 10 lines of code. (Because this example is just for purposes of illustration, the code \nexpansion is on the low side of what you should usually experience in practice.)\nNow look again at the spec on page 221 and the initial pseudocode on page 224. The \noriginal five-sentence spec expanded to 15 lines of pseudocode (depending on how \nyou count the lines), which in turn expanded into a page-long routine. Even though \nthe spec was detailed, creation of the routine required substantial design work in \npseudocode and code. That low-level design is one reason why “coding” is a nontrivial \ntask and why the subject of this book is important.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 765, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0766_7d52313d", "text": "That low-level design is one reason why “coding” is a nontrivial \ntask and why the subject of this book is important. Check whether code should be further factored In some cases, you’ll see an explo-\nsion of code below one of the initial lines of pseudocode. In this case, you should con-\nsider taking one of two courses of action:\nCross-Reference For more \non refactoring, see Chapter \n24, “Refactoring.”I\nFactor the code below the comment into a new routine. If you find one line of \npseudocode expanding into more code that than you expected, factor the code \ninto its own routine. Write the code to call the routine, including the routine name. If you’ve used the PPP well, the name of the new routine should drop out easily \nfrom the pseudocode. Once you’ve completed the routine you were originally cre-\nating, you can dive into the new routine and apply the PPP again to that routine. I\nApply the PPP recursively.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 766, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 920}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0767_298ca366", "text": "Once you’ve completed the routine you were originally cre-\nating, you can dive into the new routine and apply the PPP again to that routine. I\nApply the PPP recursively. Rather than writing a couple dozen lines of code \nbelow one line of pseudocode, take the time to decompose the original line of \npseudocode into several more lines of pseudocode. Then continue filling in the \ncode below each of the new lines of pseudocode. C09619670.fm Page 229 Tuesday, April 12, 2011 2:34 PM\n230\nChapter 9: The Pseudocode Programming Process\nCheck the Code \nAfter designing and implementing the routine, the third big step in constructing it is \nchecking to be sure that what you’ve constructed is correct. Any errors you miss at this \nstage won’t be found until later testing. They’re more expensive to find and correct \nthen, so you should find all that you can at this stage.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 767, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 867}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0768_ca6b2bc6", "text": "Any errors you miss at this \nstage won’t be found until later testing. They’re more expensive to find and correct \nthen, so you should find all that you can at this stage. Cross-Reference For details \non checking for errors in \narchitecture and require-\nments, see Chapter 3, \n“Measure Twice, Cut Once: \nUpstream Prerequisites.”\nA problem might not appear until the routine is fully coded for several reasons. An \nerror in the pseudocode might become more apparent in the detailed implementation \nlogic. A design that looks elegant in pseu docode might become clumsy in the imple-\nmentation language. Working with the detailed implementation might disclose an \nerror in the architecture, high-level design , or requirements. Finally, the code might \nhave an old-fashioned, mongrel coding erro r—nobody’s perfect! For all these reasons, \nreview the code before you move on. Mentally check the routine for errors The first formal check of a routine is mental.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 768, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 957}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0769_b55a7583", "text": "For all these reasons, \nreview the code before you move on. Mentally check the routine for errors The first formal check of a routine is mental. The cleanup and informal checking steps me ntioned earlier are two kinds of mental \nchecks. Another is executing each path mentally. Mentally executing a routine is diffi-\ncult, and that difficulty is one reason to ke ep your routines small. Make sure that you \ncheck nominal paths and endpoints and all exception conditions. Do this both by \nyourself, which is called “desk checking,” an d with one or more peers, which is called \na “peer review,” a “walk-through,” or an “inspection,” depending on how you do it. One of the biggest differences between hobbyists and professional programmers is \nthe difference that grows out of moving from superstition into understanding. The \nword “superstition” in this context doesn’t refer to a program that gives you the creeps \nor generates extra errors when the moon is full.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 769, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0770_eff88267", "text": "The \nword “superstition” in this context doesn’t refer to a program that gives you the creeps \nor generates extra errors when the moon is full. It means substituting feelings about \nthe code for understanding. If you often find yourself suspecting that the compiler or \nthe hardware made an error, you’re still in the realm of superstition. A study con-\nducted many years ago found that only about five percent of all errors are hardware, \ncompiler, or operating-system errors (Ostrand and Weyuker 1984). Today, that per-\ncentage would probably be even lower. Programmers who have moved into the realm \nof understanding always suspect their own work first because they know that they \ncause 95 percent of errors. Understand the role of each line of code and why it’s \nneeded. Nothing is ever right just because it seems to work. If you don’t know why it \nworks, it probably doesn’t—you just don’t know it yet. Bottom line: A working routine isn’t enough.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 770, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0771_d5821a87", "text": "Nothing is ever right just because it seems to work. If you don’t know why it \nworks, it probably doesn’t—you just don’t know it yet. Bottom line: A working routine isn’t enough. If you don’t know why it works, study it, \ndiscuss it, and experiment with alternative designs until you do. Compile the routine After reviewing the routine, compile it. It might seem inefficient \nto wait this long to compile since the co de was completed seve ral pages ago. Admit-\ntedly, you might have saved some work by compiling the routine earlier and letting \nthe computer check for undeclared vari ables, naming conflicts, and so on. 1\n23\nHARD DATA\nKEY POINT\n9.3 Constructing Routines by Using the PPP 231\nYou’ll benefit in several ways, however, by not compiling until late in the process. The \nmain reason is that when you compile new code, an internal stopwatch starts ticking.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 771, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 867}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0772_13d4935d", "text": "The \nmain reason is that when you compile new code, an internal stopwatch starts ticking. After the first compile, you step up the pressure: “I’ll get it right with just one more \ncompile.” The “Just One More Compile” synd rome leads to hasty, error-prone changes \nthat take more time in the long run. Avoi d the rush to completion by not compiling \nuntil you’ve convinced yourself that the routine is right. The point of this book is to show how to rise above the cycle of hacking something \ntogether and running it to see if it work s. Compiling before you’re sure your pro-\ngram works is often a symptom of the hacker mindset. If you’re not caught in the \nhacking-and-compiling cycle, compile when you feel it’s appropriate. But be con-\nscious of the tug most people feel toward “hacking, compiling, and fixing” their way \nto a working program. Here are some guidelines for getting the most out of compiling your routine:\n■\nSet the compiler’s warning level to the pickiest level possible.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 772, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 991}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0773_79e17922", "text": "Here are some guidelines for getting the most out of compiling your routine:\n■\nSet the compiler’s warning level to the pickiest level possible. You can catch an \namazing number of subtle errors simply by allowing the compiler to detect them. ■\nUse validators. The compiler checking performed by languages like C can be \nsupplemented by use of tools like lint. Even code that isn’t compiled, such as \nHTML and JavaScript, can be ch ecked by validation tools. ■\nEliminate the causes of all error message s and warnings. Pay attention to what \nthe messages tell you about your code. A large number of warnings often indi-\ncates low-quality code, and you should try to understand each warning you get. In practice, warnings you’ve seen ag ain and again have one of two possible \neffects: you ignore them and they camouflage other, more important, warnings, \nor they simply become annoying. It’s usually safer and less painful to rewrite the \ncode to solve the underlying prob lem and eliminate the warnings.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 773, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0774_43f822ee", "text": "It’s usually safer and less painful to rewrite the \ncode to solve the underlying prob lem and eliminate the warnings. Step through the code in the debugger Once the routine compiles, put it into the \ndebugger and step through each line of code. Make sure each line executes as you \nexpect it to. You can find many errors by following this simple practice. Cross-Reference For details, \nsee Chapter 22, “Developer \nTesting.” Also see “Building \nScaffolding to Test Individual \nClasses” in Section 22.5. Test the code Test the code using the test cases you planned or created while you \nwere developing the routine. You might have to develop scaffolding to support your \ntest cases—that is, code that ’s used to support routines while they’re tested and that \nisn’t included in the final product. Scaffold ing can be a test-harness routine that calls \nyour routine with test data, or it can be stubs called by your routine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 774, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0775_71d1d6bc", "text": "Scaffold ing can be a test-harness routine that calls \nyour routine with test data, or it can be stubs called by your routine. Cross-Reference For details, \nsee Chapter 23, “Debugging.”\nRemove errors from the routine Once an error has been detected, it has to be \nremoved. If the routine you’re developing is buggy at this point, chances are good that \nit will stay buggy. If you find that a rout ine is unusually buggy, start over. Don’t hack \naround it—rewrite it. Hacks usually indica te incomplete underst anding and guarantee \nerrors both now and later. Creating an entirely new design for a buggy routine pays \noff. Few things are more satisfying than rewriting a problematic routine and never \nfinding another error in it. 232\nChapter 9: The Pseudocode Programming Process\nClean Up Leftovers\nWhen you’ve finished checking your code for problems, check it for the general char-\nacteristics described througho ut this book.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 775, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0776_93abb687", "text": "232\nChapter 9: The Pseudocode Programming Process\nClean Up Leftovers\nWhen you’ve finished checking your code for problems, check it for the general char-\nacteristics described througho ut this book. You can take several cleanup steps to \nmake sure that the routine’s quality is up to your standards:\n■\nCheck the routine’s interface. Make sure that all input and output data is \naccounted for and that all parameters are used. For more details, see Section 7.5, \n“How to Use Routine Parameters.”\n■\nCheck for general design quality. Make su re the routine does one thing and does \nit well, that it’s loosely coupled to other routines, and that it’s designed defen-\nsively. For details, see Chapte r 7, “High-Quality Routines.”\n■\nCheck the routine’s variables. Check fo r inaccurate variable names, unused \nobjects, undeclared variables, improperly initialized objects, and so on. For \ndetails, see the chapters on using variables, Chapters 10 through 13. ■\nCheck the routine’s statements and logic.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 776, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0777_33b9579f", "text": "For \ndetails, see the chapters on using variables, Chapters 10 through 13. ■\nCheck the routine’s statements and logic. Check for off-by-one errors, infinite \nloops, improper nesting, and resource le aks. For details, see the chapters on \nstatements, Chapters 14 through 19. ■\nCheck the routine’s layout. Make sure you’ve used white space to clarify the log-\nical structure of the routine, expression s, and parameter lists. For details, see \nChapter 31, “Layout and Style.”\n■\nCheck the routine’s documentation. Make sure the pseudocode that was trans-\nlated into comments is still accurate. Check for algorithm descriptions, for doc-\numentation on interface assumptions and nonobvious dependencies, for \njustification of unclear coding practices, and so on. For details, see Chapter 32, \n“Self-Documenting Code.”\n■\nRemove redundant comments.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 777, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 841}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0778_72cf91a2", "text": "For details, see Chapter 32, \n“Self-Documenting Code.”\n■\nRemove redundant comments. Sometimes a pseudocode comment turns out to be \nredundant with the code the comment descri bes, especially when the PPP has been \napplied recursively and the comment just precedes a call to a well-named routine. Repeat Steps as Needed\nIf the quality of the routine is poor, back up to the pseudocode. High-quality pro-\ngramming is an iterative proc ess, so don’t hesitate to l oop through the construction \nactivities again. 9.4 Alternatives to the PPP\nFor my money, the PPP is the best method for creating classes and routines. Here are \nsome different approaches recommended by other experts. You can use these \napproaches as alternatives or as supplements to the PPP. 9.4 Alternatives to the PPP 233\nTest-first development Test-first is a popular developm ent style in which test cases \nare written prior to writing any code. This approach is described in more detail in \n“Test First or Test Last?” in Section 22.2.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 778, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0779_3bbbd6d6", "text": "This approach is described in more detail in \n“Test First or Test Last?” in Section 22.2. A good book on test-first programming is \nKent Beck’s Test-Driven Development: By Example (Beck 2003). Refactoring Refactoring is a development approach in which you improve code \nthrough a series of semantic preserving transformations. Programmers use patterns of \nbad code or “smells” to identify sections of code that need to be improved. Chapter \n24, “Refactoring,” describes this approach in detail, and a good book on the topic is \nMartin Fowler’s Refactoring: Improving the Design of Existing Code (Fowler 1999). Design by contract Design by contract is a development approach in which each \nroutine is considered to have preconditions and postconditions. This approach is \ndescribed in “Use assertions to document and verify preconditions and postcondi-\ntions” in Section 8.2. The best source of info rmation on design by contract is Bertrand \nMeyers’s Object-Oriented Software Construction (Meyer 1997).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 779, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0780_9301c830", "text": "The best source of info rmation on design by contract is Bertrand \nMeyers’s Object-Oriented Software Construction (Meyer 1997). Hacking? Some programmers try to hack their way toward working code rather \nthan using a systematic approach like the PPP. If you’ve ever found that you’ve coded \nyourself into a corner in a routine and have to start over, that’s an indication that the \nPPP might work better. If you find yourself losing your train of thought in the middle \nof coding a routine, that’s another indicati on that the PPP would be beneficial. Have \nyou ever simply forgotten to write part of a class or part of routine? That hardly ever \nhappens if you’re using the PPP. If you find yourself staring at the computer screen not \nknowing where to start, that’s a surefire sign that the PPP would make your program-\nming life easier.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 780, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 839}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0781_d94f8687", "text": "If you find yourself staring at the computer screen not \nknowing where to start, that’s a surefire sign that the PPP would make your program-\nming life easier. cc2e.com/0943\nCHECKLIST: The Pseudocode Programming Process\nCross-Reference The point \nof this list is to check \nwhether you followed a \ngood set of steps to create a \nroutine. For a checklist that \nfocuses on the quality of the \nroutine itself, see the “High-\nQuality Routines” checklist in \nChapter 7, page 185.❑\nHave you checked that the prerequisites have been satisfied? ❑\nHave you defined the problem that the class will solve? ❑\nIs the high-level design clear enough to give the class and each of its rou-\ntines a good name? ❑\nHave you thought about how to test the class and each of its routines? ❑\nHave you thought about efficiency mainly in terms of stable interfaces and \nreadable implementations or mainly in terms of meeting resource and \nspeed budgets?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 781, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0782_0ed10c1a", "text": "❑\nHave you thought about efficiency mainly in terms of stable interfaces and \nreadable implementations or mainly in terms of meeting resource and \nspeed budgets? ❑\nHave you checked the standard libraries and other code libraries for appli-\ncable routines or components? ❑\nHave you checked reference books for helpful algorithms? 234\nChapter 9: The Pseudocode Programming Process\n❑\nHave you designed each routine by using detailed pseudocode? ❑\nHave you mentally checked the pseudocode? Is it easy to understand? ❑\nHave you paid attention to warnings that would send you back to design \n(use of global data, operations that seem better suited to another class or \nanother routine, and so on)? ❑\nDid you translate the pseudocode to code accurately? ❑\nDid you apply the PPP recursively, breaking routines into smaller routines \nwhen needed? ❑\nDid you document assumptions as you made them? ❑\nDid you remove comments that turned out to be redundant?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 782, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0783_7819402b", "text": "❑\nDid you apply the PPP recursively, breaking routines into smaller routines \nwhen needed? ❑\nDid you document assumptions as you made them? ❑\nDid you remove comments that turned out to be redundant? ❑\nHave you chosen the best of several iterations, rather than merely stop-\nping after your first iteration? ❑\nDo you thoroughly understand your code? Is it easy to understand? Key Points\n■\nConstructing classes and constructing rout ines tends to be an iterative process. Insights gained while constructing specific routines tend to ripple back through \nthe class’s design. ■\nWriting good pseudocode calls for usin g understandable English, avoiding fea-\ntures specific to a single programming language, and writing at the level of \nintent (describing what the design does rather than how it will do it). ■\nThe Pseudocode Programming Process is a useful tool for detailed design and \nmakes coding easy. Pseudocode translat es directly into comments, ensuring \nthat the comments are accurate and useful.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 783, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1000}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0784_eed76ba8", "text": "■\nThe Pseudocode Programming Process is a useful tool for detailed design and \nmakes coding easy. Pseudocode translat es directly into comments, ensuring \nthat the comments are accurate and useful. ■\nDon’t settle for the first design you think of. Iterate through multiple approaches \nin pseudocode and pick the best approach before you begin writing code. ■\nCheck your work at each step, and encourage others to check it too. That way, \nyou’ll catch mistakes at the least expensive level, when you’ve invested the least \namount of effort. Part III\nVariables\nIn this part:\nChapter 10: General Issues in Us ing Variables . . . . . . . . . . . . . . . . . . . . . .237\nChapter 11: The Power of Variable Names . . . . . . . . . . . . . . . . . . . . . . . . .259\nChapter 12: Fundamental Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . .291\nChapter 13: Unusual Data Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 784, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0785_a5b7eb4d", "text": ". . . . . . . . . . . . . . . . . . . . . . . .259\nChapter 12: Fundamental Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . .291\nChapter 13: Unusual Data Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .319\n\n237\nChapter 10\nGeneral Issues in Using \nVariables\ncc2e.com/1085\nContents\n■\n10.1 Data Literacy: page 238\n■\n10.2 Making Variable Declarations Easy: page 239\n■\n10.3 Guidelines for Initializing Variables: page 240\n■\n10.4 Scope: page 244\n■\n10.5 Persistence: page 251\n■\n10.6 Binding Time: page 252\n■\n10.7 Relationship Between Data Types and Control Structures: page 254\n■\n10.8 Using Each Variable for Exactly One Purpose: page 255\nRelated Topics\n■\nNaming variables: Chapter 11\n■\nFundamental data types: Chapter 12 \n■\nUnusual data types: Chapter 13\n■\nFormatting data declarations: “Laying Out Data Declarations” in Section 31.5\n■\nDocumenting variables: “Commenting Data Declarations” in Section 32.5\nIt’s normal and desirable for construction to fill in small gaps in the requirements and \narchitecture.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 785, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1045}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0786_5155a12b", "text": "It would be inefficient to draw blueprints to such a microscopic level that \nevery detail was completely specified. This chapter describes a nuts-and-bolts con-\nstruction issue: the ins and outs of using variables. The information in this chapter should be particularly valuable to you if you’re an expe-\nrienced programmer. It’s easy to start using hazardous practices before you’re fully aware \nof your alternatives and then to continue to use them out of habit even after you’ve \nlearned ways to avoid them. An experienced programmer might find the discussions on \nbinding time in Section 10.6 and on using each variable for one purpose in Section 10.8 \nparticularly interesting. If you’re not sure whether you qualify as an “experienced pro-\ngrammer,” take the “Data Literacy Test ” in the next section and find out. 238\nChapter 10: General Issues in Using Variables\nThroughout this chapter I use the word “variabl e” to refer to objects as well as to built-\nin data types like integers and arrays.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 786, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0787_edd135c9", "text": "238\nChapter 10: General Issues in Using Variables\nThroughout this chapter I use the word “variabl e” to refer to objects as well as to built-\nin data types like integers and arrays. The phrase “data type” generally refers to built-\nin data types, while the word “data” refers to either objects or built-in types. 10.1 Data Literacy\nThe first step in creating effective data is knowing which kind of da ta to create. A good \nrepertoire of data types is a key part of a programmer’s toolbox. A tutorial in data \ntypes is beyond the scope of this book, but the “Data Literacy Test” will help you \ndetermine how much more you might need to learn about them. The Data Literacy Test\nPut a 1 next to each term that looks familiar. If you think you know what a term means \nbut aren’t sure, give yourself a 0.5. Add the points when you’re done, and interpret \nyour score according to the scoring table below.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 787, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0788_65f0fa37", "text": "If you think you know what a term means \nbut aren’t sure, give yourself a 0.5. Add the points when you’re done, and interpret \nyour score according to the scoring table below. KEY POINT\n______\n abstract data type ______ literal\n______\n array ______ local variable\n______ bitmap ______ lookup table\n______ boolean variable ______ member data\n______ B-tree ______ pointer\n______ character variable ______ private\n______ container class ______ retroactive synapse\n______ double precision ______ referential integrity\n______ elongated stream ______ stack\n______ enumerated type ______ string\n______ floating point ______ structured variable\n______ heap ______ tree\n______ index ______ typedef\n______ integer ______ union\n______ linked list ______ value chain\n______ named constant ______ variant\n______ \nTotal Score\n10.2 Making Variable Declarations Easy 239\nHere is how you can interpret the scores (loosely):\nAdditional Resources on Data Types\nThese books are good sources of information about data types:\nCormen, H.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 788, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1014}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0789_3b658053", "text": "Thomas, Charles E. Leiserson, Ronald L. Rivest. Introduction to Algorithms . New York, NY: McGraw Hill. 1990. Sedgewick, Robert. Algorithms in C++, Parts 1-4 , 3d ed. Boston, MA: Addison-Wesley, \n1998. Sedgewick, Robert. Algorithms in C++, Part 5 , 3d ed. Boston, MA : Addison-Wesley, \n2002. 10.2 Making Variable Declarations Easy\nCross-Reference For details \non layout of variable decla-\nrations, see “Laying Out Data \nDeclarations” in Section \n31.5. For details on docu-\nmenting them, see “Com-\nmenting Data Declarations” \nin Section 32.5. This section describes what you can do to st reamline the task of declaring variables. To be sure, this is a small task, and you mi ght think it’s too small to deserve its own \nsection in this book. Nevertheless, you spen d a lot of time creating variables, and \ndeveloping the right habits ca n save time and frustration over the life of a project. Implicit Declarations\nSome languages have implicit variable declarations.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 789, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0790_9a14325d", "text": "Implicit Declarations\nSome languages have implicit variable declarations. For example, if you use a variable \nin Microsoft Visual Basic without declaring it, the compiler declares it for you automat-\nically (depending on your compiler settings). 0–14 You are a beginning programmer, probably in your first year of computer sci-\nence in school or teaching yourself your first programming language. You can \nlearn a lot by reading one of the books li sted in the next su bsection. Many of \nthe descriptions of techniques in this part of the book are addressed to \nadvanced programmers, and you’ll get more out of them after you’ve read \none of these books. 15–19 You are an intermedia te programmer or an experienced programmer who has \nforgotten a lot. Although many of the concepts will be familiar to you, you \ntoo can benefit from reading one of the books listed below. 20–24 You are an expert programmer. You probably already have the books listed \nbelow on your shelf.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 790, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0791_c738e204", "text": "20–24 You are an expert programmer. You probably already have the books listed \nbelow on your shelf. 25–29 You know more about data types than I do. Consider writing your own com-\nputer book. (Send me a copy!)\n30–32 You are a pompous fraud. The terms “elongated stream,” “retroactive syn-\napse,” and “value chain” don’t refer to data types—I made them up. Please \nread the “Intellectual Honesty” section in Chapter 33, “Personal Character”! 240\nChapter 10: General Issues in Using Variables\nImplicit declaration is one of the most hazardous features available in any language. If \nyou program in Visual Basic, you know how frustrating it is to try to figure out why \nacctNo doesn’t have the right value and then notice that acctNum is the variable that’s \nreinitialized to 0. This kind of mistake is an easy one to make if your language doesn’t \nrequire you to declare variables.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 791, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 879}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0792_7c5fab0b", "text": "This kind of mistake is an easy one to make if your language doesn’t \nrequire you to declare variables. If you’re programming in a language that requires you to declare variables, you have to \nmake two mistakes before your program will bite you. First you have to put both acct-\nNum and acctNo into the body of the routine. Then you have to declare both variables \nin the routine. This is a harder mistake to make, and it virtually eliminates the synon-\nymous-variables problem. Languages that require you to declare data explicitly are, in \nessence, requiring you to use data more carefully, which is one of their primary advan-\ntages. What do you do if you program in a language with implicit declarations? Here \nare some suggestions:\nTurn off implicit declarations Some compilers allow you to disable implicit declara-\ntions. For example, in Visual Basic you would use an Option Explicit statement, which \nforces you to declare all variables before you use them.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 792, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0793_22d8a02e", "text": "For example, in Visual Basic you would use an Option Explicit statement, which \nforces you to declare all variables before you use them. Declare all variables As you type in a new variable, declare it, even though the com-\npiler doesn’t require you to. This won’t catch all the errors, but it will catch some of them. Cross-Reference For details \non the standardization of \nabbreviations, see “General \nAbbreviation Guidelines” in \nSection 11.6. Use naming conventions Establish a naming convention for common suffixes such as \nNum and No so that you don’t use two variables when you mean to use one. Check variable names Use the cross-reference list generated by your compiler or \nanother utility program. Many compilers list all the variables in a routine, allowing \nyou to spot both acctNum and acctNo . They also point out variables that you’ve \ndeclared and not used.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 793, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 872}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0794_66ade08e", "text": "Many compilers list all the variables in a routine, allowing \nyou to spot both acctNum and acctNo . They also point out variables that you’ve \ndeclared and not used. 10.3 Guidelines for Initializing Variables\nImproper data initialization is one of the most fertile sources of error in computer pro-\ngramming. Developing effective techniques for avoiding initialization problems can \nsave a lot of debugging time. The problems with improper initialization stem from a variable’s containing an initial \nvalue that you do not expect it to contain. This can happen for any of several reasons:\nCross-Reference For a test-\ning approach based on data \ninitialization and use pat-\nterns, see “Data-Flow Test-\ning” in Section 22.3.I\nThe variable has never been assigned a value. Its value is whatever bits hap-\npened to be in its area of memory when the program started. I\nThe value in the variable is outdated. The variable was assigned a value at some \npoint, but the value is no longer valid.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 794, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 986}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0795_d0833082", "text": "I\nThe value in the variable is outdated. The variable was assigned a value at some \npoint, but the value is no longer valid. I\nPart of the variable has been assigned a value and part has not. KEY POINT\nKEY POINT\nC10619670.fm Page 240 Tuesday, April 12, 2011 2:37 PM\n10.3 Guidelines for Initializing Variables 241\nThis last theme has several variations. You can initialize some of the members of an \nobject but not all of them. You can forget to allocate memory and then initialize the \n“variable” the unini tialized pointer points to. This means that you are really selecting \na random portion of computer memory and assigning it some value. It might be mem-\nory that contains data. It might be memory that contains code. It might be the operat-\ning system. The symptom of the pointer prob lem can manifest itself in completely \nsurprising ways that are different each time—that’s what makes debugging pointer \nerrors harder than debugging other errors.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 795, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0796_d69d7b80", "text": "The symptom of the pointer prob lem can manifest itself in completely \nsurprising ways that are different each time—that’s what makes debugging pointer \nerrors harder than debugging other errors. Following are guidelines for avoiding initialization problems:\nInitialize each variable as it’s declared Initializing variables as they’re declared is an \ninexpensive form of defensive programming. It’s a good insurance policy against ini-\ntialization errors. The example below ensures that studentGrades will be reinitialized \neach time you call the routine that contains it. C+ + Example of Initialization at Declaration Time\nfloat studentGrades[ MAX_STUDENTS ] = { 0.0 }; \nCross-Reference Checking \ninput parameters is a form of \ndefensive programming. For \ndetails on defensive pro-\ngramming, see Chapter 8, \n“Defensive Programming.”\nInitialize each variable close to where it’s first used Some languages, including \nVisual Basic, don’t support initializing vari ables as they’re declared.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 796, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0797_e4ede347", "text": "That can lead to \ncoding styles like the following one, in which declarations are grouped together and \nthen initializations are grouped together—all far from the first actual use of the variables. Visual Basic Example of Bad Initialization\n' declare all variables\nDim accountIndex As Integer\nDim total As Double\nDim done As Boolean\n' initialize all variables\naccountIndex = 0\ntotal = 0.0\ndone = False\n... ' code using accountIndex\n... ' code using total\n... ' code using done\nWhile Not done\n ... CODING \nHORROR\n242\nChapter 10: General Issues in Using Variables\nA better practice is to initialize variables as close as possible to where they’re first used:\nVisual Basic Example of Good Initialization\nDim accountIndex As Integer\naccountIndex = 0\n' code using accountIndex\n... Dim total As Double\ntotal is declared and initial-\nized close to where it’s used. total = 0.0\n' code using total\n... Dim done As Boolean\ndone is also declared and \ninitialized close to where it’s \nused.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 797, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0798_a268a2ec", "text": "Dim total As Double\ntotal is declared and initial-\nized close to where it’s used. total = 0.0\n' code using total\n... Dim done As Boolean\ndone is also declared and \ninitialized close to where it’s \nused. done = False\n' code using done\nWhile Not done\n ... The second example is superior to the first for several reasons. By the time execution \nof the first example gets to the code that uses done , done could have been modified. If \nthat’s not the case when you first write th e program, later modifications might make \nit so. Another problem with the first approach is that throwing all the initializations \ntogether creates the impression that all the variables are used throughout the whole \nroutine—when in fact done is used only at the end. Fina lly, as the program is modified \n(as it will be, if only by debugging), loop s might be built around the code that uses \ndone , and done will need to be reinitialized. Th e code in the second example will \nrequire little modification in such a case.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 798, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0799_0ad283f4", "text": "Th e code in the second example will \nrequire little modification in such a case. Th e code in the first example is more prone \nto producing an annoying initialization error. Cross-Reference For more \ndetails on keeping related \nactions together, see Section \n10.4, “Scope.”\nThis is an example of the Principle of Pr oximity: keep related actions together. The \nsame principle applies to keeping comments close to the code they describe, keeping \nloop setup code close to the loop, grouping statements in straight-line code, and to \nmany other areas. Ideally, declare and define each variable close to where it’s first used A declaration \nestablishes a variable’s type. A definition a ssigns the variable a specific value. In lan-\nguages that support it, such as C++ and Java , variables should be declared and defined \nclose to where they are first used.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 799, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 855}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0800_e701b1be", "text": "A definition a ssigns the variable a specific value. In lan-\nguages that support it, such as C++ and Java , variables should be declared and defined \nclose to where they are first used. Ideally, each variable should be defined at the same \ntime it’s declared, as shown next: \nJava Example of Good Initialization\nint accountIndex = 0;\n// code using accountIndex\n... 10.3 Guidelines for Initializing Variables 243\ntotal is initialized close to \nwhere it’s used. double total = 0.0;\n// code using total\n... done is also initialized close \nto where it’s used. boolean done = false;\n// code using done\nwhile ( ! done ) {\n ... Cross-Reference For more \ndetails on keeping related \nactions together, see Section \n14.2, “Statements Whose \nOrder Doesn’t Matter.”\nUse final or const when possible By declaring a variable to be final in Java or const \nin C++, you can prevent the variable from be ing assigned a value after it’s initialized.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 800, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0801_f92aed82", "text": "The final and const keywords are useful for defining class constants, input-only \nparameters, and any local variables whose va lues are intended to remain unchanged \nafter initialization. Pay special attention to counters and accumulators The variables i, j, k, sum, and \ntotal are often counters or accumulators. A common error is forgetting to reset a \ncounter or an accumulator before the next time it’s used. Initialize a class’s member data in its constructor Just as a routine’s variables should \nbe initialized within each routine, a class’s da ta should be initialized within its construc-\ntor. If memory is allocated in the construc tor, it should be freed in the destructor. Check the need for reinitialization Ask yourself whether the variable will ever need \nto be reinitialized, either because a loop in the routine uses the variable many times or \nbecause the variable retains its value between calls to the routine and needs to be reset \nbetween calls.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 801, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0802_160cc8ba", "text": "If it needs to be reinitialized, make sure that the initialization statement \nis inside the part of the code that’s repeated. Initialize named constants once; initia lize variables with executable code If you’re \nusing variables to emulate named constants, it’s OK to write code that initializes them \nonce, at the beginning of the program. To do this, initialize them in a Startup() routine. Initialize true variables in executable code close to where they’re used. One of the \nmost common program modifications is to chan ge a routine that was originally called \nonce so that you call it multiple times. Vari ables that are initialized in a program-level \nStartup() routine aren’t reinitialized the second time through the routine. Use the compiler setting that auto matically initializes all variables If your compiler \nsupports such an option, having the compiler set to automatically initialize all variables \nis an easy variation on the theme of relying on your compiler.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 802, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0803_1e5aa230", "text": "Relying on specific com-\npiler settings, however, can cause problems when you move the code to another \nmachine and another compiler. Make sure you document your use of the compiler set-\nting; assumptions that rely on specific compiler settings are hard to uncover otherwise. Take advantage of your compiler’s warning messages Many compilers warn you that \nyou’re using an uninitialized variable. 244\nChapter 10: General Issues in Using Variables\nCross-Reference For more \non checking input parame-\nters, see Section 8.1, “Pro-\ntecting Your Program from \nInvalid Inputs,” and the rest \nof Chapter 8, “Defensive Pro-\ngramming.” \nCheck input parameters for validity Another valuable form of initialization is check-\ning input parameters for validity. Before yo u assign input values to anything, make \nsure the values are reasonable. Use a memory-access checker to check for bad pointers In some operating systems, \nthe operating-system code checks for invalid pointer references.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 803, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0804_31625f4f", "text": "Use a memory-access checker to check for bad pointers In some operating systems, \nthe operating-system code checks for invalid pointer references. In others, you’re on \nyour own. You don’t have to stay on your own, however, because you can buy mem-\nory-access checkers that check your program’s pointer operations. Initialize working memory at the beginning of your program Initializing working \nmemory to a known value helps to expose in itialization problems. You can take any of \nseveral approaches:\n■\nYou can use a preprogram memory filler to fill the memory with a predictable \nvalue. The value 0 is good for some purposes b ecause it ensures that uninitial-\nized pointers point to low memory, making it relatively easy to detect them \nwhen they’re used. On the Intel processors, 0xCC is a good value to use because \nit’s the machine code for a breakpoint interrupt; if you are running code in a \ndebugger and try to execute your data rather than your code, you’ll be awash in \nbreakpoints.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 804, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0805_84878219", "text": "Another virtue of the value 0xCC is that it’s easy to recognize in \nmemory dumps—and it’s rarely used for legitimate reasons. Alternatively, Brian \nKernighan and Rob Pike suggest using the constant 0xDEADBEEF as memory \nfiller that’s easy to recognize in a debugger (1999). ■\nIf you’re using a memory filler, you can change the value you use to fill the mem-\nory once in awhile. Shaking up the program sometimes uncovers problems that \nstay hidden if the environmen tal background never changes. ■\nYou can have your program initialize its working memory at startup time. Whereas the purpose of using a preprogram memory filler is to expose defects, \nthe purpose of this technique is to hide them. By filling working memory with \nthe same value every time, you guarantee that your program won’t be affected by \nrandom variations in the startup memory. 10.4 Scope\n“Scope” is a way of thinking about a variable’s celebrity status: how famous is it?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 805, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0806_bbb688cc", "text": "10.4 Scope\n“Scope” is a way of thinking about a variable’s celebrity status: how famous is it? Scope, or visibility, refers to the extent to which your variables are known and can be \nreferenced throughout a program. A variable with limited or small scope is known in \nonly a small area of a program—a loop index used in only one small loop, for instance. A variable with large scope is known in ma ny places in a program—a table of employee \ninformation that’s used throughout a program, for instance. Different languages handle scope in different ways. In some primitive languages, all \nvariables are global. You therefore don’t have any control over the scope of a variable, \n10.4 Scope 245\nand that can create a lot of problems. In C+ + and similar languages, a variable can be \nvisible to a block (a section of code enclosed in curly brackets), a routine, a class (and \npossibly its derived classes), or the whole prog ram.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 806, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0807_ebf1c68d", "text": "In C+ + and similar languages, a variable can be \nvisible to a block (a section of code enclosed in curly brackets), a routine, a class (and \npossibly its derived classes), or the whole prog ram. In Java and C#, a variable can also \nbe visible to a package or name space (a collection of classes). The following sections provide guidelines that apply to scope. Localize References to Variables\nThe code between references to a variable is a “window of vulnerability.” In the win-\ndow, new code might be added, inadvertentl y altering the variable, or someone read-\ning the code might forget the value the variable is supposed to contain. It’s always a \ngood idea to localize references to va riables by keeping them close together. The idea of localizing references to a variable is pretty self-evident, but it’s an idea that \nlends itself to formal measurement. One method of measuring how close together the \nreferences to a variable are is to compute the “span” of a variable.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 807, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0808_99a4d1c2", "text": "One method of measuring how close together the \nreferences to a variable are is to compute the “span” of a variable. Here’s an example:\nJava Example of Variable Span\na = 0;\nb = 0;\nc = 0;\na = b + c;\nIn this case, two lines come between the first reference to a and the second, so a has a \nspan of two. One line comes between the two references to b, so b has a span of one, \nand c has a span of zero. Here’s another example:\nJava Example of Spans of One and Zero\na = 0;\nb = 0;\nc = 0;\nb = a + 1;\nb = b / c;\nFurther Reading For more \ninformation on variable \nspan, see Software Engineer-\ning Metrics and Models \n(Conte, Dunsmore, and Shen \n1986). In this case, there is one line between the first reference to b and the second, for a span \nof one. There are no lines between the second reference to b and the third, for a span \nof zero. The average span is computed by averaging the individual spans. In the second exam-\nple, for b, (1+0)/2 equals an average span of 0.5.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 808, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0809_fe5f38f8", "text": "The average span is computed by averaging the individual spans. In the second exam-\nple, for b, (1+0)/2 equals an average span of 0.5. When you keep references to vari-\nables close together, you enable the person reading your code to focus on one section \nat a time. If the references are far apart, you force the reader to jump around in the pro-\ngram. Thus the main advantage of keeping references to variables together is that it \nimproves program readability. 246\nChapter 10: General Issues in Using Variables\nKeep Variables “Live” for as Short a Time as Possible\nA concept that’s related to variable span is variable “live time,” the total number of \nstatements over which a variable is live. A variable’s life begins at the first statement in \nwhich it’s referenced; its life ends at the last statement in which it’s referenced. Unlike span, live time isn’t affected by ho w many times the variable is used between \nthe first and last times it’s referenced.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 809, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0810_d155f5b3", "text": "Unlike span, live time isn’t affected by ho w many times the variable is used between \nthe first and last times it’s referenced. If the variable is first referenced on line 1 and \nlast referenced on line 25, it has a live time of 25 statements. If those are the only two \nlines in which it’s used, it has an average span of 23 statements. If the variable were \nused on every line from line 1 through line 25, it would have an average span of 0 \nstatements, but it would still have a live time of 25 statements. Figure 10-1 illustrates \nboth span and live time. Figure 10-1 “Long live time” means that a variable is live over the course of many state-\nments. “Short live time” means it’s live for only a few statements. “Span” refers to how close \ntogether the references to a variable are. As with span, the goal with respect to live time is to keep the number low, to keep a \nvariable live for as short a time as possible.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 810, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0811_d5909225", "text": "As with span, the goal with respect to live time is to keep the number low, to keep a \nvariable live for as short a time as possible. And as with span, the basic advantage of \nmaintaining a low number is that it reduces the window of vulnerability. You reduce \nLong live \ntime\nShort \nspans\nLong live\ntime\nLo n g \nspans\nShort live \ntime\nShort spans\n10.4 Scope 247\nthe chance of incorrectly or inadvertently al tering a variable between the places in \nwhich you intend to alter it. A second advantage of keeping the live time short is that it gives you an accurate pic-\nture of your code. If a variable is assigned a value in line 10 and not used again until \nline 45, the very space between the two references implies that the variable is used \nbetween lines 10 and 45. If the variable is assigned a value in line 44 and used in line \n45, no other uses of the variable are implie d, and you can concentrate on a smaller sec-\ntion of code when you’re thinking about that variable.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 811, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0812_e6d04a0e", "text": "A short live time also reduces the chance of initialization errors. As you modify a pro-\ngram, straight-line code tends to turn into loops and you tend to forget initializations \nthat were made far away from the loop. By keeping the initialization code and the loop \ncode closer together, you reduce the chance that modifications will introduce initial-\nization errors. A short live time makes your code more read able. The fewer lines of code a reader has \nto keep in mind at once, the easier your code is to understand. Likewise, the shorter \nthe live time, the less code you have to keep on your screen when you want to see all \nthe references to a variable during editing and debugging. Finally, short live times are useful when splitting a large routine into smaller routines. If references to variables are kept close together, it’s easier to refactor related sections \nof code into routines of their own.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 812, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0813_3264d5fe", "text": "If references to variables are kept close together, it’s easier to refactor related sections \nof code into routines of their own. Measuring the Live Time of a Variable\nYou can formalize the concept of live time by counting the number of lines between \nthe first and last references to a variable (inc luding both the first and last lines). Here’s \nan example with live times that are too long:\nJava Example of Variables with Excessively Long Live Times\n1 // initialize all variables\n2 recordIndex = 0;\n3 total = 0;\n4 done = false;\n ... 26 while ( recordIndex < recordCount ) {\n27 ... Last reference to recordIndex . 28 recordIndex = recordIndex + 1;\n ... 64 while ( !done ) {\n ... Last reference to total. Last reference to done .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 813, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 730}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0814_34118030", "text": "26 while ( recordIndex < recordCount ) {\n27 ... Last reference to recordIndex . 28 recordIndex = recordIndex + 1;\n ... 64 while ( !done ) {\n ... Last reference to total. Last reference to done . 69 if ( total > projectedTotal ) {\n70 done = true;\n248\nChapter 10: General Issues in Using Variables\nHere are the live times for the variables in this example:\nThe example has been rewritten below so th at the variable references are closer \ntogether:\nJava Example of Variables with Good, Short Live Times\n ... Initialization of recordIndex \nis moved down from line 3. 25 recordIndex = 0;\n26 while ( recordIndex < recordCount ) {\n27 ... 28 recordIndex = recordIndex + 1;\n ... Initialization of total and \ndone are moved down from \nlines 4 and 5. 62 total = 0;\n63 done = false;\n64 while ( !done ) {\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 814, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 797}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0815_8711c931", "text": "28 recordIndex = recordIndex + 1;\n ... Initialization of total and \ndone are moved down from \nlines 4 and 5. 62 total = 0;\n63 done = false;\n64 while ( !done ) {\n ... 69 if ( total > projectedTotal ) {\n70 done = true;\nHere are the live times for the variables in this example:\nFurther Reading For more \ninformation on “live” vari-\nables, see Software Engi-\nneering Metrics and Models \n(Conte, Dunsmore, and Shen \n1986). Intuitively, the second example seems better than the first because the initializations \nfor the variables are performed closer to where the variables are used. The measured \ndifference in average live time between the two examples is significant: An average of \n54 vs. an average of 7 provides good quantitative support for the intuitive preference \nfor the second piece of code. Does a hard number separate a good live time from a bad one? A good span from a \nbad one?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 815, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 889}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0816_7a3fa1c1", "text": "an average of 7 provides good quantitative support for the intuitive preference \nfor the second piece of code. Does a hard number separate a good live time from a bad one? A good span from a \nbad one? Researchers haven’t yet produced that quantitative data, but it’s safe to \nassume that minimizing both span and live time is a good idea. If you try to apply the ideas of span and live time to global variables, you’ll find that \nglobal variables have enormous spans and live times—one of many good reasons to \navoid global variables.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 816, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 534}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0817_c9e62b30", "text": "If you try to apply the ideas of span and live time to global variables, you’ll find that \nglobal variables have enormous spans and live times—one of many good reasons to \navoid global variables. recordIndex ( line 28 - line 2 + 1 ) = 27\ntotal ( line 69 - line 3 + 1 ) = 67\ndone ( line 70 - line 4 + 1 ) = 67\nAverage Live Time ( 27 + 67 + 67 ) / 3 ≈54\nrecordIndex ( line 28 - line 25 + 1 ) = 4\ntotal ( line 69 - line 62 + 1 ) = 8\ndone ( line 70 - line 63 + 1 ) = 8\nAverage Live Time ( 4 + 8 + 8 ) / 3 ≈7\n10.4 Scope 249\nGeneral Guidelines for Minimizing Scope\nHere are some specific guidelines you can use to minimize scope: \nCross-Reference For details \non initializing variables close \nto where they’re used, see \nSection 10.3, “Guidelines for \nInitializing Variables,” earlier \nin this chapter.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 817, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 796}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0818_48319662", "text": "Initialize variables used in a loop immediately before the loop rather than back at the \nbeginning of the routine containing the loop Doing this improves the chance that \nwhen you modify the loop, you’ll remember to make corresponding modifications to \nthe loop initialization. Later, when you modify the program and put another loop \naround the initial loop, the initialization will work on each pass through the new loop \nrather than on only the first pass. Cross-Reference For more \non this style of variable dec-\nlaration and definition, see \n“Ideally, declare and define \neach variable close to where \nit’s first used” in Section 10.3. Don’t assign a value to a variable until just before the value is used You might have \nexperienced the frustration of trying to fi gure out where a variable was assigned its \nvalue. The more you can do to clarify where a variable receives its value, the better.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 818, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0819_db1e08b0", "text": "The more you can do to clarify where a variable receives its value, the better. Languages like C++ and Java support variable initializations like these:\nC+ + Example of Good Variable Declarations and Initializations\nint receiptIndex = 0; \nfloat dailyReceipts = TodaysReceipts();\ndouble totalReceipts = TotalReceipts( dailyReceipts ); \nCross-Reference For more \ndetails on keeping related \nstatements together, see Sec-\ntion 14.2, “Statements Whose \nOrder Doesn’t Matter.”\nGroup related statements The following examples show a routine for summarizing \ndaily receipts and illustrate how to put refere nces to variables together so that they’re \neasier to locate. The first example illu strates the violation of this principle:\nC+ + Example of Using Two Sets of Variables in a Confusing Way \nvoid SummarizeData(...) {\n ... Statements using two sets \nof variables.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 819, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 861}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0820_c4389ba6", "text": "The first example illu strates the violation of this principle:\nC+ + Example of Using Two Sets of Variables in a Confusing Way \nvoid SummarizeData(...) {\n ... Statements using two sets \nof variables. GetOldData( oldData, &numOldData );\n GetNewData( newData, &numNewData );\n totalOldData = Sum( oldData, numOldData );\n totalNewData = Sum( newData, numNewData );\n PrintOldDataSummary( oldData, totalOldData, numOldData );\n PrintNewDataSummary( newData, totalNewData, numNewData );\n SaveOldDataSummary( totalOldData, numOldData );\n SaveNewDataSummary( totalNewData, numNewData );\n ... }\nNote that, in this example, you have to keep track of oldData , newData , numOldData , \nnumNewData , totalOldData , and totalNewData all at once—six variables for just this \n250\nChapter 10: General Issues in Using Variables\nshort fragment.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 820, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 823}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0821_13a90a18", "text": "The next example shows how to reduce that number to only three ele-\nments within each block of code:\nC+ + Example of Using Two Sets of Variables More Understandably\nvoid SummarizeData( ... ) {\nStatements using oldData . GetOldData( oldData, &numOldData );\n totalOldData = Sum( oldData, numOldData );\n PrintOldDataSummary( oldData, totalOldData, numOldData );\n SaveOldDataSummary( totalOldData, numOldData );\n ... Statements using newData . GetNewData( newData, &numNewData );\n totalNewData = Sum( newData, numNewData );\n PrintNewDataSummary( newData, totalNewData, numNewData );\n SaveNewDataSummary( totalNewData, numNewData );\n ... }\nWhen the code is broken up, the two blocks are each shorter than the original block \nand individually contain fewer variables. The y’re easier to understand, and if you need \nto break this code out into separate routin es, the shorter blocks with fewer variables \nwill promote better-defined routines.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 821, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0822_63a8ac24", "text": "The y’re easier to understand, and if you need \nto break this code out into separate routin es, the shorter blocks with fewer variables \nwill promote better-defined routines. Break groups of related stat ements into separate routines All other things being \nequal, a variable in a shorter routine will tend to have smaller span and live time than \na variable in a longer routine. By breaking related statements into separate, smaller \nroutines, you reduce the scope that the variable can have. Cross-Reference For more \non global variables, see \nSection 13.3, “Global Data.”\nBegin with most restricted visibility, and expand the variable’s scope only if \nnecessary Part of minimizing the scope of a vari able is keeping it as local as possi-\nble.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 822, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 746}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0823_ab494e1e", "text": "It is much more difficult to reduce th e scope of a variable that has had a large \nscope than to expand the scope of a vari able that has had a small scope—in other \nwords, it’s harder to turn a global variable into a class variable than it is to turn a class \nvariable into a global variable. It’s harder to turn a protected data member into a pri-\nvate data member than vice versa. For that reason, when in doubt, favor the smallest \npossible scope for a variable: local to a specific loop, local to an individual routine, \nthen private to a class, then protected, then package (if your programming language \nsupports that), and global only as a last resort.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 823, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 660}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0824_4baadfe7", "text": "Comments on Minimizing Scope\nMany programmers’ approach to minimizing variables’ scope depends on their views \nof the issues of “convenience” and “intel lectual manageability.” Some programmers \nmake many of their variables global becaus e global scope makes variables convenient \nto access and the programmers don’t have to fool around with parameter lists and \nclass-scoping rules. In their minds, the conv enience of being able to access variables at \nany time outweighs the risks involved. 10.5 Persistence 251\nCross-Reference The idea of \nminimizing scope is related \nto the idea of information \nhiding. For details, see “Hide \nSecrets (Information Hid-\ning)” in Section 5.3. Other programmers prefer to keep their va riables as local as possible because local \nscope helps intellectual manageability. Th e more information you can hide, the less \nyou have to keep in mind at any one time.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 824, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 894}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0825_26c177c3", "text": "Th e more information you can hide, the less \nyou have to keep in mind at any one time. The less you have to keep in mind, the \nsmaller the chance that you’ll make an error because you forgot one of the many \ndetails you needed to remember. The difference between the “convenience” ph ilosophy and the “intellectual manage-\nability” philosophy boils down to a difference in emphasis between writing programs \nand reading them. Maximizing scope might in deed make programs easy to write, but \na program in which any routine can use any variable at any time is harder to under-\nstand than a program that uses well-factored routines. In such a program, you can’t \nunderstand only one routine; you have to understand all the other routines with \nwhich that routine shares global data. Such programs are hard to read, hard to debug, \nand hard to modify. Cross-Reference For details \non using access routines, see \n“Using Access Routines \nInstead of Global Data” in \nSection 13.3.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 825, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0826_5d70a939", "text": "Such programs are hard to read, hard to debug, \nand hard to modify. Cross-Reference For details \non using access routines, see \n“Using Access Routines \nInstead of Global Data” in \nSection 13.3. Consequently, you should declare each variable to be visible to the smallest segment \nof code that needs to see it. If you can confine the variable’s scope to a single loop or \nto a single routine, great. If you can’t confine the scope to one routine, restrict the vis-\nibility to the routines in a single class. If you can’t restrict the variable’s scope to the \nclass that’s most responsible for the variable, create access routines to share the vari-\nable’s data with other classes. You’ll find th at you rarely, if ever, need to use naked glo-\nbal data. 10.5 Persistence\n“Persistence” is another word for the life span of a piece of data. Persistence takes sev-\neral forms. Some variables persist\n■\nfor the life of a particular block of code or routine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 826, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0827_afd1874f", "text": "10.5 Persistence\n“Persistence” is another word for the life span of a piece of data. Persistence takes sev-\neral forms. Some variables persist\n■\nfor the life of a particular block of code or routine. Variables declared inside a for \nloop in C++ or Java are examples of this kind of persistence. ■\nas long as you allow them to. In Java, variables created with new persist until \nthey are garbage collected. In C++, variables created with new persist until you \ndelete them. ■\nfor the life of a program. Global variables in most languages fit this description, \nas do static variables in C++ and Java. ■\nforever. These variables might include values that you store in a database \nbetween executions of a program. For example, if you have an interactive pro-\ngram in which users can customize the color of the screen, you can store their \ncolors in a file and then read them back each time the program is loaded.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 827, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0828_cfe42003", "text": "For example, if you have an interactive pro-\ngram in which users can customize the color of the screen, you can store their \ncolors in a file and then read them back each time the program is loaded. The main problem with persistence arises when you assume that a variable has a \nlonger persistence than it really does. The variab le is like that jug of milk in your refrig-\nerator. It’s supposed to last a week. Sometimes it lasts a month, and sometimes it \nKEY POINT\n252\nChapter 10: General Issues in Using Variables\nturns sour after five days. A variable can be just as unpredictable. If you try to use the \nvalue of a variable after its normal life span is over, will it have retained its value? Sometimes the value in the variable is sour, and you know that you’ve got an error. Other times, the computer leaves the old value in the variable, letting you imagine that \nyou have used it correctly.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 828, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 900}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0829_07fc94fd", "text": "Sometimes the value in the variable is sour, and you know that you’ve got an error. Other times, the computer leaves the old value in the variable, letting you imagine that \nyou have used it correctly. Here are a few steps you can take to avoid this kind of problem:\nCross-Reference Debug \ncode is easy to include in \naccess routines and is dis-\ncussed more in “Advantages \nof Access Routines” in \nSection 13.3.■\nUse debug code or assertions in your program to check critical variables for rea-\nsonable values. If the values aren’t reason able, display a warning that tells you to \nlook for improper initialization. ■\nSet variables to “unreasonable values” when you’re through with them. For \nexample, you could set a pointer to null after you delete it. ■\nWrite code that assumes data isn’t persiste nt. For example, if a variable has a cer-\ntain value when you exit a routine, don’t assume it has the same value the next \ntime you enter the routine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 829, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0830_4c96e303", "text": "■\nWrite code that assumes data isn’t persiste nt. For example, if a variable has a cer-\ntain value when you exit a routine, don’t assume it has the same value the next \ntime you enter the routine. This doesn’t apply if you’re using language-specific \nfeatures that guarantee the value will remain the same, such as static in C++ and \nJava. ■\nDevelop the habit of declaring and initializing all data right before it’s used. If \nyou see data that’s used without a ne arby initialization, be suspicious! 10.6 Binding Time\nAn initialization topic with far-reaching implications for program maintenance and \nmodifiability is “binding time”: the time at which the variable and its value are bound \ntogether (Thimbleby 1988). Are they bound together when the code is written? When \nit is compiled? When it is loaded? When the program is run? Some other time? It can be to your advantage to use the latest binding time possible.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 830, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 920}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0831_26891808", "text": "Are they bound together when the code is written? When \nit is compiled? When it is loaded? When the program is run? Some other time? It can be to your advantage to use the latest binding time possible. In general, the later \nyou make the binding time, the more flexibility you build into your code. The next \nexample shows binding at the earliest po ssible time, when the code is written:\nJava Example of a Variable That’s Bound at Code-Writing Time \ntitleBar.color = 0xFF; // 0xFF is hex value for color blue\nThe value 0xFF is bound to the variable titleBar.color at the time the code is written \nbecause 0xFF is a literal value hard-coded into the program. Hard-coding like this is \nnearly always a bad idea because if this 0xFF changes, it can get out of synch with 0xFF s \nused elsewhere in the code that must be the same value as this one.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 831, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 844}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0832_2b184859", "text": "Hard-coding like this is \nnearly always a bad idea because if this 0xFF changes, it can get out of synch with 0xFF s \nused elsewhere in the code that must be the same value as this one. Here’s an example of binding at a slightly later time, when the code is compiled:\n10.6 Binding Time 253\nJava Example of a Variable That’s Bound at Compile Time \nprivate static final int COLOR_BLUE = 0xFF; \nprivate static final int TITLE_BAR_COLOR = COLOR_BLUE; \n... titleBar.color = TITLE_BAR_COLOR;\nTITLE_BAR_COLOR is a named constant, an expression for which the compiler sub-\nstitutes a value at compile time. This is near ly always better than hard-coding, if your \nlanguage supports it. It increases readability because TITLE_BAR_COLOR tells you \nmore about what is being represented than 0xFF does. It makes changing the title bar \ncolor easier because one change accounts for all occurrences. And it doesn’t incur a \nrun-time performance penalty.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 832, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0833_bdbf9b14", "text": "It makes changing the title bar \ncolor easier because one change accounts for all occurrences. And it doesn’t incur a \nrun-time performance penalty. Here’s an example of binding later, at run time: \nJava Example of a Variable That’s Bound at Run Time\ntitleBar.color = ReadTitleBarColor();\nReadTitleBarColor() is a routine that reads a value while a program is executing, per-\nhaps from the Microsoft Windows registry file or a Java properties file. The code is more readable and flexible than it would be if a value were hard-coded. You \ndon’t need to change the program to change titleBar.color ; you simply change the con-\ntents of the source that’s read by ReadTitleBarColor( ). This approach is commonly used \nfor interactive applications in which a user can customize the application environment. There is still another variation in bindin g time, which has to do with when the Read-\nTitleBarColor() routine is called.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 833, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0834_0099ea5e", "text": "There is still another variation in bindin g time, which has to do with when the Read-\nTitleBarColor() routine is called. That routine could be called once at program load \ntime, each time the window is created, or each time the window is drawn—each alter-\nnative represents successi vely later binding times. To summarize, following are the times a variable can be bound to a value in this exam-\nple. (The details could vary somewhat in other cases.)\n■\nCoding time (use of magic numbers)\n■\nCompile time (use of a named constant)\n■\nLoad time (reading a value from an external source such as the Windows regis-\ntry file or a Java properties file)\n■\nObject instantiation time (such as readin g the value each time a window is cre-\nated)\n■\nJust in time (such as reading the value each time the window is drawn)\n254\nChapter 10: General Issues in Using Variables\nIn general, the earlier the binding time, the lower the flexibility and the lower the com-\nplexity.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 834, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 957}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0835_a06b5c89", "text": "For the first two options, using named constants is preferable to using magic \nnumbers for many reasons, so you can get the flexibility that named constants provide \njust by using good programming practices. Beyond that, the greater the flexibility \ndesired, the higher the complexity of the co de needed to support that flexibility and \nthe more error-prone the code will be. Because successful programming depends on \nminimizing complexity, a skilled programmer will build in as much flexibility as \nneeded to meet the software’s requiremen ts but will not add flexibility—and related \ncomplexity—beyond what’s required. 10.7 Relationship Between Data Types and Control \nStructures\nData types and control structures relate to each other in well-defined ways that were \noriginally described by th e British computer scientis t Michael Jackson (Jackson \n1975). This section sketches the regular re lationship between data and control flow.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 835, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0836_72aad76e", "text": "This section sketches the regular re lationship between data and control flow. Jackson draws connections between three types of data and corresponding control \nstructures:\nCross-Reference For details \non sequences, see Chapter \n14, “Organizing Straight-\nLine Code.”\nSequential data translates to sequential statements in a program Sequences con-\nsist of clusters of data used together in a certain order, as suggested by Figure 10-2. If \nyou have five statements in a row that handle five different values, they are sequential \nstatements. If you read an employee’s name, Social Security Number, address, phone \nnumber, and age from a file, you’d have sequential statements in your program to read \nsequential data from the file. Figure 10-2 Sequential data is data that’s handled in a defined order.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 836, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 800}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0837_2152de09", "text": "Figure 10-2 Sequential data is data that’s handled in a defined order. Cross-Reference For details \non conditionals, see Chapter \n15, “Using Conditionals.”\nSelective data translates to if and case statements in a program In general, selective \ndata is a collection in which one of several pieces of data is used at an y particular time, but \nonly one, as shown in Figure 10-3. The corresponding program statements must do the \nactual selection, and they consist of if-then-else or case statements. If you had an employee \npayroll program, you might process employee s differently depending on whether they \nwere paid hourly or salaried. Again, patter ns in the code match patterns in the data. 10.8 Using Each Variable for Exactly One Purpose 255\nFigure 10-3 Selective data allows you to use on e piece or the other, but not both.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 837, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 830}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0838_aad39eba", "text": "Again, patter ns in the code match patterns in the data. 10.8 Using Each Variable for Exactly One Purpose 255\nFigure 10-3 Selective data allows you to use on e piece or the other, but not both. Cross-Reference For details \non loops, see Chapter 16, \n“Controlling Loops.”\nIterative data translates to for, repeat , and while looping structures in a program \nIterative data is the same type of data repeated several times, as suggested by Fig-\nure 10-4. Typically, iterative data is stored as elements in a container, records in a \nfile, or elements in an array. You might have a list of Social Security Numbers that \nyou read from a file. The iterative data would match the iterative code loop used to \nread the data. Figure 10-4 Iterative data is repeated. Your real data can be combinations of the sequential, selective, and iterative types of \ndata. You can combine the simple building b locks to describe more complicated data \ntypes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 838, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 937}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0839_bc8f6099", "text": "Your real data can be combinations of the sequential, selective, and iterative types of \ndata. You can combine the simple building b locks to describe more complicated data \ntypes. 10.8 Using Each Variable for Exactly One Purpose\nIt’s possible to use variables for more than one purpose in several subtle ways. You’re \nbetter off without this kind of subtlety. Use each variable for one purpose only It’s sometimes tempting to use one variable \nin two different places for two different activities. Usually, the variable is named inap-\npropriately for one of its uses or a “temporary” variable is used in both cases (with the \nKEY POINT\n256\nChapter 10: General Issues in Using Variables\nusual unhelpful name x or temp ). Here’s an example that shows a temporary variable \nthat’s used for two purposes:\nC+ + Example of Using One Variable for Two Purposes—Bad Practice\n// Compute roots of a quadratic equation. // This code assumes that (b*b-4*a*c) is positive.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 839, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0840_7e64cb4c", "text": "// This code assumes that (b*b-4*a*c) is positive. temp = Sqrt( b*b - 4*a*c );\nroot[O] = ( -b + temp ) / ( 2 * a );\nroot[1] = ( -b - temp ) / ( 2 * a );\n... // swap the roots\ntemp = root[0];\nroot[0] = root[1];\nroot[1] = temp;\nCross-Reference Routine \nparameters should also be \nused for one purpose only. For details on using routine \nparameters, see Section 7.5, \n“How to Use Routine \nParameters.”\nQuestion: What is the relationship between temp in the first few lines and temp in the \nlast few? Answer: The two temp s have no relationship. Using the same variable in both \ninstances makes it seem as though they’re related when they’re not. Creating unique \nvariables for each purpose makes your code more readable. Here’s an improvement:\nC+ + Example of Using Two Variables for Two Purposes—Good Practice\n// Compute roots of a quadratic equation. // This code assumes that (b*b-4*a*c) is positive.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 840, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 900}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0841_b7fe66fd", "text": "Here’s an improvement:\nC+ + Example of Using Two Variables for Two Purposes—Good Practice\n// Compute roots of a quadratic equation. // This code assumes that (b*b-4*a*c) is positive. discriminant = Sqrt( b*b - 4*a*c );\nroot[0] = ( -b + discriminant ) / ( 2 * a );\nroot[1] = ( -b - discriminant ) / ( 2 * a );\n... // swap the roots\noldRoot = root[0];\nroot[0] = root[1];\nroot[1] = oldRoot;\nAvoid variables with hidden meanings Another way in which a variable can be used \nfor more than one purpose is to have different values for the variable mean different \nthings. For example:\n■\nThe value in the variable pageCount might represent the number of pages \nprinted, unless it equals -1, in which case it indicates that an error has occurred. ■\nThe variable customerId might represent a customer number, unless its value is \ngreater than 500,000 , in which case you subtract 500,000 to get the number of a \ndelinquent account.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 841, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0842_87972d10", "text": "■\nThe variable customerId might represent a customer number, unless its value is \ngreater than 500,000 , in which case you subtract 500,000 to get the number of a \ndelinquent account. ■\nThe variable bytesWritten might be the number of bytes written to an output file, \nunless its value is negative, in which ca se it indicates the number of the disk \ndrive used for the output. CODING \nHORROR\nCODING \nHORROR\n10.8 Using Each Variable for Exactly One Purpose 257\nAvoid variables with these kinds of hidde n meanings. The technical name for this \nkind of abuse is “hybrid coupling” (Page-Jo nes 1988). The variable is stretched over \ntwo jobs, meaning that the variable is th e wrong type for one of the jobs. In the page-\nCount example, pageCount normally indicates the number of pages; it’s an integer. When pageCount is -1, however, it indicates that an error has occurred; the integer is \nmoonlighting as a boolean! Even if the double use is clear to you, it won’t be to someone else.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 842, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0843_b9fab4e3", "text": "When pageCount is -1, however, it indicates that an error has occurred; the integer is \nmoonlighting as a boolean! Even if the double use is clear to you, it won’t be to someone else. The extra clarity \nyou’ll achieve by using two variables to hold two kinds of information will amaze you. And no one will begrudge you the extra storage. Make sure that all declared variables are used The opposite of using a variable for \nmore than one purpose is not using it at all. A study by Card, Church, and Agresti \nfound that unreferenced variables were corr elated with higher fault rates (1986). Get \nin the habit of checking to be sure that all variables that are declared are used. Some \ncompilers and utilities (such as lint) report unused variables as a warning. cc2e.com/1092\nCHECKLIST: General Considerations In Using Data \nCross-Reference For a \nchecklist that applies to \nspecific types of data rather \nthan general issues, see the \nchecklist in Chapter 12, \n“Fundamental Data Types,” \non page 316.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 843, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1000}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0844_5b9cd9f9", "text": "For issues in \nnaming variables, see the \nchecklist in Chapter 11, “The \nPower of Variable Names,” \non page 288. Initializing Variables\n❑\nDoes each routine check input parameters for validity? ❑\nDoes the code declare variables close to where they’re first used? ❑\nDoes the code initialize variable s as they’re declared, if possible? ❑\nDoes the code initialize variables close to where they’re first used, if it isn’t \npossible to declare and initiali ze them at the same time? ❑\nAre counters and accumulators initialize d properly and, if necessary, rein-\nitialized each time they are used? ❑\nAre variables reinitialized properly in code that’s executed repeatedly? ❑\nDoes the code compile with no warn ings from the compiler? (And have \nyou turned on all the available warnings?)\n❑\nIf your language uses implicit declarations, have you compensated for the \nproblems they cause? Other General Issues in Using Data\n❑\nDo all variables have th e smallest scope possible?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 844, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0845_22872d38", "text": "Other General Issues in Using Data\n❑\nDo all variables have th e smallest scope possible? ❑\nAre references to variables as close together as possible, both from each \nreference to a variable to the next reference and in total live time? ❑\nDo control structures correspond to the data types? 1\n23\nHARD DATA\n258\nChapter 10: General Issues in Using Variables\n❑\nAre all the declared variables being used? ❑\nAre all variables bound at appropriate times—that is, are you striking a con-\nscious balance between the flexibilit y of late binding and the increased \ncomplexity associated with late binding? ❑\nDoes each variable have one and only one purpose? ❑\nIs each variable’s meaning expl icit, with no hidden meanings? Key Points\n■\nData initialization is prone to errors, so use the initialization techniques described \nin this chapter to avoid the problems caused by unexpected initial values. ■\nMinimize the scope of each variable. Keep references to a variable close together. Keep it local to a routine or class.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 845, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1010}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0846_5afe3c3f", "text": "■\nMinimize the scope of each variable. Keep references to a variable close together. Keep it local to a routine or class. Avoid global data. ■\nKeep statements that work with the same variables as close together as possible. ■\nEarly binding tends to limit flexibility but minimize complexity. Late binding \ntends to increase flexibility but at the price of increased complexity. ■\nUse each variable for one and only one purpose.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 846, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 427}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0847_4bb2e95b", "text": "Late binding \ntends to increase flexibility but at the price of increased complexity. ■\nUse each variable for one and only one purpose. 259\nChapter 11\nThe Power of Variable Names\ncc2e.com/1184\nContents\n■\n11.1 Considerations in Choo sing Good Names: page 259\n■\n11.2 Naming Specific Types of Data: page 264\n■\n11.3 The Power of Naming Conventions: page 270\n■\n11.4 Informal Naming Conventions: page 272\n■\n11.5 Standardized Prefixes: page 279\n■\n11.6 Creating Short Names That Are Readable: page 282\n■\n11.7 Kinds of Names to Avoid: page 285\nRelated Topics\n■\nRoutine names: Section 7.3\n■\nClass names: Section 6.2\n■\nGeneral issues in usin g variables: Chapter 10\n■\nFormatting data declarations: “Laying Out Data Declarations” in Section 31.5\n■\nDocumenting variables: “Commenting Data Declarations” in Section 32.5\nAs important as the topic of good names is to effective programming, I have never read \na discussion that covered more than a handfu l of the dozens of considerations that go \ninto creating good names.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 847, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1007}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0848_74337031", "text": "Many programming texts devote a few paragraphs to \nchoosing abbreviations, spout a few platitud es, and expect you to fend for yourself. I \nintend to be guilty of the opposite: to in undate you with more information about good \nnames than you will ever be able to use! This chapter’s guidelines apply primarily to naming variables—objects and primitive \ndata. But they also apply to naming classe s, packages, files, and other programming \nentities. For details on naming routines, see Section 7.3, “Good Routine Names.”\n11.1 Considerations in Choosing Good Names\nYou can’t give a variable a name the way you give a dog a name—because it’s cute or it has \na good sound. Unlike the dog and its name, which are different entities, a variable and a \nvariable’s name are essentially the same th ing. Consequently, the goodness or badness \nof a variable is largely determined by it s name. Choose variable names with care.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 848, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0849_df85ecb4", "text": "Consequently, the goodness or badness \nof a variable is largely determined by it s name. Choose variable names with care. 260\nChapter 11: The Power of Variable Names\nHere’s an example of code that uses bad variable names:\nJava Example of Poor Variable Names\nx = x - xx;\nxxx = fido + SalesTax( fido );\nx = x + LateFee( x1, x ) + xxx;\nx = x + Interest( x1, x );\nWhat’s happening in this piece of code? What do x1, xx, and xxx mean? What does \nfido mean? Suppose someone told you that the code computed a total customer bill \nbased on an outstanding balance and a ne w set of purchases. Which variable would \nyou use to print the customer’s bill for just the new set of purchases?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 849, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 677}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0850_a315bf89", "text": "Which variable would \nyou use to print the customer’s bill for just the new set of purchases? Here’s a version of the same code that makes these questions easier to answer:\nJava Example of Good Variable Names\nbalance = balance - lastPayment;\nmonthlyTotal = newPurchases + SalesTax( newPurchases );\nbalance = balance + LateFee( customerID, balance ) + monthlyTotal;\nbalance = balance + Interest( customerID, balance );\nIn view of the contrast between these two pieces of code, a good variable name is read-\nable, memorable, and appropriate. You can use several general rules of thumb to \nachieve these goals. The Most Important Naming Consideration\nThe most important consideration in naming a variable is that the name fully and \naccurately describe the entity the variable represents. An effective technique for com-\ning up with a good name is to state in words what the variable represents. Often that \nstatement itself is the best variable name.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 850, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0851_d78db322", "text": "An effective technique for com-\ning up with a good name is to state in words what the variable represents. Often that \nstatement itself is the best variable name. It ’s easy to read because it doesn’t contain \ncryptic abbreviations, and it’s unambiguous . Because it’s a full description of the \nentity, it won’t be confused with something else. And it’s easy to remember because \nthe name is similar to the concept. For a variable that represents the number of people on the U.S. Olympic team, you \nwould create the name numberOfPeopleOnTheUsOlympicTeam . A variable that repre-\nsents the number of seats in a stadium would be numberOfSeatsInTheStadium . A vari-\nable that represents the maximum number of points scored by a country’s team in any \nmodern Olympics would be maximumNumberOfPointsInModernOlympics . A variable \nthat contains the current interest rate is better named rate or interestRate than r or x. You get the idea.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 851, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0852_3df9e5bb", "text": "A variable \nthat contains the current interest rate is better named rate or interestRate than r or x. You get the idea. CODING \nHORROR\nKEY POINT\n11.1 Considerations in Choosing Good Names 261\nNote two characteristics of these names. First, they’re easy to decipher. In fact, they \ndon’t need to be deciphered at all because you can simply read them. But second, \nsome of the names are long—too long to be pr actical. I’ll get to the question of variable-\nname length shortly. Table 11-1 shows several examples of variable names, good and bad:\nThe names currentDate and todaysDate are good names because they fully and accu-\nrately describe the idea of “current date.” In fact, they use the obvious words. Program-\nmers sometimes overlook using the ordinary words, which is often the easiest solution. Because they’re too short and not at all descriptive, cd and c are poor names. current is \npoor because it doesn’t tell you what is current.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 852, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 941}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0853_efaaa4db", "text": "Because they’re too short and not at all descriptive, cd and c are poor names. current is \npoor because it doesn’t tell you what is current. date is almost a good name, but it’s a \npoor name in the final analysis because the da te involved isn’t just any date, but the cur-\nrent date; date by itself gives no such indication. x, x1, and x2 are poor names because \nthey’re always poor names— x traditionally represents an unknown quantity; if you don’t \nwant your variables to be unknown quantities, think of better names. Names should be as specific as possible. Names like x, temp , and i that are general \nenough to be used for more than one purpose are not as informative as they could be \nand are usually bad names. Problem Orientation\nA good mnemonic name generally speaks to the problem rather than the solution. A \ngood name tends to express the what more than the how. In general, if a name refers \nto some aspect of computing rather than to the problem, it’s a how rather than a what .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 853, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0854_73e247ae", "text": "A \ngood name tends to express the what more than the how. In general, if a name refers \nto some aspect of computing rather than to the problem, it’s a how rather than a what . Avoid such a name in favor of a name that refers to the problem itself. A record of employee data could be called inputRec or employeeData . inputRec is a com-\nputer term that refers to computing ideas—input and record. employeeData refers to \nthe problem domain rather than the computin g universe. Similarly, for a bit field indi-\ncating printer status, bitFlag is a more computerish name than printerReady . In an \naccounting application, calcVal is more computerish than sum.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 854, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 655}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0855_8db4c7fc", "text": "Similarly, for a bit field indi-\ncating printer status, bitFlag is a more computerish name than printerReady . In an \naccounting application, calcVal is more computerish than sum. Table 11-1\nExamples of Good and Bad Variable Names\nPurpose of Variable\nGood Names, \nGood Descriptors\nBad Names, \nPoor Descriptors\nRunning total of \nchecks written to daterunningTotal , checkTotal written , ct, checks , CHKTTL , x, \nx1, x2\nVelocity of a bullet \ntrainvelocity , trainVelocity , \nvelocityInMphvelt, v, tv, x, x1, x2, train\nCurrent date currentDate , todaysDate cd , current , c, x, x1, x2, date\nLines per page linesPerPage lpp, lines, l, x, x1, x2\nKEY POINT\n262\nChapter 11: The Power of Variable Names\nOptimum Name Length\nThe optimum length for a name seems to be somewhere between the lengths of x and \nmaximumNumberOfPoint sInModernOlympics . Names that are too short don’t convey \nenough meaning.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 855, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 893}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0856_bc3ec0cc", "text": "Names that are too short don’t convey \nenough meaning. The problem with names like x1 and x2 is that even if you can discover \nwhat x is, you won’t know anything about the relationship between x1 and x2. Names \nthat are too long are hard to type and can obscure the visual structure of a program. Gorla, Benander, and Benander found that the effort required to debug a program was \nminimized when variables had names that averaged 10 to 16 characters (1990). Pro-\ngrams with names averaging 8 to 20 characters were almost as easy to debug. The \nguideline doesn’t mean that you should try to make all of your variable names 9 to 15 \nor 10 to 16 characters long. It does mean that if you look over your code and see many \nnames that are shorter, you should check to be sure that the names are as clear as they \nneed to be. You’ll probably come out ahead by taking the Goldilocks-and-the-Three-Bears \napproach to naming variables, as Tabl e 11-2 illustrates.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 856, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 955}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0857_ef523a54", "text": "You’ll probably come out ahead by taking the Goldilocks-and-the-Three-Bears \napproach to naming variables, as Tabl e 11-2 illustrates. The Effect of Scope on Variable Names\nCross-Reference Scope is \ndiscussed in more detail in \nSection 10.4, “Scope.”\nAre short variable names always bad? No, no t always. When you give a variable a short \nname like i, the length itself says something about the variable—namely, that the vari-\nable is a scratch value with a limited scope of operation. A programmer reading such a variable should be able to assume that its value isn’t \nused outside a few lines of code. When you name a variable i, you’re saying, “This vari-\nable is a run-of-the-mill loop counter or array index and doesn’t have any significance \noutside these few lines of code.”\nA study by W. J.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 857, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 798}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0858_61b99b3f", "text": "When you name a variable i, you’re saying, “This vari-\nable is a run-of-the-mill loop counter or array index and doesn’t have any significance \noutside these few lines of code.”\nA study by W. J. Hansen found that longer names are better for rarely used variables or \nglobal variables and shorter names are better for local variables or loop variables \nTable 11-2\nVariable Names That Are Too Long, Too Short, or Just Right\nToo long: numberOfPeopleOnTheUsOlympicTeam\nnumberOfSeatsInTheStadium\nmaximumNumberOfPointsInModernOlympics\nToo short: n, np, ntm\nn, ns, nsisd\nm, mp, max, points\nJust right: numTeamMembers , teamMemberCount\nnumSeatsInStadium , seatCount\nteamPointsMax , pointsRecord\n1\n23\nHARD DATA\n11.1 Considerations in Choosing Good Names 263\n(Shneiderman 1980). Short names are subject to many problems, however, and some \ncareful programmers avoid them altogether as a matter of defensive-programming policy.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 858, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0859_581a375b", "text": "Short names are subject to many problems, however, and some \ncareful programmers avoid them altogether as a matter of defensive-programming policy. Use qualifiers on names that are in the global namespace If you have variables that \nare in the global namespace (named consta nts, class names, an d so on), consider \nwhether you need to adopt a convention fo r partitioning the global namespace and \navoiding naming conflicts. In C++ and C#, you can use the namespace keyword to par-\ntition the global namespace. C+ + Example of Using the namespace Keyword to Partition the Global Namespace\nnamespace UserInterfaceSubsystem {\n ... // lots of declarations\n ... }\nnamespace DatabaseSubsystem { \n ... // lots of declarations\n ... }\nIf you declare an Employee class in both the UserInterfaceSubsystem and the Database-\nSubsystem , you can identify which you wanted to refer to by writing UserInterfaceSub-\nsystem::Employee or DatabaseSubsystem::Employee .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 859, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0860_cbb27d21", "text": "In Java, you can accomplish the \nsame thing by using packages. In languages that don’t support namespaces or packages, you can still use naming \nconventions to partition the global namespace. One convention is to require that glo-\nbally visible classes be prefixed with subsystem mnemonic. The user interface \nemployee class might become uiEmployee , and the database employee class might \nbecome dbEmployee . This minimizes the risk of global-namespace collisions. Computed-Value Qualifiers in Variable Names\nMany programs have variables that contai n computed values: totals, averages, maxi-\nmums, and so on. If you modify a name with a qualifier like Total , Sum, Average , Max, \nMin, Record , String , or Pointer , put the modifier at the end of the name. This practice offers several advantages. First, the most significant part of the variable \nname, the part that gives the variable most of its meaning, is at the front, so it’s most \nprominent and gets read first.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 860, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0861_b6b53710", "text": "First, the most significant part of the variable \nname, the part that gives the variable most of its meaning, is at the front, so it’s most \nprominent and gets read first. Second, by establishing this convention, you avoid the \nconfusion you might create if you were to use both totalRevenue and revenueTotal in the \nsame program. The names are semantically equivalent, and the convention would pre-\nvent their being used as if they were different. Third, a set of names like revenueTotal , \nexpenseTotal , revenueAverage , and expenseAverage has a pleasing symmetry. A set of names \n264\nChapter 11: The Power of Variable Names\nlike totalRevenue , expenseTotal , revenueAverage , and averageExpense doesn’t appeal to a \nsense of order. Finally, the consistency im proves readability and eases maintenance. An exception to the rule that computed values go at the end of the name is the cus-\ntomary position of the Num qualifier.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 861, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0862_1e1cba2f", "text": "Finally, the consistency im proves readability and eases maintenance. An exception to the rule that computed values go at the end of the name is the cus-\ntomary position of the Num qualifier. Placed at the beginning of a variable name, Num \nrefers to a total: numCustomers is the total number of customers. Placed at the end of \nthe variable name, Num refers to an index: customerNum is the number of the current \ncustomer. The s at the end of numCustomers is another tip-off about the difference in \nmeaning. But, because using Num so often creates confusion, it’s probably best to side-\nstep the whole issue by using Count or Total to refer to a total number of customers \nand Index to refer to a specific customer. Thus, customerCount is the total number of \ncustomers and customerIndex refers to a specific customer. Common Opposites in Variable Names\nCross-Reference For a simi-\nlar list of opposites in routine \nnames, see “Use opposites \nprecisely” in Section 7.3. Use opposites precisely.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 862, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0863_86795799", "text": "Common Opposites in Variable Names\nCross-Reference For a simi-\nlar list of opposites in routine \nnames, see “Use opposites \nprecisely” in Section 7.3. Use opposites precisely. Using naming conv entions for opposites helps consistency, \nwhich helps readability. Pairs like begin/end are easy to understand and remember. Pairs that depart from common-language opposites tend to be hard to remember and \nare therefore confusing. Here are some common opposites:\n■\nbegin/end\n■\nfirst/last\n■\nlocked/unlocked\n■\nmin/max\n■\nnext/previous\n■\nold/new\n■\nopened/closed\n■\nvisible/invisible\n■\nsource/target\n■\nsource/destination \n■\nup/down\n11.2 Naming Specific Types of Data\nIn addition to the general considerations in naming data, special considerations come \nup in the naming of specific kinds of data . This section describes considerations spe-\ncifically for loop variables, status variable s, temporary variables, boolean variables, \nenumerated types, and named constants.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 863, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0864_e0130099", "text": "This section describes considerations spe-\ncifically for loop variables, status variable s, temporary variables, boolean variables, \nenumerated types, and named constants. 11.2 Naming Specific Types of Data 265\nNaming Loop Indexes\nCross-Reference For details \non loops, see Chapter 16, \n“Controlling Loops.”\nGuidelines for naming variables in loops have arisen because loops are such a com-\nmon feature of computer programming. The names i, j, and k are customary:\nJava Example of a Simple Loop Variable Name\nfor ( i = firstItem; i < lastItem; i++ ) {\n data[ i ] = 0;\n}\nIf a variable is to be used outside the loop , it should be given a name more meaningful \nthan i, j, or k.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 864, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 676}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0865_4513525b", "text": "For example, if you are reading records from a file and need to remember \nhow many records you’ve read, a name like recordCount would be appropriate:\nJava Example of a Good Descriptive Loop Variable Name\nrecordCount = 0;\nwhile ( moreScores() ) {\n score[ recordCount ] = GetNextScore();\n recordCount++;\n}\n// lines using recordCount\n... If the loop is longer than a few lines, it’s easy to forget what i is supposed to stand for \nand you’re better off giving the loop index a more meaningful name. Because code is \nso often changed, expanded, and copied into other programs, many experienced pro-\ngrammers avoid names like i altogether. One common reason loops grow longer is that they’re nested. If you have several \nnested loops, assign longer names to th e loop variables to improve readability.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 865, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 796}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0866_ee6a341e", "text": "One common reason loops grow longer is that they’re nested. If you have several \nnested loops, assign longer names to th e loop variables to improve readability. Java Example of Good Loop Names in a Nested Loop\nfor ( teamIndex = 0; teamIndex < teamCount; teamIndex++ ) {\n for ( eventIndex = 0; eventIndex < eventCount[ teamIndex ]; eventIndex++ ) {\n score[ teamIndex ][ eventIndex ] = 0;\n }\n}\nCarefully chosen names for loop-index va riables avoid the common problem of index \ncross-talk: saying i when you mean j and j when you mean i. They also make array \naccesses clearer: score[ teamIndex ][ eventIndex ] is more informative than score[ i ][ j ] . If you have to use i, j, and k, don’t use them for anything other than loop indexes for \nsimple loops—the convention is too well esta blished, and breaking it to use them in \nother ways is confusing. The simplest way to avoid such problems is simply to think \nof more descriptive names than i, j, and k.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 866, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0867_c83438b9", "text": "The simplest way to avoid such problems is simply to think \nof more descriptive names than i, j, and k. 266\nChapter 11: The Power of Variable Names\nNaming Status Variables\nStatus variables describe the state of your program. Here’s a naming guideline:\nThink of a better name than flag for status variables It’s better to think of flags as \nstatus variables. A flag should never have flag in its name because that doesn’t give you \nany clue about what the flag does. For clarity, flags should be assigned values and \ntheir values should be tested with enumerated types, named constants, or global vari-\nables that act as named constants. Here are some examples of flags with bad names:\nC+ + Examples of Cryptic Flags\nif ( flag ) ... if ( statusFlag & 0x0F ) ... if ( printFlag == 16 ) ... if ( computeFlag == 0 ) ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 867, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 815}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0868_2937b581", "text": "Here are some examples of flags with bad names:\nC+ + Examples of Cryptic Flags\nif ( flag ) ... if ( statusFlag & 0x0F ) ... if ( printFlag == 16 ) ... if ( computeFlag == 0 ) ... flag = 0x1;\nstatusFlag = 0x80;\nprintFlag = 16;\ncomputeFlag = 0;\nStatements like statusFlag = 0x80 give you no clue about what the code does unless \nyou wrote the code or have documentation that tells you both what statusFlag is and \nwhat 0x80 represents. Here are equivalent code examples that are clearer:\nC+ + Examples of Better Use of Status Variables\nif ( dataReady ) ... if ( characterType & PRINTABLE_CHAR ) ... if ( reportType == ReportType_Annual ) ... if ( recalcNeeded = false ) ... dataReady = true;\ncharacterType = CONTROL_CHARACTER;\nreportType = ReportType_Annual;\nrecalcNeeded = false;\nClearly, characterType = CONTROL_CHARACTER is more meaningful than statusFlag = \n0x80 . Likewise, the conditional if ( reportType == ReportType_Annual ) is clearer than if \n( printFlag == 16 ) .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 868, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0869_23a83c2d", "text": "Likewise, the conditional if ( reportType == ReportType_Annual ) is clearer than if \n( printFlag == 16 ) . The second example shows that you can use this approach with \nenumerated types as well as predefined named constants. Here’s how you could use \nnamed constants and enumerated types to set up the values used in the example:\nDeclaring Status Variables in C++\n// values for CharacterType\nconst int LETTER = 0x01;\nconst int DIGIT = 0x02;\nconst int PUNCTUATION = 0x04;\nconst int LINE_DRAW = 0x08;\nCODING \nHORROR\nC11619670.fm Page 266 Tuesday, April 12, 2011 2:40 PM\n11.2 Naming Specific Types of Data 267\nconst int PRINTABLE_CHAR = ( LETTER | DIGIT | PUNCTUATION | LINE_DRAW );\nconst int CONTROL_CHARACTER = 0x80;\n// values for ReportType\nenum ReportType { \n ReportType_Daily, \n ReportType_Monthly, \n ReportType_Quarterly, \n ReportType_Annual,\n ReportType_All \n};\nWhen you find yourself “figuring out” a section of code, consider renaming the vari-\nables.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 869, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 957}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0870_ff1bd883", "text": "It’s OK to figure out murder mysteries, but you shouldn’t need to figure out \ncode. You should be able to read it. Naming T emporary Variables\nTemporary variables are used to hold intermediate results of calculations, as tempo-\nrary placeholders, and to hold housekeeping values. They’re usually called temp , x, or \nsome other vague and nondescriptive name. In general, temporary variables are a sign \nthat the programmer does not yet fully understand the problem. Moreover, because \nthe variables are officially given a “temporary” status, programmers tend to treat them \nmore casually than other variables, increasing the chance of errors. Be leery of “temporary” variables It’s often necessary to preserve values tempo-\nrarily. But in one way or another, most of the variables in your program are temporary. Calling a few of them temporary may indicate that you aren’t sure of their real pur-\nposes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 870, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 903}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0871_c45a3148", "text": "But in one way or another, most of the variables in your program are temporary. Calling a few of them temporary may indicate that you aren’t sure of their real pur-\nposes. Consider the following example:\nC+ + Example of an Uninformative “Temporary” Variable Name\n// Compute solutions of a quadratic equation. // This assumes that (b^2-4*a*c) is positive. temp = sqrt( b^2 - 4*a*c );\nsolution[0] = ( -b + temp ) / ( 2 * a );\nsolution[1] = ( -b - temp ) / ( 2 * a );\nIt’s fine to store the value of the expression sqrt( b^2 - 4 * a * c ) in a variable, especially \nsince it’s used in two places later. But the name temp doesn’t tell you anything about \nwhat the variable does. A better approach is shown in this example:\nC+ + Example with a “Temporary” Variable Name Replaced with a Real Variable\n// Compute solutions of a quadratic equation. // This assumes that (b^2-4*a*c) is positive.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 871, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0872_c3891b39", "text": "// This assumes that (b^2-4*a*c) is positive. discriminant = sqrt( b^2 - 4*a*c );\nsolution[0] = ( -b + discriminant ) / ( 2 * a );\nsolution[1] = ( -b - discriminant ) / ( 2 * a );\nC11619670.fm Page 267 Tuesday, April 12, 2011 2:45 PM\n268\nChapter 11: The Power of Variable Names\nThis is essentially the same code, but it’s improved with the use of an accurate, \ndescriptive variable name. Naming Boolean Variables\nFollowing are a few guidelines to use in naming boolean variables:\nKeep typical boolean names in mind Here are some particular ly useful boolean vari-\nable names:\n■\ndone Use done to indicate whether something is done. The variable can indi-\ncate whether a loop is done or some other operation is done. Set done to false \nbefore something is done, and set it to true when something is completed. ■\nerror Use error to indicate that an error has occurred. Set the variable to false \nwhen no error has occurred and to true when an error has occurred.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 872, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0873_5a6af3fd", "text": "■\nerror Use error to indicate that an error has occurred. Set the variable to false \nwhen no error has occurred and to true when an error has occurred. ■\nfound Use found to indicate whether a value has been found. Set found to false \nwhen the value has not been found and to true once the value has been found. Use found when searching an array for a value, a file for an employee ID, a list of \npaychecks for a certain paycheck amount, and so on. ■\nsuccess or ok Use success or ok to indicate whether an operation has been suc-\ncessful. Set the variable to false when an operation has failed and to true when an \noperation has succeeded. If you can, replace success with a more specific name \nthat describes precisely what it means to be successful. If the program is success-\nful when processing is complete, you might use processingComplete instead. If \nthe program is successful when a value is found, you might use found instead.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 873, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 934}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0874_739bf366", "text": "If the program is success-\nful when processing is complete, you might use processingComplete instead. If \nthe program is successful when a value is found, you might use found instead. Give boolean variables names that imply true or false Names like done and success \nare good boolean names because the state is either true or false; something is done or \nit isn’t; it’s a success or it isn’t. Names like status and sourceFile , on the other hand, are \npoor boolean names because they’re not obviously true or false. What does it mean if \nstatus is true? Does it mean that something has a status? Everything has a status. Does \ntrue mean that the status of something is OK? Or does false mean that nothing has \ngone wrong? With a name like status , you can’t tell. For better results, replace status with a name like error or statusOK , and replace source-\nFile with sourceFileAvailable or sourceFileFound , or whatever the variable represents. Some programmers like to put Is in front of their boolean names.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 874, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1008}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0875_f7fc2e09", "text": "Some programmers like to put Is in front of their boolean names. Then the variable \nname becomes a question: isdone ? isError ? isFound ? isProcessingComplete ? Answering \nthe question with true or false provides the value of the variable. A benefit of this \napproach is that it won’t work with vague names: isStatus ? makes no sense at all. A \ndrawback is that it makes simple logical expressions less readable: if ( isFound ) is \nslightly less readable than if ( found ) . 11.2 Naming Specific Types of Data 269\nUse positive boolean variable names Negative names like notFound , notdone , and \nnotSuccessful are difficult to read when they are negated—for example,\nif not notFound\nSuch a name should be replaced by found , done , or processingComplete and then \nnegated with an operator as appropriate. If what you’re looking for is found, you have \nfound instead of not notFound .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 875, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 883}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0876_4631c19c", "text": "If what you’re looking for is found, you have \nfound instead of not notFound . Naming Enumerated Types\nCross-Reference For details \non using enumerated types, \nsee Section 12.6, “Enumer-\nated Types.”\nWhen you use an enumerated type, you can ensure that it’s clear that members of the type \nall belong to the same group by using a group prefix, such as Color_ , Planet_ , or Month_ . Here are some examples of identifying elem ents of enumerated types using prefixes: \nVisual Basic Example of Using a Prefix Na ming Convention for Enumerated Types\nPublic Enum Color\n Color_Red\n Color_Green\n Color_Blue\nEnd Enum\nPublic Enum Planet\n Planet_Earth\n Planet_Mars\n Planet_Venus\nEnd Enum\nPublic Enum Month\n Month_January\n Month_February\n ... Month_December\nEnd Enum\nIn addition, the enum type itself ( Color , Planet , or Month ) can be identified in various \nways, including all caps or prefixes ( e_Color , e_Planet , or e_Month ).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 876, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0877_ddac34cc", "text": "Month_December\nEnd Enum\nIn addition, the enum type itself ( Color , Planet , or Month ) can be identified in various \nways, including all caps or prefixes ( e_Color , e_Planet , or e_Month ). A person could \nargue that an enum is essentially a user-defined type and so the name of the enum \nshould be formatted the same as other user-d efined types like classes. A different argu-\nment would be that enums are types, but they are also constants, so the enum type \nname should be formatted as constants. This book uses the convention of mixed case \nfor enumerated type names. In some languages, enumerated types are tr eated more like cla sses, and the members \nof the enumeration are always prefixed with the enum name, like Color.Color_Red or \nPlanet.Planet_Earth . If you’re working in that kind of language, it makes little sense to \nrepeat the prefix, so you can treat the name of the enum type itself as the prefix and \nsimplify the names to Color.Red and Planet.Earth .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 877, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0878_a12b118a", "text": "270\nChapter 11: The Power of Variable Names\nNaming Constants\nCross-Reference For details \non using named constants, \nsee Section 12.7, “Named \nConstants.”\nWhen naming constants, name the abstract entity the constant represents rather \nthan the number the constant refers to. FIVE is a bad name for a constant (regard-\nless of whether the value it represents is 5.0). CYCLES_NEEDED is a good name. CYCLES_NEEDED can equal 5.0 or 6.0. FIVE = 6.0 would be ridiculous. By the same \ntoken, BAKERS_DOZEN is a poor constant name; DONUTS_MAX is a good con-\nstant name. 11.3 The Power of Naming Conventions\nSome programmers resist standards and co nventions—and with good reason. Some \nstandards and conventions are rigid and inef fective—destructive to creativity and pro-\ngram quality. This is unfortunate since effective standards are some of the most pow-\nerful tools at your disposal. This sectio n discusses why, when , and how you should \ncreate your own standards for naming variables. Why Have Conventions?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 878, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0879_44c54ab2", "text": "This sectio n discusses why, when , and how you should \ncreate your own standards for naming variables. Why Have Conventions? Conventions offer severa l specific benefits:\n■\nThey let you take more for granted. By making one global d ecision rather than \nmany local ones, you can concentrate on the more important characteristics of \nthe code. ■\nThey help you transfer knowledge across projects. Similarities in names give you \nan easier and more confident understanding of what unfamiliar variables are \nsupposed to do. ■\nThey help you learn code more quickly on a new project. Rather than learning \nthat Anita’s code looks like this, Julia’ s like that, and Kristin’s like something \nelse, you can work with a mo re consistent set of code. ■\nThey reduce name proliferation. Withou t naming conventions, you can easily \ncall the same thing by two different names. For example, you might call total \npoints both pointTotal and totalPoints .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 879, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0880_ecac71d3", "text": "■\nThey reduce name proliferation. Withou t naming conventions, you can easily \ncall the same thing by two different names. For example, you might call total \npoints both pointTotal and totalPoints . This might not be confusing to you when \nyou write the code, but it can be enormously confusing to a new programmer \nwho reads it later. ■\nThey compensate for language weaknesse s. You can use conventions to emulate \nnamed constants and enumerated types. The conventions can differentiate \namong local, class, and global data and can incorporate type information for \ntypes that aren’t supported by the compiler. 11.3 The Power of Naming Conventions 271\n■\nThey emphasize relationships among related items. If you use object data, the \ncompiler takes care of this automatically. If your language doesn’t support \nobjects, you can supplement it with a naming convention. Names like address , \nphone , and name don’t indicate that the variables are related.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 880, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0881_b32688e0", "text": "If your language doesn’t support \nobjects, you can supplement it with a naming convention. Names like address , \nphone , and name don’t indicate that the variables are related. But suppose you \ndecide that all employee-data va riables should begin with an Employee prefix. employeeAddress , employeePhone , and employeeName leave no doubt that the vari-\nables are related. Programming conventions can make up for the weakness of \nthe language you’re using. The key is that any convention at all is often better than no convention. The conven-\ntion may be arbitrary. The power of nami ng conventions doesn’t come from the spe-\ncific convention chosen but from the fact th at a convention exists, adding structure to \nthe code and giving you fewer things to worry about.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 881, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 768}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0882_c7c5cf84", "text": "When You Should Have a Naming Convention\nThere are no hard-and-fast rules for when you should establish a naming convention, \nbut here are a few cases in which conventions are worthwhile:\n■\nWhen multiple programmers are working on a project\n■\nWhen you plan to turn a program over to another programmer for modifica-\ntions and maintenance (which is nearly always)\n■\nWhen your programs are reviewed by other programmers in your organization\n■\nWhen your program is so large that you can’t hold the whole thing in your brain \nat once and must think about it in pieces\n■\nWhen the program will be long-lived en ough that you might put it aside for a \nfew weeks or months before working on it again\n■\nWhen you have a lot of unusual terms that are common on a project and want to \nhave standard terms or abbr eviations to use in coding\nYou always benefit from having some kind of naming convention.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 882, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 890}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0883_59e04539", "text": "The consider-\nations above should help you determine th e extent of the convention to use on a \nparticular project. Degrees of Formality\nCross-Reference For details \non the differences in for-\nmality in small and large \nprojects, see Chapter 27, \n“How Program Size Affects \nConstruction.”\nDifferent conventions have different degrees of formality. An informal convention \nmight be as simple as “Use meaningful names.” Other informal conventions are \ndescribed in the next section. In general, the degree of formality you need is depen-\ndent on the number of people working on a program, the size of the program, and the \nprogram’s expected life span. On tiny, thro waway projects, a strict convention might \nbe unnecessary overhead. On larger projects in which several people are involved, \neither initially or over the program’s life span, formal conventions are an indispens-\nable aid to readability.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 883, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0884_bc9a04f2", "text": "On larger projects in which several people are involved, \neither initially or over the program’s life span, formal conventions are an indispens-\nable aid to readability. KEY POINT\n272\nChapter 11: The Power of Variable Names\n11.4 Informal Naming Conventions\nMost projects use relatively informal naming conventions such as the ones laid out in \nthis section. Guidelines for a Language-Independent Convention\nHere are some guidelines for creating a language-independent convention:\nDifferentiate between variab le names and routine names The convention this book \nuses is to begin variable and object names with lower case and routine names with \nupper case: variableName vs. RoutineName() . Differentiate between classes and objects The correspondence between class names \nand object names—or between types and vari ables of those types—can get tricky.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 884, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 851}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0885_38cc7717", "text": "RoutineName() . Differentiate between classes and objects The correspondence between class names \nand object names—or between types and vari ables of those types—can get tricky. Sev-\neral standard options exist, as shown in the following examples:\nOption 1: Differentiating Types and Variables via Initial Capitalization\nWidget widget;\nLongerWidget longerWidget;\nOption 2: Differentiating Types and Variables via All Caps\nWIDGET widget;\nLONGERWIDGET longerWidget\nOption 3: Differentiating Types and Variables via the “t_” Prefix for Types\nt_Widget Widget;\nt_LongerWidget LongerWidget;\nOption 4: Differentiating Types and Variables via the “a” Prefix for Variables\nWidget aWidget;\nLongerWidget aLongerWidget;\nOption 5: Differentiating Types and Variabl es via Using More Specific Names for the \nVariables\nWidget employeeWidget;\nLongerWidget fullEmployeeWidget;\nEach of these options has strengths and weaknesses.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 885, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0886_1836ab87", "text": "Option 1 is a common conven-\ntion in case-sensitive lang uages including C++ and Java, but some programmers are \nuncomfortable differentiating names solely on the basis of capitalization. Indeed, cre-\nating names that differ only in the capitalization of the first letter in the name seems to \nprovide too little “psychological distance” and too small a visual distinction between \nthe two names. 11.4 Informal Naming Conventions 273\nThe Option 1 approach can’t be applied cons istently in mixed-language environments \nif any of the languages are case-insensitive. In Microsoft Visual Basic, for example, Dim \nwidget as Widget will generate a syntax error because widget and Widget are treated as \nthe same token. Option 2 creates a more obvious distinction between the type name and the variable \nname.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 886, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 803}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0887_3949d9af", "text": "Option 2 creates a more obvious distinction between the type name and the variable \nname. For historical reasons, all caps are us ed to indicate constants in C++ and Java, \nhowever, and the approach is subject to th e same problems in mixed-language envi-\nronments that Option 1 is subject to. Option 3 works adequately in all languages, but some programmers dislike the idea of \nprefixes for aesthetic reasons. Option 4 is sometimes used as an alternativ e to Option 3, but it has the drawback of \naltering the name of every instance of a class instead of just the one class name. Option 5 requires more thought on a variab le-by-variable basis. In most instances, \nbeing forced to think of a specific name for a variable results in more readable code. But sometimes a widget truly is just a generic widget , and in those instances you’ll find \nyourself coming up with less- than-obvious names, like genericWidget , which are argu-\nably less readable.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 887, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0888_ff925662", "text": "But sometimes a widget truly is just a generic widget , and in those instances you’ll find \nyourself coming up with less- than-obvious names, like genericWidget , which are argu-\nably less readable. In short, each of the available options involves tradeoffs. The code in this book uses \nOption 5 because it’s the most understandable in situations in which the person read-\ning the code isn’t necessarily familiar wi th a less intuitive naming convention. Identify global variables One common programming problem is misuse of global \nvariables. If you give all global variable names a g_ prefix, for example, a programmer \nseeing the variable g_RunningTotal will know it’s a global variable and treat it as such. Identify member variables Identify a class’s member data. Make it clear that the vari-\nable isn’t a local variable and that it isn’t a global variable either. For example, you can \nidentify class member variables with an m_ prefix to indicate that it is member data.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 888, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0889_9cbef1a7", "text": "For example, you can \nidentify class member variables with an m_ prefix to indicate that it is member data. Identify type definitions Naming conventions for types serve two purposes: they \nexplicitly identify a name as a type name , and they avoid naming clashes with vari-\nables. To meet those considerations, a prefix or suffix is a good approach. In C++, the \ncustomary approach is to use all uppercase letters for a type name—for example, \nCOLOR and MENU . (This convention applies to typedef s and struct s, not class names.) \nBut this creates the possibili ty of confusion with named preprocessor constants. To \navoid confusion, you can prefix the type names with t_, such as t_Color and t_Menu . Identify named constants Named constants need to be identified so that you can tell \nwhether you’re assigning a variable a value from another variable (whose value might \nchange) or from a named constant. In Visual Basic, you have the additional possibility \nthat the value might be from a function.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 889, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0890_b43c417c", "text": "In Visual Basic, you have the additional possibility \nthat the value might be from a function. Visual Basic doesn’t require function names to \nuse parentheses, whereas in C++ even a func tion with no parameters uses parentheses. 274\nChapter 11: The Power of Variable Names\nOne approach to naming constants is to use a prefix like c_ for constant names. That \nwould give you names like c_RecsMax or c_LinesPerPageMax . In C++ and Java, the con-\nvention is to use all uppercase letters, possibly with underscores to separate words, \nRECSMAX or RECS_ MAX and LINESPERPAGEMAX or LINES_PER_PAGE_ MAX . Identify elements of enumerated types Elements of enumerated types need to be \nidentified for the same reasons that named constants do—to make it easy to tell that \nthe name is for an enumerated type as opposed to a variable, named constant, or func-\ntion.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 890, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 853}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0891_17bb6a18", "text": "The standard approach applie s: you can use all caps or an e_ or E_ prefix for the \nname of the type itself and use a prefix based on the specific type like Color_ or Planet_ \nfor the members of the type. Identify input-only parameters in languages that don’t enforce them Sometimes \ninput parameters are accidentally modified . In languages such as C++ and Visual \nBasic, you must indicate explicitly whether you want a value that’s been modified to \nbe returned to the calling routin e. This is indicated with the *, &, and const qualifiers \nin C++ or ByRef and ByVal in Visual Basic. In other languages, if you modify an input vari able, it is returned whether you like it or \nnot. This is especially true when passing ob jects. In Java, for example, all objects are \npassed “by value,” so when you pass an object to a routine, the contents of the object \ncan be changed within the called rout ine (Arnold, Gosling, Holmes 2000).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 891, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 932}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0892_03e7b487", "text": "In Java, for example, all objects are \npassed “by value,” so when you pass an object to a routine, the contents of the object \ncan be changed within the called rout ine (Arnold, Gosling, Holmes 2000). Cross-Reference Augment-\ning a language with a nam-\ning convention to make up \nfor limitations in the lan-\nguage itself is an example of \nprogramming into a lan-\nguage instead of just pro-\ngramming in it. For more \ndetails on programming into \na language, see Section 34.4, \n“Program into Your Lan-\nguage, Not in It.” \nIn those languages, if you establish a nami ng convention in which input-only param-\neters are given a const prefix (or final, nonmodifiable , or something comparable) , you’ll \nknow that an error has occurred when you see anything with a const prefix on the left \nside of an equal sign. If you see constMax.SetNewMax( ... ) , you’ll know it’s a goof \nbecause the const prefix indicates that the variable isn’t supposed to be modified.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 892, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 955}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0893_225a5d57", "text": "If you see constMax.SetNewMax( ... ) , you’ll know it’s a goof \nbecause the const prefix indicates that the variable isn’t supposed to be modified. Format names to enhance readability Two common techniques for increasing read-\nability are using capitalization and spacing ch aracters to separate words. For example, \nGYMNASTICSPOINTTOTAL is less readable than gymnasticsPointTotal or \ngymnastics_point_total . C++, Java, Visual Basic, and other languages allow for mixed \nuppercase and lowercase characters. C++, Java , Visual Basic, and other languages also \nallow the use of the underscore (_) separator. Try not to mix these techniques; that makes code hard to read. If you make an honest \nattempt to use any of these readability techniques consistently, however, it will \nimprove your code. People have managed to have zealous, blistering debates over fine \npoints such as whether the first character in a name should be capitalized ( TotalPoints \nvs.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 893, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 955}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0894_9482698b", "text": "People have managed to have zealous, blistering debates over fine \npoints such as whether the first character in a name should be capitalized ( TotalPoints \nvs. totalPoints ), but as long as you and your team are consistent, it won’t make much \ndifference. This book uses initial lowercase because of the strength of the Java practice \nand to facilitate similarity in style across several languages. 11.4 Informal Naming Conventions 275\nGuidelines for Language-Specific Conventions\nFollow the naming conventions of the language you’re using. You can find books for \nmost languages that describe style guidelines . Guidelines for C, C++, Java, and Visual \nBasic are provided in the following sections. C Conventions\nFurther Reading The classic \nbook on C programming \nstyle is C Programming \nGuidelines (Plum 1984). Several naming conventions apply specifi cally to the C programming language:\n■\nc and ch are character variables. ■\ni and j are integer indexes. ■\nn is a number of something. ■\np is a pointer.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 894, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1007}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0895_1f361701", "text": "Several naming conventions apply specifi cally to the C programming language:\n■\nc and ch are character variables. ■\ni and j are integer indexes. ■\nn is a number of something. ■\np is a pointer. ■\ns is a string. ■\nPreprocessor macros are in ALL_CAPS . This is usually extended to include type-\ndefs as well. ■\nVariable and routine names are in all_lowercase . ■\nThe underscore (_) character is used as a separator: letters_in_lowercase is more \nreadable than lettersinlowercase . These are the conventions for generic, UNIX-style and Linux-style C programming, \nbut C conventions are different in different environments. In Microsoft Windows, C \nprogrammers tend to use a form of the Hungarian naming convention and mixed \nuppercase and lowercase letters for variable names. On the Macintosh, C program-\nmers tend to use mixed-case names for routines because the Macintosh toolbox and \noperating-system routines were originally designed for a Pascal interface.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 895, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 958}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0896_9537b171", "text": "On the Macintosh, C program-\nmers tend to use mixed-case names for routines because the Macintosh toolbox and \noperating-system routines were originally designed for a Pascal interface. C+ + Conventions\nFurther Reading For more \non C++ programming style, \nsee The Elements of C++ \nStyle (Misfeldt, Bumgardner, \nand Gray 2004). Here are the conventions that have grown up around C++ programming: \n■\ni and j are integer indexes. ■\np is a pointer. ■\nConstants, typedefs, and preprocessor macros are in ALL_CAPS . ■\nClass and other type names are in MixedUpperAndLowerCase() . ■\nVariable and function names use lowercase for the first word, with the first letter \nof each following word capitalized—for example, variableOrRoutineName . ■\nThe underscore is not used as a separator within names, except for names in all \ncaps and certain kinds of prefixes (such as those used to identify global variables).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 896, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 900}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0897_bc8c6274", "text": "■\nThe underscore is not used as a separator within names, except for names in all \ncaps and certain kinds of prefixes (such as those used to identify global variables). 276\nChapter 11: The Power of Variable Names\nAs with C programming, this convention is far from standard and different environ-\nments have standardized on different convention details. Java Conventions\nFurther Reading For more \non Java programming style, \nsee The Elements of Java \nStyle, 2d ed. (Vermeulen et \nal. 2000). In contrast with C and C++, Java style co nventions have been well established since \nthe language’s beginning:\n■\ni and j are integer indexes. ■\nConstants are in ALL_CAPS separated by underscores. ■\nClass and interface names capitalize the fi rst letter of each word, including the \nfirst word—for example, ClassOrInterfaceName . ■\nVariable and method names use lowercase for the first word, with the first letter \nof each following word capitalized—for example, variableOrRoutineName .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 897, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0898_0a18fd13", "text": "■\nVariable and method names use lowercase for the first word, with the first letter \nof each following word capitalized—for example, variableOrRoutineName . ■\nThe underscore is not used as a separator within names except for names in all \ncaps. ■\nThe get and set prefixes are used for accessor methods. Visual Basic Conventions\nVisual Basic has not really established fi rm conventions. The next section recom-\nmends a convention for Visual Basic. Mixed-Language Programming Considerations\nWhen programming in a mixed-language en vironment, the naming conventions (as \nwell as formatting conventions, documentation conventions, and other conventions) \ncan be optimized for overall consistency and readability—even if that means going \nagainst convention for one of the languages that’s part of the mix. In this book, for example, variable names a ll begin with lowercase, which is consistent \nwith conventional Java programming practi ce and some but not all C++ conventions.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 898, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0899_560b5351", "text": "In this book, for example, variable names a ll begin with lowercase, which is consistent \nwith conventional Java programming practi ce and some but not all C++ conventions. This book formats all routine names with an initial capital letter, which follows the \nC++ convention. The Java co nvention would be to begin method names with lower-\ncase, but this book uses routine names that begin in uppercase across all languages for \nthe sake of overall readability. Sample Naming Conventions\nThe standard conventions above tend to ignore several important aspects of naming \nthat were discussed over the past few pages— including variable scop ing (private, class, \nor global), differentiating between class, object, routine, and variable names, and \nother issues. 11.4 Informal Naming Conventions 277\nThe naming-convention guidelines can look complicated when they’re strung across \nseveral pages. They don’t need to be terribly complex, however, and you can adapt \nthem to your needs.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 899, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0900_3a91d4b1", "text": "They don’t need to be terribly complex, however, and you can adapt \nthem to your needs. Variable names include three kinds of information:\n■\nThe contents of the variable (what it represents)\n■\nThe kind of data (named constant, prim itive variable, user-defined type, or \nclass)\n■\nThe scope of the variable (private, class, package, or global)\nTables 11-3, 11-4, and 11-5 provide naming conventions for C, C++, Java, and Visual \nBasic that have been adapted from the guidel ines presented earlier. These specific con-\nventions aren’t necessarily recommended, but they give you an idea of what an infor-\nmal naming convention includes. Table 11-3\nSample Naming Conventions for C++ and Java\nEntity\nDescription\nClassName Class names are in mixed uppercase and lowercase with \nan initial capital letter. TypeName Type definitions, including enumerated types and type-\ndefs, use mixed uppercase and lowercase with an initial \ncapital letter.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 900, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0901_023cf02f", "text": "TypeName Type definitions, including enumerated types and type-\ndefs, use mixed uppercase and lowercase with an initial \ncapital letter. EnumeratedTypes In addition to the rule ab ove, enumerated types are \nalways stated in the plural form. localVariable Local variables are in mixed uppercase and lowercase \nwith an initial lowercase letter. The name should be inde-\npendent of the underlying data type and should refer to \nwhatever the variable represents. routineParameter Routine parameters are formatted the same as local vari-\nables. RoutineName() Routines are in mixed uppercase and lowercase. (Good \nroutine names are discussed in Section 7.3.)\nm_ClassVariable Member variables that are available to multiple routines \nwithin a class, but only within a class, are prefixed with an \nm_. g_GlobalVariable Global variables are prefixed with a g_. CONSTANT Named constants are in ALL_CAPS . MACRO Macros are in ALL_CAPS .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 901, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 925}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0902_bc61d0bf", "text": "g_GlobalVariable Global variables are prefixed with a g_. CONSTANT Named constants are in ALL_CAPS . MACRO Macros are in ALL_CAPS . Base_EnumeratedType Enumerated types are prefixed with a mnemonic for their \nbase type stated in the singular—for example, Color_Red , \nColor_Blue . 278\nChapter 11: The Power of Variable Names\nBecause Visual Basic is not case-sensitive , special rules apply for differentiating \nbetween type names and variable names. Take a look at Table 11-5. Table 11-4\nSample Naming Conventions for C\nEntity\nDescription\nTypeName Type definitions use mixed uppercase and lowercase with \nan initial capital letter. GlobalRoutineName() Public routines are in mixed uppercase and lowercase. f_FileRoutineName() Routines that are private to a single module (file) are pre-\nfixed with an f_. LocalVariable Local variables are in mixed uppercase and lowercase. The name should be independent of the underlying data \ntype and should refer to whatever the variable repre-\nsents.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 902, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0903_efba9c79", "text": "LocalVariable Local variables are in mixed uppercase and lowercase. The name should be independent of the underlying data \ntype and should refer to whatever the variable repre-\nsents. RoutineParameter Routine parameters are formatted the same as local vari-\nables. f_FileStaticVariable Module (file) variables are prefixed with an f_. G_GLOBAL_GlobalVariable Global variables are prefixed with a G_ and a mnemonic \nof the module (file) that defines the variable in all upper-\ncase—for example, SCREEN_Dimensions . LOCAL_CONSTANT Named constants that are private to a single routine or \nmodule (file) are in all uppercase—for example, \nROWS_MAX . G_GLOBALCONSTANT Global named constants are in all uppercase and are pre-\nfixed with G_ and a mnemonic of the module (file) that \ndefines the named constant in all uppercase—for exam-\nple, G_SCREEN_ROWS_MAX . LOCALMACRO() Macro definitions that are private to a single routine or \nmodule (file) are in all uppercase.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 903, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0904_62ba00dc", "text": "LOCALMACRO() Macro definitions that are private to a single routine or \nmodule (file) are in all uppercase. G_GLOBAL_MACRO() Global macro definitions are in all uppercase and are \nprefixed with G_ and a mnemonic of the module (file) \nthat defines the macro in all uppercase—for example, \nG_SCREEN_LOCATION() . Table 11-5\nSample Naming Conventions for Visual Basic\nEntity\nDescription\nC_ClassName Class names are in mixed uppercase and lowercase with \nan initial capital letter and a C_ prefix. T_TypeName Type definitions, including enumerated types and type-\ndefs, use mixed uppercase and lowercase with an initial \ncapital letter and a T_ prefix. T_EnumeratedTypes In addition to the rule ab ove, enumerated types are \nalways stated in the plural form. 11.5 Standardized Prefixes 279\n11.5 Standardized Prefixes\nFurther Reading For further \ndetails on the Hungarian \nnaming convention, see \n“The Hungarian Revolution” \n(Simonyi and Heller 1991).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 904, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0905_c53025c0", "text": "11.5 Standardized Prefixes 279\n11.5 Standardized Prefixes\nFurther Reading For further \ndetails on the Hungarian \nnaming convention, see \n“The Hungarian Revolution” \n(Simonyi and Heller 1991). Standardizing prefixes for common meanings provides a terse but consistent and \nreadable approach to naming data. The best known scheme for standardizing prefixes \nis the Hungarian naming convention, which is a set of detailed guidelines for naming \nvariables and routines (not Hungarians!) that was widely used at one time in \nMicrosoft Windows programming. Although the Hungarian naming convention is no \nlonger in widespread use, the basic idea of standardizing on terse, precise abbrevia-\ntions continues to have value. Standardized prefixes are composed of two parts: the user-defined type (UDT) abbre-\nviation and the semantic prefix. User-Defined Type Abbreviations\nThe UDT abbreviation identifies the data type of the object or variable being named.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 905, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0906_e9e1eae4", "text": "User-Defined Type Abbreviations\nThe UDT abbreviation identifies the data type of the object or variable being named. UDT abbreviations might refer to entities such as windows, screen regions, and fonts. A UDT abbreviation generally doesn’t refer to any of the predefined data types offered \nby the programming language. UDTs are described with short codes that you create for a specific program and then \nstandardize on for use in that program. The codes are mnemonics such as wn for win-\ndows and scr for screen regions. Table 11-6 offers a sample list of UDTs that you might \nuse in a program for a word processor. localVariable Local variables are in mixed uppercase and lowercase \nwith an initial lowercase letter. The name should be inde-\npendent of the underlying data type and should refer to \nwhatever the variable represents. routineParameter Routine parameters are formatted the same as local vari-\nables. RoutineName() Routines are in mixed uppercase and lowercase.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 906, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0907_c8a1a99a", "text": "routineParameter Routine parameters are formatted the same as local vari-\nables. RoutineName() Routines are in mixed uppercase and lowercase. (Good \nroutine names are discussed in Section 7.3.)\nm_ClassVariable Member variables that are available to multiple routines \nwithin a class, but only within a class, are prefixed with an \nm_. g_GlobalVariable Global variables are prefixed with a g_. CONSTANT Named constants are in ALL_CAPS . Base_EnumeratedType Enumerated types are prefixed with a mnemonic for their \nbase type stated in the singular—for example, Color_Red , \nColor_Blue .Table 11-5\nSample Naming Conventions for Visual Basic\nEntity\nDescription\n280\nChapter 11: The Power of Variable Names\nWhen you use UDTs, you also define prog ramming-language data types that use the \nsame abbreviations as the UDTs.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 907, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 814}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0908_48ae18ec", "text": "Thus, if you had the UDTs in Table 11-6, you’d see \ndata declarations like these:\nCH chCursorPosition;\nSCR scrUserWorkspace;\nDOC docActive\nPA firstPaActiveDocument;\nPA lastPaActiveDocument;\nWN wnMain;\nAgain, these examples relate to a word processor. For use on your own projects, you’d \ncreate UDT abbreviations for the UDTs that are used most commonly within your \nenvironment. Semantic Prefixes\nSemantic prefixes go a step beyond the UDT and describe how the variable or object \nis used. Unlike UDTs, which vary from project to project, semantic prefixes are some-\nwhat standard across projects. Table 11-7 sh ows a list of standard semantic prefixes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 908, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 654}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0909_90c5ce78", "text": "Unlike UDTs, which vary from project to project, semantic prefixes are some-\nwhat standard across projects. Table 11-7 sh ows a list of standard semantic prefixes. Table 11-6\nSample of UDTs for a Word Processor\nUDT \nAbbreviation\nMeaning\nch Character (a character not in the C++ sense, but in the sense of the \ndata type a word-processing program would use to represent a \ncharacter in a document)\ndoc Document\npa Paragraph\nscr Screen region\nsel Selection\nwn Window\nTable 11-7\nSemantic Prefixes \nSemantic \nPrefix\nMeaning\nc Count (as in the number of records, characters, and so on)\nfirst The first element that needs to be dealt with in an array. first is similar to \nmin but relative to the current operation rather than to the array itself. g Global variable\ni Index into an array\nlast The last element that needs to be dealt with in an array. last is the counter-\npart of first.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 909, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 880}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0910_cb5d0f78", "text": "g Global variable\ni Index into an array\nlast The last element that needs to be dealt with in an array. last is the counter-\npart of first. 11.5 Standardized Prefixes 281\nSemantic prefixes are formatted in lowercase or mixed uppercase and lowercase and \nare combined with the UDTs and with other semantic prefixes as needed. For exam-\nple, the first paragraph in a document would be named pa to show that it’s a para-\ngraph and first to show that it’s the first paragraph: firstPa . An index into the set of \nparagraphs would be named iPa; cPa is the count, or the number of paragraphs; and \nfirstPaActiveDocument and lastPaActiveDocument are the first and last paragraphs in the \ncurrent active document. Advantages of Standardized Prefixes\nStandardized prefixes give you all the gene ral advantages of havi ng a naming conven-\ntion as well as several other advantages. Because so many names are standard, you \nhave fewer names to remember in any single program or class.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 910, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0911_68e4d67e", "text": "Because so many names are standard, you \nhave fewer names to remember in any single program or class. Standardized prefixes add precision to several areas of naming that tend to be impre-\ncise. The precise distinctions between min, first, last, and max are particularly helpful. Standardized prefixes make names more compact. For example, you can use cpa for \nthe count of paragraphs rather than totalParagraphs . You can use ipa to identify an \nindex into an array of paragraphs rather than indexParagraphs or paragraphsIndex . Finally, standardized prefixes allow you to check types accurately when you’re using \nabstract data types that your compiler can’t necessarily check: paReformat = docRefor-\nmat is probably wrong because pa and doc are different UDTs. The main pitfall with standardized prefixes is a programmer neglecting to give the \nvariable a meaningful name in addition to its prefix.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 911, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 900}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0912_45bc68a9", "text": "The main pitfall with standardized prefixes is a programmer neglecting to give the \nvariable a meaningful name in addition to its prefix. If ipa unambiguously designates \nan index into an array of paragraphs, it’s tempting not to make the name more mean-\ningful like ipaActiveDocument . For readability, close the loop and come up with a \ndescriptive name. lim The upper limit of elements that need to be dealt with in an array. lim is \nnot a valid index. Like last, lim is used as a counterpart of first. Unlike last, \nlim represents a noninclusive upper bound on the array; last represents a \nfinal, legal element. Generally, lim equals last + 1 . m Class-level variable\nmax The absolute last element in an array or other kind of list. max refers to the \narray itself rather than to operations on the array. min The absolute first element in an array or other kind of list.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 912, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 875}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0913_84784158", "text": "max refers to the \narray itself rather than to operations on the array. min The absolute first element in an array or other kind of list. p PointerTable 11-7\nSemantic Prefixes \nSemantic \nPrefix\nMeaning\nKEY POINT\n282\nChapter 11: The Power of Variable Names\n11.6 Creating Short Na mes That Are Readable\nThe desire to use short variable names is in some ways a remnant of an earlier age of \ncomputing. Older languages like assembler, generic Basic, and Fortran limited vari-\nable names to 2–8 characters and forced programmers to create short names. Early \ncomputing was more closely linked to mathematics and its use of terms like i, j, and k \nas the variables in summations and other eq uations. In modern languages like C++, \nJava, and Visual Basic, you can create name s of virtually any length; you have almost \nno reason to shorten meaningful names. If circumstances do require you to create short names, note that some methods of \nshortening names are better than others.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 913, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0914_ed650944", "text": "If circumstances do require you to create short names, note that some methods of \nshortening names are better than others. You can create good short variable names by \neliminating needless words, using short syno nyms, and using any of several abbrevia-\ntion strategies. It’s a good idea to be familiar with multiple techniques for abbreviating \nbecause no single technique works well in all cases. General Abbreviation Guidelines\nHere are several guidelines for creating abbreviations. Some of them contradict others, \nso don’t try to use them all at the same time. ■\nUse standard abbreviations (the ones in common use, which are listed in a \ndictionary). ■\nRemove all nonleading vowels. ( computer becomes cmptr , and screen becomes \nscrn. apple becomes appl, and integer becomes intgr .)\n■\nRemove articles: and, or, the, and so on. ■\nUse the first letter or first few letters of each word. ■\nTruncate consistently after the first, second, or third (whichever is appropriate) \nletter of each word.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 914, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0915_9fed8fdc", "text": "■\nUse the first letter or first few letters of each word. ■\nTruncate consistently after the first, second, or third (whichever is appropriate) \nletter of each word. ■\nKeep the first and last letters of each word. ■\nUse every significant word in the name, up to a maximum of three words. ■\nRemove useless suffixes— ing, ed, and so on. ■\nKeep the most noticeable sound in each syllable. ■\nBe sure not to change the meaning of the variable. ■\nIterate through these techniques until yo u abbreviate each variable name to \nbetween 8 to 20 characters or the number of characters to which your language \nlimits variable names. KEY POINT\n11.6 Creating Short Names That Are Readable 283\nPhonetic Abbreviations\nSome people advocate creating abbreviations based on the sound of the words rather \nthan their spelling. Thus skating becomes sk8ing , highlight becomes hilite , before \nbecomes b4, execute becomes xqt, and so on.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 915, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0916_e3e713b9", "text": "Thus skating becomes sk8ing , highlight becomes hilite , before \nbecomes b4, execute becomes xqt, and so on. This seems too much like asking people \nto figure out personalized license plates to me, and I don’t recommend it. As an exer-\ncise, figure out what these names mean:\nComments on Abbreviations\nYou can fall into several traps when creating abbreviations. Here are some rules for \navoiding pitfalls:\nDon’t abbreviate by removing one character from a word Typing one character is lit-\ntle extra work, and the one-character savings ha rdly justifies the loss in readability. It’s \nlike the calendars that have “Jun” and “Jul.” You have to be in a big hurry to spell June \nas “Jun.” With most one-letter deletions, it’s hard to remember whether you removed \nthe character. Either remove more than one character or spell out the word. Abbreviate consistently Always use the same abbrev iation. For example, use Num \neverywhere or No everywhere, but don’t use both.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 916, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0917_363b336c", "text": "Either remove more than one character or spell out the word. Abbreviate consistently Always use the same abbrev iation. For example, use Num \neverywhere or No everywhere, but don’t use both. Similarly, don’t abbreviate a word \nin some names and not in others. For instance, don’t use the full word Number in \nsome places and the abbreviation Num in others. Create names that you can pronounce Use xPos rather than xPstn and needsComp \nrather than ndsCmptg . Apply the telephone test—if you can’t read your code to some-\none over the phone, rename your variables to be more distinctive (Kernighan and \nPlauger 1978). Avoid combinations that result in misreading or mispronunciation To refer to the \nend of B, favor ENDB over BEND . If you use a good separation technique, you won’t \nneed this guideline since B-END , BEnd , or b_end won’t be mispronounced. Use a thesaurus to resolve naming collisions One problem in creating short names \nis naming collisions—names that abbreviate to the same thing.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 917, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0918_55eef3fc", "text": "Use a thesaurus to resolve naming collisions One problem in creating short names \nis naming collisions—names that abbreviate to the same thing. For example, if you’re \nlimited to three characters and you need to use fired and full revenue disbursal in the \nsame area of a program, you might inadvertently abbreviate both to frd. One easy way to avoid naming collisions is to use a different word with the same \nmeaning, so a thesaurus is handy. In this example, dismissed might be substituted for \nfired and complete revenue disbursal might be substituted for full revenue disbursal . The \nthree-letter abbreviations become dsm and crd, eliminating the naming collision. ILV2SK8 XMEQWK S2DTM8O NXTC TRMN8R\n284\nChapter 11: The Power of Variable Names\nDocument extremely short names wi th translation tables in the code In languages \nthat allow only very short names, include a translation table to provide a reminder of \nthe mnemonic content of the variables.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 918, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 958}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0919_e57dd8ed", "text": "Include the table as comments at the begin-\nning of a block of code. Here’s an example:\nFortran Example of a Good Translation Table\nC *******************************************************************\nC Translation Table\nC\nC Variable Meaning\nC -------- -------\nC XPOS x-Coordinate Position (in meters)\nC YPOS Y-Coordinate Position (in meters)\nC NDSCMP Needs Computing (=0 if no computation is needed;\nC =1 if computation is needed)\nC PTGTTL Point Grand Total\nC PTVLMX Point Value Maximum\nC PSCRMX Possible Score Maximum\nC *****************************************************************\nYou might think that this technique is outdated, but as recently as mid-2003 I \nworked with a client that had hundreds of thousands of lines of code written in RPG \nthat was subject to a 6-char acter–variable-name limitatio n. These issues still come \nup from time to time.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 919, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 862}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0920_0cec8a98", "text": "These issues still come \nup from time to time. Document all abbreviations in a project -level “Standard Abbreviations” document\nAbbreviations in code create two general risks:\n■\nA reader of the code might not understand the abbreviation. ■\nOther programmers might use multiple abbreviations to refer to the same word, \nwhich creates needless confusion. To address both these potential problems, you can create a “Standard Abbreviations” \ndocument that captures all the coding abbr eviations used on your project. The docu-\nment can be a word processor document or a spreadsheet. On a very large project, it \ncould be a database. The document is check ed into version control and checked out \nanytime anyone creates a new abbreviation in the code. Entries in the document \nshould be sorted by the full word, not the abbreviation.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 920, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 828}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0921_f18930ec", "text": "The document is check ed into version control and checked out \nanytime anyone creates a new abbreviation in the code. Entries in the document \nshould be sorted by the full word, not the abbreviation. This might seem like a lot of overhead, but aside from a small amount of startup over-\nhead, it really just sets up a mechanism th at helps the project use abbreviations effec-\ntively. It addresses the first of the two ge neral risks described above by documenting \nall abbreviations in use. The fact that a programmer can’t create a new abbreviation \nwithout the overhead of checking the Stan dard Abbreviations document out of ver-\n11.7 Kinds of Names to Avoid 285\nsion control, entering the abbreviation, and checking it back in is a good thing . It \nmeans that an abbreviation won’t be create d unless it’s so common that it’s worth the \nhassle of documenting it. This approach addresses the second risk by reducing the likelihood that a program-\nmer will create a redundant abbreviation.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 921, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0922_50b2cf71", "text": "This approach addresses the second risk by reducing the likelihood that a program-\nmer will create a redundant abbreviation. A programmer who wants to abbreviate \nsomething will check out the abbreviations document and enter the new abbrevia-\ntion. If there is already an abbreviation for the word the programmer wants to abbre-\nviate, the programmer will notice that and wi ll then use the existing abbreviation \ninstead of creating a new one. The general issue illustrated by this guidelin e is the difference between write-time con-\nvenience and read-time convenience. This approach clearly creates a write-time incon-\nvenience , but programmers over the lifetime of a system spend far more time reading \ncode than writing code. This approach incr eases read-time convenience. By the time \nall the dust settles on a project, it might well also have improved write-time conve-\nnience.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 922, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0923_18e3185c", "text": "This approach incr eases read-time convenience. By the time \nall the dust settles on a project, it might well also have improved write-time conve-\nnience. Remember that names matter more to the reader of the code than to the writer Read \ncode of your own that you haven’t seen for at least six months and notice where you \nhave to work to understand what the names mean. Resolve to change the practices \nthat cause such confusion. 11.7 Kinds of Names to Avoid\nHere are some guidelines regarding variable names to avoid:\nAvoid misleading names or abbreviations Make sure that a name is unambiguous. For example, FALSE is usually the opposite of TRUE and would be a bad abbreviation \nfor “Fig and Almond Season.”\nAvoid names with similar meanings If you can switch the names of two variables \nwithout hurting the program, you need to rename both variables.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 923, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 854}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0924_1cb51d1e", "text": "For example, input \nand inputValue , recordNum and numRecords , and fileNumber and fileIndex are so seman-\ntically similar that if you use them in the sa me piece of code you’ll easily confuse them \nand install some subtle, hard-to-find errors. Cross-Reference The techni-\ncal term for differences like \nthis between similar variable \nnames is “psychological dis-\ntance.” For details, see “How \n‘Psychological Distance’ Can \nHelp” in Section 23.4. Avoid variables with different meanings but similar names If you have two variables \nwith similar names and different meanings, tr y to rename one of them or change your \nabbreviations. Avoid names like clientRecs and clientReps . They’re only one letter differ-\nent from each other, and the letter is hard to notice. Have at least two-letter differences \nbetween names, or put the differences at the beginning or at the end. clientRecords and \nclientReports are better than the original names.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 924, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0925_913526dc", "text": "Have at least two-letter differences \nbetween names, or put the differences at the beginning or at the end. clientRecords and \nclientReports are better than the original names. KEY POINT\n286\nChapter 11: The Power of Variable Names\nAvoid names that sound similar, such as wrap and rap Homonyms get in the way \nwhen you try to discuss your code with others. One of my pet peeves about Extreme \nProgramming (Beck 2000) is its overly clev er use of the terms Goal Donor and Gold \nOwner, which are virtually indistinguisha ble when spoken. You end up having con-\nversations like this:\nI was just speaking with the Goal Donor—\nDid you say “Gold Owner” or “Goal Donor”? I said “Goal Donor.” \nWhat? GOAL - - - DONOR! OK, Goal Donor. You don’t have to yell, Goll’ Darn it. Did you say “Gold Donut?” \nRemember that the telephone test applies to similar sounding names just as it does to \noddly abbreviated names.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 925, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0926_731f6b78", "text": "OK, Goal Donor. You don’t have to yell, Goll’ Darn it. Did you say “Gold Donut?” \nRemember that the telephone test applies to similar sounding names just as it does to \noddly abbreviated names. Avoid numerals in names If the numerals in a name are really significant, use an array \ninstead of separate variables. If an array is inappropriate, numerals are even more inap-\npropriate. For example, avoid file1 and file2, or total1 and total2 . You can almost always \nthink of a better way to differentiate between two variables than by tacking a 1 or a 2 \nonto the end of the name. I can’t say never use numerals. Some real-world entities (such \nas Route 66 or Interstate 405) have numera ls embedded in them. But consider whether \nthere are better alternatives before you create a name that includes numerals. Avoid misspelled words in names It’s hard enough to remember how words are sup-\nposed to be spelled. To require people to remember “correct” misspellings is simply \ntoo much to ask.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 926, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 990}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0927_dfbfb59b", "text": "Avoid misspelled words in names It’s hard enough to remember how words are sup-\nposed to be spelled. To require people to remember “correct” misspellings is simply \ntoo much to ask. For example, misspelling highlight as hilite to save three characters \nmakes it devilishly difficult for a reader to remember how highlight was misspelled. Was it highlite ? hilite ? hilight ? hilit? jai-a-lai-t ? Who knows? Avoid words that are commonly misspelled in English Absense , acummulate , acsend , \ncalender , concieve , defferred , definate , independance , occassionally , prefered , reciept , super-\nseed, and many others are common misspelling s in English. Most English handbooks \ncontain a list of commonly mi sspelled words. Avoid using su ch words in your variable \nnames. Don’t differentiate variable na mes solely by capitalization If you’re programming in \na case-sensitive language such as C++, you may be tempted to use frd for fired, FRD for \nfinal review duty , and Frd for full revenue disbursal .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 927, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0928_e25868b4", "text": "Avoid this practice. Although the \nnames are unique, the association of each wi th a particular meaning is arbitrary and \nconfusing. Frd could just as easily be associated with final review duty and FRD with \nfull revenue disbursal , and no logical rule will help you or anyone else to remember \nwhich is which. 11.7 Kinds of Names to Avoid 287\nAvoid multiple natural languages In multinational projects, enforce use of a single \nnatural language for all code, including clas s names, variable name s, and so on. Read-\ning another programmer’s code can be a challenge; reading another programmer’s \ncode in Southeast Martian is impossible. A more subtle problem occurs in variations of English. If a project is conducted in \nmultiple English-speaking countries, standa rdize on one version of English so that \nyou’re not constantly wondering whether the code should say “color” or “colour,” \n“check” or “cheque,” and so on.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 928, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0929_82e116e8", "text": "Avoid the names of standard types, variables, and routines All programming-\nlanguage guides contain lists of the language’s reserved and predefined names. Read the list occasionally to make sure you’re not stepping on the toes of the language \nyou’re using. For example, the following code fragment is legal in PL/I, but you would \nbe a certifiable idiot to use it:\nif if = then then\n then = else;\nelse else = if;\nDon’t use names that are totally unrela ted to what the variables represent Sprin-\nkling names such as margaret and pookie throughout your program virtually guaran-\ntees that no one else will be able to unders tand it. Avoid your boyfriend’s name, wife’s \nname, favorite beer’s name, or other clever (aka silly) names for variables, unless the \nprogram is really about your boyfriend, wife, or favorite beer. Even then, you would be \nwise to recognize that each of these might change, and that therefore the generic \nnames boyfriend , wife, and favoriteBeer are superior!", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 929, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0930_cf5a9f03", "text": "Even then, you would be \nwise to recognize that each of these might change, and that therefore the generic \nnames boyfriend , wife, and favoriteBeer are superior! Avoid names containing hard-to-read characters Be aware that some characters look \nso similar that it’s hard to tell them apart. If the only difference between two names is \none of these characters, you might have a ha rd time telling the names apart. For exam-\nple, try to circle the name that doesn’ t belong in each of the following sets:\neyeChartl eyeChartI eyeChartl\nTTLCONFUSION TTLCONFUSION TTLC0NFUSION\nhard2Read hardZRead hard2Read\nGRANDTOTAL GRANDTOTAL 6RANDTOTAL\nttl5 ttlS ttlS\nPairs that are hard to distinguish include (1 and l), (1 and I), (. and ,), (0 and O), (2 \nand Z), (; and :), (S and 5), and (G and 6). Cross-Reference For consid-\nerations in using data, see \nthe checklist on page 257 in \nChapter 10, “General Issues \nin Using Variables.”\nDo details like these really matter? Indeed!", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 930, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0931_dc3ff791", "text": "Cross-Reference For consid-\nerations in using data, see \nthe checklist on page 257 in \nChapter 10, “General Issues \nin Using Variables.”\nDo details like these really matter? Indeed! Gerald Weinberg reports that in the 1970s, \na comma was used in a Fortran FORMAT statement where a period should have been \nused. The result was that scientists miscalcu lated a spacecraft’s trajectory and lost a \nspace probe—to the tune of $1.6 billion (Weinberg 1983). CODING \nHORROR\n288\nChapter 11: The Power of Variable Names\ncc2e.com/1191\nCHECKLIST: Naming Variables\nGeneral Naming Considerations\n❑\nDoes the name fully and accurately describe what the variable represents? ❑\nDoes the name refer to the real-world problem rather than to the program-\nming-language solution? ❑\nIs the name long enough that you don’t have to puzzle it out? ❑\nAre computed-value qualifiers, if any, at the end of the name? ❑\nDoes the name use Count or Index instead of Num ?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 931, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0932_e04bad93", "text": "❑\nIs the name long enough that you don’t have to puzzle it out? ❑\nAre computed-value qualifiers, if any, at the end of the name? ❑\nDoes the name use Count or Index instead of Num ? Naming Specific Kinds of Data\n❑\nAre loop index names meaningf ul (something other than i, j, or k if the \nloop is more than one or two lines long or is nested)? ❑\nHave all “temporary” variables been renamed to something more mean-\ningful? ❑\nAre boolean variables named so th at their meanings when they’re true are \nclear? ❑\nDo enumerated-type names include a pref ix or suffix that indicates the cat-\negory—for example, Color_ for Color_Red , Color_Green , Color_Blue , and so \non? ❑\nAre named constants named for the abstract entities they represent rather \nthan the numbers they refer to? Naming Conventions\n❑\nDoes the convention distinguish amon g local, class, and global data? ❑\nDoes the convention distinguish am ong type names, named constants, \nenumerated types, and variables?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 932, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0933_4a54a264", "text": "Naming Conventions\n❑\nDoes the convention distinguish amon g local, class, and global data? ❑\nDoes the convention distinguish am ong type names, named constants, \nenumerated types, and variables? ❑\nDoes the convention identify input-o nly parameters to routines in lan-\nguages that don’t enforce them? ❑\nIs the convention as compatible as possible with standard conventions for \nthe language? ❑\nAre names formatted for readability? Short Names\n❑\nDoes the code use long names (unless it’s necessary to use short ones)? ❑\nDoes the code avoid ab breviations that save only one character? ❑\nAre all words abbreviated consistently? Key Points 289\n❑\nAre the names pronounceable? ❑\nAre names that could be misread or mispronounced avoided? ❑\nAre short names documented in translation tables? Common Naming Problems : Have You Avoided... ❑\n...names that are misleading? ❑\n...names with similar meanings? ❑\n...names that are different by only one or two characters? ❑\n...names that sound similar? ❑\n...names that use numerals?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 933, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1016}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0934_526256c1", "text": "❑\n...names that are misleading? ❑\n...names with similar meanings? ❑\n...names that are different by only one or two characters? ❑\n...names that sound similar? ❑\n...names that use numerals? ❑\n...names intentionally misspel led to make them shorter? ❑\n...names that are commonly misspelled in English? ❑\n...names that conflict with standard library routine names or with pre-\ndefined variable names? ❑\n...totally arbitrary names? ❑\n...hard-to-read characters? Key Points\n■\nGood variable names are a key element of program readability. Specific kinds of \nvariables such as loop indexes and status variables require specific considerations. ■\nNames should be as specific as possibl e. Names that are vague enough or gen-\neral enough to be used for more than one purpose are usually bad names. ■\nNaming conventions distinguish among loca l, class, and global data. They dis-\ntinguish among type names, named consta nts, enumerated types, and variables.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 934, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0935_14ac0ad9", "text": "■\nNaming conventions distinguish among loca l, class, and global data. They dis-\ntinguish among type names, named consta nts, enumerated types, and variables. ■\nRegardless of the kind of project you’re working on, you should adopt a variable \nnaming convention. The kind of conventi on you adopt depends on the size of \nyour program and the number of people working on it. ■\nAbbreviations are rarely needed with mo dern programming languages. If you do \nuse abbreviations, keep track of abbrevia tions in a project dictionary or use the \nstandardized prefixes approach. ■\nCode is read far more times than it is written. Be sure that the names you choose \nfavor read-time convenience over write-time convenience.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 935, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 711}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0936_e68de127", "text": "■\nCode is read far more times than it is written. Be sure that the names you choose \nfavor read-time convenience over write-time convenience. 291\nChapter 12\nFundamental Data Types \ncc2e.com/1278\nContents\n■\n12.1 Numbers in General: page 292\n■\n12.2 Integers: page 293\n■\n12.3 Floating-Point Numbers: page 295\n■\n12.4 Characters and Strings: page 297\n■\n12.5 Boolean Variables: page 301\n■\n12.6 Enumerated Types: page 303\n■\n12.7 Named Constants: page 307\n■\n12.8 Arrays: page 310\n■\n12.9 Creating Your Own Types (Type Aliasing): page 311\nRelated Topics\n■\nNaming data: Chapter 11\n■\nUnusual data types: Chapter 13\n■\nGeneral issues in usin g variables: Chapter 10\n■\nFormatting data declarations: “Laying Out Data Declarations” in Section 31.5\n■\nDocumenting variables: “Commenting Data Declarations” in Section 32.5\n■\nCreating classes: Chapter 6\nThe fundamental data types are the basic buildi ng blocks for all other data types.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 936, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0937_a824288a", "text": "This \nchapter contains tips for using numbers (in general), integers, floating-point numbers, \ncharacters and strings, bool ean variables, enumerated types, named constants, and \narrays. The final section in this chapter describes how to create your own types. This chapter covers basic troubleshooting for the fundamental types of data. If you’ve \ngot your fundamental-data bases covered, skip to the end of the chapter, review the \nchecklist of problems to avoid, and move on to the discussion of unusual data types in \nChapter 13. 292\nChapter 12: Fundam ental Data Types\n12.1 Numbers in General\nHere are several guidelines for making your use of numbers less error-prone: \nCross-Reference For more \ndetails on using named con-\nstants instead of magic num-\nbers, see Section 12.7, \n“Named Constants,” later in \nthis chapter. Avoid “magic numbers” Magic numbers are literal numbers, such as 100 or 47524 , \nthat appear in the middle of a program without explanation.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 937, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0938_ff67838b", "text": "Avoid “magic numbers” Magic numbers are literal numbers, such as 100 or 47524 , \nthat appear in the middle of a program without explanation. If you program in a lan-\nguage that supports named constants, use them instead. If you can’t use named con-\nstants, use global variables when it’s feasible to do so. Avoiding magic numbers yields three advantages:\n■\nChanges can be made more reliably. If you use named constants, you won’t over-\nlook one of the 100s or change a 100 that refers to something else. ■\nChanges can be made more easily. When the maximum number of entries \nchanges from 100 to 200, if you’re using magic numbers you have to find all the \n100s and change them to 200s. If you use 100+1 or 100-1 , you’ll also have to find \nall the 101s and 99s and change them to 201s and 199s. If you’re using a named \nconstant, you simply change the definition of the constant from 100 to 200 in \none place. ■\nYour code is more readable. Sure, in the expression \nfor i = 0 to 99 do ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 938, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0939_2d600fa1", "text": "If you’re using a named \nconstant, you simply change the definition of the constant from 100 to 200 in \none place. ■\nYour code is more readable. Sure, in the expression \nfor i = 0 to 99 do ... you can guess that 99 refers to the maximum number of entries. But the expres-\nsion\nfor i = 0 to MAX_ENTRIES-1 do ... leaves no doubt. Even if you’re certain that a number will never change, you get \na readability benefit if you use a named constant. Use hard-coded 0s and 1s if you need to The values 0 and 1 are used to increment, \ndecrement, and start loops at the first element of an array. The 0 in \nfor i = 0 to CONSTANT do ... is OK, and the 1 in \ntotal = total + 1\nis OK. A good rule of thumb is that the only literals that should occur in the body of \na program are 0 and 1. Any other literals should be replaced with something more \ndescriptive.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 939, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 848}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0940_571780e0", "text": "A good rule of thumb is that the only literals that should occur in the body of \na program are 0 and 1. Any other literals should be replaced with something more \ndescriptive. Anticipate divide-by-zero errors Each time you use the division symbol (/ in most \nlanguages), think about whether it’s possible for the denominator of the expression to \nbe 0. If the possibility exists, write code to prevent a divide-by-zero error. 12.2 Integers 293\nMake type conversions obvious Make sure that someone reading your code will be \naware of it when a conversion between differ ent data types occurs. In C++ you could say\ny = x + (float) i\nand in Microsoft Visual Basic you could say \ny = x + CSng( i )\nThis practice also helps to ensure that the conversion is the one you want to occur—\ndifferent compilers do different conversions, so you’re taking your chances otherwise. Cross-Reference For a varia-\ntion on this example, see \n“Avoid equality compari-\nsons” in Section 12.3.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 940, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 969}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0941_cb5a8f2b", "text": "Cross-Reference For a varia-\ntion on this example, see \n“Avoid equality compari-\nsons” in Section 12.3. Avoid mixed-type comparisons If x is a floating-point number and i is an integer, the \ntest\nif ( i = x ) then ... is almost guaranteed not to work. By the time the compiler figures out which type it \nwants to use for the comparison, converts one of the types to the other, does a bunch \nof rounding, and determines the answer, you’ll be lucky if your program runs at all. Do the conversion manually so that the compiler can compare two numbers of the \nsame type and you know exactly what’s being compared. Heed your compiler’s warnings Many modern compilers tell you when you have dif-\nferent numeric types in the same expression. Pay attention! Every programmer has \nbeen asked at one time or another to help someone track down a pesky error, only to \nfind that the compiler had warned about the error all along. Top programmers fix \ntheir code to eliminate all compiler warnings.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 941, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0942_1cb4d193", "text": "Top programmers fix \ntheir code to eliminate all compiler warnings. It’s easier to let the compiler do the \nwork than to do it yourself. 12.2 Integers\nBear these considerations in mind when using integers:\nCheck for integer division When you’re using integers, 7/10 does not equal 0.7. It \nusually equals 0, or minus infinity, or the ne arest integer, or—you get the picture. What \nit equals varies from language to langua ge. This applies equally to intermediate \nresults. In the real world 10 * (7/10) = (10*7) / 10 = 7. Not so in the world of integer \narithmetic. 10 * (7/10) equals 0 because the integer division (7/10) equals 0. The eas-\niest way to remedy this problem is to reor der the expression so that the divisions are \ndone last: (10*7) / 10. Check for integer overflow When doing integer multiplica tion or addition, you need \nto be aware of the largest possible integer. The largest possible unsigned integer is \noften 2\n32\n-1 and is sometimes 2\n16\n-1, or 65,535.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 942, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0943_112cc498", "text": "The largest possible unsigned integer is \noften 2\n32\n-1 and is sometimes 2\n16\n-1, or 65,535. The problem comes up when you mul-\ntiply two numbers that produce a number bigger than the maximum integer. For \nKEY POINT\n294\nChapter 12: Fundamental Data Types\nexample, if you multiply 250 * 300, the right answer is 75,000. But if the maximum \ninteger is 65,535, the answer you’ll get is probably 9464 because of integer overflow \n(75,000 - 65,536 = 9464). Table 12-1 shows the ranges of common integer types. The easiest way to prevent integer overflow is to think through each of the terms in \nyour arithmetic expression and try to imagine the largest value each can assume. For \nexample, if in the integer expression m = j * k , the largest expected value for j is 200 \nand the largest expected value for k is 25, the largest value you can expect for m is 200 \n* 25 = 5,000 . This is OK on a 32-bit machine since the largest integer is 2,147,483,647.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 943, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0944_9d64dca1", "text": "This is OK on a 32-bit machine since the largest integer is 2,147,483,647. On the other hand, if the largest expected value for j is 200,000 and the largest \nexpected value for k is 100,000, the largest value you can expect for m is 200,000 * \n100,000 = 20,000,000,000 . This is not OK since 20,000,000,000 is larger than \n2,147,483,647. In this case, you would have to use 64-bit integers or floating-point \nnumbers to accommodate the largest expected value of m. Also consider future extensions to the program. If m will never be bigger than 5,000, \nthat’s great. But if you expect m to grow steadily for several years, take that into account. Check for overflow in intermediate results The number at the end of the equation \nisn’t the only number you have to worry about.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 944, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 774}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0945_544f1cec", "text": "Check for overflow in intermediate results The number at the end of the equation \nisn’t the only number you have to worry about. Suppose you have the following code:\nJava Example of Overflow of Intermediate Results\nint termA = 1000000;\nint termB = 1000000;\nint product = termA * termB / 1000000;\nSystem.out.println( \"( \" + termA + \" * \" + termB + \" ) / 1000000 = \" + product );\nIf you think the Product assignment is the same as (1,00,000*1,000,000) / 1,000 ,000, you \nmight expect to get the answer 1,000,000 . But the code has to compute the intermediate \nresult of 1,000,000*1,000,000 before it can divide by the final 1,000,000 , and that means \nit needs a number as big as 1,000,000,000,000 . Guess what?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 945, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 709}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0946_173f4d7e", "text": "But the code has to compute the intermediate \nresult of 1,000,000*1,000,000 before it can divide by the final 1,000,000 , and that means \nit needs a number as big as 1,000,000,000,000 . Guess what? Here’s the result:\n( 1000000 * 1000000 ) / 1000000 = -727\nTab le 12 - 1\nRanges for Different Types of Integers\nInteger Type\nRange\nSigned 8-bit -128 through 127\nUnsigned 8-bit 0 through 255\nSigned 16-bit -32,768 through 32,767\nUnsigned 16-bit 0 through 65,535\nSigned 32-bit -2,147,483,648 through 2,147,483,647\nUnsigned 32-bit 0 through 4,294,967,295\nSigned 64-bit -9,223,372,036,854,775,808 through \n9,223,372,036,854,775,807\nUnsigned 64-bit 0 through 18,446,744,073,709,551,615\nC12619670.fm Page 294 Tuesday, April 12, 2011 2:49 PM\n12.3 Floating-Point Numbers 295\nIf your integers go to only 2,147,483,647, the intermediate result is too large for the inte-\nger data type.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 946, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 871}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0947_eba3eb3d", "text": "In this case, the intermediate result that should be 1,000,000,000,000 is \n-727,379,968 , so when you divide by 1,000,000 , you get - 727, rather than 1,000,000 . You can handle overflow in intermediate results the same way you handle integer \noverflow, by switching to a long-integer or floating-point type. 12.3 Floating-Point Numbers\nThe main consideration in using floating-point numbers is that many fractional deci-\nmal numbers can’t be represented accurately using the 1s and 0s available on a digital \ncomputer. Nonterminating decimals like 1/3 or 1/7 can usually be represented to \nonly 7 or 15 digits of accuracy. In my version of Microsoft Visual Basic, a 32-bit float-\ning-point representation of 1/3 equals 0.33333330. It’s accurate to 7 digits. This is \naccurate enough for most purposes but inaccurate enough to trick you sometimes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 947, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 847}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0948_5ada31aa", "text": "It’s accurate to 7 digits. This is \naccurate enough for most purposes but inaccurate enough to trick you sometimes. Following are a few specific guidelines for using floating-point numbers:\nCross-Reference For algo-\nrithms books that describe \nways to solve these prob-\nlems, see “Additional \nResources on Data Types” in \nSection 10.1. Avoid additions and subtractions on numbers that have greatly different magnitudes\nWith a 32-bit floating-point variable, 1,000,000.00 + 0.1 probably produces an answer of \n1,000,000.00 because 32 bits don’t give you enough significant digits to encompass the \nrange between 1,000,000 and 0.1. Likewise, 5,000,000.02 - 5,000,000.01 is probably 0.0. Solutions? If you have to add a sequence of numbers that contains huge differences \nlike this, sort the numbers first, and then add them starting with the smallest values. Likewise, if you need to sum an infinite series, start with the smallest term—essentially, \nsum the terms backwards.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 948, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0949_faaf7e2b", "text": "Likewise, if you need to sum an infinite series, start with the smallest term—essentially, \nsum the terms backwards. This doesn’t eliminate round-off problems, but it mini-\nmizes them. Many algorithms books have suggestions for dealing with cases like this. 1 is equal to 2 for sufficiently \nlarge values of 1. —Anonymous \nAvoid equality comparisons Floating-point numbers that should be equal are not \nalways equal. The main problem is that two different paths to the same number don’t \nalways lead to the same number. For example, 0.1 added 10 times rarely equals 1.0. The \nfollowing example shows two variables, nominal and sum, that should be equal but aren’t. Java Example of a Bad Comparison of Floating-Point Numbers \nThe variable nominal is a\n64-bit real. double nominal = 1.0;\ndouble sum = 0.0;\nfor ( int i = 0; i < 10; i++ ) {\nsum is 10*0.1. It should be \n1.0. sum += 0.1;\n}\nHere’s the bad comparison.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 949, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0950_8bd121f0", "text": "double nominal = 1.0;\ndouble sum = 0.0;\nfor ( int i = 0; i < 10; i++ ) {\nsum is 10*0.1. It should be \n1.0. sum += 0.1;\n}\nHere’s the bad comparison. if ( nominal == sum ) {\n System.out.println( \"Numbers are the same.\" );\n}\nelse {\n System.out.println( \"Numbers are different.\" );\n}\nKEY POINT\nC12619670.fm Page 295 Tuesday, April 12, 2011 2:50 PM\n296\nChapter 12: Fundam ental Data Types\nAs you can probably guess, the output from this program is\nNumbers are different. The line-by-line values of sum in the for loop look like this:\n0.1\n0.2\n0.30000000000000004\n0.4\n0.5\n0.6\n0.7\n0.7999999999999999\n0.8999999999999999\n0.9999999999999999\nThus, it’s a good idea to find an alternativ e to using an equality comparison for float-\ning-point numbers. One effective approach is to determine a range of accuracy that is \nacceptable and then use a bool ean function to determine whether the values are close \nenough.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 950, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 901}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0951_d161f6fd", "text": "One effective approach is to determine a range of accuracy that is \nacceptable and then use a bool ean function to determine whether the values are close \nenough. Typically, you’d write an Equals() function that returns true if the values are \nclose enough and false otherwise. In Java, such a function would look like this:\nCross-Reference This exam-\nple is proof of the maxim \nthat there’s an exception to \nevery rule. Variables in this \nrealistic example have digits \nin their names.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 951, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 486}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0952_54c285af", "text": "Variables in this \nrealistic example have digits \nin their names. For the rule \nagainst using digits in vari-\nable names, see Section \n11.7, “Kinds of Names to \nAvoid.”\nJava Example of a Routine to Compare Floating-Point Numbers \nfinal double ACCEPTABLE_DELTA = 0.00001;\nboolean Equals( double Term1, double Term2 ) { \n if ( Math.abs( Term1 - Term2 ) < ACCEPTABLE_DELTA ) {\n return true;\n }\n else {\n return false;\n }\n}\nIf the code in the “bad comparison of floating-point numbers” example were con-\nverted so that this routine could be used for comparisons, the new comparison would \nlook like this:\nif ( Equals( Nominal, Sum ) ) ... The output from the program when it uses this test is \nNumbers are the same. Depending on the demands of your applicat ion, it might be inappropriate to use a \nhard-coded value for ACCEPTABLE_DELTA . You might need to compute \nACCEPTABLE_DELTA based on the size of the two numbers being compared.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 952, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0953_20d06eb3", "text": "You might need to compute \nACCEPTABLE_DELTA based on the size of the two numbers being compared. 12.4 Characters and Strings 297\nAnticipate rounding errors Rounding-error problems are no different from the prob-\nlem of numbers with greatly different magn itudes. The same issue is involved, and \nmany of the same techniques help to solv e rounding problems. In addition, here are \ncommon specific solutions to rounding problems: \n■\nChange to a variable type that has greate r precision. If you’re using single-preci-\nsion floating point, change to double -precision floating point, and so on. Cross-Reference Usually the \nperformance impact of con-\nverting to BCD will be mini-\nmal. If you’re concerned \nabout the performance \nimpact, see Section 25.6, \n“Summary of the Approach \nto Code Tuning.”■\nChange to binary coded d ecimal (BCD) variables. The BCD scheme is typically \nslower and takes up more storage space, but it prevents many rounding errors.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 953, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0954_05011b16", "text": "The BCD scheme is typically \nslower and takes up more storage space, but it prevents many rounding errors. This is particularly valuable if the variables you’re using represent dollars and \ncents or other quantities that must balance precisely. ■\nChange from floating-point to integer variables. This is a roll-your-own approach \nto BCD variables. You will probably have to use 64-bit integers to get the preci-\nsion you want. This technique requires you to keep track of the fractional part of \nyour numbers yourself. Suppose you were originally keeping track of dollars \nusing floating point with cents expressed as fractional parts of dollars. This is a \nnormal way to handle dollars and cents. When you switch to integers, you have \nto keep track of cents using integers and of dollars using multiples of 100 cents. In other words, you multiply dollars by 100 and keep the cents in the 0-to-99 \nrange of the variable.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 954, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0955_affe1224", "text": "In other words, you multiply dollars by 100 and keep the cents in the 0-to-99 \nrange of the variable. This might seem absurd at first glance, but it’s an effective \nsolution in terms of both speed and accuracy. You can make these manipula-\ntions easier by creating a DollarsAndCents class that hides the integer representa-\ntion and supports the necessary numeric operations. Check language and library support for specific data types Some languages, includ-\ning Visual Basic, have data types such as Currency that specifically support data that is \nsensitive to rounding errors. If your language has a built-in data type that provides \nsuch functionality, use it! 12.4 Characters and Strings\nThis section provides some tips for using st rings. The first applies to strings in all \nlanguages.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 955, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 792}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0956_23f73795", "text": "12.4 Characters and Strings\nThis section provides some tips for using st rings. The first applies to strings in all \nlanguages. Cross-Reference Issues for \nusing magic characters and \nstrings are similar to those \nfor magic numbers dis-\ncussed in Section 12.1, \n“Numbers in General.”\nAvoid magic characters and strings Magic characters are lite ral characters (such as \n'A') and magic strings are li teral strings (such as \"Gigamatic Accounting Program\" ) that \nappear throughout a program. If you program in a language that supports the use of \nnamed constants, use them instead. Otherwis e, use global variables. Several reasons \nfor avoiding literal strings exist:\n■\nFor commonly occurring strings like the name of your program, command \nnames, report titles, and so on, you mi ght at some point need to change the \nstring’s contents. For example, \"Gigamatic Accounting Program\" might change to \n\"New and Improved! Gigamatic Accounting Program\" for a later version.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 956, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0957_a6d02f64", "text": "For example, \"Gigamatic Accounting Program\" might change to \n\"New and Improved! Gigamatic Accounting Program\" for a later version. 298\nChapter 12: Fundam ental Data Types\n■\nInternational markets are becoming increa singly important, and it’s easier to \ntranslate strings that are gro uped in a string resource file than it is to translate to \nthem in situ throughout a program. ■\nString literals tend to take up a lot of space. They’re used for menus, messages, \nhelp screens, entry forms, and so on. If you have too many, they grow beyond \ncontrol and cause memory problems. String space isn’t a concern in many envi-\nronments, but in embedded systems programming and other applications in \nwhich storage space is at a premium, solutions to string-space problems are eas-\nier to implement if the strings are relatively independent of the source code. ■\nCharacter and string literals are crypti c. Comments or named constants clarify \nyour intentions. In the next example, the meaning of 0x1B isn’t clear.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 957, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0958_fdf9b9bf", "text": "■\nCharacter and string literals are crypti c. Comments or named constants clarify \nyour intentions. In the next example, the meaning of 0x1B isn’t clear. The use of \nthe ESCAPE constant makes the meaning more obvious. C+ + Examples of Comparisons Using Strings \nBad! if ( input_char == 0x1B ) ... Better! if ( input_char == ESCAPE ) ... Watch for off-by-one errors Because substrings can be indexed much as arrays are, \nwatch for off-by-one errors that read or write past the end of a string. cc2e.com/1285\nKnow how your language and environment support Unicode In some languages \nsuch as Java, all strings are Unicode. In ot hers such as C and C++, handling Unicode \nstrings requires its own set of functions. Conversion between Unicode and other char-\nacter sets is often required for communication with standard and third-party libraries. If some strings won’t be in Unicode (for example, in C or C++), decide early on \nwhether to use the Unicode character set at all.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 958, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0959_aa2cdfc6", "text": "If some strings won’t be in Unicode (for example, in C or C++), decide early on \nwhether to use the Unicode character set at all. If you decide to use Unicode strings, \ndecide where and when to use them. Decide on an internationalization/localization strategy early in the lifetime of a \nprogram Issues related to internationalization and localization are major issues. Key \nconsiderations are deciding whether to stor e all strings in an external resource and \nwhether to create separate builds for each language or to determine the specific lan-\nguage at run time. cc2e.com/1292\nIf you know you only need to support a sing le alphabetic language, consider using an \nISO 8859 character set For applications that need to support only a single alpha-\nbetic language (such as English) and that don’t need to support multiple languages or \nan ideographic language (such as writte n Chinese), the ISO 8859 extended-ASCII-\ntype standard makes a good alternative to Unicode.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 959, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0960_6f6fda16", "text": "12.4 Characters and Strings 299\nIf you need to support mult iple languages, use Unicode Unicode provides more com-\nprehensive support for international character sets than ISO 8859 or other standards. Decide on a consistent conversi on strategy among string types If you use multiple \nstring types, one common approa ch that helps keep the string types distinct is to keep \nall strings in a single format within the program and convert the strings to other for-\nmats as close as possible to input and output operations. Strings in C\nC++’s standard template library string cla ss has eliminated most of the traditional \nproblems with strings in C. For those programmers working directly with C strings, \nhere are some ways to avoid common pitfalls: \nBe aware of the difference between string pointers and character arrays The prob-\nlem with string pointers and character arrays arises because of the way C handles \nstrings.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 960, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0961_88735ce7", "text": "Be alert to the difference between them in two ways: \n■\nBe suspicious of any expression containing a string that involves an equal sign. String operations in C are nearly always done with strcmp() , strcpy() , strlen() , and \nrelated routines. Equal signs often imply some kind of pointer error. In C, \nassignments do not copy string literals to a string variable. Suppose you have a \nstatement like\nStringPtr = \"Some Text String\";\nIn this case, \"Some Text String\" is a pointer to a literal text string and the assign-\nment merely sets the pointer StringPtr to point to the text string. The assignment \ndoes not copy the contents to StringPtr . ■\nUse a naming convention to indicate whet her the variables are arrays of charac-\nters or pointers to strings. One common convention is to use ps as a prefix to \nindicate a pointer to a string and ach as a prefix for an array of characters . Although they’re not always wrong, you should regard expressions involving \nboth ps and ach prefixes with suspicion.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 961, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0962_e6bf4221", "text": "Although they’re not always wrong, you should regard expressions involving \nboth ps and ach prefixes with suspicion. Declare C-style string s to have length CONSTANT+1 In C and C++, off-by-one \nerrors with C-style strings are common becaus e it’s easy to forget that a string of \nlength n requires n + 1 bytes of storage and to forget to leave room for the null termi-\nnator (the byte set to 0 at the end of the string). An effective way to avoid such prob-\nlems is to use named constants to declare all strings. A key in this approach is that you \nuse the named constant the same way every time. Declare the string to be length CON-\nSTANT+1 , and then use CONSTANT to refer to the length of a string in the rest of the \ncode. Here’s an example:\n300\nChapter 12: Fundam ental Data Types\nC Example of Good String Declarations\n/* Declare the string to have length of \"constant+1\". Every other place in the program, \"constant\" rather \n than \"constant+1\" is used.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 962, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 958}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0963_59fe356c", "text": "Every other place in the program, \"constant\" rather \n than \"constant+1\" is used. */\nThe string is declared to be of \nlength NAME_LENGTH +1 . char name[ NAME_LENGTH + 1 ] = { 0 }; /* string of length NAME_LENGTH */\n... /* Example 1: Set the string to all 'A's using the constant,\n NAME_LENGTH, as the number of 'A's that can be copied. Note that NAME_LENGTH rather than NAME_LENGTH + 1 is used. */\nOperations on the string \nusing NAME_LENGTH \nhere…\nfor ( i = 0; i < NAME_LENGTH; i++ )\n name[ i ] = 'A';\n... /* Example 2: Copy another string into the first string using \n the constant as the maximum length that can be copied. */\n…and here. strncpy( name, some_other_name, NAME_LENGTH );\nIf you don’t have a convention to handle this, you’ll sometimes declare the string to be \nof length NAME_LENGTH and have operations on it with NAME_ LENGTH-1 ; at other \ntimes you’ll declare the string to be of length NAME_LENGTH+1 and have operations \non it work with length NAME_LENGTH .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 963, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0964_7b5164b2", "text": "Every time you use a string, you’ll have to \nremember which way you declared it. When you use strings the same way every time, you don’t have to remember how you \ndealt with each string individually and yo u eliminate mistakes caused by forgetting \nthe specifics of an individual string. Having a convention minimizes mental overload \nand programming errors. Cross-Reference For more \ndetails on initializing data, \nsee Section 10.3, “Guidelines \nfor Initializing Variables.”\nInitialize strings to null to avoid endless strings C determines the end of a string by \nfinding a null terminator, a byte set to 0 at the end of the string. No matter how long \nyou think the string is, C doesn’t find the end of the string until it finds a 0 byte. If you \nforget to put a null at the end of the string, your string operations might not act the \nway you expect them to. You can avoid endless strings in two ways.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 964, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 904}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0965_bb6745ea", "text": "If you \nforget to put a null at the end of the string, your string operations might not act the \nway you expect them to. You can avoid endless strings in two ways. Fi rst, initialize arrays of characters to 0 \nwhen you declare them:\nC Example of a Good Declaration of a Character Array\nchar EventName[ MAX_NAME_LENGTH + 1 ] = { 0 };\nSecond, when you allocate strings dynamically, initialize them to 0 by using calloc() \ninstead of malloc() . calloc() allocates memory and initializes it to 0. malloc() allocates \nmemory without initializing it, so you take your chances when you use memory allo-\ncated by malloc() . 12.5 Boolean Variables 301\nCross-Reference For more \ndiscussion of arrays, read \nSection 12.8, “Arrays,” later in \nthis chapter. Use arrays of characters instead of pointers in C If memory isn’t a constraint—and \noften it isn’t—declare all your string variab les as arrays of characters.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 965, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 903}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0966_19223184", "text": "Use arrays of characters instead of pointers in C If memory isn’t a constraint—and \noften it isn’t—declare all your string variab les as arrays of characters. This helps to \navoid pointer problems, and the compiler will give you more warnings when you do \nsomething wrong. Use strncpy() instead of strcpy() to avoid endless strings String routines in C come \nin safe versions and dangerous versions. The more dangerous routines such as strcpy() \nand strcmp() keep going until they run into a null terminator. Their safer companions, \nstrncpy() and strncmp() , take a parameter for maximum length so that even if the \nstrings go on forever, your function calls won’t. 12.5 Boolean Variables\nIt’s hard to misuse logical or boolean va riables, and using them thoughtfully makes \nyour program cleaner.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 966, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 797}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0967_98e67d85", "text": "12.5 Boolean Variables\nIt’s hard to misuse logical or boolean va riables, and using them thoughtfully makes \nyour program cleaner. Cross-Reference For details \non using comments to docu-\nment your program, see \nChapter 32, “Self-Document-\ning Code.”\nUse boolean variables to document your program Instead of merely testing a bool-\nean expression, you can assign the expression to a variable that makes the implication \nof the test unmistakable. For example, in the next fragment, it’s not clear whether the \npurpose of the if test is to check for completion, fo r an error condition, or for some-\nthing else:\nCross-Reference For an \nexample of using a boolean \nfunction to document your \nprogram, see “Making Com-\nplicated Expressions Simple” \nin Section 19.1. Java Example of Boolean Test in Which the Purpose Is Unclear\nif ( ( elementIndex < 0 ) || ( MAX_ELEMENTS < elementIndex ) ||\n ( elementIndex == lastElementIndex ) \n ) {\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 967, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 934}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0968_a13def8a", "text": "Java Example of Boolean Test in Which the Purpose Is Unclear\nif ( ( elementIndex < 0 ) || ( MAX_ELEMENTS < elementIndex ) ||\n ( elementIndex == lastElementIndex ) \n ) {\n ... }\nIn the next fragment, the use of boolean variables makes the purpose of the if test \nclearer:\nJava Example of Boolean Test in Which the Purpose Is Clear \nfinished = ( ( elementIndex < 0 ) || ( MAX_ELEMENTS < elementIndex ) );\nrepeatedEntry = ( elementIndex == lastElementIndex );\nif ( finished || repeatedEntry ) {\n ... }\nUse boolean variables to simplify complicated tests Often, when you have to code a \ncomplicated test, it takes several tries to get it right. When you later try to modify the \ntest, it can be hard to understand what the test was doing in the first place. Logical \nvariables can simplify the test. In the previo us example, the program is really testing \nfor two conditions: whether the routine is finished and whether it’s working on a \nrepeated entry.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 968, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0969_a86df435", "text": "Logical \nvariables can simplify the test. In the previo us example, the program is really testing \nfor two conditions: whether the routine is finished and whether it’s working on a \nrepeated entry. By creating the boolean variables finished and repeatedEntry , you make \nthe if test simpler: easier to read, less error prone, and easier to modify. 302\nChapter 12: Fundam ental Data Types\nHere’s another example of a complicated test:\nVisual Basic Example of a Complicated Test\nIf ( ( document.AtEndOfStream() ) And ( Not inputError ) ) And _\n ( ( MIN_LINES <= lineCount ) And ( lineCount <= MAX_LINES ) ) And _\n ( Not ErrorProcessing() ) Then\n ' do something or other\n ... End If\nThe test in the example is fairly complica ted but not uncommonly so. It places a heavy \nmental burden on the reader.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 969, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 797}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0970_79614af4", "text": "End If\nThe test in the example is fairly complica ted but not uncommonly so. It places a heavy \nmental burden on the reader. My guess is that you won’t even try to understand the if \ntest but will look at it and say, “I’ll figure it out later if I really need to.” Pay attention to \nthat thought because that’s exactly the same thing other people do when they read \nyour code and it contains tests like this. Here’s a rewrite of the code with boolea n variables added to simplify the test:\nVisual Basic Example of a Simplified Test\nallDataRead = ( document.AtEndOfStream() ) And ( Not inputError )\nlegalLineCount = ( MIN_LINES <= lineCount ) And ( lineCount <= MAX_LINES )\nHere’s the simplified test. If ( allDataRead ) And ( legalLineCount ) And ( Not ErrorProcessing() ) Then\n ' do something or other\n ... End If \nThis second version is simpler. My guess is that you’ll read the boolean expression in \nthe if test without any difficulty.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 970, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0971_3608502c", "text": "End If \nThis second version is simpler. My guess is that you’ll read the boolean expression in \nthe if test without any difficulty. Create your own boolean type, if necessary Some languages, such as C++, Java, and \nVisual Basic have a predefined boolean type. Others, such as C, do not. In languages \nsuch as C, you can define your own boolean type. In C, you’d do it this way:\nC Example of Defining the BOOLEAN Type Using a Simple typedef\ntypedef int BOOLEAN;\nOr you could do it this way, which provides the added benefit of defining true and \nfalse at the same time:\nC Example of Defining the Boolean Type Using an Enum\nenum Boolean { \n True=1, \n False=(!True) \n};\nCODING \nHORROR\n12.6 Enumerated Types 303\nDeclaring variables to be BOOLEAN rather than int makes their intended use more \nobvious and makes your program a little more self-documenting. 12.6 Enumerated Types\nAn enumerated type is a type of data that allows each member of a class of objects to \nbe described in English.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 971, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0972_38bc2df8", "text": "12.6 Enumerated Types\nAn enumerated type is a type of data that allows each member of a class of objects to \nbe described in English. Enumerated types are available in C++ and Visual Basic and \nare generally used when you know all the po ssible values of a variable and want to \nexpress them in words.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 972, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 301}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0973_b6e9ae25", "text": "Enumerated types are available in C++ and Visual Basic and \nare generally used when you know all the po ssible values of a variable and want to \nexpress them in words. Here are some exam ples of enumerated types in Visual Basic:\nVisual Basic Examples of Enumerated Types \nPublic Enum Color\n Color_Red\n Color_Green\n Color_Blue\nEnd Enum \nPublic Enum Country\n Country_China\n Country_England\n Country_France\n Country_Germany\n Country_India\n Country_Japan\n Country_Usa\nEnd Enum \nPublic Enum Output\n Output_Screen\n Output_Printer\n Output_File\nEnd Enum \nEnumerated types are a powerful alternative to shopworn schemes in which you \nexplicitly say, “1 stands for red, 2 stands for green, 3 stands for blue....” This ability \nsuggests several guidelines for using enumerated types:\nUse enumerated types for readability Instead of writing statements like \nif chosenColor = 1\nyou can write more readable expressions like \nif chosenColor = Color_Red\nAnytime you see a numeric literal, ask whether it makes sense to replace it with an \nenumerated type.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 973, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1039}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0974_e3ca8a9e", "text": "Enumerated types are especially useful fo r defining routine parameters. Who knows \nwhat the parameters to this function call are? 304\nChapter 12: Fundam ental Data Types\nC+ + Examples of a Routine Call That Would be Better with Enumerated Types\nint result = RetrievePayrollData( data, true, false, false, true );\nIn contrast, the parameters to this function call are more understandable:\nC+ + Examples of a Routine Call That Uses Enumerated Types for Readability\nint result = RetrievePayrollData( \n data, \n EmploymentStatus_CurrentEmployee, \n PayrollType_Salaried, \n SavingsPlan_NoDeduction, \n MedicalCoverage_IncludeDependents\n);\nUse enumerated types for reliability With a few languages (Ada in particular), an \nenumerated type lets the compiler perform more thorough type checking than it can \nwith integer values and constants. With na med constants, the compiler has no way of \nknowing that the only legal values are Color_Red , Color_Green , and Color_Blue .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 974, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0975_fac5aa3e", "text": "With na med constants, the compiler has no way of \nknowing that the only legal values are Color_Red , Color_Green , and Color_Blue . The \ncompiler won’t object to statements like color = Country_England or country = \nOutput_Printer . If you use an enumerated type, declaring a variable as Color , the com-\npiler will allow the variable to be assigned only the values Color_Red , Color_Green , and \nColor_Blue . Use enumerated types for modifiability Enumerated types make your code easy to \nmodify. If you discover a flaw in your “1 stands for red, 2 stands for green, 3 stands for \nblue” scheme, you have to go through your code and change all the 1s, 2s, 3s, and so \non. If you use an enumerated type, you can co ntinue adding elements to the list just \nby putting them into the type definition and recompiling. Use enumerated types as an alternative to boolean variables Often, a boolean vari-\nable isn’t rich enough to express the meanings it needs to.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 975, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0976_eab55bd7", "text": "Use enumerated types as an alternative to boolean variables Often, a boolean vari-\nable isn’t rich enough to express the meanings it needs to. For example, suppose you \nhave a routine return true if it has successfully performed its task and False otherwise. Later you might find that you really have two kinds of False . The first kind means that \nthe task failed and the effects are limited to the routine itself; the second kind means \nthat the task failed and caused a fatal error that will need to be propagated to the rest \nof the program. In this case, an enumerated type with the values Status_Success , \nStatus_Warning , and Status_FatalError would be more useful than a boolean with the \nvalues true and false. This scheme can easily be expand ed to handle additional distinc-\ntions in the kinds of success or failure. Check for invalid values When you test an enumerated type in an if or case statement, \ncheck for invalid values.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 976, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 941}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0977_6aadcffe", "text": "Check for invalid values When you test an enumerated type in an if or case statement, \ncheck for invalid values. Use the else clause in a case statement to trap invalid values:\nCODING \nHORROR\n12.6 Enumerated Types 305\nGood Visual Basic Example of Checking for Invalid Values in an Enumerated Type\nSelect Case screenColor\n Case Color_Red\n ... Case Color_Blue\n ... Case Color_Green\n ... Here’s the test for the \ninvalid value. Case Else\n DisplayInternalError( False, \"Internal Error 752: Invalid color.\" )\nEnd Select\nDefine the first and last entries of an enumeration for use as loop limits Defining \nthe first and last elements in an enumeration to be Color_First , Color_Last , \nCountry_First , Country_Last , and so on allows you to write a loop that loops through \nthe elements of an enumeration.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 977, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 799}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0978_3a5707ba", "text": "You set up the enumerated type by using explicit val-\nues, as shown here:\nVisual Basic Example of Setting First and Last Values in an Enumerated Type\nPublic Enum Country\n Country_First = 0 \n Country_China = 0\n Country_England = 1\n Country_France = 2\n Country_Germany = 3\n Country_India = 4\n Country_Japan = 5\n Country_Usa = 6\n Country_Last = 6\nEnd Enum \nNow the Country_First and Country_Last values can be used as loop limits:\nGood Visual Basic Example of Looping Through Elements in an Enumeration\n' compute currency conversions from US currency to target currency\nDim usaCurrencyConversionRate( Country_Last ) As Single\nDim iCountry As Country\nFor iCountry = Country_First To Country_Last\n usaCurrencyConversionRate( iCountry ) = ConversionRate( Country_Usa, iCountry )\nNext\nReserve the first entry in the enumerated type as invalid When you declare an enu-\nmerated type, reserve the first value as an invalid value. Many compilers assign the \nfirst element in an enumerated type to the value 0.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 978, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0979_24f8daa3", "text": "Many compilers assign the \nfirst element in an enumerated type to the value 0. Declaring the element that’s \nmapped to 0 to be invalid helps to catch variables that were not properly initialized \nbecause they are more likely to be 0 than any other invalid value. 306\nChapter 12: Fundam ental Data Types\nHere’s how the Country declaration would look with that approach: \nVisual Basic Example of Declaring the First Value in an Enumeration to Be Invalid\nPublic Enum Country\n Country_InvalidFirst = 0 \n Country_First = 1\n Country_China = 1\n Country_England = 2\n Country_France = 3\n Country_Germany = 4\n Country_India = 5\n Country_Japan = 6\n Country_Usa = 7\n Country_Last = 7\nEnd Enum \nDefine precisely how First and Last elements are to be used in the project coding \nstandard, and use them consistently Using InvalidFirst , First, and Last elements in \nenumerations can make array declarations and loops more readable.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 979, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0980_7b927254", "text": "But it has the \npotential to create confusion about whether the valid entries in the enumeration \nbegin at 0 or 1 and whether the first and last elemen ts of the enumeration are valid. If \nthis technique is used, the project’s coding standard should require that InvalidFirst , \nFirst, and Last elements be used consistently in all enumerations to reduce errors. Beware of pitfalls of assigning explicit values to elements of an enumeration Some \nlanguages allow you to assign specific values to elements within an enumeration, as \nshown in this C++ example:\nC+ + Example of Explicitly Assigning Values to an Enumeration\nenum Color {\n Color_InvalidFirst = 0,\n Color_First = 1,\n Color_Red = 1,\n Color_Green = 2,\n Color_Blue = 4,\n Color_Black = 8,\n Color_Last = 8\n};\nIn this example, if you declared a loop index of type Color and attempted to loop \nthrough Color s, you would loop through the invalid values of 3, 5, 6, and 7 as well as \nthe valid values of 1, 2, 4, and 8.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 980, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0981_a6a2353e", "text": "12.7 Named Constants 307\nIf Your Language Doesn’t Have Enumerated Types\nIf your language doesn’t have enumerated types, you can simulate them with global \nvariables or classes. For example, you could use these declarations in Java:\nCross-Reference At the time \nI’m writing this, Java does \nnot support enumerated \ntypes. By the time you read \nthis, it probably will.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 981, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 366}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0982_a438e092", "text": "For example, you could use these declarations in Java:\nCross-Reference At the time \nI’m writing this, Java does \nnot support enumerated \ntypes. By the time you read \nthis, it probably will. This is a \ngood example of the “rolling \nwave of technology” dis-\ncussed in Section 4.3, “Your \nLocation on the Technology \nWave.”\nJava Example of Simulating Enumerated Types\n// set up Country enumerated type\nclass Country {\n private Country() {}\n public static final Country China = new Country();\n public static final Country England = new Country();\n public static final Country France = new Country();\n public static final Country Germany = new Country();\n public static final Country India = new Country();\n public static final Country Japan = new Country();\n}\n// set up Output enumerated type\nclass Output {\n private Output() {}\n public static final Output Screen = new Output();\n public static final Output Printer = new Output();\n public static final Output File = new Output();\n}\nThese enumerated types make your program more readable because you can use the \npublic class members such as Country.England and Output.Screen instead of named \nconstants.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 982, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1150}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0983_f15adda4", "text": "This particular method of crea ting enumerated types is also typesafe; \nbecause each type is declared as a class, the compiler will check for invalid assign-\nments such as Output output = Country.England (Bloch 2001). In languages that don’t support classes, you can achieve the same basic effect through \ndisciplined use of global variables for ea ch of the elements of the enumeration. 12.7 Named Constants\nA named constant is like a variable except that you can’t change the constant’s value \nonce you’ve assigned it. Named constants enable you to refer to fixed quantities, such \nas the maximum number of employees, by a name rather than a number—\nMAXIMUM_EMPLOYEES rather than 1000 , for instance. Using a named constant is a way of “parameterizing” your program—putting an aspect \nof your program that might change into a parameter that you can change in one place \nrather than having to make changes throughout the program.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 983, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 930}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0984_fdc64c6e", "text": "If you have ever \ndeclared an array to be as big as you think it will ever need to be and then run out of \nspace because it wasn’t big enough, you ca n appreciate the value of named constants. 308\nChapter 12: Fundam ental Data Types\nWhen an array size changes, you change only the definition of the constant you used \nto declare the array. This “single-point control” goes a long way toward making soft-\nware truly “soft”: easy to work with and change. Use named constants in data declarations Using named constants helps program \nreadability and maintainability in data decl arations and in statements that need to \nknow the size of the data they are working with. In the following example, you use \nLOCAL_NUMBER_LENGTH to describe the length of employee phone numbers \nrather than the literal 7. Good Visual Basic Example of Using a Named Constant in a Data Declaration \nConst AREA_CODE_LENGTH = 3\nLOCAL_NUMBER_LENGTH \nis declared as a constant \nhere. Const LOCAL_NUMBER_LENGTH = 7\n...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 984, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0985_9357575d", "text": "Good Visual Basic Example of Using a Named Constant in a Data Declaration \nConst AREA_CODE_LENGTH = 3\nLOCAL_NUMBER_LENGTH \nis declared as a constant \nhere. Const LOCAL_NUMBER_LENGTH = 7\n... Type PHONE_NUMBER\n areaCode( AREA_CODE_LENGTH ) As String\nIt’s used here. localNumber( LOCAL_NUMBER_LENGTH ) As String\nEnd Type\n... ' make sure all characters in phone number are digits \nIt’s used here, too. For iDigit = 1 To LOCAL_NUMBER_LENGTH \n If ( phoneNumber.localNumber( iDigit ) < \"0\" ) Or _\n ( \"9\" < phoneNumber.localNumber( iDigit ) ) Then\n ' do some error processing\n ... This is a simple example, but you can probably imagine a program in which the infor-\nmation about the phone-number leng th is needed in many places. At the time you create the program, the employees all live in one country, so you need \nonly seven digits for their phone numbers. As the company expands and branches are \nestablished in different countries, you’ll need longer phone numbers.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 985, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0986_3c010c61", "text": "As the company expands and branches are \nestablished in different countries, you’ll need longer phone numbers. If you have \nparameterized, you can make the change in only one place: in the definition of the \nnamed constant LOCAL_NUMBER_LENGTH . Further Reading For more \ndetails on the value of \nsingle-point control, see \npages 57–60 of Software \nConflict (Glass 1991). As you might expect, the use of named constants has been shown to greatly aid program \nmaintenance. As a general rule, any technique that centralizes control over things that \nmight change is a good technique for reducing maintenance efforts (Glass 1991). Avoid literals, even “safe” ones In the following loop, what do you think the 12 \nrepresents? Visual Basic Example of Unclear Code \nFor i = 1 To 12\n profit( i ) = revenue( i ) – expense( i )\nNext\n12.7 Named Constants 309\nBecause of the specific nature of the code, it appears that the code is probably looping \nthrough the 12 months in a year. But are you sure?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 986, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0987_78a23b14", "text": "But are you sure? Would you bet your Monty Python \ncollection on it? In this case, you don’t need to use a named co nstant to support future flexibility: it’s \nnot very likely that the number of months in a year will change anytime soon.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 987, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 237}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0988_1950e0a7", "text": "In this case, you don’t need to use a named co nstant to support future flexibility: it’s \nnot very likely that the number of months in a year will change anytime soon. But if \nthe way the code is written leaves any shadow of a doubt about its purpose, clarify it \nwith a well-named constant, like this:\nVisual Basic Example of Clearer Code \nFor i = 1 To NUM_MONTHS_IN_YEAR \n profit( i ) = revenue( i ) – expense( i )\nNext\nThis is better, but, to complete the example, the loop index should also be named \nsomething more informative:\nVisual Basic Example of Even Clearer Code \nFor month = 1 To NUM_MONTHS_IN_YEAR \n profit( month ) = revenue( month ) – expense( month )\nNext\nThis example seems quite good, but we can push it even one step further by using an \nenumerated type:\nVisual Basic Example of Very Clear Code \nFor month = Month_January To Month_December\n profit( month ) = revenue( month ) – expense( month )\nNext\nWith this final example, there can be no doubt about the purpose of the loop.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 988, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0989_d13038e1", "text": "Even \nif you think a literal is safe, use named constants instead. Be a fanatic about rooting \nout literals in your code. Use a text editor to search for 2, 3, 4, 5, 6, 7, 8, and 9 to make \nsure you haven’t used them accidentally. Cross-Reference For details \non simulating enumerated \ntypes, see “If Your Language \nDoesn’t Have Enumerated \nTypes” in the previous sec-\ntion, Section 12.6. Simulate named constants with approp riately scoped vari ables or classes If your lan-\nguage doesn’t support named constants, you ca n create your own. By using an approach \nsimilar to the approach suggested in the earlier Java example in which enumerated \ntypes were simulated, you can gain many of the advantages of named constants. Typical \nscoping rules apply: prefer local scope, class scope, and global scope in that order. Use named constants consistently It’s dangerous to use a named constant in one \nplace and a literal in another to represen t the same entity.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 989, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0990_f68ed41c", "text": "Use named constants consistently It’s dangerous to use a named constant in one \nplace and a literal in another to represen t the same entity. Some programming prac-\ntices beg for errors; this one is like callin g an 800 number and having errors delivered \n310\nChapter 12: Fundam ental Data Types\nto your door. If the value of the named consta nt needs to be changed, you’ll change it \nand think you’ve made all the necessary changes. You’ll overlook the hard-coded liter-\nals, your program will develop mysterious defe cts, and fixing them will be a lot harder \nthan picking up the phone and yelling for help. 12.8 Arrays\nArrays are the simplest and most common type of structured data. In some languages, \narrays are the only type of structured data. An array contains a group of items that are \nall of the same type and that are directly accessed through the use of an array index. Here are some tips on using arrays.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 990, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 919}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0991_c840a6f8", "text": "An array contains a group of items that are \nall of the same type and that are directly accessed through the use of an array index. Here are some tips on using arrays. Make sure that all array indexes are within the bounds of the array In one way or \nanother, all problems with arrays are caused by the fact that array elements can be \naccessed randomly. The most common problem arises when a program tries to access \nan array element that’s out of bounds. In some languages, this produces an error; in \nothers, it simply produces bizarre and unexpected results. Consider using containers instead of arra ys, or think of arrays as sequential \nstructures Some of the brightest people in computer science have suggested that \narrays never be accessed randomly, but only sequentially (Mills and Linger 1986). Their argument is that random accesses in arrays are similar to random gotos in a pro-\ngram: such accesses tend to be undisciplined, error prone, and hard to prove correct.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 991, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0992_963788db", "text": "Their argument is that random accesses in arrays are similar to random gotos in a pro-\ngram: such accesses tend to be undisciplined, error prone, and hard to prove correct. They suggest using sets, stacks, and queues, whose elements are accessed sequen-\ntially, rather than using arrays. In a small experiment, Mills and Linger found that designs created this way resulted \nin fewer variables and fewer variable refere nces. The designs were relatively efficient \nand led to highly reliable software. Consider using container classes that you can access sequentially—sets, stacks, \nqueues, and so on—as alternatives before you automatically choose an array. Cross-Reference Issues in \nusing arrays and loops are \nsimilar and related. For \ndetails on loops, see Chapter \n16, “Controlling Loops.”\nCheck the end points of arrays Just as it’s helpful to think through the end points in \na loop structure, you can catch a lot of errors by checking the end points of arrays.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 992, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0993_b0f8254a", "text": "Ask \nyourself whether the code correctly accesses the first element of the array or mistak-\nenly accesses the element before or after th e first element. What about the last ele-\nment? Will the code make an off-by-one erro r? Finally, ask yourself whether the code \ncorrectly accesses the middle elements of the array. If an array is multidimensional, make sure its subscripts are used in the correct order\nIt’s easy to say Array[ i ][ j ] when you mean Array[ j ][ i ] , so take the time to double-\ncheck that the indexes are in the right order. Consider using more meaningful names \nthan i and j in cases in which their roles aren’t immediately clear. KEY POINT\n1\n23\nHARD DATA\n12.9 Creating Your Ow n Types (Type Aliasing) 311\nWatch out for index cross-talk If you’re using nested loops, it’s easy to write Array[ j ] \nwhen you mean Array[ i ] . Switching loop indexes is called “index cross-talk.” Check for \nthis problem.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 993, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 925}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0994_a31c3e66", "text": "Switching loop indexes is called “index cross-talk.” Check for \nthis problem. Better yet, use more meaningful index names than i and j to make it \nharder to commit cross-talk mistakes in the first place. In C, use the ARRAY_LENGTH() macro to work with arrays You can build extra \nflexibility into your work with arrays by defining an ARRAY_LENGTH() macro that \nlooks like this:\nC Example of Defining an ARRAY_LENGTH() Macro \n#define ARRAY_LENGTH( x ) (sizeof(x)/sizeof(x[0]))\nWhen you use operations on an array, in stead of using a named constant for the \nupper bound of the array size, use the ARRAY_LENGTH() macro. Here’s an example:\nC Example of Using the ARRAY_LENGTH() Macro for Array Operations \nConsistencyRatios[] =\n { 0.0, 0.0, 0.58, 0.90, 1.12,\n 1.24, 1.32, 1.41, 1.45, 1.49,\n 1.51, 1.48, 1.56, 1.57, 1.59 };\n ... Here’s where the macro is \nused. for ( ratioIdx = 0; ratioIdx < ARRAY_LENGTH( ConsistencyRatios ); ratioIdx++ );\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 994, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0995_3d2ebb82", "text": "Here’s where the macro is \nused. for ( ratioIdx = 0; ratioIdx < ARRAY_LENGTH( ConsistencyRatios ); ratioIdx++ );\n ... This technique is particularly useful for di mensionless arrays such as the one in this \nexample. If you add or subtract entries, you don’t have to remember to change a \nnamed constant that describes the array’s size. Or course, the technique works with \ndimensioned arrays too, but if you use this approach, you don’t always need to set up \nan extra named constant for the array definition. 12.9 Creating Your Own Types (Type Aliasing)\nProgrammer-defined data types are one of the most powerful capabilities a language \ncan give you to clarify your understanding of a program. They protect your program \nagainst unforeseen changes and make it easi er to read—all without requiring you to \ndesign, construct, or test new classes. If yo u’re using C, C++, or another language that \nallows user-defined types, take advantage of them!", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 995, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0996_a1d317bb", "text": "If yo u’re using C, C++, or another language that \nallows user-defined types, take advantage of them! Cross-Reference In many \ncases, it’s better to create a \nclass than to create a simple \ndata type. For details, see \nChapter 6, “Working \nClasses.”\nTo appreciate the power of type creation, s uppose you’re writing a program to convert \ncoordinates in an x, y, z system to latitude, longitude, and elevation. You think that \ndouble-precision floating-point numbers might be needed but would prefer to write a \nprogram with single-precision floating-point numbers until you’re absolutely sure. You can create a new type specifically for coordinates by using a typedef statement in \nKEY POINT\n312\nChapter 12: Fundam ental Data Types\nC or C++ or the equivalent in another language.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 996, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 779}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0997_60f43617", "text": "You can create a new type specifically for coordinates by using a typedef statement in \nKEY POINT\n312\nChapter 12: Fundam ental Data Types\nC or C++ or the equivalent in another language. Here’s how you’d set up the type def-\ninition in C++:\nC+ + Example of Creating a Type\ntypedef float Coordinate; // for coordinate variables\nThis type definition declares a new type, Coordinate , that’s functionally the same as \nthe type float. To use the new type, you declare variables with it just as you would with \na predefined type such as float. Here’s an example:\nC+ + Example of Using the Type You’ve Created\nRoutine1( ... ) {\n Coordinate latitude; // latitude in degrees\n Coordinate longitude; // longitude in degrees\n Coordinate elevation; // elevation in meters from earth center\n ... }\n... Routine2( ... ) {\n Coordinate x; // x coordinate in meters\n Coordinate y; // y coordinate in meters\n Coordinate z; // z coordinate in meters\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 997, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0998_1b123315", "text": "}\n... Routine2( ... ) {\n Coordinate x; // x coordinate in meters\n Coordinate y; // y coordinate in meters\n Coordinate z; // z coordinate in meters\n ... }\nIn this code, the variables latitude , longitude , elevation , x, y, and z are all declared to be \nof type Coordinate . Now suppose that the program changes and you find that you need to use double-pre-\ncision variables for coordinates after all. Because you defined a type specifically for \ncoordinate data, all you have to change is the type definition. And you have to change \nit in only one place: in the typedef statement. Here’s the changed type definition:\nC+ + Example of Changed Type Definition\nThe original float has \nchanged to double . typedef double Coordinate; // for coordinate variables\nHere’s a second example—this one in Pascal. Suppose you’re creating a payroll system \nin which employee names are a maximum of 30 characters long. Your users have told \nyou that no one ever has a name longer than 30 characters.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 998, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_0999_d0b4e4bc", "text": "Suppose you’re creating a payroll system \nin which employee names are a maximum of 30 characters long. Your users have told \nyou that no one ever has a name longer than 30 characters. Do you hard-code the \nnumber 30 throughout your program? If you do, you trust your users a lot more than \nI trust mine! A better approach is to define a type for employee names:\nPascal Example of Creating a Type for Employee Names\nType\n employeeName = array[ 1..30 ] of char;\n12.9 Creating Your Ow n Types (Type Aliasing) 313\nWhen a string or an array is involved, it’s usually wise to define a named constant that \nindicates the length of the string or array and then use the named constant in the type \ndefinition. You’ll find many places in your program in which to use the constant—this \nis just the first place in which you’ll use it. Here’s how it looks:\nPascal Example of Better Type Creation\nConst\nHere’s the declaration of \nthe named constant. NAME_LENGTH = 30;\n ... Type\nHere’s where the named \nconstant is used.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 999, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1000_fee32a55", "text": "Here’s how it looks:\nPascal Example of Better Type Creation\nConst\nHere’s the declaration of \nthe named constant. NAME_LENGTH = 30;\n ... Type\nHere’s where the named \nconstant is used. employeeName = array[ 1..NAME_LENGTH ] of char;\nA more powerful example would combine the idea of creating your own types with \nthe idea of information hiding. In some ca ses, the information you want to hide is \ninformation about the type of the data. The coordinates example in C++ is about half way to information hiding. If you always \nuse Coordinate rather than float or double , you effectively hide the type of the data. In \nC++, this is about all the information hiding the language does for you. For the rest, \nyou or subsequent users of your code have to have the discipline not to look up the \ndefinition of Coordinate . C++ gives you figurative, rather than literal, information-hid-\ning ability. Other languages, such as Ada, go a step further and support literal information hid-\ning.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1000, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1001_d57e6b41", "text": "C++ gives you figurative, rather than literal, information-hid-\ning ability. Other languages, such as Ada, go a step further and support literal information hid-\ning. Here’s how the Coordinate code fragment would look in an Ada package that \ndeclares it:\nAda Example of Hiding Details of a Type Inside a Package\npackage Transformation is\nThis statement declares \nCoordinate as private to the \npackage. type Coordinate is private;\n ... Here’s how Coordinate looks in another package, one that uses it:\nAda Example of Using a Type from Another Package\nwith Transformation;\n... procedure Routine1(...) ... latitude: Coordinate;\n longitude: Coordinate;\nbegin\n -- statements using latitude and longitude\n ... end Routine1;\n314\nChapter 12: Fundam ental Data Types\nNotice that the Coordinate type is declared as private in the package specification. That \nmeans that the only part of the program that knows the definition of the Coordinate \ntype is the private part of the Transformation package.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1001, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1002_b023fb17", "text": "That \nmeans that the only part of the program that knows the definition of the Coordinate \ntype is the private part of the Transformation package. In a development environment \nwith a group of programmers, you could distribute only the package specification, \nwhich would make it harder for a programmer working on another package to look \nup the underlying type of Coordinate . The information would be literally hidden. Lan-\nguages like C++ that require you to distribute the definition of Coordinate in header \nfiles undermine true information hiding. These examples have illustrated several reasons to create your own types:\n■\nTo make modifications easier It’s little work to create a new type, and it gives \nyou a lot of flexibility. ■\nTo avoid excessive information distribution Hard typing spreads data-typ-\ning details around your program instead of centralizing them in one place. This \nis an example of the information-hiding principle of centralization discussed in \nSection 6.2.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1002, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 990}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1003_76e1c8ba", "text": "This \nis an example of the information-hiding principle of centralization discussed in \nSection 6.2. ■\nTo increase reliability In Ada, you can define types such as type Age is range \n0..99 . The compiler then generates run-time checks to verify that any variable of \ntype Age is always within the range 0..99 . ■\nTo make up for language weaknesses If your language doesn’t have the pre-\ndefined type you want, you can create it yourself. For example, C doesn’t have a \nboolean or logical type. This deficiency is easy to compensate for by creating the \ntype yourself:\ntypedef int Boolean;\nWhy Are the Examples of Creating Your Own Types in Pascal and Ada? Pascal and Ada have gone the way of the stegosaurus and, in general, the languages \nthat have replaced them are more usable. In the area of simple type definitions, how-\never, I think C++, Java, and Visual Basic represent a case of three steps forward and \none step back.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1003, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1004_1b021521", "text": "In the area of simple type definitions, how-\never, I think C++, Java, and Visual Basic represent a case of three steps forward and \none step back. An Ada declaration like \ncurrentTemperature: INTEGER range 0..212;\ncontains important semantic information that a statement like\nint temperature;\ndoes not. Going a step furt her, a type declaration like\ntype Temperature is range 0..212;\n... currentTemperature: Temperature;\n12.9 Creating Your Ow n Types (Type Aliasing) 315\nallows the compiler to ensure that currentTemperature is assigned only to other vari-\nables with the Temperature type, and very little extra codi ng is required to provide that \nextra safety margin. Of course, a programmer could create a Temperature class to enforce the same seman-\ntics that were enforced automatically by the Ada language, but the step from creating \na simple data type in one line of code to creating a class is a bi g step.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1004, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 915}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1005_b9fb4121", "text": "In many situa-\ntions, a programmer would create the simple type but would not step up to the addi-\ntional effort of creating a class. Guidelines for Creating Your Own Types\nCross-Reference In each \ncase, consider whether cre-\nating a class might work bet-\nter than a simple data type. For details, see Chapter 6, \n“Working Classes.”\nKeep these guidelines in mind as you create your own “user-defined” types:\nCreate types with functionally oriented names Avoid type names that refer to the \nkind of computer data underlying the type. Use type names that refer to the parts of \nthe real-world problem that the new type represents. In the previous examples, the \ndefinitions created well-named types for co ordinates and names—re al-world entities. Similarly, you could create types for curren cy, payment codes, ages, and so on—aspects \nof real-world problems. Be wary of creating type names that refe r to predefined types.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1005, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 922}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1006_2373cc8d", "text": "Similarly, you could create types for curren cy, payment codes, ages, and so on—aspects \nof real-world problems. Be wary of creating type names that refe r to predefined types. Type names like BigIn-\nteger or LongString refer to computer data rather than the real-world problem. The big \nadvantage of creating your own type is that it provides a layer of insulation between \nyour program and the implementation langua ge. Type names that refer to the under-\nlying programming-language types poke holes in that insulation. They don’t give you \nmuch advantage over using a predefined ty pe. Problem-oriented names, on the other \nhand, buy you easy modifiability and data declarations that are self-documenting. Avoid predefined types If there is any possibility that a type might change, avoid using \npredefined types anywhere but in typedef or type definitions. It’s easy to create new types \nthat are functionally oriented, and it’s hard to change data in a program that uses hard-\nwired types.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1006, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1007_cac56665", "text": "It’s easy to create new types \nthat are functionally oriented, and it’s hard to change data in a program that uses hard-\nwired types. Moreover, use of functionally oriented type declarations partially docu-\nments the variables declared with them. A declaration like Coordinate x tells you a lot \nmore about x than a declaration like float x . Use your own types as much as you can. Don’t redefine a predefined type Changing the definition of a standard type can cre-\nate confusion. For example, if your language has a predefined type Integer , don’t create \nyour own type called Integer . Readers of your code might forget that you’ve redefined \nthe type and assume that the Integer they see is the Integer they’re used to seeing.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1007, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 730}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1008_1bb67924", "text": "Readers of your code might forget that you’ve redefined \nthe type and assume that the Integer they see is the Integer they’re used to seeing. Define substitute types for portability In contrast to the advice that you not change \nthe definition of a standard type, you might want to define substitutes for the stan-\ndard types so that on different hardware platforms you can make the variables repre-\nsent exactly the same entities. Fo r example, you can define a type INT32 and use it \n316\nChapter 12: Fundam ental Data Types\ninstead of int, or a type LONG64 instead of long. Originally, the only difference \nbetween the two types would be their capi talization. But when you moved the pro-\ngram to a new hardware platform, you could redefine the capitalized versions so that \nthey could match the data types on the original hardware. Be sure not to define types that are easily mistaken for predefined types.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1008, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1009_9b8f09ac", "text": "Be sure not to define types that are easily mistaken for predefined types. It would be \npossible to define INT rather than INT32 , but you’re better off creating a clean distinc-\ntion between types you define and types provided by the language. Consider creating a class rather than using a typedef Simple typedefs can go a long \nway toward hiding information about a variable’s underlying type. In some cases, \nhowever, you might want the additional flex ibility and control you’ll achieve by creat-\ning a class. For details, see Chapter 6, “Working Classes.”\ncc2e.com/1206\nCross-Reference For a \nchecklist that applies to \ngeneral data issues rather \nthan to issues with specific \ntypes of data, see the check-\nlist on page 257 in Chapter \n10, “General Issues in Using \nVariables.” For a checklist of \nconsiderations in naming \nvarieties, see the checklist on \npage 288 in Chapter 11, “The \nPower of Variable Names.”\nCHECKLIST: Fundamental Data\nNumbers in General\n❑\nDoes the code avoid magic numbers?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1009, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1010_7978cc26", "text": "❑\nDoes the code anticipate divide-by-zero errors? ❑\nAre type conversions obvious? ❑\nIf variables with two different types are used in the same expression, will \nthe expression be evaluated as you intend it to be? ❑\nDoes the code avoid mi xed-type comparisons? ❑\nDoes the program compile with no warnings? Integers\n❑\nDo expressions that use integer division work the way they’re meant to? ❑\nDo integer expressions avoid integer-overflow problems? Floating-Point Numbers\n❑\nDoes the code avoid additions and su btractions on numbers with greatly \ndifferent magnitudes? ❑\nDoes the code systematically prevent rounding errors? ❑\nDoes the code avoid comparing floating-point numbers for equality? Characters and Strings\n❑\nDoes the code avoid magic characters and strings? ❑\nAre references to strings free of off-by-one errors? 12.9 Creating Your Ow n Types (Type Aliasing) 317\n❑\nDoes C code treat string pointers and character arrays differently?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1010, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1011_d5144582", "text": "❑\nAre references to strings free of off-by-one errors? 12.9 Creating Your Ow n Types (Type Aliasing) 317\n❑\nDoes C code treat string pointers and character arrays differently? ❑\nDoes C code follow the convention of declaring strings to be length CON-\nSTANT+1 ? ❑\nDoes C code use arrays of characters rather than pointers, when appropriate? ❑\nDoes C code initialize strings to NULL s to avoid endless strings? ❑\nDoes C code use strncpy() rather than strcpy() ? And strncat() and \nstrncmp() ? Boolean Variables\n❑\nDoes the program use additional bo olean variables to document condi-\ntional tests? ❑\nDoes the program use additional boolean variables to simplify conditional \ntests? Enumerated Types\n❑\nDoes the program use enumerated ty pes instead of named constants for \ntheir improved readability, reliability, and modifiability? ❑\nDoes the program use enumerated ty pes instead of bo olean variables \nwhen a variable’s use cannot be completely captured with true and false?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1011, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1012_fef978ab", "text": "❑\nDoes the program use enumerated ty pes instead of bo olean variables \nwhen a variable’s use cannot be completely captured with true and false? ❑\nDo tests using enumerated ty pes test for invalid values? ❑\nIs the first entry in an enumerated type reserved for “invalid”? Named Constants\n❑\nDoes the program use named constants for data declarations and loop \nlimits rather than magic numbers? ❑\nHave named constants been used consistently—not used as named con-\nstants in some places and as literals in others? Arrays\n❑\nAre all array indexes within the bounds of the array? ❑\nAre array references free of off-by-one errors? ❑\nAre all subscripts on multidimensional arrays in the correct order? ❑\nIn nested loops, is the correct variable used as the array subscript, avoid-\ning loop-index cross-talk? 318\nChapter 12: Fundam ental Data Types\nCreating Types\n❑\nDoes the program use a different type for each kind of data that might \nchange?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1012, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1013_d1455974", "text": "318\nChapter 12: Fundam ental Data Types\nCreating Types\n❑\nDoes the program use a different type for each kind of data that might \nchange? ❑\nAre type names oriented toward the real-world entities the types represent \nrather than toward programming-language types? ❑\nAre the type names descriptive enough to help document data declarations? ❑\nHave you avoided redefining predefined types? ❑\nHave you considered creating a new class rather than simply redefining a \ntype? Key Points\n■\nWorking with specific data types means remembering many individual rules for \neach type. Use this chapter’s checklist to make sure that you’ve considered the \ncommon problems. ■\nCreating your own types makes your programs easier to modify and more self-\ndocumenting, if your language supports that capability. ■\nWhen you create a simple type using typedef or its equivalent, consider whether \nyou should be creating a new class instead.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1013, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1014_236a0866", "text": "■\nWhen you create a simple type using typedef or its equivalent, consider whether \nyou should be creating a new class instead. 319\nChapter 13\nUnusual Data Types\ncc2e.com/1378\nContents\n■\n13.1 Structures: page 319\n■\n13.2 Pointers: page 323\n■\n13.3 Global Data: page 335\nRelated Topics\n■\nFundamental data types: Chapter 12\n■\nDefensive programming: Chapter 8\n■\nUnusual control structures: Chapter 17\n■\nComplexity in software development: Section 5.2\nSome languages support exotic kinds of data in addition to the data types discussed \nin Chapter 12, “Fundamental Data Types. ” Section 13.1 describes when you might \nstill use structures rather than classes in some circumstances. Section 13.2 describes \nthe ins and outs of using pointers. If you’ve ever encountered problems associated \nwith using global data, Section 13.3 explai ns how to avoid such difficulties.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1014, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 861}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1015_8c4fdce2", "text": "Section 13.2 describes \nthe ins and outs of using pointers. If you’ve ever encountered problems associated \nwith using global data, Section 13.3 explai ns how to avoid such difficulties. If you \nthink the data types described in this chapter are not the types you normally read \nabout in modern object-oriented programming books, you’re right. That’s why the \nchapter is called “ Unusual Data Types.”\n13.1 Structures\nThe term “structure” refers to data that’s built up from other types. Because arrays are \na special case, they are treated separately in Chapter 12. This section deals with user-\ncreated structured data— struct s in C and C++ and Structures in Microsoft Visual Basic. In Java and C++, classes also sometimes perform as structures (when the class con-\nsists entirely of public data me mbers with no public routines).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1015, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 832}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1016_274143bd", "text": "In Java and C++, classes also sometimes perform as structures (when the class con-\nsists entirely of public data me mbers with no public routines). You’ll generally want to create classes rather than structures so that you can take \nadvantage of the privacy and functionality offe red by classes in addition to the public \ndata supported by structures. But sometimes directly manipulating blocks of data can \nbe useful, so here are some reasons for using structures:\n320\nChapter 13: Unusual Data Types\nUse structures to clarify data relationships Structures bundle groups of related \nitems together. Sometimes the hardest part of figuring out a program is figuring out \nwhich data goes with which other data. It’s like going to a small town and asking \nwho’s related to whom. You come to find out that everybody’s kind of related to every-\nbody else, but not really, and you never get a good answer. If the data has been carefully structured, figuring out what goes with what is much \neasier.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1016, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1017_5680695f", "text": "If the data has been carefully structured, figuring out what goes with what is much \neasier. Here’s an example of data that hasn’t been structured:\nVisual Basic Example of Misleading, Unstructured Variables\nname = inputName\naddress = inputAddress\nphone = inputPhone\ntitle = inputTitle\ndepartment = inputDepartment\nbonus = inputBonus\nBecause this data is unstructured, it looks as if all the assignment statements belong \ntogether. Actually, name , address , and phone are variables associated with individual \nemployees, and title, department , and bonus are variables associated with a supervisor. The code fragment provides no hint that there are two kinds of data at work.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1017, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 675}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1018_6893e609", "text": "The code fragment provides no hint that there are two kinds of data at work. In the \ncode fragment below, the use of stru ctures makes the relationships clearer:\nVisual Basic Example of More Informative, Structured Variables\nemployee.name = inputName\nemployee.address = inputAddress\nemployee.phone = inputPhone\nsupervisor.title = inputTitle\nsupervisor.department = inputDepartment\nsupervisor.bonus = inputBonus\nIn the code that uses structured variables, it ’s clear that some of the data is associated \nwith an employee, other data with a supervisor. Use structures to simplify operations on blocks of data You can combine related ele-\nments into a structure and perform operations on the structure. It’s easier to operate \non the structure than to perform the same op eration on each of the elements. It’s also \nmore reliable, and it takes fewer lines of code. Suppose you have a group of data items that belong together—for instance, data about \nan employee in a personnel database.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1018, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1019_42a2e2bf", "text": "It’s also \nmore reliable, and it takes fewer lines of code. Suppose you have a group of data items that belong together—for instance, data about \nan employee in a personnel database. If the data isn’t combined into a structure, \nmerely copying the group of data can involve a lot of statements. Here’s an example in \nVisual Basic:\n13.1 Structures 321\nVisual Basic Example of Copying a Group of Data Items Clumsily\nnewName = oldName\nnewAddress = oldAddress\nnewPhone = oldPhone\nnewSsn = oldSsn\nnewGender = oldGender\nnewSalary = oldSalary\nEvery time you want to transfer information about an employee, you have to have this \nwhole group of statements. If you ever add a new piece of employee information—for \nexample, numWithholdings —you have to find every place at which you have a block of \nassignments and add an assignment for newNumWithholdings = oldNumWithholdings . Imagine how horrible swapping data between two employees would be.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1019, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 937}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1020_a004253d", "text": "Imagine how horrible swapping data between two employees would be. You don’t \nhave to use your imagination—here it is:\nVisual Basic Example of Swapping Two Groups of Data the Hard Way\n' swap new and old employee data\npreviousOldName = oldName\npreviousOldAddress = oldAddress\npreviousOldPhone = oldPhone\npreviousOldSsn = oldSsn\npreviousOldGender = oldGender\npreviousOldSalary = oldSalary\noldName = newName\noldAddress = newAddress\noldPhone = newPhone\noldSsn = newSsn\noldGender = newGender\noldSalary = newSalary\nnewName = previousOldName\nnewAddress = previousOldAddress\nnewPhone = previousOldPhone\nnewSsn = previousOldSsn\nnewGender = previousOldGender\nnewSalary = previousOldSalary\nAn easier way to approach the problem is to declare a structured variable:\nVisual Basic Example of Declaring Structures\nStructure Employee\n name As String\n address As String\n phone As String\n ssn As String\n gender As String\n salary As long\nCODING \nHORROR\n322\nChapter 13: Unusual Data Types\nEnd Structure\nDim newEmployee As Employee\nDim oldEmployee As Employee\nDim previousOldEmployee As Employee\nNow you can switch all the elements in the old and new employee structures with \nthree statements:\nVisual Basic Example of an Easier Way to Swap Two Groups of Data\npreviousOldEmployee = oldEmployee\noldEmployee = newEmployee\nnewEmployee = previousOldEmployee\nIf you want to add a field such as numWithholdings , you simply add it to the Structure \ndeclaration.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1020, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1434}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1021_9cc351a7", "text": "Neither the three statements above nor any similar statements through-\nout the program need to be modified. C++ and other languages have similar capabili-\nties. Cross-Reference For details \non how much data to share \nbetween routines, see “Keep \nCoupling Loose” in Section \n5.3. Use structures to simplify parameter lists You can simplify routine parameter lists \nby using structured variables. The technique is similar to the one just shown. Rather \nthan passing each of the elements needed individually, you can group related ele-\nments into a structure and pass the whole enchilada as a group structure.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1021, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 606}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1022_0069599c", "text": "Rather \nthan passing each of the elements needed individually, you can group related ele-\nments into a structure and pass the whole enchilada as a group structure. Here’s an \nexample of the hard way to pass a group of related parameters:\nVisual Basic Example of a Clumsy Routine Call Without a Structure\nHardWayRoutine( name, address, phone, ssn, gender, salary )\nAnd this is an example of the easy way to call a routine by using a structured variable \nthat contains the elements of the first parameter list:\nVisual Basic Example of an Elegant Routine Call with a Structure\nEasyWayRoutine( employee )\nIf you want to add numWithholdings to the first kind of call, you have to wade through \nyour code and change every call to HardWayRoutine() . If you add a numWithholdings ele-\nment to Employee , you don’t have to change the parameters to EasyWayRoutine() at all. Cross-Reference For details \non the hazards of passing \ntoo much data, see “Keep \nCoupling Loose” in Section \n5.3.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1022, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1023_7220ed85", "text": "Cross-Reference For details \non the hazards of passing \ntoo much data, see “Keep \nCoupling Loose” in Section \n5.3. You can carry this technique to extremes, putting all the variables in your program \ninto one big, juicy variable and then passing it everywhere. Careful programmers \navoid bundling data any more than is logically necessary. Furthermore, careful pro-\ngrammers avoid passing a structure as a para meter when only one or two fields from \nthe structure are needed—they pass the specific fields needed instead. This is an \naspect of information hiding: some information is hidden in routines, and some is hid-\nden from routines. Information is passed around on a need-to-know basis. 13.2 Pointers 323\nUse structures to reduce maintenance Because you group related data when you use \nstructures, changing a structure requires fewer changes throughout a program. This is \nespecially true in sections of code that ar en’t logically related to the change in the \nstructure.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1023, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1024_50ca97fa", "text": "This is \nespecially true in sections of code that ar en’t logically related to the change in the \nstructure. Since changes tend to produce errors, fewer changes mean fewer errors. If \nyour Employee structure has a title field and you decide to delete it, you don’t need to \nchange any of the parameter lists or assign ment statements that use the whole struc-\nture. Of course, you have to change any code that deals specifically with employee \ntitles, but that is conceptually related to deleting the title field and is hard to overlook. The big advantage of structured the data is fo und in sections of code that bear no log-\nical relation to the title field. Sometimes programs have statements that refer concep-\ntually to a collection of data rather than to individual components. In such cases, \nindividual components, such as the title field, are referenced merely because they are \npart of the collection.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1024, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 911}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1025_a6264a08", "text": "In such cases, \nindividual components, such as the title field, are referenced merely because they are \npart of the collection. Such sections of code don’t have any logical reason to work with \nthe title field specifically, and those sections are easy to overlook when you change \ntitle. If you use a structure, it’s all right to overlook such sections because the code \nrefers to the collection of related data ra ther than to each component individually. 13.2 Pointers\nPointer usage is one of the most error-prone areas of modern programming, to such \nan extent that modern languages like Java, C#, and Visual Basic don’t provide a \npointer data type. Using pointers is inhere ntly complicated, and using them correctly \nrequires that you have an excellent understanding of your compiler’s memory-man-\nagement scheme. Many common security problems, especially buffer overruns, can be \ntraced back to erroneous use of pointers (Howard and LeBlanc 2003).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1025, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1026_7dcf525e", "text": "Many common security problems, especially buffer overruns, can be \ntraced back to erroneous use of pointers (Howard and LeBlanc 2003). Even if your language doesn’t require you to use pointers, a good understanding of \npointers will help your understanding of how your programming language works. A \nliberal dose of defensive programming practices will help even further. Paradigm for Understanding Pointers\nConceptually, every pointer consists of tw o parts: a location in memory and a knowl-\nedge of how to interpret the contents of that location. Location in Memory\nThe location in memory is an address, of ten expressed in hexadecimal notation. An \naddress on a 32-bit processor woul d be a 32-bit value, such as 0x0001EA40 . The \npointer itself contains only this address. To use the data the pointer points to, you \nhave to go to that address and interpret the contents of memory at that location. If you \nwere to look at the memory in that location, it would be just a collection of bits.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1026, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1027_89175dd5", "text": "If you \nwere to look at the memory in that location, it would be just a collection of bits. It has \nto be interpreted to be meaningful. KEY POINT\n324\nChapter 13: Unusual Data Types\nKnowledge of How to Interpret the Contents\nThe knowledge of how to interpret the conten ts of a location in memory is provided \nby the base type of the pointer. If a pointer points to an integer, what that really means \nis that the compiler interprets the memory lo cation given by the pointer as an integer. Of course, you can have an integer pointer, a string pointer, and a floating-point \npointer all pointing at the same memory loc ation. But only one of the pointers inter-\nprets the contents at that location correctly. In thinking about pointers, it’s helpful to remember that memory doesn’t have any \ninherent interpretation associated with it. It is only through use of a specific type of \npointer that the bits in a particular loca tion are interpreted as meaningful data.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1027, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1028_5d484c15", "text": "It is only through use of a specific type of \npointer that the bits in a particular loca tion are interpreted as meaningful data. Figure 13-1 shows several views of the same location in memory, in terpreted in several \ndifferent ways. Figure 13-1 The amount of memory used by each data type is shown by double lines. In each of the cases in Figure 13-1, the poin ter points to the location containing the hex \nvalue 0x0A . The number of bytes used beyond the 0A depends on how the memory is \ninterpreted.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1028, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 504}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1029_25e0f9d0", "text": "In each of the cases in Figure 13-1, the poin ter points to the location containing the hex \nvalue 0x0A . The number of bytes used beyond the 0A depends on how the memory is \ninterpreted. The way memory contents are used also depends on how the memory is \n0A\n61\n62\n63\n64\n65\n66\n67\n68\n69\n6A\nViewed as: Raw memory contents used for further examples (in hex)\nInterpreted as: No interpretation possible without associated pointer variable\n65\n66\n67\n68\n69\n6A\n68\n69\n6A\n6A\nViewed as: char\nInter preted as: linefeed character (ASCII hex 0A or decimal 10)\n0A\n61\n62\n63\n64\n65\n66\n67\n68\n69\n6A\nViewed as: 4-byte integer\nInterpreted as: 1667391754\n0A\n61\n62\n63\n64\n65\n66\n67\n68\n69\nViewed as: 4-byte floating point\nInterpreted as: 4.17595656202980E+0021\n0A\n61\n62\n63\n64\n65\n66\n67\nViewed as: 2-byte integer\nInterpreted as: 24842\n0A\n61\n62\n63\n64\nViewed as: String[10] (in Visual Basic format with length byte first)\nInterpreted as: abcdefghij\n0A\n61\n62\n63\n64\n65\n66\n67\n68\n69\n6A\n13.2 Pointers 325\ninterpreted.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1029, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1030_a4f5cd1a", "text": "(It also depends on what processor you’re using, so keep that in mind if you \ntry to duplicate these results on your Desk top Cray.) The same raw memory contents \ncan be interpreted as a string, an integer, a floating point, or anything else—it all depends \non the base type of the pointer that points to the memory. General Tips on Pointers\nWith many types of defects, locating the error is the easiest part of dealing with the error \nand correcting it is the hard part. Pointer errors are different. A pointer error is usually \nthe result of a pointer’s pointing somewhere it shouldn’t. When you assign a value to a \nbad pointer variable, you write data into an area of memory you shouldn’t. This is called \n“memory corruption.” Sometimes memory corr uption produces horrible, fiery system \ncrashes; sometimes it alters the results of a calculation in another part of the program; \nsometimes it causes your pr ogram to skip routines unpredictably; and sometimes it \ndoesn’t do anything at all.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1030, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1031_864ff36d", "text": "In the last case, the pointer error is a ticking time bomb, wait-\ning to ruin your program five minutes before you show it to your most important cus-\ntomer. Symptoms of pointer errors tend to be unrelated to causes of pointer errors. Thus, most of the work in correcting a pointer error is locating the cause. Working with pointers successfully requires a two-pronged strategy. First, avoid \ninstalling pointer errors in the first place. Pointer errors are so difficult to find that \nextra preventive measures are justified. Second, detect pointer errors as soon after \nthey are coded as possible. Symptoms of po inter errors are so erratic that extra mea-\nsures to make the symptoms more predictable are justified. Here’s how to achieve \nthese key goals:\nIsolate pointer operations in routines or classes Suppose you use a linked list in sev-\neral places in a program.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1031, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 870}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1032_88edd52f", "text": "Here’s how to achieve \nthese key goals:\nIsolate pointer operations in routines or classes Suppose you use a linked list in sev-\neral places in a program. Rather than traver sing the list manually each place it’s used, \nwrite access routines such as NextLink() , PreviousLink() , InsertLink() , and DeleteLink() . By minimizing the number of places in wh ich pointers are accessed, you minimize the \npossibility of making careless mistakes that spread throughout your program and take \nforever to find. Because the code is then relatively independent of data-implementation \ndetails, you also improve the chance that you can reuse it in other programs. Writing \nroutines for pointer allocation is another way to centralize control over your data. Declare and define pointers at the same time Assigning a variable its initial value \nclose to where it is declared is generally good programming practice, and it’s all the \nmore valuable when working with pointers.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1032, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1033_92ef5502", "text": "Here is an example of what not to do:\nC+ + Example of Bad Pointer Initialization\nEmployee *employeePtr;\n// lots of code\n... employeePtr = new Employee;\nKEY POINT\nCODING \nHORROR\n326\nChapter 13: Unusual Data Types\nIf even this code works correctly initially, it’s error-prone under modification because \na chance exists that someone will try to use employeePtr between the point where the \npointer is declared and the time it’s initialized. Here’s a safer approach:\nC+ + Example of Good Pointer Initialization\n// lots of code\n... Employee *employeePtr = new Employee;\nDelete pointers at the same scoping level as they were allocated Keep allocation and \ndeallocation of pointers symmetric. If you us e a pointer within a single scope, call new \nto allocate and delete to deallocate the pointer within the same scope. If you allocate a \npointer inside a routine, deallocate it inside a sister routine. If you allocate a pointer \ninside an object’s constructor, deallocate it inside the object’s destructor.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1033, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1034_581040b4", "text": "If you allocate a \npointer inside a routine, deallocate it inside a sister routine. If you allocate a pointer \ninside an object’s constructor, deallocate it inside the object’s destructor. A routine \nthat allocates memory and then expects its client code to deallocate the memory man-\nually creates an inconsistency that is ripe for error. Check pointers before using them Before you use a pointer in a critical part of your \nprogram, make sure the memory location it points to is reasonable. For example, if \nyou expect memory locations to be between StartData and EndData , you should take \na suspicious view of a pointer that points before StartData or after EndData . You’ll \nhave to determine what the values of StartData and EndData are in your environment. You can set this up to work automatically if you use pointers through access routines \nrather than manipulate them directly.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1034, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1035_47c1dfef", "text": "You can set this up to work automatically if you use pointers through access routines \nrather than manipulate them directly. Check the variable referenced by the pointer before using it Sometimes you can per-\nform reasonableness checks on the value the pointer points to. For example, if you’re \nsupposed to be pointing to an integer va lue between 0 and 1000, you should be sus-\npicious of values over 1000. If you’re poin ting to a C++-style string, you might be sus-\npicious of strings with lengths greater than 100. This can also be done automatically \nif you work with pointers through access routines. Use dog-tag fields to check for corrupted memory A “tag field” or “dog tag” is a field \nyou add to a structure solely for the purpose of error checking. When you allocate a \nvariable, put a value that should remain unchanged into its tag field. When you use \nthe structure—especially when you delete the memory—check the tag field’s value.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1035, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1036_f1254b0b", "text": "When you allocate a \nvariable, put a value that should remain unchanged into its tag field. When you use \nthe structure—especially when you delete the memory—check the tag field’s value. If \nthe tag field doesn’t have the expected value, the data has been corrupted. When you delete the pointer, corrupt the field so that if you accidentally try to free the \nsame pointer again, you’ll detect the corruption. For example, let’s say that you need \nto allocate 100 bytes:\n1.First, new 104 bytes, 4 bytes more than requested. 104 bytes\n13.2 Pointers 327\n2.Set the first 4 bytes to a dog-tag value, and then return a pointer to the memory \nthat starts after that. 3.When the time comes to delete the pointer, check the tag. 4.If the tag is OK, set it to 0 or some other value that you and your program recog-\nnize as an invalid tag value. You don’t want the value to be mistaken for a valid \ntag after the memory has been freed. Set the data to 0, 0xCC , or some other non-\nrandom value for the same reason.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1036, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1037_7e96367e", "text": "You don’t want the value to be mistaken for a valid \ntag after the memory has been freed. Set the data to 0, 0xCC , or some other non-\nrandom value for the same reason. 5.Finally, delete the pointer. Putting a dog tag at the beginning of the memory block you’ve allocated allows you to \ncheck for redundant attempts to dealloca te the memory block without needing to \nmaintain a list of all the memory blocks you’ve allocated. Putting the dog tag at the \nend of the memory block allows you to check for overwriting memory beyond the \nlocation that was supposed to be used. You can use tags at the beginning and the end \nof the block to accomplish both objectives. You can use this approach in concert with the reasonableness check suggested ear-\nlier—checking that the pointers are between StartData and EndData . To be sure that a \npointer points to a reasonable location, rather than checki ng for a probable range of \nmemory, check to see that the pointer is in the list of allocated pointers.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1037, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1038_d0d2aa37", "text": "To be sure that a \npointer points to a reasonable location, rather than checki ng for a probable range of \nmemory, check to see that the pointer is in the list of allocated pointers. You could check the tag field just once before you delete the variable. A corrupted tag \nwould then tell you that sometime during the life of that variable its contents were cor-\nrupted. The more often you check the tag field, however, the closer to the root of the \nproblem you will detect the corruption. Add explicit redundancies An alternative to using a tag field is to use certain fields \ntwice. If the data in the redundant fields doesn’t match, you know memory has been \ncorrupted. This can result in a lot of overhe ad if you manipulate pointers directly. If \nyou isolate pointer operations in routines, however, it adds duplicate code in only a \nfew places. Use extra pointer va riables for clarity By all means, don’t skimp on pointer vari-\nables.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1038, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 941}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1039_5dd853a1", "text": "If \nyou isolate pointer operations in routines, however, it adds duplicate code in only a \nfew places. Use extra pointer va riables for clarity By all means, don’t skimp on pointer vari-\nables. The point is made elsewhere that a variable shouldn’t be used for more than \none purpose. This is especially true for pointe r variables. It’s hard enough to figure out \ntagSet pointer to here. tag\nCheck this tag. Free the whole 104 bytes\n328\nChapter 13: Unusual Data Types\nwhat someone is doing with a linked list without having to figure out why one \ngenericLink variable is used over and over again or what pointer->next->last->next is \npointing at. Consider this code fragment:\nC+ + Example of Traditional Node Insertion Code\nvoid InsertLink(\n Node *currentNode,\n Node *insertNode\n ) {\n // insert \"insertNode\" after \"currentNode\"\n insertNode->next = currentNode->next;\n insertNode->previous = currentNode;\n if ( currentNode->next != NULL ) {\nThis line is needlessly \ndifficult.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1039, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1040_5bd0f5f3", "text": "currentNode->next->previous = insertNode;\n }\n currentNode->next = insertNode;\n}\nThis is traditional code for inserting a node in a linked list, and it’s needlessly hard to \nunderstand. Inserting a new node involves three objects: the current node, the node \ncurrently following the current node, and the node to be inserted between them. The \ncode fragment explicitly acknowledges only two objects: insertNode and currentNode . It forces you to figure out and remember that currentNode->next is also involved. If you \ntried to diagram what is happening without the node originally following currentNode , \nyou would get something like this:\nA better diagram would identify all thre e objects.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1040, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 692}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1041_a2f587b4", "text": "If you \ntried to diagram what is happening without the node originally following currentNode , \nyou would get something like this:\nA better diagram would identify all thre e objects. It would look like this:\nHere’s code that explicitly referenc es all three of the objects involved:\nC+ + Example of More Readable Node-Insertion Code\nvoid InsertLink(\n Node *startNode,\n Node *newMiddleNode\n ) {\n // insert \"newMiddleNode\" between \"startNode\" and \"followingNode\"\n Node *followingNode = startNode->next;\n newMiddleNode->next = followingNode;\n newMiddleNode->previous = startNode;\n if ( followingNode != NULL ) {\n followingNode->previous = newMiddleNode;\n }\n startNode->next = newMiddleNode;\n}\ncurrentNode\ninsertNode\nstartNode\nnewMiddleNode\nfollowingNode\n13.2 Pointers 329\nThis code fragment has an extra line of code, but without the first fragment’s current-\nNode->next->previous , it’s easier to follow. Simplify complicated pointer expressions Complicated pointer expressions are hard \nto read.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1041, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1042_82ed550e", "text": "Simplify complicated pointer expressions Complicated pointer expressions are hard \nto read. If your code contains expressions like p->q->r->s.data, think about the person \nwho has to read the expression. Here’s a particularly egregious example:\nC+ + Example of a Pointer Expressi on That’s Hard to Understand\nfor ( rateIndex = 0; rateIndex < numRates; rateIndex++ ) {\n netRate[ rateIndex ] = baseRate[ rateIndex ] * rates->discounts->factors->net;\n}\nComplicated expressions like the pointer ex pression in this example make for code \nthat has to be figured out rather than read. If your code contains a complicated expres-\nsion, assign it to a well-named variable to clarify the intent of the operation.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1042, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 703}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1043_963de11f", "text": "If your code contains a complicated expres-\nsion, assign it to a well-named variable to clarify the intent of the operation. Here’s an \nimproved version of the example:\nC+ + Example of Simplifying a Complicated Pointer Expression\nquantityDiscount = rates->discounts->factors->net;\nfor ( rateIndex = 0; rateIndex < numRates; rateIndex++ ) {\n netRate[ rateIndex ] = baseRate[ rateIndex ] * quantityDiscount;\n}\nWith this simplification, not only do you get a gain in readability, but you might also get \na boost in performance from simplifying the po inter operation inside the loop. As usual, \nyou’d have to measure the performance benefit before you bet any folding money on it. Draw a picture Code descriptions of pointers can get confusing. It usually helps to \ndraw a picture. For example, a picture of the linked-list insertion problem might look \nlike the one shown in Figure 13-2.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1043, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 885}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1044_1a2b6f0c", "text": "It usually helps to \ndraw a picture. For example, a picture of the linked-list insertion problem might look \nlike the one shown in Figure 13-2. Cross-Reference Diagrams \nsuch as the one in Figure \n13-2 can become part of the \nexternal documentation of \nyour program. For details on \ngood documentation prac-\ntices, see Chapter 32, “Self-\nDocumenting Code.”\nFigure 13-2 An example of a picture that helps us think through the steps involved in \nrelinking pointers. CODING \nHORROR\nInitial Linkage\nfollowingNode->previousstartNode->next\nstartNode\nfollowingNode\nDesired Linkage\nfollowingNode->previous startNode->next\nstartNode\nfollowingNode\nnewMiddleNodenewMiddleNode->previous newMiddleNode->next\n330\nChapter 13: Unusual Data Types\nDelete pointers in linked lists in the right order A common problem in working with \ndynamically allocated linked lists is freeing the first pointer in the list first and then \nnot being able to get to the next pointer in the list.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1044, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1045_b1749bda", "text": "To avoid this problem, make sure \nthat you have a pointer to the next element in a list before you free the current one. Allocate a reserve parachute of memory If your program uses dynamic memory, you \nneed to avoid the problem of suddenly running out of memory, leaving your user and \nyour user’s data lost in RAM space. One way to give your program a margin of error is \nto preallocate a memory parachute. Determine how much memory your program \nneeds to save work, clean up, and exit gracefully. Allocate that amount of memory at \nthe beginning of the program as a reserve parachute, and leave it alone. When you run \nout of memory, free the reserve parachute, clean up, and shut down. Further Reading For an \nexcellent discussion of safe \napproaches to handling \npointers in C, see Writing \nSolid Code (Maguire 1993). Shred your garbage Pointer errors are hard to debug because the point at which the \nmemory the pointer points to becomes invalid is not deterministic.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1045, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 972}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1046_1a68d41a", "text": "Shred your garbage Pointer errors are hard to debug because the point at which the \nmemory the pointer points to becomes invalid is not deterministic. Sometimes the \nmemory contents will look valid long after the pointer is freed. Other times, the mem-\nory will change right away. In C, you can force errors related to using deallocated pointers to be more consistent \nby overwriting memory blocks with junk data right before they’re deallocated. As with \nmany other operations, you can do this automatically if you use access routines. In C, \neach time you delete a pointer, you could use code like this:\nC Example of Forcing a Deallocated Object to Contain Junk Data\npointer->SetContentsToGarbage();\ndelete pointer;\nOf course, this technique will not work in C++ where the pointer points to an object, \nand it requires you to implement a Set Contents to Garbage routine for each object..", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1046, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 889}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1047_e5d62d47", "text": "Set pointers to null after deleting or freeing them A common type of pointer error is \nthe “dangling pointer,” use of a pointer that has been delete’ d or free’d. One reason \npointer errors are hard to detect is that sometimes the error doesn’t produce any \nsymptoms. By setting pointers to null after freeing them, you don’t change the fact \nthat you can read data pointed to by a dangling pointer. But you do ensure that writing \ndata to a dangling pointer produces an error. It will probably be an ugly, nasty, disas-\nter of an error, but at least you’ll find it instead of someone else finding it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1047, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 601}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1048_7be23db0", "text": "But you do ensure that writing \ndata to a dangling pointer produces an error. It will probably be an ugly, nasty, disas-\nter of an error, but at least you’ll find it instead of someone else finding it. The code preceding the delete operation in the previous example could be augmented \nto handle this, too:\nC+ + Example of Setting a Pointer to Null After Deleting It\npointer->SetContentsToGarbage();\ndelete pointer;\npointer = NULL;\nC13619670.fm Page 330 Tuesday, April 12, 2011 2:56 PM\n13.2 Pointers 331\nCheck for bad pointers before deleting a variable One of the best ways to ruin a pro-\ngram is to delete() or free() a pointer after it has already been delete ’d or free’d. Unfor-\ntunately, few languages detect this kind of problem. Setting freed pointers to null also allows you to check whether a pointer is set to null \nbefore you use it or attempt to delete it again; if you don’t set freed pointers to null, you \nwon’t have that option.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1048, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1049_3dc758e2", "text": "That suggests another addition to the pointer deletion code:\nC+ + Example of Asserting That a Pointer Is Not Null Before Deleting It\nASSERT( pointer != NULL, \"Attempting to delete null pointer.\" );\npointer->SetContentsToGarbage();\ndelete pointer;\npointer = NULL;\nKeep track of pointer allocations Keep a list of the pointers you have allocated. This \nallows you to check whether a pointer is in the list before you dispose of it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1049, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 429}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1050_1bb75cf3", "text": "This \nallows you to check whether a pointer is in the list before you dispose of it. Here’s an \nexample of how the standard pointer deletion code could be modified to include that:\nC+ + Example of Checking Whether a Pointer Has Been Allocated\nASSERT( pointer != NULL, \"Attempting to delete null pointer.\" );\nif ( IsPointerInList( pointer ) ) {\n pointer->SetContentsToGarbage();\n RemovePointerFromList( pointer );\n delete pointer;\n pointer = NULL;\n}\nelse {\n ASSERT( FALSE, \"Attempting to delete unallocated pointer.\" );\n}\nWrite cover routines to centralize your strategy to avoiding pointer problems As you \ncan see from this example, you can end up with quite a lot of extra code each time a \npointer is new’d or delete ’d. Some of the techniques described in this section are mutu-\nally exclusive or redundant, and you wouldn’t want to have multiple, conflicting strat-\negies in use in the same code base.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1050, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 906}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1051_750a7c8d", "text": "Some of the techniques described in this section are mutu-\nally exclusive or redundant, and you wouldn’t want to have multiple, conflicting strat-\negies in use in the same code base. For example, you don’t need to create and check \ndog-tag values if you’re maintaining your own list of valid pointers. You can minimize programming overhead and reduce chance of errors by creating cover \nroutines for common pointer operations. In C++, you could use these two routines:\nI\nSAFE_NEW This routine calls new to allocate the pointer, adds the new \npointer to a list of allocated pointers, and returns the newly allocated pointer to \nthe calling routine. It can also be checked for an exception or a null return from \nnew (aka an “out-of-memory” error) in this one place only, which simplifies \nerror processing in other parts of your program.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1051, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 836}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1052_8b726d7f", "text": "It can also be checked for an exception or a null return from \nnew (aka an “out-of-memory” error) in this one place only, which simplifies \nerror processing in other parts of your program. C13619670.fm Page 331 Tuesday, April 12, 2011 2:56 PM\n332\nChapter 13: Unusual Data Types\nI\nSAFE_DELETE This routine checks to see whether the pointer passed to it is \nin the list of allocated pointers. If it is in the list, it sets the variable the pointer \npointed at to garbage values, removes the pointer from the list, calls C++’s delete \noperator to deallocate the pointer, and sets the pointer to null. If the pointer isn’t \nin the list, SAFE_DELETE displays a diagnostic message and stops the program.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1052, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 697}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1053_2558efac", "text": "If the pointer isn’t \nin the list, SAFE_DELETE displays a diagnostic message and stops the program. Implemented here as a macro, the SAFE_DELETE routine looks like this:\nC+ + Example of Putting a Wrapper Around Pointer Deletion Code\n#define SAFE_DELETE( pointer ) { \\\n ASSERT( pointer != NULL, \"Attempting to delete null pointer.\"); \\\n if ( IsPointerInList( pointer ) ) { \\\n pointer->SetContentsToGarbage();\n RemovePointerFromList( pointer ); \\\n delete pointer; \\\n pointer = NULL; \\\n } \\\n else { \\\n ASSERT( FALSE, \"Attempting to delete unallocated pointer.\" ); \\\n } \\\n}\nCross-Reference For details \non planning to remove code \nused for debugging, see \n“Plan to Remove Debugging \nAids” in Section 8.6. In C++, this routine will delete individual pointers, but you would also need to imple-\nment a similar SAFE_DELETE_ARRAY routine to delete arrays. By centralizing memory handling in these two routines, you can also make \nSAFE_NEW and SAFE_DELETE behave differently in debug mode vs. production \nmode.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1053, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1054_bb980100", "text": "By centralizing memory handling in these two routines, you can also make \nSAFE_NEW and SAFE_DELETE behave differently in debug mode vs. production \nmode. For example, when SAFE_DELETE detects an attempt to free a null pointer dur-\ning development, it might stop the program, but during production it might simply \nlog an error and continue processing. You can easily adapt this scheme to calloc and free in C and to other languages that use \npointers. Use a nonpointer technique Pointers are harder than average to understand, they’re \nerror-prone, and they tend to require machine-dependent, unportable code. If you can \nthink of an alternative to using a pointer that works reasonably, save yourself a few \nheadaches and use it instead. C++-Pointer Pointers\nFurther Reading For many \nmore tips on using pointers \nin C++, see Effective C++ , 2d \ned. (Meyers 1998) and More \nEffective C++ (Meyers 1996). C++ introduces some specific wrinkles related to using pointers and references.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1054, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1055_9a3e2b24", "text": "(Meyers 1998) and More \nEffective C++ (Meyers 1996). C++ introduces some specific wrinkles related to using pointers and references. The \nfollowing subsections describe guidelines that apply to using pointers in C++:\nUnderstand the difference between pointers and references In C++, both pointers \n(*) and the references ( &) refer indirectly to an object. To the uninitiated the only \ndifference appears to be a purely cosmetic distinction between referring to fields as \nC13619670.fm Page 332 Tuesday, April 12, 2011 2:57 PM\n13.2 Pointers 333\nobject->field vs. object.field . The most significant differences are that a reference must \nalways refer to an object, whereas a pointer can point to null, and what a reference \nrefers to can’t be changed after the reference is initialized. Use pointers for “pass by reference” parameters and use const references for “pass by \nvalue” parameters C++ defaults to passing arguments to routines by value rather \nthan by reference.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1055, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1056_564aca19", "text": "Use pointers for “pass by reference” parameters and use const references for “pass by \nvalue” parameters C++ defaults to passing arguments to routines by value rather \nthan by reference. When you pass an object to a routine by value, C++ creates a copy \nof the object, and when the object is passed back to the calling routine, a copy is cre-\nated again. For large objects, that copying can eat up time and other resources. Conse-\nquently, when passing objects to a routine, you usually want to avoid copying the \nobject, which means you want to pass it by reference rather than by value. Sometimes, however, you would like to have the semantics of a pass by value—that is, \nthat the passed object should not be altered—with the implementation of a pass by \nreference—that is, passing the actual object rather than a copy. In C++, the resolution to this issue is that you use pointers for pass by reference and—\nodd as the terminology might sound—“ const references” for pass by value!", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1056, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1057_a6a3300f", "text": "In C++, the resolution to this issue is that you use pointers for pass by reference and—\nodd as the terminology might sound—“ const references” for pass by value! Here’s an \nexample:\nC+ + Example of Passing Parameters by Reference and by Value\nvoid SomeRoutine(\n const LARGE_OBJECT &nonmodifiableObject,\n LARGE_OBJECT *modifiableObject\n);\nThis approach provides the additional benefit of providing a syntactic differentiation \nwithin the called routine between objects that are supposed to be treated as modifi-\nable and those that aren’t. In a modifiable object, the references to members will use \nthe object->member notation, whereas for nonmodifiable objects references to mem-\nbers will use object.member notation. The limitation of this approach is difficulties propagating const references. If you control \nyour own code base, it’s good discipline to use const whenever possible (Meyers 1998), \nand you should be able to declare pass-by-value parameters as const references.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1057, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1058_9e5cf985", "text": "If you control \nyour own code base, it’s good discipline to use const whenever possible (Meyers 1998), \nand you should be able to declare pass-by-value parameters as const references. For \nlibrary code or other code you don’t control, you’ll run into problems using const routine \nparameters. The fallback position is still to use references for read-only parameters but \nnot declare them const . With that approach, you won’t realize the full benefits of the com-\npiler checking for attempts to modify nonmodifiable arguments to a routine, but you’ll at \nleast give yourself the visual distinction between object->member and object.member . Use auto_ptrs If you haven’t developed the habit of using auto_ptr s, get into the \nhabit! By deleting memory automatically when the auto_ptr goes out of scope, \nauto_ptr s avoid many of the memory-leakage problems associated with regular point-\ners. In Scott Meyers’s More Effective C++ , Item #9 contains a good discussion of \nauto_ptr (Meyers 1996).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1058, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1059_b309c9ee", "text": "In Scott Meyers’s More Effective C++ , Item #9 contains a good discussion of \nauto_ptr (Meyers 1996). C13619670.fm Page 333 Tuesday, April 12, 2011 2:58 PM\n334\nChapter 13: Unusual Data Types\nGet smart about smart pointers Smart pointers are a replacement for regular point-\ners or “dumb” pointers (Meyers 1996). They operate similarly to regular pointers, but \nthey provide more control over resource management, copy operations, assignment \noperations, object construction, and object destruction. The issues involved are spe-\ncific to C++. More Effective C++ , Item #28, contains a complete discussion. C-Pointer Pointers\nHere are a few tips on using pointers that apply specifically to the C language:\nUse explicit pointer types rather than the default type C lets you use char or void \npointers for any type of variable. As long as the pointer points, the language doesn’t \nreally care what it points at.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1059, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 908}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1060_9ff9308f", "text": "As long as the pointer points, the language doesn’t \nreally care what it points at. If you use ex plicit types for your pointers, however, the \ncompiler can give you warnings about mismatched pointer types and inappropriate \ndereferences. If you don’t, it can’t. Use the specific pointer type whenever you can. The corollary to this rule is to use explicit type casting when you have to make a type \nconversion. For example, in this fragment, it’s clear that a variable of type NODE_ PTR \nis being allocated:\nC Example of Explicit Type Casting\nNodePtr = (NODE_PTR) calloc( 1, sizeof( NODE ) );\nAvoid type casting Avoiding type casting doesn’t have anything to do with going to \nacting school or getting out of always playin g “the heavy.” It has to do with avoiding \nsqueezing a variable of one type into the space for a variable of another type. Type \ncasting turns off your complier’s ability to check for type mismatches and therefore \ncreates a hole in your defensive-programming armor.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1060, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 990}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1061_57c9f84d", "text": "Type \ncasting turns off your complier’s ability to check for type mismatches and therefore \ncreates a hole in your defensive-programming armor. A program that requires many \ntype casts probably has some architectural gaps that need to be revisited. Redesign if \nthat’s possible; otherwise, try to avoid type casts as much as you can. Follow the asterisk rule for parameter passing You can pass an argument back from \na routine in C only if you have an asterisk (*) in front of the argument in the assign-\nment statement. Many C programmers have difficulty determining when C allows a \nvalue to be passed back to a calling routine. It’s easy to remember that, as long as you \nhave an asterisk in front of the parameter when you assign it a value, the value is \npassed back to the calling routine. Regardless of how many asterisks you stack up in \nthe declaration, you must have at least one in the assignment statement if you want to \npass back a value.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1061, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1062_cc346c65", "text": "Regardless of how many asterisks you stack up in \nthe declaration, you must have at least one in the assignment statement if you want to \npass back a value. For example, in the following fragment, the value assigned to \nparameter isn’t passed back to the calling routine because the assignment statement \ndoesn’t use an asterisk:\n13.3 Global Data 335\nC Example of Parameter Passing That Won’t Work\nvoid TryToPassBackAValue( int *parameter ) {\n parameter = SOME_VALUE;\n}\nHere, the value assigned to parameter is passed back because parameter has an asterisk \nin front of it:\nC Example of Parameter Passing That Will Work\nvoid TryToPassBackAValue( int *parameter ) {\n *parameter = SOME_VALUE;\n}\nUse sizeof() to determine the size of a variable in a memory allocation It’s easier to \nuse sizeof() than to look up the size in a manual, and sizeof() works for structures you \ncreate yourself, which aren’t in the manual.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1062, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 915}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1063_404b2e34", "text": "Because it’s calculat ed at compile time, \nsizeof() doesn’t carry a performance penalty. It’s portable—recompiling in a different \nenvironment automatically chan ges the value calculated by sizeof() . And it requires lit-\ntle maintenance since you can change types you have defined and allocations will be \nadjusted automatically. 13.3 Global Data\nCross-Reference For details \non the differences between \nglobal data and class data, \nsee “Class data mistaken for \nglobal data” in Section 5.3. Global variables are accessible anywhere in a program. The term is also sometimes \nused sloppily to refer to variables with a broader scope than local variables—such as \nclass variables that are accessible anywhere within a class. But accessibility anywhere \nwithin a single class does not by itself mean that a variable is global. Most experienced programmers have concluded that using global data is riskier than \nusing local data.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1063, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1064_d37125bc", "text": "Most experienced programmers have concluded that using global data is riskier than \nusing local data. Most experienced programme rs have also concluded that access to \ndata from several routines is pretty useful. Even if global variables don’t always produce errors, however, they’re hardly ever the \nbest way to program. The rest of this se ction fully explores the issues involved. Common Problems with Global Data\nIf you use global variables indiscriminately or you feel that not being able to use them \nis restrictive, you probably haven’t caught on to the full value of information hiding \nand modularity yet. Modularity, information hiding, and the associated use of well-\ndesigned classes might not be revealed trut hs, but they go a long way toward making \nlarge programs understandable and maintainable. Once you get the message, you’ll \nwant to write routines and classes with as li ttle connection as possible to global vari-\nables and the outside world.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1064, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1065_ba4c797b", "text": "Once you get the message, you’ll \nwant to write routines and classes with as li ttle connection as possible to global vari-\nables and the outside world. KEY POINT\n336\nChapter 13: Unusual Data Types\nPeople cite numerous problems in using glob al data, but the problems boil down to a \nsmall number of major issues:\nInadvertent changes to global data You might change the value of a global variable \nin one place and mistakenly think that it has remained unchanged somewhere else. Such a problem is known as a “side effect.” For example, in this example, theAnswer is \na global variable:\ntheAnswer is a global variable. Visual Basic Example of a Side-Effect Problem\nGetOtherAnswer() changes \ntheAnswer . averageAnswer is wrong. theAnswer = GetTheAnswer()\notherAnswer = GetOtherAnswer()\naverageAnswer = (theAnswer + otherAnswer) / 2\nYou might assume that the call to GetOtherAnswer() doesn’t change the value of theAn-\nswer; if it does, the average in the third line will be wrong.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1065, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1066_1980aeb5", "text": "And, in fact, GetOtherAn-\nswer() does change the value of theAnswer , so the program has an error to be fixed. Bizarre and exciting aliasing problems with global data “Aliasing” refers to calling \nthe same variable by two or more differen t names. This happens when a global vari-\nable is passed to a routine and then used by the routine both as a global variable and \nas a parameter.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1066, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 384}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1067_4a36fd2d", "text": "This happens when a global vari-\nable is passed to a routine and then used by the routine both as a global variable and \nas a parameter. Here’s a routine that uses a global variable:\nVisual Basic Example of a Routine That’s Ripe for an Aliasing Problem\nSub WriteGlobal( ByRef inputVar As Integer )\n inputVar = 0\n globalVar = inputVar + 5\n MsgBox( \"Input Variable: \" & Str( inputVar ) )\n MsgBox( \"Global Variable: \" & Str( globalVar ) )\nEnd Sub\nHere’s the code that calls the routine with the global variable as an argument:\nVisual Basic Example of Calling the Ro utine with an Argument, Which Exposes \nan Aliasing Problem\nWriteGlobal( globalVar )\nSince inputVar is initialized to 0 and WriteGlobal() adds 5 to inputVar to get globalVar , \nyou’d expect globalVar to be 5 more than inputVar . But here’s the surprising result:\nThe Result of the Aliasing Problem in Visual Basic\nInput Variable: 5\nGlobal Variable: 5\nThe subtlety here is that globalVar and inputVar are actually the same variable!", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1067, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1068_46bf80f9", "text": "Since \nglobalVar is passed into WriteGlobal() by the calling routine, it’s referenced or \nCODING \nHORROR\n13.3 Global Data 337\n“aliased” by two different names. The effect of the MsgBox() lines is thus quite differ-\nent from the one intended: they display the same variable twice, even though they \nrefer to two different names. Re-entrant code problems with global data Code that can be entered by more than \none thread of control is becoming increa singly common. Multithreaded code creates \nthe possibility that global data will be shared not only among routines, but among dif-\nferent copies of the same program. In such an environment, you have to make sure \nthat global data keeps its meaning even when multiple copies of a program are run-\nning. This is a significant problem, and you can avoid it by using techniques suggested \nlater in this section.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1068, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 857}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1069_80b47f8e", "text": "This is a significant problem, and you can avoid it by using techniques suggested \nlater in this section. Code reuse hindered by global data To use code from one program in another pro-\ngram, you have to be able to pull it out of the first program and plug it into the second. Ideally, you’d be able to lift out a single routine or class, plug it into another program, \nand continue merrily on your way. Global data complicates the picture. If the class you want to reuse reads or writes glo-\nbal data, you can’t just plug it into the ne w program. You have to modify the new pro-\ngram or the old class so that they’re compatible. If you take the high road, you’ll \nmodify the old class so that it doesn’t use gl obal data. If you do that, the next time you \nneed to reuse the class you’ll be able to plug it in with no extra fuss. If you take the low \nroad, you’ll modify the new program to create the global data that the old class needs \nto use.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1069, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1070_42a3b130", "text": "If you take the low \nroad, you’ll modify the new program to create the global data that the old class needs \nto use. This is like a virus; not only does the global data affect the original program, \nbut it also spreads to new programs that use any of the old program’s classes. Uncertain initialization-order issues with global data The order in which data is ini-\ntialized among different “translation units” (files) is not defined in some languages, \nnotably C++. If the initialization of a global variable in one file uses a global variable that \nwas initialized in a different file, all bets are off on the second variable’s value unless you \ntake explicit steps to ensure the two vari ables are initialized in the right sequence. This problem is solvable with a workaround that Scott Meyers describes in Effective \nC++, Item #47 (Meyers 1998). But the trickiness of the solution is representative of the \nextra complexity that using global data introduces.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1070, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 961}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1071_649f367f", "text": "But the trickiness of the solution is representative of the \nextra complexity that using global data introduces. Modularity and intellectual manage ability damaged by global data The essence of \ncreating programs that are larger than a few hundred lines of code is managing com-\nplexity. The only way you can intellectually ma nage a large program is to break it into \npieces so that you only have to think about one part at a time. Modularization is the \nmost powerful tool at your disposal for breaking a program into pieces. Global data pokes holes in your ability to modularize. If you use global data, can you \nconcentrate on one routine at a time? No. You have to concentrate on one routine and \nevery other routine that uses the same glob al data. Although global data doesn’t com-\nKEY POINT\n338\nChapter 13: Unusual Data Types\npletely destroy a program’s modularity, it weakens it, and that’s reason enough to try \nto find better solutions to your problems.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1071, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1072_61725ce7", "text": "Reasons to Use Global Data\nData purists sometimes argue that programmers should never use global data, but \nmost programs use “global data” when the term is broadly construed. Data in a data-\nbase is global data, as is data in config uration files such as the Windows registry. Named constants are global data, just not global variables. Used with discipline, global variable s are useful in several situations:\nPreservation of global values Sometimes you have data that applies conceptually to \nyour whole program. This might be a variab le that reflects the state of a program—for \nexample, interactive vs. command-line mode, or normal vs. error-recovery mode. Or it \nmight be information that’s needed throughout a program—for example, a data table \nthat every routine in the program uses.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1072, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 792}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1073_3af5c327", "text": "command-line mode, or normal vs. error-recovery mode. Or it \nmight be information that’s needed throughout a program—for example, a data table \nthat every routine in the program uses. Cross-Reference For more \ndetails on named constants, \nsee Section 12.7, “Named \nConstants.”\nEmulation of named constants Although C++, Java, Visual Basic, and most modern \nlanguages support named constants, some la nguages such as Python, Perl, Awk, and \nUNIX shell script still don’t. You can use global variables as substitutes for named \nconstants when your language doesn’t s upport them. For example, you can replace \nthe literal values 1 and 0 with the global variables TRUE and FALSE set to 1 and 0, or \nyou can replace 66 as the number of lines per page with LINES_PER_PAGE = 66 . It’s \neasier to change code later when this approa ch is used, and the code tends to be easier \nto read. This disciplined use of global da ta is a prime example of the distinction \nbetween programming in vs.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1073, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 981}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1074_ec5db942", "text": "This disciplined use of global da ta is a prime example of the distinction \nbetween programming in vs. programming into a language, which is discussed more \nin Section 34.4, “Program into Your Language, Not in It.”\nEmulation of enumerated types You can also use global variables to emulate enumer-\nated types in languages such as Python th at don’t support enumerated types directly. Streamlining use of extremely common data Sometimes you have so many refer-\nences to a variable that it appears in the parameter list of every routine you write. Rather than including it in every paramete r list, you can make it a global variable. However, in cases in which a variable seems to be accessed everywhere, it rarely is. Usually it’s accessed by a limited set of rout ines you can package into a class with the \ndata they work on. More on this later. Eliminating tramp data Sometimes you pass data to a routine or class merely so that \nit can be passed to another routine or class.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1074, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1075_e8f40196", "text": "More on this later. Eliminating tramp data Sometimes you pass data to a routine or class merely so that \nit can be passed to another routine or class. For example, you might have an error-pro-\ncessing object that’s used in each routine. When the routine in the middle of the call \nchain doesn’t use the object, the object is ca lled “tramp data.” Use of global variables \ncan eliminate tramp data. 13.3 Global Data 339\nUse Global Data Only as a Last Resort\nBefore you resort to using global data, consider a few alternatives:\nBegin by making each variable local and ma ke variables global only as you need to\nMake all variables local to individual routines initially. If you find they’re needed else-\nwhere, make them private or protected class variables before you go so far as to make \nthem global. If you finally find that you have to make them global, do it, but only when \nyou’re sure you have to.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1075, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 902}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1076_a1199ecc", "text": "If you finally find that you have to make them global, do it, but only when \nyou’re sure you have to. If you start by maki ng a variable global, you’ll never make it \nlocal, whereas if you start by making it local, you might never need to make it global. Distinguish between global and class variables Some variables are truly global in that \nthey are accessed throughout a whole program. Others are really class variables, used \nheavily only within a certain set of routines. It ’s OK to access a class variable any way you \nwant to within the set of routines that use it heavily. If routines outside the class need to \nuse it, provide the variable’s value by means of an access routine. Don’t access class val-\nues directly—as if they were global variable s—even if your programming language allows \nyou to. This advice is tantamount to sa ying “Modularize! Modularize! Modularize!”\nUse access routines Creating access routines is the workhorse approach to getting \naround problems with global data.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1076, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1077_784440ba", "text": "This advice is tantamount to sa ying “Modularize! Modularize! Modularize!”\nUse access routines Creating access routines is the workhorse approach to getting \naround problems with global data. More on that in the next section. Using Access Routines Instead of Global Data\nAnything you can do with global data, you can do better with access routines. The use \nof access routines is a core technique for im plementing abstract data types and achiev-\ning information hiding. Even if you don’t want to use a full-blown abstract data type, \nyou can still use access routines to centralize control over your data and to protect \nyourself against changes. Advantages of Access Routines\nUsing access routines has multiple advantages:\n■\nYou get centralized control over the data. If you discover a more appropriate \nimplementation of the structure later, you don’t have to change the code every-\nwhere the data is referenced. Changes don’t ripple through your whole pro-\ngram. They stay inside the access routines.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1077, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1004}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1078_0c22e9e6", "text": "Changes don’t ripple through your whole pro-\ngram. They stay inside the access routines. Cross-Reference For more \ndetails on barricading, see \nSection 8.5, “Barricade Your \nProgram to Contain the \nDamage Caused by Errors.”■\nYou can ensure that all references to the variable are barricaded. If you push ele-\nments onto the stack with statements like stack.array[ stack.top ] = newElement , \nyou can easily forget to check for stack overflow and make a serious mistake. If \nyou use access routines—for example, PushStack( newElement ) —you can write \nthe check for stack overflow into the PushStack() routine. The check will be done \nautomatically every time the routine is called, and you can forget about it. KEY POINT\n340\nChapter 13: Unusual Data Types\nCross-Reference For details \non information hiding, see \n“Hide Secrets (Information \nHiding)” in Section 5.3.■\nYou get the general benefits of informatio n hiding automatically.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1078, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 933}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1079_3d09403d", "text": "Access routines \nare an example of information hiding, even if you don’t design them for that rea-\nson. You can change the interior of an access routine without changing the rest \nof the program. Access routines allow you to redecorate the interior of your \nhouse and leave the exterior unchanged so that your friends still recognize it. ■\nAccess routines are easy to convert to an abstract data type. One advantage of \naccess routines is that you can create a leve l of abstraction that’s harder to do when \nyou’re working with global data directly. For example, instead of writing code that \nsays if lineCount > MAX_LINES , an access routine allows you to write code that says \nif PageFull() . This small change documents the intent of the if lineCount test , and it \ndoes so in the code. It’s a small gain in readability, but consistent attention to \nsuch details makes the difference between beautifully crafted software and code \nthat’s just hacked together.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1079, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1080_9774bf0a", "text": "It’s a small gain in readability, but consistent attention to \nsuch details makes the difference between beautifully crafted software and code \nthat’s just hacked together. How to Use Access Routines\nHere’s the short version of the theory and practice of access routines: Hide data in a \nclass. Declare that data by using the static keyword or its equivalent to ensure only a \nsingle instance of the data exists. Write routines that let you look at the data and \nchange it. Require code outside the class to use the access routines rather than work-\ning directly with the data. For example, if you have a global status variable g_globalStatus that describes your pro-\ngram’s overall status, you can create two access routines: globalStatus.Get() and global-\nStatus.Set() , each of which does what it sounds like it does. Those routines access a \nvariable hidden within the class that replaces g_globalStatus .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1080, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1081_617d8b9d", "text": "Those routines access a \nvariable hidden within the class that replaces g_globalStatus . The rest of the program \ncan get all the benefit of the formerly global variable by accessing globalStatus.Get() \nand globalStatus.Set() . Cross-Reference Restricting \naccess to global variables \neven when your language \ndoesn’t directly support that \nis an example of program-\nming into a language vs. programming in a language. For more details, see Section \n34.4, “Program into Your \nLanguage, Not in It.”\nIf your language doesn’t support classes, yo u can still create access routines to manip-\nulate the global data but you’ll have to enforce restrictions on the use of the global \ndata through coding standards in lieu of built-in programming language enforcement.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1081, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 759}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1082_03a69bd3", "text": "Here are a few detailed guidelines for using access routines to hide global variables \nwhen your language doesn’t have built-in support:\nRequire all code to go through the access routines for the data A good convention is \nto require all global data to begin with the g_ prefix, and to further require that no \ncode access a variable with the g_ prefix except that variable’s access routines. All \nother code reaches the data through the access routines. Don’t just throw all your glob al data into the same barrel If you throw all your glo-\nbal data into a big pile and write access routines for it, you eliminate the problems of \nglobal data but you miss out on some of the advantages of information hiding and \nabstract data types. As long as you’re wr iting access routines, take a moment to think \n13.3 Global Data 341\nabout which class each global variable belo ngs in and then package the data and its \naccess routines with the other data and routines in that class.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1082, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1083_32e3f6af", "text": "Use locking to control access to global variables Similar to concurrency control in a \nmultiuser database environment, locking requires that before the value of a global \nvariable can be used or updated, the variable must be “checked out.” After the variable \nis used, it’s checked back in. During the time it’s in use (checked out), if some other \npart of the program tries to check it out, the lock/unlock routine displays an error \nmessage or fires an assertion. Cross-Reference For details \non planning for differences \nbetween developmental and \nproduction versions of a pro-\ngram, see “Plan to Remove \nDebugging Aids” in Section \n8.6 and Section 8.7, “Deter-\nmining How Much Defensive \nProgramming to Leave in \nProduction Code.”\nThis description of locking ignores many of the subtleties of writing code to fully sup-\nport concurrency. For that reason, simplified locking schemes like this one are most \nuseful during the developmen t stage.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1083, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 947}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1084_07f21f82", "text": "For that reason, simplified locking schemes like this one are most \nuseful during the developmen t stage. Unless the scheme is very well thought out, it \nprobably won’t be reliable enough to be put into production. When the program is \nput into production, the code is modified to do something safer and more graceful \nthan displaying error messages. For example, it might log an error message to a file \nwhen it detects multiple parts of the program trying to lock the same global variable. This sort of development-time safeguard is fairly easy to implement when you use \naccess routines for global data, but it would be awkward to implement if you were \nusing global data directly. Build a level of abstractio n into your access routines Build access routines at the \nlevel of the problem domain rather than at the level of the implementation details. That approach buys you improved readabilit y as well as insurance against changes in \nthe implementation details.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1084, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1085_15847b88", "text": "That approach buys you improved readabilit y as well as insurance against changes in \nthe implementation details. Compare the pairs of statements in Table 13-1:\nIn the first three examples, the point is that an abstract access routine tells you a lot \nmore than a generic structure. If you use the structure directly, you do too much at \nonce: you show both what the structure itself is doing (moving to the next link in a \nlinked list) and what’s being done with respect to the entity it represents (getting an \naccount, next employee, or rate level). This is a big burden to put on a simple data-\nstructure assignment. Hiding the information behind abstract access routines lets the \ncode speak for itself and makes the code read at the level of the problem domain, \nrather than at the level of implementation details.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1085, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 820}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1086_52700c7a", "text": "Hiding the information behind abstract access routines lets the \ncode speak for itself and makes the code read at the level of the problem domain, \nrather than at the level of implementation details. Table 13-1\nAccessing Global Data Directly and Through Access Routines\nDirect Use of Global Data\nUse of Global Data Through Access Routines\nnode = node.next account = NextAccount( account )\nnode = node.next employee = NextEmployee( employee )\nnode = node.next rateLevel = NextRateLevel( rateLevel ) \nevent = eventQueue[ queueFront ] e vent = HighestPriorityEvent() \nevent = eventQueue[ queueBack ] event = LowestPriorityEvent()\n342\nChapter 13: Unusual Data Types\nKeep all accesses to the data at the same level of abstraction If you use an access \nroutine to do one thing to a structure, you should use an access routine to do every-\nthing else to it too. If you read from the structure with an access routine, write to it \nwith an access routine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1086, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1087_6599c35c", "text": "If you read from the structure with an access routine, write to it \nwith an access routine. If you call InitStack() to initialize a stack and PushStack() to \npush an item onto the stack, you’ve created a consistent view of the data. If you pop \nthe stack by writing value = array[ stack.top ] , you’ve created an inconsistent view of the \ndata. The inconsistency makes it harder for others to understand the code. Create a \nPopStack() routine instead of writing value = array[ stack top ] . Cross-Reference Using \naccess routines for an event \nqueue suggests the need to \ncreate a class. For details, \nsee Chapter 6, “Working \nClasses.”\nIn the example pairs of statements in Table 13-1, the two event-queue operations \noccurred in parallel.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1087, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 740}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1088_432ea11e", "text": "For details, \nsee Chapter 6, “Working \nClasses.”\nIn the example pairs of statements in Table 13-1, the two event-queue operations \noccurred in parallel. Inserting an event into the queue would be trickier than either of \nthe two operations in the table, requiring several lines of code to find the place to \ninsert the event, adjust existing events to make room for the new event, and adjust the \nfront or back of the queue. Removing an event from the queue would be just as com-\nplicated. During coding, the complex operations would be put into routines and the \nothers would be left as direct data manipulations. This would create an ugly, nonpar-\nallel use of the structure. Now compare the pairs of statements in Table 13-2:\nAlthough you might think that these guidel ines apply only to large programs, access \nroutines have shown themselves to be a productive way of avoiding the problems of \nglobal data. As a bonus, they make the code more readable and add flexibility.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1088, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1089_f0a905a0", "text": "As a bonus, they make the code more readable and add flexibility. How to Reduce the Risks of Using Global Data\nIn most instances, global data is really cla ss data for a class that hasn’t been designed \nor implemented very well. In a few instances, data really does need to be global, but \naccesses to it can be wrapped with access ro utines to minimize potential problems. In \na tiny number of remaining instances, you really do need to use global data. In those \ncases, you might think of following the guidel ines in this section as getting shots so \nthat you can drink the water when you travel to a foreign country: they’re kind of pain-\nful, but they improve the odds of staying healthy. Cross-Reference For details \non naming conventions for \nglobal variables, see “Iden-\ntify global variables” in Sec-\ntion 11.4. Develop a naming convention that makes global variables obvious You can avoid \nsome mistakes just by making it obvious that you’re working with global data.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1089, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1090_11a75461", "text": "Develop a naming convention that makes global variables obvious You can avoid \nsome mistakes just by making it obvious that you’re working with global data. If \nyou’re using global variables for more than one purpose (for example, as variables and \nas substitutes for named constants), make su re your naming conven tion differentiates \namong the types of uses. Table 13-2\n Parallel and Nonparallel Uses of Complex Data\nNonparallel Use of Complex Data\nParallel Use of Complex Data \nevent = EventQueue[ queueFront ] event = HighestPriorityEvent()\nevent = EventQueue[ queueBack ] event = LowestPriorityEvent()\nAddEvent( event ) AddEvent( event )\neventCount = eventCount - 1 RemoveEvent( event )\nAdditional Resources 343\nCreate a well-annotated list of all your global variables Once your naming conven-\ntion indicates that a variable is global, it’s helpful to indicate what the variable does. A \nlist of global variables is one of the most useful tools that someone working with your \nprogram can have.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1090, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1091_9f85354d", "text": "A \nlist of global variables is one of the most useful tools that someone working with your \nprogram can have. Don’t use global variables to contain intermediate results If you need to compute a \nnew value for a global variable, assign the g lobal variable the final value at the end of \nthe computation rather than using it to hold the result of intermediate calculations. Don’t pretend you’re not using global data by putting all your data into a monster \nobject and passing it everywhere Putting everything into one huge object might sat-\nisfy the letter of the law by avoiding global variables, but it’s pure overhead, producing \nnone of the benefits of true encapsulation. If you use global data, do it openly. Don’t \ntry to disguise it with obese objects. Additional Resources\ncc2e.com/1385\nFollowing are more resources that cover unusual data types:\nMaguire, Steve. Writing Solid Code . Redmond, WA: Microsoft Press, 1993.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1091, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1092_63fff95a", "text": "Additional Resources\ncc2e.com/1385\nFollowing are more resources that cover unusual data types:\nMaguire, Steve. Writing Solid Code . Redmond, WA: Microsoft Press, 1993. Chapter 3 \ncontains an excellent discussion of the ha zards of pointer use and numerous specific \ntips for avoiding problems with pointers. Meyers, Scott. Effective C++ , 2d ed. Reading, MA: Addison-Wesley, 1998; Meyers, Scott, \nMore Effective C++ . Reading, MA: Addison-Wesley, 1996 . As the titles suggest, these \nbooks contain numerous specific tips for improving C++ programs, including guide-\nlines for using pointers safely and effectively. More Effective C++ in particular contains \nan excellent discussion of C+ +’s memory management issues. cc2e.com/1392\nCHECKLIST: Considerations in Using Unusual Data Types\nStructures\n❑\nHave you used structures instead of naked variables to organize and \nmanipulate groups of related data? ❑\nHave you considered creati ng a class as an alternative to using a structure?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1092, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 982}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1093_e9bae77c", "text": "❑\nHave you considered creati ng a class as an alternative to using a structure? Global Data\n❑\nAre all variables local or of class scop e unless they absolutely need to be \nglobal? ❑\nDo variable naming conventions differ entiate among local, class, and glo-\nbal data? ❑\nAre all global variables documented? 344\nChapter 13: Unusual Data Types\n❑\nIs the code free of pseudoglobal data—mammoth objects containing a \nmishmash of data that’s passed to every routine? ❑\nAre access routines used instead of global data? ❑\nAre access routines and data organized into classes? ❑\nDo access routines provide a level of abstraction beyond the underlying \ndata type implementations? ❑\nAre all related access routines at the same level of abstraction? Pointers\n❑\nAre pointer operations isolated in routines? ❑\nAre pointer references valid, or could the pointer be dangling? ❑\nDoes the code check pointers for validity before using them? ❑\nIs the variable that the pointer references checked for validity before it’s \nused?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1093, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1006}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1094_f1099e10", "text": "❑\nDoes the code check pointers for validity before using them? ❑\nIs the variable that the pointer references checked for validity before it’s \nused? ❑\nAre pointers set to null after they’re freed? ❑\nDoes the code use all the pointer variables needed for the sake of readabil-\nity? ❑\nAre pointers in linked lists freed in the right order? ❑\nDoes the program allocate a reserve parachute of memory so that it can \nshut down gracefully if it runs out of memory? ❑\nAre pointers used only as a last resort, when no other method is available? Key Points\n■\nStructures can help make programs less complicated, easier to understand, and \neasier to maintain. ■\nWhenever you consider using a structure, consider whether a class would work \nbetter. ■\nPointers are error-prone. Protect yourself by using access routines or classes and \ndefensive-programming practices. ■\nAvoid global variables, not just because they’re dangerous, but because you can \nreplace them with something better.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1094, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1095_f6236a39", "text": "■\nAvoid global variables, not just because they’re dangerous, but because you can \nreplace them with something better. ■\nIf you can’t avoid global variables, wo rk with them through access routines. Access routines give you everything that global variables give you, and more. Part IV\nStatements\nIn this part:\nChapter 14: Organizing Straight-Line Code . . . . . . . . . . . . . . . . . . . . . . . .347\nChapter 15: Using Conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .355\nChapter 16: Controlling Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .367\nChapter 17: Unusual Control Structures . . . . . . . . . . . . . . . . . . . . . . . . . . .391\nChapter 18: Table-Driven Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .411\nChapter 19: General Control Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1095, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 896}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1096_7f0c34de", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . .391\nChapter 18: Table-Driven Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .411\nChapter 19: General Control Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .431\n\n347\nChapter 14\nOrganizing Straight-Line \nCode\ncc2e.com/1465\nContents\n■\n14.1 Statements That Must Be in a Specific Order: page 347\n■\n14.2 Statements Whose Order Doesn’t Matter: page 351\nRelated Topics\n■\nGeneral control topics: Chapter 19\n■\nCode with conditionals: Chapter 15\n■\nCode with loops: Chapter 16\n■\nScope of variables and obj ects: Section 10.4, “Scope”\nThis chapter turns from a data-centered vi ew of programming to a statement-centered \nview. It introduces the simplest kind of control flow: putting statements and blocks of \nstatements in sequential order. Although organizing straight-line code is a relatively simple task, some organizational \nsubtleties influence code quality, correc tness, readability, and maintainability.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1096, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1097_1d9d6493", "text": "Although organizing straight-line code is a relatively simple task, some organizational \nsubtleties influence code quality, correc tness, readability, and maintainability. 14.1 Statements That Must Be in a Specific Order\nThe easiest sequential statements to order are those in which the order counts. Here’s \nan example:\nJava Example of Statements in Which Order Counts\ndata = ReadData();\nresults = CalculateResultsFromData( data );\nPrintResults( results );\nUnless something mysterious is happening with this code fragment, the statement \nmust be executed in the order shown. The data must be read before the results can be \ncalculated, and the results must be calculated before they can be printed. The underlying concept in this example is that of dependencies. The third statement \ndepends on the second, the second on the fi rst. In this example, the fact that one \n348\nChapter 14: Organizing Straight-Line Code\nstatement depends on another is obvious from the routine names.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1097, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1098_c4b87976", "text": "In this example, the fact that one \n348\nChapter 14: Organizing Straight-Line Code\nstatement depends on another is obvious from the routine names. In the following \ncode fragment, the dependencies are less obvious:\nJava Example of Statements in Which Order Counts, but Not Obviously\nrevenue.ComputeMonthly();\nrevenue.ComputeQuarterly();\nrevenue.ComputeAnnual();\nIn this case, the quarterly revenue calculation assumes that the monthly revenues \nhave already been calculated. A familiar ity with accounting—or even common sense—\nmight tell you that quarterly revenues have to be calculated before annual revenues. There is a dependency, but it’s not obvious merely from reading the code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1098, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 685}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1099_e6d6387b", "text": "There is a dependency, but it’s not obvious merely from reading the code. And here, \nthe dependencies aren’t obvious—they’re literally hidden:\nVisual Basic Example of Statements in Which Order Dependencies Are Hidden\nComputeMarketingExpense\nComputeSalesExpense\nComputeTravelExpense\nComputePersonnelExpense\nDisplayExpenseSummary\nSuppose that ComputeMarketingExpense() initializes the class member variables that \nall the other routines put their data into. In su ch a case, it needs to be called before the \nother routines. How could you know that from reading this code? Because the routine \ncalls don’t have any parameters, you might be able to guess that each of these routines \naccesses class data. But you can’t know for sure from reading this code. When statements have dependencies that require you to put them in a certain order, \ntake steps to make the dependencies clear.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1099, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 880}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1100_85f1b091", "text": "But you can’t know for sure from reading this code. When statements have dependencies that require you to put them in a certain order, \ntake steps to make the dependencies clear. Here are some simple guidelines for order-\ning statements:\nOrganize code so that dependencies are obvious In the Microsoft Visual Basic exam-\nple just presented, ComputeMarketingExpense() shouldn’t initialize the class member \nvariables. The routine names suggest that ComputeMarketingExpense() is similar to \nComputeSalesExpense() , ComputeTravelExpense() , and the other routines except that it \nworks with marketing data rather than with sales data or other data. Having Comp-\nuteMarketingExpense() initialize the member variable is an arbitrary practice you \nshould avoid. Why should initialization be done in that routine instead of one of the \nother two? Unless you can think of a good reason, you should write another routine, \nInitializeExpenseData() , to initialize the member variable.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1100, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1101_b7796bfd", "text": "Unless you can think of a good reason, you should write another routine, \nInitializeExpenseData() , to initialize the member variable. The routine’s name is a clear \nindication that it should be called before the other expense routines. Name routines so that de pendencies are obvious In the Visual Basic example, Comp-\nuteMarketingExpense() is misnamed because it does more than compute marketing \nexpenses; it also initializes member data. If you’re opposed to creating an additional \nroutine to initialize the data, at least give ComputeMarketingExpense() a name that \nKEY POINT\n14.1 Statements That Must Be in a Specific Order 349\ndescribes all the functions it performs. In this case, ComputeMarketingExpenseAndIni-\ntializeMemberData() would be an adequate name. You might say it’s a terrible name \nbecause it’s so long, but the name describes what the routine does and is not terrible. The routine itself is terrible!", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1101, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 923}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1102_7e00e06b", "text": "You might say it’s a terrible name \nbecause it’s so long, but the name describes what the routine does and is not terrible. The routine itself is terrible! Cross-Reference For details \non using routines and their \nparameters, see Chapter 5, \n“Design in Construction.”\nUse routine parameters to make dependencies obvious Again in the Visual Basic \nexample, since no data is passed between routines, you don’t know whether any of \nthe routines use the same data. By rewriting the code so that data is passed between \nthe routines, you set up a clue that the execution order is important.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1102, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 585}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1103_f26c3f21", "text": "By rewriting the code so that data is passed between \nthe routines, you set up a clue that the execution order is important. The new code \nwould look like this:\nVisual Basic Example of Data Th at Suggests an Order Dependency\nInitializeExpenseData( expenseData )\nComputeMarketingExpense( expenseData )\nComputeSalesExpense( expenseData )\nComputeTravelExpense( expenseData )\nComputePersonnelExpense( expenseData )\nDisplayExpenseSummary( expenseData )\nBecause all the routines use expenseData , you have a hint that they might be working \non the same data and that the order of the statements might be important. In this particular example, a better approach might be to convert the routines to func-\ntions that take expenseData as inputs and return updated expenseData as outputs, \nwhich makes it even clearer that the code includes order dependencies.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1103, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 849}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1104_fc0f90e3", "text": "Visual Basic Example of Data and Routin e Calls That Suggest an Order Dependency\nexpenseData = InitializeExpenseData( expenseData )\nexpenseData = ComputeMarketingExpense( expenseData )\nexpenseData = ComputeSalesExpense( expenseData )\nexpenseData = ComputeTravelExpense( expenseData )\nexpenseData = ComputePersonnelExpense( expenseData )\nDisplayExpenseSummary( expenseData )\nData can also indicate that execution or der isn’t important, as in this case:\nVisual Basic Example of Data That Doesn’t Indicate an Order Dependency\nComputeMarketingExpense( marketingData )\nComputeSalesExpense( salesData )\nComputeTravelExpense( travelData )\nComputePersonnelExpense( personnelData )\nDisplayExpenseSummary( marketingData, salesData, travelData, personnelData )\nSince the routines in the first four lines don’t have any data in common, the code \nimplies that the order in which they’re called doesn’t matter.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1104, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 897}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1105_973f70e3", "text": "Because the routine in \nthe fifth line uses data from each of the first four routines, you can assume that it \nneeds to be executed after the first four routines. 350\nChapter 14: Organizing Straight-Line Code\nDocument unclear dependencies with comments Try first to write code without \norder dependencies.Try second to write code that makes dependencies obvious. If \nyou’re still concerned that an order dependency isn’t explicit enough, document it. Documenting unclear dependencies is one aspect of documenting coding assump-\ntions, which is critical to writing maintainable, modifiable code. In the Visual Basic \nexample, comments along these lines would be helpful:\nVisual Basic Example of Statements in Which Order Dependencies Are Hidden but \nClarified with Comments\n' Compute expense data. Each of the routines accesses the\n' member data expenseData. DisplayExpenseSummary \n' should be called last because it depends on data calculated \n' by the other routines.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1105, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1106_9b4aa5aa", "text": "Each of the routines accesses the\n' member data expenseData. DisplayExpenseSummary \n' should be called last because it depends on data calculated \n' by the other routines. InitializeExpenseData\nComputeMarketingExpense\nComputeSalesExpense\nComputeTravelExpense\nComputePersonnelExpense\nDisplayExpenseSummary\nThis code doesn’t use the techniques for making order dependencies obvious. It’s bet-\nter to rely on such techniques rather than on comments, but if you’re maintaining \ntightly controlled code or you can’t improve the code itself for some other reason, use \ndocumentation to compensate for code weaknesses. Check for dependencies with assertions or error-handling code If the code is critical \nenough, you might use status variables and error-handling code or assertions to doc-\nument critical sequential dependencies. For example, in the class’s constructor, you \nmight initialize a class member variable isExpenseDataInitialized to false.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1106, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 945}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1107_76bf137e", "text": "For example, in the class’s constructor, you \nmight initialize a class member variable isExpenseDataInitialized to false. Then in Ini-\ntializeExpenseData() , you can set isExpenseDataInitialized to true. Each function that \ndepends on expenseData being initialized can then check whether isExpenseDataIni-\ntialized has been set to true before performing additional operations on expenseData . Depending on how extensive the dependencies are, you might also need variables like \nisMarketingExpenseComputed , isSalesExpenseComputed , and so on. This technique creates new variables, new in itialization code, and new error-checking \ncode, all of which create addi tional possibilities for error. The benefits of this tech-\nnique should be weighed against the additi onal complexity and increased chance of \nsecondary errors that this technique creates.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1107, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 850}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1108_95bf92e9", "text": "The benefits of this tech-\nnique should be weighed against the additi onal complexity and increased chance of \nsecondary errors that this technique creates. KEY POINT\n14.2 Statements Whose Order Doesn’t Matter 351\n14.2 Statements Whose Order Doesn’t Matter\nYou might encounter cases in which it seems as if the order of a few statements or a \nfew blocks of code doesn’t matter at all. One statement doesn’t depend on, or logi-\ncally follow, another statemen t. But ordering affects re adability, performance, and \nmaintainability, and in the absence of ex ecution-order dependencies, you can use \nsecondary criteria to determine the order of statements or blocks of code. The guid-\ning principle is the Pr inciple of Proximity: Keep related actions together . Making Code Read from Top to Bottom\nAs a general principle, make the program read from top to bottom rather than jump-\ning around. Experts agree that top-to-bottom order contributes most to readability.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1108, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1109_0a7a05e8", "text": "Experts agree that top-to-bottom order contributes most to readability. Simply making the control flow from top to bottom at run time isn’t enough. If some-\none who is reading your code has to search the whole program to find needed infor-\nmation, you should reorganize the code. Here’s an example:\nC++ Example of Bad Code That Jumps Around\nMarketingData marketingData; \nSalesData salesData;\nTravelData travelData;\ntravelData.ComputeQuarterly();\nsalesData.ComputeQuarterly();\nmarketingData.ComputeQuarterly();\nsalesData.ComputeAnnual();\nmarketingData.ComputeAnnual();\ntravelData.ComputeAnnual();\nsalesData.Print();\ntravelData.Print();\nmarketingData.Print();\nSuppose that you want to determine how marketingData is calculated. You have to \nstart at the last line and track all references to marketingData back to the first line. mar-\nketingData is used in only a few other places, but you have to keep in mind how mar-\nketingData is used everywhere between the first and last references to it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1109, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1110_0bb22516", "text": "mar-\nketingData is used in only a few other places, but you have to keep in mind how mar-\nketingData is used everywhere between the first and last references to it. In other \nwords, you have to look at and think about every line of code in this fragment to figure \nout how marketingData is calculated. And of course this example is simpler than code \nyou see in life-size systems. Here’s the same code with better organization:\nC++ Example of Good, Sequential Code That Reads from Top to Bottom\nMarketingData marketingData;\nmarketingData.ComputeQuarterly();\nmarketingData.ComputeAnnual();\nmarketingData.Print();\n352\nChapter 14: Organizing Straight-Line Code\nSalesData salesData;\nsalesData.ComputeQuarterly();\nsalesData.ComputeAnnual();\nsalesData.Print();\nTravelData travelData;\ntravelData.ComputeQuarterly();\ntravelData.ComputeAnnual();\ntravelData.Print();\nCross-Reference A more \ntechnical definition of “live” \nvariables is given in “Mea-\nsuring the Live Time of a \nVariable” in Section 10.4.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1110, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1111_4d6893f7", "text": "This code is better in several ways. References to each object are kept close together; \nthey’re “localized.” The number of lines of code in which the objects are “live” is small. And perhaps most important, the code now looks as if it could be broken into sepa-\nrate routines for marketing, sales, and travel data. The first code fragment gave no hint \nthat such a decomp osition was possible. Grouping Related Statements\nCross-Reference If you fol-\nlow the Pseudocode Pro-\ngramming Process, your \ncode will automatically be \ngrouped into related state-\nments. For details on the \nprocess, see Chapter 9, “The \nPseudocode Programming \nProcess.”\nPut related statements together. They can be related because they operate on the same \ndata, perform similar tasks, or depend on each other’s being performed in order. An easy way to test whether related statements are grouped well is to print out a listing \nof your routine and then draw boxes around the related statements.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1111, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1112_86464f7f", "text": "An easy way to test whether related statements are grouped well is to print out a listing \nof your routine and then draw boxes around the related statements. If the statements \nare ordered well, you’ll get a picture like that shown in Figure 14-1, in which the boxes \ndon’t overlap. Figure 14-1 If the code is well organized into groups, boxes drawn around related sections \ndon’t overlap. They might be nested. Cross-Reference For more \non keeping operations on \nvariables together, see Sec-\ntion 10.4, “Scope.”\nIf statements aren’t ordered well, you’ll get a picture something like that shown in Fig-\nure 14-2, in which the boxes do overlap. If you find that your boxes overlap, reorganize \nyour code so that related statements are grouped better. Key Points 353\nFigure 14-2 If the code is organized poorly, boxes drawn around related sections overlap.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1112, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 854}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1113_32dcccfa", "text": "Key Points 353\nFigure 14-2 If the code is organized poorly, boxes drawn around related sections overlap. Once you’ve grouped related statements, you might find that they’re strongly related and \nhave no meaningful relationship to the statements that precede or follow them. In such a \ncase, you might want to refactor the strongly related statements into their own routine. cc2e.com/1472\nChecklist: Organizing Straight-Line Code\n❑\nDoes the code make dependenci es among statements obvious? ❑\nDo the names of routines make dependencies obvious? ❑\nDo parameters to routines make dependencies obvious? ❑\nDo comments describe any dependencies that would otherwise be \nunclear? ❑\nHave housekeeping variables been used to check for sequential dependen-\ncies in critical sections of code? ❑\nDoes the code read from top to bottom? ❑\nAre related statements grouped together? ❑\nHave relatively independent groups of statements been moved into their \nown routines?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1113, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1114_bac9b944", "text": "❑\nDoes the code read from top to bottom? ❑\nAre related statements grouped together? ❑\nHave relatively independent groups of statements been moved into their \nown routines? Key Points\n■\nThe strongest principle for organizing straight-line code is ordering dependencies. ■\nDependencies should be made obvious th rough the use of good routine names, \nparameter lists, comments, and—if the code is critical enough—housekeeping \nvariables. ■\nIf code doesn’t have order dependenci es, keep related statements as close \ntogether as possible.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1114, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 534}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1115_3c4967d8", "text": "■\nIf code doesn’t have order dependenci es, keep related statements as close \ntogether as possible. 355\nChapter 15\nUsing Conditionals \ncc2e.com/1538\nContents\n■\n15.1 if Statements: page 355\n■\n15.2 case Statements: page 361\nRelated Topics\n■\nTaming deep nesting: Section 19.4\n■\nGeneral control issues: Chapter 19\n■\nCode with loops: Chapter 16\n■\nStraight-line code: Chapter 14\n■\nRelationship between data types and control structures: Section 10.7\nA conditional is a statement that controls the execution of other statements; execution \nof the other statements is “condi tioned” on statements such as if, else, case, and switch . Although it makes sense logically to refer to loop controls such as while and for as con-\nditionals too, by convention they’ve been treated separately. Chapter 16, “Controlling \nLoops,” will examine while and for statements. 15.1 if Statements\nDepending on the language you’re using, you might be able to use any of several kinds \nof if statements.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1115, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1116_13cb3049", "text": "Chapter 16, “Controlling \nLoops,” will examine while and for statements. 15.1 if Statements\nDepending on the language you’re using, you might be able to use any of several kinds \nof if statements. The simplest is the plain if or if-then statement. The if-then-else is a lit-\ntle more complex, and chains of if-then-else-if are the most complex. Plain if-then Statements\nFollow these guidelines when writing if statements:\nWrite the nominal path through the code first; then write the unusual cases Write \nyour code so that the normal path through th e code is clear. Make sure that the rare \ncases don’t obscure the normal path of execut ion. This is important for both readabil-\nity and performance. Make sure that you branch correctly on equality Using > instead of >= or < instead \nof <= is analogous to making an off-by-one error in accessing an array or computing a \nloop index. In a loop, think through the endp oints to avoid an off-by-one error.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1116, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 953}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1117_76d653c4", "text": "In a loop, think through the endp oints to avoid an off-by-one error. In a \nconditional statement, think throug h the equals case to avoid one. KEY POINT\n356\nChapter 15: Using Conditionals\nCross-Reference For other \nways to handle error-pro-\ncessing code, see \"Summary \nof Techniques for Reducing \nDeep Nesting\" in Section \n19.4. Put the normal case after the if rather than after the else Put the case you nor-\nmally expect to process first. This is in li ne with the general principle of putting code \nthat results from a decision as close as po ssible to the decision. Here’s a code example \nthat does a lot of error processing, haph azardly checking for errors along the way:\nVisual Basic Example of Code That Processes a Lot of Errors Haphazardly\nOpenFile( inputFile, status )\nIf ( status = Status_Error ) Then\nError case. errorType = FileOpenError\nElse\nNominal case. ReadFile( inputFile, fileData, status )\n If ( status = Status_Success ) Then\nNominal case.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1117, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 963}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1118_16b7ad22", "text": "errorType = FileOpenError\nElse\nNominal case. ReadFile( inputFile, fileData, status )\n If ( status = Status_Success ) Then\nNominal case. SummarizeFileData( fileData, summaryData, status )\n If ( status = Status_Error ) Then\nError case. errorType = ErrorType_DataSummaryError\n Else\nNominal case. PrintSummary( summaryData )\n SaveSummaryData( summaryData, status )\n If ( status = Status_Error ) Then\nError case. errorType = ErrorType_SummarySaveError\n Else\nNominal case. UpdateAllAccounts()\n EraseUndoFile()\n errorType = ErrorType_None\n End If\n End If\n Else\n errorType = ErrorType_FileReadError\n End If\nEnd If\nThis code is hard to follow because the nominal cases and the error cases are all mixed \ntogether. It’s hard to find the path that is normally taken through the code. In addi-\ntion, because the error conditions are sometimes processed in the if clause rather than \nthe else clause, it’s hard to figure out which if test the normal case goes with.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1118, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1119_863e4942", "text": "In addi-\ntion, because the error conditions are sometimes processed in the if clause rather than \nthe else clause, it’s hard to figure out which if test the normal case goes with. In the fol-\nlowing rewritten code, the normal path is consistently coded first and all the error \ncases are coded last. This makes it easi er to find and read the nominal case. Visual Basic Example of Code That Processes a Lot of Errors Systematically\nOpenFile( inputFile, status )\nIf ( status = Status_Success ) Then\nNominal case. ReadFile( inputFile, fileData, status )\n If ( status = Status_Success ) Then\nNominal case. SummarizeFileData( fileData, summaryData, status )\n If ( status = Status_Success ) Then\nNominal case. PrintSummary( summaryData )\n SaveSummaryData( summaryData, status )\n If ( status = Status_Success ) Then\nNominal case. UpdateAllAccounts()\n EraseUndoFile()\n15.1 if Statements 357\n15.1 if Statements\n errorType = ErrorType_None\n Else\nError case.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1119, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1120_8335f3aa", "text": "UpdateAllAccounts()\n EraseUndoFile()\n15.1 if Statements 357\n15.1 if Statements\n errorType = ErrorType_None\n Else\nError case. errorType = ErrorType_SummarySaveError\n End If\n Else\nError case. errorType = ErrorType_DataSummaryError\n End If\n Else\nError case. errorType = ErrorType_FileReadError\n End If\nElse\nError case. errorType = ErrorType_FileOpenError\nEnd If\nIn the revised example, you can read the main flow of the if tests to find the normal \ncase. The revision puts the focus on reading the main flow rather than on wading \nthrough the exceptional cases, so the code is easier to read overall. The stack of error \nconditions at the bottom of the nest is a sign of well-written error-processing code. This example illustrates one systematic appr oach to handling normal cases and error \ncases.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1120, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 796}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1121_718ac64b", "text": "The stack of error \nconditions at the bottom of the nest is a sign of well-written error-processing code. This example illustrates one systematic appr oach to handling normal cases and error \ncases. A variety of other solutions to this problem are discussed throughout this book, \nincluding using guard clauses, converting to polymorphic dispatch, and extracting \nthe inner part of the test into a separate routine. For a complete list of available \napproaches, see “Summary of Techniques for Reducing Deep Nesting” in Section 19.4. Follow the if clause with a meaningful statement Sometimes you see code like the \nnext example, in which the if clause is null:\nJava Example of a Null if Clause\nif ( SomeTest )\n ;\nelse {\n // do something\n ... }\nCross-Reference One key to \nconstructing an effective if \nstatement is writing the right \nboolean expression to con-\ntrol it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1121, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 869}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1122_51d19b45", "text": "}\nCross-Reference One key to \nconstructing an effective if \nstatement is writing the right \nboolean expression to con-\ntrol it. For details on using \nboolean expressions effec-\ntively, see Section 19.1, \n“Boolean Expressions.”\nMost experienced programmers would avoid code like this if only to avoid the work of \ncoding the extra null line and the else line. It looks silly and is easily improved by \nnegating the predicate in the if statement, moving the code from the else clause to the \nif clause, and eliminating the else clause. Here’s how the code would look after those \nchanges:\nJava Example of a Converted Null if Clause\nif ( ! someTest ) {\n // do something\n ... }\nCODING \nHORROR\n358\nChapter 15: Using Conditionals\nConsider the else clause If you think you need a plain if statement, consider \nwhether you don’t actually need an if-then-else statement. A classic General Motors \nanalysis found that 50 to 80 percent of if statements should have had an else clause \n(Elshoff 1976).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1122, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1123_993e76fe", "text": "A classic General Motors \nanalysis found that 50 to 80 percent of if statements should have had an else clause \n(Elshoff 1976). One option is to code the else clause—with a null statement if necessary—to show that \nthe else case has been cons idered. Coding null elses just to show that that case has \nbeen considered might be overkill, but at the very least, take the else case into account. When you have an if test without an else, unless the reason is obvious, use comments \nto explain why the else clause isn’t necessary, like so:\nJava Example of a Helpful, Commented else Clause\n// if color is valid\nif ( COLOR_MIN <= color && color <= COLOR_MAX ) {\n // do something\n ... }\nelse {\n // else color is invalid\n // screen not written to –- safely ignore command\n}\nTest the else clause for correctness When testing your code, you might think that \nthe main clause, the if, is all that needs to be tested . If it’s possible to test the else \nclause, however, be sure to do that.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1123, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1124_10ad701f", "text": "If it’s possible to test the else \nclause, however, be sure to do that. Check for reversal of the if and else clauses A common mistake in programming if-\nthens is to flip-flop the code that’s supposed to follow the if clause and the code that’s \nsupposed to follow the else clause or to get the logic of the if test backward. Check \nyour code for this common error. Chains of if-then-else Statements\nIn languages that don’t support case statements—or that support them only partially—\nyou’ll often find yourself writing chains of if-then-else tests.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1124, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 549}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1125_99ee3e85", "text": "Chains of if-then-else Statements\nIn languages that don’t support case statements—or that support them only partially—\nyou’ll often find yourself writing chains of if-then-else tests. For example, the code to \ncategorize a character might use a chain like this one:\nCross-Reference For more \ndetails on simplifying com-\nplicated expressions, see \nSection 19.1, “Boolean \nExpressions.”\nC+ + Example of Using an if-then-else Chain to Categorize a Character\nif ( inputCharacter < SPACE ) {\n characterType = CharacterType_ControlCharacter;\n}\nelse if ( \n inputCharacter == ' ' || \n inputCharacter == ',' || \n inputCharacter == '.' ||\n inputCharacter == '!' || \n inputCharacter == '(' || \n inputCharacter == ')' || \n1\n23\nHARD DATA\n15.1 if Statements 359\n15.1 if Statements\n inputCharacter == ':' ||\n inputCharacter == ';' || \n inputCharacter == '?' || \n inputCharacter == '-' \n ) {\n characterType = CharacterType_Punctuation;\n}\nelse if ( '0' <= inputCharacter && inputCharacter <= '9' ) {\n characterType = CharacterType_Digit;\n}\nelse if ( \n ( 'a' <= inputCharacter && inputCharacter <= 'z' ) ||\n ( 'A' <= inputCharacter && inputCharacter <= 'Z' ) \n ) {\n characterType = CharacterType_Letter;\n}\nConsider these guidelines when writing such if-then-else chains: \nSimplify complicated tests with boolean function calls One reason the code in the \nprevious example is hard to read is that the tests that categorize the character are compli-\ncated.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1125, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1436}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1126_625f3a65", "text": "To improve readability, you can repl ace them with calls to boolean functions. Here’s how the example’s code looks when the tests are replaced with boolean functions:\nC+ + Example of an if-then-else Chain That Uses Boolean Function Calls\nif ( IsControl( inputCharacter ) ) {\n characterType = CharacterType_ControlCharacter;\n}\nelse if ( IsPunctuation( inputCharacter ) ) {\n characterType = CharacterType_Punctuation;\n}\nelse if ( IsDigit( inputCharacter ) ) {\n characterType = CharacterType_Digit;\n}\nelse if ( IsLetter( inputCharacter ) ) {\n characterType = CharacterType_Letter;\n}\nPut the most common cases first By putting the most common cases first, you mini-\nmize the amount of exception -case handling code someone has to read to find the \nusual cases. You improve efficiency because you minimize the number of tests the \ncode does to find the most common cases. In the example just shown, letters would \nbe more common than punctuation but the test for punctuation is made first.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1126, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1127_f323eb72", "text": "In the example just shown, letters would \nbe more common than punctuation but the test for punctuation is made first. Here’s \nthe code revised so that it tests for letters first:\nC+ + Example of Testing the Most Common Case First\nThis test, the most common, \nis now done first. if ( IsLetter( inputCharacter ) ) {\n characterType = CharacterType_Letter;\n}\n360\nChapter 15: Using Conditionals\nelse if ( IsPunctuation( inputCharacter ) ) {\n characterType = CharacterType_Punctuation;\n}\nelse if ( IsDigit( inputCharacter ) ) {\n characterType = CharacterType_Digit;\n}\nThis test, the least common, \nis now done last. else if ( IsControl( inputCharacter ) ) {\n characterType = CharacterType_ControlCharacter;\n}\nMake sure that all cases are covered Code a final else clause with an error message \nor assertion to catch cases you didn’t plan for. This error message is intended for you \nrather than for the user, so word it appropriately.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1127, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 928}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1128_81bfc259", "text": "This error message is intended for you \nrather than for the user, so word it appropriately. Here’s how you can modify the char-\nacter-classification example to perform an “other cases” test: \nCross-Reference This is also \na good example of how you \ncan use a chain of if-then-\nelse tests instead of deeply \nnested code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1128, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 319}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1129_6c907c8a", "text": "For details on \nthis technique, see Section \n19.4, “Taming Dangerously \nDeep Nesting.”\nC+ + Example of Using the Default Case to Trap Errors\nif ( IsLetter( inputCharacter ) ) {\n characterType = CharacterType_Letter;\n}\nelse if ( IsPunctuation( inputCharacter ) ) {\n characterType = CharacterType_Punctuation;\n}\nelse if ( IsDigit( inputCharacter ) ) {\n characterType = CharacterType_Digit;\n}\nelse if ( IsControl( inputCharacter ) ) {\n characterType = CharacterType_ControlCharacter;\n}\nelse {\n DisplayInternalError( \"Unexpected type of character detected.\" );\n}\nReplace if-then-else chains with other constructs if your language supports them A \nfew languages—Microsoft Visual Ba sic and Ada, for example—provide case statements \nthat support use of strings, enums, and logical functions. Use them—they are easier to \ncode and easier to read than if-then-else chains.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1129, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 864}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1130_e5bce097", "text": "Use them—they are easier to \ncode and easier to read than if-then-else chains. Code for classifying character types by \nusing a case statement in Visual Basic would be written like this:\nVisual Basic Example of Using a case Statement Instead of an if-then-else Chain\nSelect Case inputCharacter\n Case \"a\" To \"z\"\n characterType = CharacterType_Letter\n Case \" \", \",\", \".\", \"!\", \"(\", \")\", \":\", \";\", \"?\", \"-\"\n characterType = CharacterType_Punctuation\n Case \"0\" To \"9\"\n characterType = CharacterType_Digit\n Case FIRST_CONTROL_CHARACTER To LAST_CONTROL_CHARACTER\n characterType = CharacterType_Control\n Case Else\n DisplayInternalError( \"Unexpected type of character detected.\" )\nEnd Select\n15.2 case Statements 361\n15.2 case Statements\nThe case or switch statement is a construct that varies a great deal from language to lan-\nguage. C++ and Java support case only for ordinal types taken one value at a time.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1130, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 903}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1131_1f7cb990", "text": "C++ and Java support case only for ordinal types taken one value at a time. Visual Basic supports case for ordinal types and has powerful shorthand notations for \nexpressing ranges and combinations of va lues. Many scripting languages don’t sup-\nport case statements at all. The following sections present guidelines for using case statements effectively:\nChoosing the Most Effective Ordering of Cases\nYou can choose from among a variety of ways to organize the cases in a case statement. If you have a small case statement with three options and three corresponding lines of \ncode, the order you use doesn’t ma tter much. If you have a long case statement—for \nexample, a case statement that handles dozens of events in an event-driven program—\norder is significant. Following are some ordering possibilities:\nOrder cases alphabetically or numerically If cases are equally important, putting \nthem in A-B-C order improves readability. That way a specific case is easy to pick out \nof the group.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1131, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1132_504fb5e9", "text": "That way a specific case is easy to pick out \nof the group. Put the normal case first If you have one normal case and several exceptions, put \nthe normal case first. Indicate with comment s that it’s the normal case and that the \nothers are unusual. Order cases by frequency Put the most frequently executed cases first and the least \nfrequently executed last. This approach ha s two advantages. First, human readers can \nfind the most common cases easily. Readers scanning the list for a specific case are \nlikely to be interested in one of the most common cases, and putting the common \nones at the top of the code makes the search quicker. Tips for Using case Statements \nHere are several tips for using case statements: \nCross-Reference For other \ntips on simplifying code, see \nChapter 24, \"Refactoring.\"\nKeep the actions of each case simple Keep the code associated with each case short. Short code following each case helps make the structure of the case statement clear.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1132, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1133_4d8fc64e", "text": "Short code following each case helps make the structure of the case statement clear. If \nthe actions performed for a case are complicated, write a routine and call the routine \nfrom the case rather than putting the code into the case itself. Don’t make up phony variable s to be able to use the case statement A case state-\nment should be used for simple data that’s easily categorized. If your data isn’t simple, \nuse chains of if-then-else s instead. Phony variables are co nfusing, and you should avoid \nthem. For example, don’t do this:\n15.1 case Statements\n362\nChapter 15: Using Conditionals\nJava Example of Creating a Phony case Variable—Bad Practice\naction = userCommand[ 0 ];\nswitch ( action ) {\n case 'c': \n Copy(); \n break;\n case 'd': \n DeleteCharacter(); \n break;\n case 'f': \n Format(); \n break;\n case 'h': \n Help(); \n break;\n ... default: \n HandleUserInputError( ErrorType.InvalidUserCommand );\n} \nThe variable that controls the case statement is action .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1133, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1134_e988c52f", "text": "default: \n HandleUserInputError( ErrorType.InvalidUserCommand );\n} \nThe variable that controls the case statement is action . In this case, action is created by peel-\ning off the first character of the userCommand string, a string that was entered by the user. Cross-Reference In contrast \nto this advice, sometimes \nyou can improve readability \nby assigning a complicated \nexpression to a well-named \nboolean variable or function. For details, see “Making \nComplicated Expressions \nSimple” in Section 19.1. This troublemaking code is from the wrong side of town and invites problems. In gen-\neral, when you manufacture a variable to use in a case statement, the real data might \nnot map onto the case statement the way you want it to. In this example, if the user \ntypes copy , the case statement peels off the first “c” and correctly calls the Copy() rou-\ntine. On the other hand, if the user types cement overshoes , clambake , or cellulite , \nthe case statement also peels off the “c” and calls Copy() .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1134, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1007}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1135_9df158f0", "text": "On the other hand, if the user types cement overshoes , clambake , or cellulite , \nthe case statement also peels off the “c” and calls Copy() . The test for an erroneous \ncommand in the case statement’s else clause won’t work very well because it will miss \nonly erroneous first letters rather than erroneous commands. Rather than making up a phony variab le, this code should use a chain of if-then-else-if \ntests to check the whole string. A virtuous rewrite of the code looks like this:\nJava Example of Using if-then-else s Instead of a Phony case Variable—Good Practice\nif ( UserCommand.equals( COMMAND_STRING_COPY ) ) {\n Copy();\n}\nelse if ( UserCommand.equals( COMMAND_STRING_DELETE ) ) {\n DeleteCharacter();\n}\nelse if ( UserCommand.equals( COMMAND_STRING_FORMAT ) ) {\n Format();\n}\nelse if ( UserCommand.equals( COMMAND_STRING_HELP ) ) {\n Help();\n}\n...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1135, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 857}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1136_aa549c70", "text": "else {\n HandleUserInputError( ErrorType_InvalidCommandInput );\n}\nCODING \nHORROR\n15.2 case Statements 363\n15.1 case Statements\nUse the default clause only to detect legitimate defaults You might sometimes have \nonly one case remaining and decide to code that case as the default clause. Though \nsometimes tempting, that’s dumb. You lose the automatic documentation provided by \ncase-statement labels, and you lose the ability to detect errors with the default clause. Such case statements break down under modificati on. If you use a legitimate default, \nadding a new case is trivial—you just add the case and the corresponding code. If you \nuse a phony default, the modification is more difficult. You have to add the new case, \npossibly making it the new default, and then change the case previously used as the \ndefault so that it’s a legitimate case. Us e a legitimate default in the first place.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1136, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1137_6c61cd40", "text": "You have to add the new case, \npossibly making it the new default, and then change the case previously used as the \ndefault so that it’s a legitimate case. Us e a legitimate default in the first place. Use the default clause to detect errors If the default clause in a case statement isn’t \nbeing used for other processing and isn’t supposed to occur, put a diagnostic mes-\nsage in it:\nJava Example of Using the Default Case to Detect Errors—Good Practice\nswitch ( commandShortcutLetter ) {\n case 'a': \n PrintAnnualReport();\n break;\n case 'p': \n // no action required, but case was considered\n break;\n case 'q': \n PrintQuarterlyReport();\n break;\n case 's': \n PrintSummaryReport();\n break;\n default: \n DisplayInternalError( \"Internal Error 905: Call customer support.\" );\n} \nMessages like this are useful in both debugging and production code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1137, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 842}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1138_fe7cb5df", "text": "Most users pre-\nfer a message like “Internal Error: Please ca ll customer support” to a system crash or, \nworse, subtly incorrect results that look right until the user’s boss checks them. If the default clause is used for some purpose other than error detection, the implica-\ntion is that every case selector is correct. Double-check to be sure that every value that \ncould possibly enter the case statement would be legitimate. If you come up with some \nthat wouldn’t be legitimate, rewrite the statements so that the default clause will \ncheck for errors. In C++ and Java, avoid dropping through the end of a case statement C-like lan-\nguages (C, C++, and Java) don’t automatically break out of each case. Instead, you \nhave to code the end of each case explicitly. If you don’t code the end of a case, the \n364\nChapter 15: Using Conditionals\nprogram drops through the end and executes the code for the next case.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1138, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1139_123497e3", "text": "If you don’t code the end of a case, the \n364\nChapter 15: Using Conditionals\nprogram drops through the end and executes the code for the next case. This can lead \nto some particularly egregious coding pr actices, including the following horrible \nexample:\n \nCross-Reference This code’s \nformatting makes it look bet-\nter than it is. For details on \nhow to use formatting to \nmake good code look good \nand bad code look bad, see \n“Endline Layout” in Section \n31.3 and the rest of Chapter \n31, “Layout and Style.”\nC+ + Example of Abusing the case Statement\nswitch ( InputVar ) {\n case 'A': if ( test ) {\n // statement 1\n // statement 2\n case 'B': // statement 3\n // statement 4\n ... } \n ... break;\n ... }\nThis practice is bad because it intermingles control constructs. Nested control con-\nstructs are hard enough to understand; overlapping constructs are all but impossible.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1139, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 873}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1140_fc51f8b1", "text": "} \n ... break;\n ... }\nThis practice is bad because it intermingles control constructs. Nested control con-\nstructs are hard enough to understand; overlapping constructs are all but impossible. Modifications of case 'A' or case 'B' will be harder than brain surgery, and it’s likely that \nthe cases will need to be cleaned up before any modifications will work. You might as \nwell do it right the first time. In general, it’s a good idea to avoid dropping through the \nend of a case statement. In C++, clearly and unmistakably iden tify flow-throughs at the end of a case \nstatement If you intentionally write code to drop through the end of a case, clearly \ncomment the place at which it happens and explain why it needs to be coded that way.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1140, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 742}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1141_656122cf", "text": "C+ + Example of Documenting Falling Through the End of a case Statement\nswitch ( errorDocumentationLevel ) {\n case DocumentationLevel_Full:\n DisplayErrorDetails( errorNumber );\n // FALLTHROUGH -- Full documentation also prints summary comments\n case DocumentationLevel_Summary:\n DisplayErrorSummary( errorNumber );\n // FALLTHROUGH -- Summary documentation also prints error number\n case DocumentationLevel_NumberOnly:\n DisplayErrorNumber( errorNumber );\n break;\n default: \n DisplayInternalError( \"Internal Error 905: Call customer support.\" );\n} \nCODING \nHORROR\n15.2 case Statements 365\nThis technique is useful about as often as you find someone who would rather have a \nused Pontiac Aztek than a new Corvette. Generally, code that falls through from one \ncase to another is an invitation to make mistakes as the code is modified, and it \nshould be avoided. cc2e.com/1545\nCHECKLIST: Using Conditionals\nif-then Statements\n❑\nIs the nominal path through the code clear?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1141, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1142_6914b0ec", "text": "cc2e.com/1545\nCHECKLIST: Using Conditionals\nif-then Statements\n❑\nIs the nominal path through the code clear? ❑\nDo if-then tests branch correctly on equality? ❑\nIs the else clause present and documented? ❑\nIs the else clause correct? ❑\nAre the if and else clauses used correctly—not reversed? ❑\nDoes the normal case follow the if rather than the else? if-then-else-if Chains\n❑\nAre complicated tests encapsulat ed in boolean function calls? ❑\nAre the most common cases tested first? ❑\nAre all cases covered? ❑\nIs the if-then-else-if chain the best implementation—better than a case \nstatement? case Statements\n❑\nAre cases ordered meaningfully? ❑\nAre the actions for each case simple—calling other routines if necessary? ❑\nDoes the case statement test a real variable, not a phony one that’s made \nup solely to use and abuse the case statement? ❑\nIs the use of the default clause legitimate? ❑\nIs the default clause used to detect and report unexpected cases?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1142, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1143_48b164d9", "text": "❑\nIs the use of the default clause legitimate? ❑\nIs the default clause used to detect and report unexpected cases? ❑\nIn C, C++, or Java, does th e end of each case have a break ? 15.1 case Statements\n366\nChapter 15: Using Conditionals\nKey Points\n■\nFor simple if-else statements, pay attention to the order of the if and else clauses, \nespecially if they process a lot of errors. Make sure the nominal case is clear. ■\nFor if-then-else chains and case statements, choose an order that maximizes read-\nability. ■\nTo trap errors, use the default clause in a case statement or the last else in a chain \nof if-then-else statements. ■\nAll control constructs are not created equal. Choose the control construct that’s \nmost appropriate for each section of code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1143, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 754}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1144_501a54c8", "text": "■\nAll control constructs are not created equal. Choose the control construct that’s \nmost appropriate for each section of code. 367\nChapter 16\nControlling Loops\ncc2e.com/1609\nContents\n■\n16.1 Selecting the Kind of Loop: page 367\n■\n16.2 Controlling the Loop: page 373\n■\n16.3 Creating Loops Easily—F rom the Inside Out: page 385\n■\n16.4 Correspondence Between Loops and Arrays: page 387\nRelated Topics\n■\nTaming deep nesting: Section 19.4\n■\nGeneral control issues: Chapter 19\n■\nCode with conditionals: Chapter 15\n■\nStraight-line code: Chapter 14\n■\nRelationship between control structures and data types: Section 10.7\n“Loop” is an informal term that refers to any kind of iterative control structure—any \nstructure that causes a program to repe atedly execute a block of code. Common \nloop types are for, while , and do-while in C++ and Java, and For-Next , While-Wend , and \nDo-Loop-While in Microsoft Visual Basic.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1144, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 910}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1145_8ff176ff", "text": "Common \nloop types are for, while , and do-while in C++ and Java, and For-Next , While-Wend , and \nDo-Loop-While in Microsoft Visual Basic. Usin g loops is one of the most complex \naspects of programming; knowing how and when to use each kind of loop is a deci-\nsive factor in constructi ng high-quality software. 16.1 Selecting the Kind of Loop\nIn most languages, you’ll use a few kinds of loops:\n■\nThe counted loop is performed a specific number of times, perhaps one time for \neach employee. ■\nThe continuously evaluated loop doesn’t know ahead of time how many times it \nwill be executed and tests whether it has fi nished on each iteration. For example, it \nruns while money remains, until the user selects quit, or until it encounters an error. ■\nThe endless loop executes forever once it has started. It’s the kind you find in \nembedded systems such as pacemakers, microwave ovens, and cruise controls. ■\nThe iterator loop performs its action once for each element in a container class.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1145, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1146_03893520", "text": "It’s the kind you find in \nembedded systems such as pacemakers, microwave ovens, and cruise controls. ■\nThe iterator loop performs its action once for each element in a container class. 368\nChapter 16: Controlling Loops\nThe kinds of loops are differentiated first by flexibility—whether the loop executes a \nspecified number of times or whether it tests for completion on each iteration. The kinds of loops are also differentiated by the location of the test for completion. You can put the test at the beginning, the middle, or the end of the loop. This charac-\nteristic tells you whether the loop executes at least once. If the loop is tested at the \nbeginning, its body isn’t necessarily executed. If the loop is tested at the end, its body \nis executed at least once. If the loop is te sted in the middle, the part of the loop that \nprecedes the test is executed at least once, but the part of the loop that follows the test \nisn’t necessarily executed at all.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1146, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1147_6d5c5a69", "text": "If the loop is te sted in the middle, the part of the loop that \nprecedes the test is executed at least once, but the part of the loop that follows the test \nisn’t necessarily executed at all. Flexibility and the location of the test dete rmine the kind of loop to choose as a con-\ntrol structure. Table 16-1 shows the kinds of loops in several languages and describes \neach loop’s flexibilit y and test location. When to Use a while Loop\nNovice programmers sometimes think that a while loop is continuously evaluated and \nthat it terminates the instant the while condition becomes false, regardless of which \nstatement in the loop is being executed (Curtis et al. 1986). Although it’s not quite \nthat flexible, a while loop is a flexible loop choice. If you don’t know ahead of time \nexactly how many times you’ll want the loop to iterate, use a while loop.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1147, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 858}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1148_12fac5f1", "text": "1986). Although it’s not quite \nthat flexible, a while loop is a flexible loop choice. If you don’t know ahead of time \nexactly how many times you’ll want the loop to iterate, use a while loop. Contrary to \nwhat some novices think, the test for the lo op exit is performed only once each time \nthrough the loop, and the main issue with respect to while loops is deciding whether \nto test at the beginning or the end of the loop. Table 16-1\nThe Kinds of Loops\nLanguage\nKind of Loop\nFlexibility\nTest Location\nVisual Basic For-Next rigid beginning\nWhile-Wend flexible beginning\nDo-Loop-While flexible beginning or end\nFor-Each rigid beginning\nC, C++, C#, Java for flexible beginning\nwhile flexible beginning\ndo-while flexible end\nforeach\n*\n* Available only in C#. Planned for other languages, including Java, at the time of this writing.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1148, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 834}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1149_6af302e3", "text": "Planned for other languages, including Java, at the time of this writing. rigid beginning\n16.1 Selecting the Kind of Loop 369\nLoop with Test at the Beginning\nFor a loop that tests at the beginning, you can use a while loop in C++, C#, Java, Visual \nBasic, and most other languages. You can emulate a while loop in other languages. Loop with Test at the End\nYou might occasionally have a situation in which you want a flexible loop, but the \nloop needs to execute at least one time. In such a case, you can use a while loop that is \ntested at its end. You can use do-while in C++, C#, and Java, Do-Loop-While in Visual \nBasic, or you can emulate end-tested loops in other languages. When to Use a Loop-With-Exit Loop\nA loop-with-exit loop is a loop in which the exit condition appears in the middle of the \nloop rather than at the beginning or at th e end.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1149, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 855}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1150_bf1dbff3", "text": "When to Use a Loop-With-Exit Loop\nA loop-with-exit loop is a loop in which the exit condition appears in the middle of the \nloop rather than at the beginning or at th e end. The loop-with-exit loop is available \nexplicitly in Visual Basic, and you can em ulate it with the structured constructs while \nand break in C++, C, and Java or with gotos in other languages. Normal Loop-With-Exit Loops\nA loop-with-exit loop usually consists of the loop beginning, the loop body (including \nan exit condition), and the loop end, as in this Visual Basic example:\nVisual Basic Example of a Generic Loop-With-Exit Loop\nDo\nStatements. ... If ( some exit condition ) Then Exit Do\nMore statements. ... Loop\nThe typical use of a loop-with-exit loop is for the case in which testing at the beginning \nor at the end of the loop requires coding a loop-and-a-half.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1150, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 844}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1151_10f47627", "text": "... Loop\nThe typical use of a loop-with-exit loop is for the case in which testing at the beginning \nor at the end of the loop requires coding a loop-and-a-half. Here’s a C++ example of a \ncase that warrants a loop-with-exit loop but doesn’t use one:\nC+ + Example of Duplicated Code That Will Break Down Under Maintenance\n// Compute scores and ratings. score = 0;\nThese lines appear here... GetNextRating( &ratingIncrement );\nrating = rating + ratingIncrement;\nwhile ( ( score < targetScore ) && ( ratingIncrement != 0 ) ) {\n GetNextScore( &scoreIncrement );\n score = score + scoreIncrement;\n…and are repeated here. GetNextRating( &ratingIncrement );\n rating = rating + ratingIncrement;\n}\n370\nChapter 16: Controlling Loops\nThe two lines of code at the top of the example are repeated in the last two lines of \ncode of the while loop. During modification, you can ea sily forget to keep the two sets \nof lines parallel.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1151, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1152_b6ce33e8", "text": "During modification, you can ea sily forget to keep the two sets \nof lines parallel. Another programmer modifying the code probably won’t even realize \nthat the two sets of lines are supposed to be modified in parallel. Either way, the result \nwill be errors arising from incomplete modifications. Here’s how you can rewrite the \ncode more clearly:\nC+ + Example of a Loop-With-Exit Loop That’s Easier to Maintain\n// Compute scores and ratings. The code uses an infinite loop\n// and a break statement to emulate a loop-with-exit loop. score = 0;\nwhile ( true ) {\n GetNextRating( &ratingIncrement );\n rating = rating + ratingIncrement;\nThis is the loop-exit condi-\ntion (and now it could be \nsimplified using DeMorgan’s \nTheorems, described in \nSection 19.1).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1152, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 757}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1153_b43f5b2c", "text": "if ( !( ( score < targetScore ) && ( ratingIncrement != 0 ) ) ) {\n break;\n }\n GetNextScore( &scoreIncrement );\n score = score + scoreIncrement;\n}\nHere’s how the same code is written in Visual Basic:\nVisual Basic Example of a Loop-With-Exit Loop\n' Compute scores and ratings\nscore = 0\nDo\n GetNextRating( ratingIncrement )\n rating = rating + ratingIncrement\n If ( not ( score < targetScore and ratingIncrement <> 0 ) ) Then Exit Do\n GetNextScore( ScoreIncrement )\n score = score + scoreIncrement\nLoop\nConsider these finer points when you use this kind of loop:\nCross-Reference Details on \nexit conditions are presented \nlater in this chapter. For \ndetails on using comments \nwith loops, see “Comment-\ning Control Structures” in \nSection 32.5. Put all the exit conditions in one place. Sp reading them around practically guarantees \nthat one exit condition or another will be overlooked during debugging, modification, \nor testing. Use comments for clarification.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1153, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1154_73b372a6", "text": "Sp reading them around practically guarantees \nthat one exit condition or another will be overlooked during debugging, modification, \nor testing. Use comments for clarification. If you use the loop-with-exit loop technique in a lan-\nguage that doesn’t support it directly, use comments to make what you’re doing clear. 16.1 Selecting the Kind of Loop 371\nThe loop-with-exit loop is a one-entry, one-ex it, structured control construct, and it is \nthe preferred kind of loop control (Software Productivity Consortium 1989). It has \nbeen shown to be easier to understand than other kinds of loops. A study of student \nprogrammers compared this kind of loop with those that exited at either the top or \nthe bottom (Soloway, Bonar, and Ehrlich 1983 ).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1154, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 747}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1155_6227879d", "text": "A study of student \nprogrammers compared this kind of loop with those that exited at either the top or \nthe bottom (Soloway, Bonar, and Ehrlich 1983 ). Students scored 25 percent higher on \na test of comprehension when loop-with-exit loops were used, and the authors of the \nstudy concluded that the loop-with-exit structure more closely models the way people \nthink about iterative control th an other loop structures do. In common practice, the loop-with-exit loop isn’t widely used yet. The jury is still \nlocked in a smoky room arguing about whet her it’s a good practice for production \ncode. Until the jury is in, the loop-with-exit loop is a good technique to have in your \nprogrammer’s toolbox—as long as you use it carefully. Abnormal Loop-With-Exit Loops\nAnother kind of loop-with-exit loop that’s us ed to avoid a loop-and-a-half is shown here:\nC+ + Example of Entering the Middle of a Loop with a goto—Bad Practice\ngoto Start;\nwhile ( expression ) {\n // do something\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1155, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1156_c80223f6", "text": "Start:\n // do something else\n ... }\nAt first glance, this seems to be similar to the previous loop-with-exit examples. It’s \nused in simulations in which // do something doesn’t need to be executed at the first \npass through the loop but // do something else does. It’s a one-in, one-out control con-\nstruct: the only way into the loop is through the goto at the top, and the only way out \nof the loop is through the while test. This approach has two problems: it uses a goto, \nand it’s unusual enough to be confusing. In C++, you can accomplish the same effect without using a goto, as demonstrated in \nthe following example. If the langua ge you’re using doesn’t support a break command, \nyou can emulate one with a goto. C+ + Example of Code Rewritten Without a goto—Better Practice\nwhile ( true ) {\nThe blocks before and after \nthe break have been \nswitched. // do something else\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1156, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 888}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1157_71265df3", "text": "C+ + Example of Code Rewritten Without a goto—Better Practice\nwhile ( true ) {\nThe blocks before and after \nthe break have been \nswitched. // do something else\n ... 1\n23\nHARD DATA\nCODING \nHORROR\n372\nChapter 16: Controlling Loops\n if ( !( expression ) ) {\n break;\n }\n // do something\n ... }\nWhen to Use a for Loop\nFurther Reading For more \ngood guidelines on using for \nloops, see Writing Solid \nCode (Maguire 1993). A for loop is a good choice when you need a lo op that executes a specified number of \ntimes. You can use for in C++, C, Java, Visual Ba sic, and most other languages. Use for loops for simple activities that don’t require internal loop controls. Use them \nwhen the loop control involves simple increm ents or simple decrements, such as iter-\nating through the elements in a container. The point of a for loop is that you set it up \nat the top of the loop and then forget about it. You don’t have to do anything inside the \nloop to control it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1157, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1158_d934280d", "text": "The point of a for loop is that you set it up \nat the top of the loop and then forget about it. You don’t have to do anything inside the \nloop to control it. If you have a condition under which execution has to jump out of a \nloop, use a while loop instead. Likewise, don’t explicitly change the index value of a for loop to force it to terminate. Use a while loop instead. The for loop is for simple uses. Most complicated looping \ntasks are better handled by a while loop. When to Use a foreach Loop\nThe foreach loop or its equivalent ( foreach in C#, For-Each in Visual Basic, for-in in \nPython) is useful for performing an operation on each member of an array or other \ncontainer. It has the advantage of elim inating loop-housekeeping arithmetic and \ntherefore eliminating any chance of errors in the loop-housekeeping arithmetic.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1158, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 835}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1159_da701703", "text": "It has the advantage of elim inating loop-housekeeping arithmetic and \ntherefore eliminating any chance of errors in the loop-housekeeping arithmetic. Here’s an example of this kind of loop:\nC# Example of a foreach Loop\nint [] fibonacciSequence = new int [] { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };\nint oddFibonacciNumbers = 0;\nint evenFibonacciNumbers = 0;\n// count the number of odd and even numbers in a Fibonacci sequence\nforeach ( int fibonacciNumber in fibonacciSequence ) {\n if ( fibonacciNumber % 2 ) == 0 ) {\n evenFibonacciNumbers++;\n }\n else {\n oddFibonacciNumbers++;\n }\n}\nConsole.WriteLine( \"Found {0} odd numbers and {1} even numbers.\", \n oddFibonacciNumbers, evenFibonacciNumbers );\n16.2 Controlling the Loop 373\n16.2 Controlling the Loop\nWhat can go wrong with a loop?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1159, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 778}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1160_317f1316", "text": "Any answer would have to include incorrect or omit-\nted loop initialization, omitted initialization of accumulators or other variables related \nto the loop, improper nesting, incorrect termination of the loop, forgetting to incre-\nment a loop variable or incrementing the variable incorrectly, and indexing an array \nelement from a loop index incorrectly. You can forestall these problems by observing two practices. First, minimize the num-\nber of factors that affect the loop. Simplify ! Simplify! Simplify! Second, treat the inside \nof the loop as if it were a routine—keep as much of the control as possible outside the \nloop. Explicitly state the conditions under which the body of the loop is to be exe-\ncuted. Don’t make the reader look inside the loop to understand the loop control. Think of a loop as a black box: the surrounding program knows the control condi-\ntions but not the contents.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1160, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 900}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1161_8859df14", "text": "Don’t make the reader look inside the loop to understand the loop control. Think of a loop as a black box: the surrounding program knows the control condi-\ntions but not the contents. Cross-Reference If you use \nthe while ( true ) -break tech-\nnique described earlier, the \nexit condition is inside the \nblack box. Even if you use \nonly one exit condition, you \nlose the benefit of treating \nthe loop as a black box. C+ + Example of Treating a Loop as a Black Box\nwhile ( !inputFile.EndOfFile() && moreDataAvailable ) {\n}\nWhat are the conditions under which this lo op terminates? Clearly, all you know is \nthat either inputFile.EndOfFile() becomes true or MoreDataAvailable becomes false. Entering the Loop\nUse these guidelines when entering a loop:\nEnter the loop from one location only A variety of loop-control structures allows you to \ntest at the beginning, middle, or end of a loop . These structures are rich enough to allow \nyou to enter the loop from the top every time.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1161, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 980}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1162_5a70ad6c", "text": "These structures are rich enough to allow \nyou to enter the loop from the top every time. You don’t need to enter at multiple locations. Put initialization code directly before the loop The Principle of Proximity advocates \nputting related statements together. If related statements are strewn across a routine, it’s \neasy to overlook them during modification an d to make the modifications incorrectly. If \nrelated statements are kept together, it’s ea sier to avoid errors during modification. Cross-Reference For more \non limiting the scope of loop \nvariables, see “Limit the \nscope of loop-index vari-\nables to the loop itself” later \nin this chapter. Keep loop-initialization statements with the loop they’re related to. If you don’t, you’re \nmore likely to cause errors when you generalize the loop into a bigger loop and forget \nto modify the initialization code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1162, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 870}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1163_af13870c", "text": "If you don’t, you’re \nmore likely to cause errors when you generalize the loop into a bigger loop and forget \nto modify the initialization code. The same kind of error can occur when you move or \ncopy the loop code into a different routine wi thout moving or copying its initialization \ncode. Putting initializations away from the loop—in the data-declaration section or in \na housekeeping section at the top of the routine that contains the loop—invites initial-\nization troubles. KEY POINT\n374\nChapter 16: Controlling Loops\nUse while( true ) for infinite loops You might have a loop that runs without termi-\nnating—for example, a loop in firmware such as a pacemaker or a microwave oven. Or \nyou might have a loop that terminates only in response to an event—an “event loop.” \nYou could code such an infinite loop in se veral ways.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1163, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 833}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1164_352cfe42", "text": "Or \nyou might have a loop that terminates only in response to an event—an “event loop.” \nYou could code such an infinite loop in se veral ways. Faking an infinite loop with a \nstatement like for i = 1 to 99999 is a poor choice because the specific loop limits muddy \nthe intent of the loop— 99999 could be a legitimate value. Such a fake infinite loop can \nalso break down under maintenance. The while( true ) idiom is considered a standard way of writing an infinite loop in C++, \nJava, Visual Basic, and other languages that support comparable structures. Some pro-\ngrammers prefer to use for( ;; ) , which is an accepted alternative. Prefer for loops when they’re appropriate The for loop packages loop-control code \nin one place, which makes for easily read able loops. One mistake programmers com-\nmonly make when modifying so ftware is changing the loop-initialization code at the \ntop of a while loop but forgetting to change related code at the bottom.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1164, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1165_78b57c3a", "text": "One mistake programmers com-\nmonly make when modifying so ftware is changing the loop-initialization code at the \ntop of a while loop but forgetting to change related code at the bottom. In a for loop, all \nthe relevant code is together at the top of the loop, which makes correct modifications \neasier. If you can use the for loop appropriately instead of another kind of loop, do it. Don’t use a for loop when a while loop is more appropriate A common abuse of the \nflexible for loop structure in C++, C#, and Java is haphazardly cramming the contents \nof a while loop into a for loop header.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1165, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 594}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1166_b2f502d2", "text": "The foll owing example shows a while loop \ncrammed into a for loop header:\nC+ + Example of a while Loop Abusively Crammed into a for Loop Header\n// read all the records from a file \nfor ( inputFile.MoveToStart(), recordCount = 0; !inputFile.EndOfFile(); \n recordCount++ ) {\n inputFile.GetRecord();\n}\nThe advantage of C++’s for loop over for loops in other languages is that it’s more flex-\nible about the kinds of initialization and te rmination information it can use. The weak-\nness inherent in such flexibility is that you can put statements into the loop header \nthat have nothing to do with controlling the loop. Reserve the for loop header for loop-control statements—statements that initialize the \nloop, terminate it, or move it toward termination. In the example just shown, the \ninputFile.GetRecord() statement in the body of the loop moves the loop toward termi-\nnation, but the recordCount statements don’t; they’re housekeeping statements that \ndon’t control the loop’s progress.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1166, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1167_c8287360", "text": "Putting the recordCount statements in the loop \nheader and leaving the inputFile.GetRecord() statement out is misleading; it creates the \nfalse impression that recordCount controls the loop. If you want to use the for loop rather than the while loop in this case, put the loop-con-\ntrol statements in the loop header and leave everything else out. Here’s the right way \nto use the loop header:\nCODING \nHORROR\n16.2 Controlling the Loop 375\nC+ + Example of Logical if Unconventional Use of a for Loop Header\nrecordCount = 0;\nfor ( inputFile.MoveToStart(); !inputFile.EndOfFile(); inputFile.GetRecord() ) {\n recordCount++;\n}\nThe contents of the loop header in this exam ple are all related to control of the loop. The inputFile.MoveToStart() statement initializes the loop, the !inputFile.EndOfFile() \nstatement tests whether the loop has finished, and the inputFile.GetRecord() statement \nmoves the loop toward termination.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1167, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1168_84a6c94e", "text": "The statements that affect recordCount don’t \ndirectly move the loop toward termination and are appropriately not included in the \nloop header. The while loop is probably still more appropriate for this job, but at least \nthis code uses the loop header logically. For the record, here’s how the code looks \nwhen it uses a while loop:\nC+ + Example of Appropriate Use of a while Loop\n// read all the records from a file \ninputFile.MoveToStart();\nrecordCount = 0;\nwhile ( !inputFile.EndOfFile() ) {\n inputFile.GetRecord();\n recordCount++;\n}\nProcessing the Middle of the Loop\nThe following subsections describe handling the middle of a loop:\nUse { and } to enclose the statements in a loop Use code brackets every time. They \ndon’t cost anything in speed or space at run time, they help readability, and they help \nprevent errors as the code is modified. Th ey’re a good defensive-programming practice.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1168, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 898}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1169_778caee7", "text": "They \ndon’t cost anything in speed or space at run time, they help readability, and they help \nprevent errors as the code is modified. Th ey’re a good defensive-programming practice. Avoid empty loops In C++ and Java, it’s possible to create an empty loop, one in \nwhich the work the loop is doing is coded on the same line as the test that checks \nwhether the work is finished. Here’s an example:\nC+ + Example of an Empty Loop\nwhile ( ( inputChar = dataFile.GetChar() ) != CharType_Eof ) {\n ;\n}\n376\nChapter 16: Controlling Loops\nIn this example, the loop is empty because the while expression includes two things: \nthe work of the loop— inputChar = dataFile.GetChar() —and a test for whether the loop \nshould terminate— inputChar != CharType_Eof .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1169, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 748}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1170_2ab5cf2c", "text": "The loop would be clearer if it were \nrecoded so that the work it does is evident to the reader:\nC+ + Example of an Empty Loop Converted to an Occupied Loop\ndo {\n inputChar = dataFile.GetChar();\n} while ( inputChar != CharType_Eof );\nThe new code takes up three full lines rather than one line and a semicolon, which is \nappropriate since it does the work of three lines rather than that of one line and a \nsemicolon. Keep loop-housekeeping chores at either the beginning or the end of the loop Loop-\nhousekeeping chores are expressions like i = i + 1 or j++, expressions whose main pur-\npose isn’t to do the work of the loop but to control the loop. The housekeeping is \ndone at the end of the loop in this example:\nC+ + Example of Housekeeping Statements at the End of a Loop\nnameCount = 0;\ntotalLength = 0;\nwhile ( !inputFile.EndOfFile() ) {\n // do the work of the loop\n inputFile >> inputString;\n names[ nameCount ] = inputString;\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1170, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1171_ce238b82", "text": "// prepare for next pass through the loop--housekeeping\nHere are the housekeeping \nstatements. nameCount++;\n totalLength = totalLength + inputString.length();\n}\nAs a general rule, the variables you initialize before the loop are the variables you’ll \nmanipulate in the housekeeping part of the loop. Cross-Reference For more \non optimization, see Chapter \n25, “Code-Tuning Strate-\ngies,” and Chapter 26, \n“Code-Tuning Techniques.”\nMake each loop perform only one function The mere fact that a loop can be used to \ndo two things at once isn’t sufficient ju stification for doing them together. Loops \nshould be like routines in that each one should do only one thing and do it well. If it \nseems inefficient to use two loops where one would suffice, write the code as two \nloops, comment that they could be combined for efficiency, and then wait until bench-\nmarks show that the section of the prog ram poses a performance problem before \nchanging the two loops into one.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1171, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1172_28ef59e3", "text": "16.2 Controlling the Loop 377\nExiting the Loop\nThese subsections describe handling the end of a loop:\nAssure yourself that the loop ends This is fundamental. Mentally simulate the execu-\ntion of the loop until you are confident th at, in all circumstances, it ends. Think \nthrough the nominal cases, the endpoints, and each of the exceptional cases. Make loop-termination conditions obvious If you use a for loop and don’t fool \naround with the loop index and don’t use a goto or break to get out of the loop, the ter-\nmination condition will be obvious. Likewise, if you use a while or repeat-until loop \nand put all the control in the while or repeat-until clause, the termination condition \nwill be obvious. The key is putting the control in one place. Don’t monkey with the loop index of a for loop to make the loop terminate Some \nprogrammers jimmy the value of a for loop index to make the loop terminate early.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1172, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 917}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1173_3041dc76", "text": "Don’t monkey with the loop index of a for loop to make the loop terminate Some \nprogrammers jimmy the value of a for loop index to make the loop terminate early. Here’s an example:\nJava Example of Monkeying with a Loop Index\nfor ( int i = 0; i < 100; i++ ) {\n // some code\n ... if ( ... ) {\nHere’s the monkeying. i = 100;\n }\n // more code\n ... }\nThe intent in this example is to terminate the loop under some condition by setting i \nto 100, a value that’s larger than the end of the for loop’s range of 0 through 99. Virtu-\nally all good programmers avoid this practice; it’s the sign of an amateur. When you \nset up a for loop, the loop counter is off limits. Use a while loop to provide more con-\ntrol over the loop’s exit conditions. Avoid code that depends on the loop index’s final value It’s bad form to use the value \nof the loop index after the loop. The terminal value of the loop index varies from lan-\nguage to language and implementation to implementation.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1173, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1174_24d9727d", "text": "The terminal value of the loop index varies from lan-\nguage to language and implementation to implementation. The value is different \nwhen the loop terminates normally and when it terminates abnormally. Even if you \nhappen to know what the final value is without stopping to think about it, the next \nperson to read the code will probably have to think about it. It’s better form and more \nself-documenting if you assign the final value to a variab le at the appropriate point \ninside the loop. CODING \nHORROR\n378\nChapter 16: Controlling Loops\nThis code misuses the index’s final value:\nC+ + Example of Code That Misuses a Loop Index’s Terminal Value\nfor ( recordCount = 0; recordCount < MAX_RECORDS; recordCount++ ) {\n if ( entry[ recordCount ] == testValue ) {\n break;\n }\n}\n// lots of code \n... Here’s the misuse of the loop \nindex’s terminal value.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1174, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 851}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1175_999b6879", "text": "Here’s the misuse of the loop \nindex’s terminal value. if ( recordCount < MAX_RECORDS ) {\n return( true );\n}\nelse {\n return( false );\n}\nIn this fragment, the second test for recordCount < MaxRecords makes it appear that the \nloop is supposed to loop though all the values in entry[] and return true if it finds the \none equal to testValue and false otherwise. It’s hard to remember whether the index \ngets incremented past the end of the loop, so it’s easy to make an off-by-one error. You’re better off writing code that doesn’t depend on the index’s final value. Here’s \nhow to rewrite the code:\nC+ + Example of Code That Doesn’t Mi suse a Loop Index’s Terminal Value\nfound = false;\nfor ( recordCount = 0; recordCount < MAX_RECORDS; recordCount++ ) {\n if ( entry[ recordCount ] == testValue ) {\n found = true;\n break;\n }\n}\n// lots of code \n... return( found );\nThis second code fragment uses an extra variable and keeps references to recordCount \nmore localized.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1175, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 964}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1176_00a173d2", "text": "return( found );\nThis second code fragment uses an extra variable and keeps references to recordCount \nmore localized. As is often the case when an extra boolean variable is used, the result-\ning code is clearer. Consider using safety counters A safety counter is a variable you increment each \npass through a loop to determine whether a loop has been executed too many times. If you have a program in which an error would be catastrophic, you can use safety \ncounters to ensure that all loops end. Th is C++ loop could profitably use a safety \ncounter:\n16.2 Controlling the Loop 379\nC+ + Example of a Loop That Could Use a Safety Counter\ndo {\n node = node->Next;\n ... } while ( node->Next != NULL );\nHere’s the same code with the safety counters added:\nC+ + Example of Using a Safety Counter\nsafetyCounter = 0;\ndo {\n node = node->Next;\n ... Here’s the safety-counter \ncode. safetyCounter++;\n if ( safetyCounter >= SAFETY_LIMIT ) {\n Assert( false, \"Internal Error: Safety-Counter Violation.\" );\n }\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1176, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1002}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1177_c8845aa6", "text": "Here’s the safety-counter \ncode. safetyCounter++;\n if ( safetyCounter >= SAFETY_LIMIT ) {\n Assert( false, \"Internal Error: Safety-Counter Violation.\" );\n }\n ... } while ( node->Next != NULL );\nSafety counters are not a cure-all. Introduc ed into the code one at a time, safety \ncounters increase complexity and can lead to additional errors. Because they aren’t \nused in every loop, you might forget to maintain safety-counter code when you modify \nloops in parts of the program that do use th em. If safety counters are instituted as a \nprojectwide standard for critical loops, ho wever, you learn to expect them and the \nsafety-counter code is no more prone to pr oduce errors later than any other code is. Exiting Loops Early\nMany languages provide a means of causing a loop to terminate in some way other than \ncompleting the for or while condition.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1177, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 853}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1178_a4459616", "text": "Exiting Loops Early\nMany languages provide a means of causing a loop to terminate in some way other than \ncompleting the for or while condition. In this discussion, break is a generic term for break \nin C++, C, and Java; for Exit-Do and Exit-For in Visual Basic; and for similar constructs, \nincluding those simulated with gotos in languages that don’t support break directly. The \nbreak statement (or equivalent) causes a loop to terminate through the normal exit \nchannel; the program resumes execution at the first statement following the loop. The continue statement is similar to break in that it’s an auxiliary loop-control state-\nment. Rather than causing a loop exit, however, continue causes the program to skip \nthe loop body and continue executing at the beginning of the next iteration of the \nloop. A continue statement is shorthand for an if-then clause that would prevent the \nrest of the loop from being executed.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1178, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 929}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1179_d56693b3", "text": "A continue statement is shorthand for an if-then clause that would prevent the \nrest of the loop from being executed. Consider using break statements rather than boolean flags in a while loop In some \ncases, adding boolean flags to a while loop to emulate exits from the body of the loop \nmakes the loop hard to read. Sometimes you can remove several levels of indentation \ninside a loop and simplify loop control just by using a break instead of a series of if tests. 380\nChapter 16: Controlling Loops\nPutting multiple break conditions into separate statements and placing them near the \ncode that produces the break can reduce nesting and make the loop more readable. Be wary of a loop with a lot of break s scattered through it A loop’s containing a lot \nof break s can indicate unclear thinking about the structure of the loop or its role in the \nsurrounding code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1179, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 868}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1180_83f4465c", "text": "Be wary of a loop with a lot of break s scattered through it A loop’s containing a lot \nof break s can indicate unclear thinking about the structure of the loop or its role in the \nsurrounding code. A proliferation of break s raises the possibility that the loop could \nbe more clearly expressed as a series of loop s rather than as one loop with many exits. According to an article in Software Engineering Notes , the software error that brought \ndown the New York City phone systems for 9 hours on January 15, 1990, was due to \nan extra break statement (SEN 1990):\nC+ + Example of Erroneous Use of a break Statement Within a do-switch -if Block\ndo {\n ... switch\n ... if () {\n ... This break was intended for \nthe if but broke out of the \nswitch instead. break; \n ... }\n ... } while ( ... );\nMultiple break s don’t necessarily indicate an error, but their existence in a loop is a \nwarning sign, a canary in a coal mine that’s gasping for air instead of singing as loud \nas it should be.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1180, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1181_49baa127", "text": ");\nMultiple break s don’t necessarily indicate an error, but their existence in a loop is a \nwarning sign, a canary in a coal mine that’s gasping for air instead of singing as loud \nas it should be. Use continue for tests at the top of a loop A good use of continue is for moving exe-\ncution past the body of the loop after testin g a condition at the top. For example, if the \nloop reads records, discards records of one kind, and processes records of another \nkind, you could put a test like this one at the top of the loop:\nPseudocode Example of a Relatively Safe Use of continue\nwhile ( not eof( file ) ) do\n read( record, file )\n if ( record.Type <> targetType ) then\n continue\n -- process record of targetType\n ... end while\nUsing continue in this way lets you avoid an if test that would effectively indent the \nentire body of the loop. If, on the other hand, the continue occurs toward the middle \nor end of the loop, use an if instead.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1181, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1182_8daaf9e5", "text": "If, on the other hand, the continue occurs toward the middle \nor end of the loop, use an if instead. 16.2 Controlling the Loop 381\nUse the labeled break structure if your language supports it Java supports use of \nlabeled break s to prevent the kind of problem ex perienced with the New York City \ntelephone outage. A labeled break can be used to exit a for loop, an if statement, or any \nblock of code enclosed in braces (Arnold, Gosling, and Holmes 2000). Here’s a possible solution to the New York City telephone code problem, with the pro-\ngramming language changed from C++ to Java to show the labeled break:\nJava Example of a Better Use of a Labeled break Statement Within a \ndo-switch-if Block\ndo {\n ... switch\n ... CALL_CENTER_DOWN:\n if () {\n ... The target of the labeled \nbreak is unambiguous. break CALL_CENTER_DOWN; \n ... }\n ... } while ( ... );\nUse break and continue only with caution Use of break eliminates the possibility of \ntreating a loop as a black box.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1182, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1183_29fdef58", "text": "break CALL_CENTER_DOWN; \n ... }\n ... } while ( ... );\nUse break and continue only with caution Use of break eliminates the possibility of \ntreating a loop as a black box. Limiting yo urself to only one statement to control a \nloop’s exit condition is a powerful way to simplify your loops. Using a break forces the \nperson reading your code to look inside the loop for an understanding of the loop \ncontrol. That makes the loop more difficult to understand. Use break only after you have considered the alternatives. You don’t know with cer-\ntainty whether continue and break are virtuous or evil constructs. Some computer sci-\nentists argue that they are a legitimate technique in structured programming; some \nargue that they aren’t. Because you don’t know in general whether continue and break \nare right or wrong, use them, but only with a fear that you might be wrong. It really is \na simple proposition: if you can’t defend a break or a continue , don’t use it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1183, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1184_37deb28f", "text": "It really is \na simple proposition: if you can’t defend a break or a continue , don’t use it. Checking Endpoints\nA single loop usually has three cases of inte rest: the first case, an arbitrarily selected \nmiddle case, and the last case. When you create a loop, mentally run through the first, \nmiddle, and last cases to make sure that th e loop doesn’t have any off-by-one errors. If \nyou have any special cases that are different from the first or last case, check those too. If the loop contains complex computations, get out your calculator and manually \ncheck the calculations. 382\nChapter 16: Controlling Loops\nWillingness to perform this kind of check is a key difference between efficient and \ninefficient programmers. Efficient programme rs do the work of mental simulations \nand hand calculations because they know th at such measures help them find errors. Inefficient programmers tend to experiment randomly until they find a combination \nthat seems to work.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1184, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1185_49dd9088", "text": "Inefficient programmers tend to experiment randomly until they find a combination \nthat seems to work. If a loop isn’t working the way it’s supposed to, the inefficient pro-\ngrammer changes the < sign to a <= sign. If that fails, the inefficient programmer \nchanges the loop index by adding or subtracting 1. Eventually the programmer using \nthis approach might stumble onto the right combination or simply replace the origi-\nnal error with a more subtle one. Even if this random process results in a correct pro-\ngram, it doesn’t result in the programmer’s knowing why the program is correct. You can expect several benefits from mental simulations and hand calculations. The \nmental discipline results in fewer errors du ring initial coding, in more rapid detection \nof errors during debugging, and in a better overall understanding of the program. The \nmental exercise means that you understand how your code works rather than guess-\ning about it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1185, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1186_b395e362", "text": "The \nmental exercise means that you understand how your code works rather than guess-\ning about it. Using Loop Variables\nHere are some guidelines for using loop variables:\nCross-Reference For details \non naming loop variables, \nsee “Naming Loop Indexes” \nin Section 11.2. Use ordinal or enumerated types for limits on both arrays and loops Generally, loop \ncounters should be integer values. Floating-p oint values don’t increment well. For exam-\nple, you could add 1.0 to 26,742,897.0 and get 26,742,897.0 instead of 26,742,898.0. If \nthis incremented value were a loop counter, you’d have an infinite loop. Use meaningful variable names to make nested loops readable Arrays are often \nindexed with the same variables that are used for loop indexes. If you have a one-\ndimensional array, you might be able to get away with using i, j, or k to index it. But if \nyou have an array with two or more dimensions, you should use meaningful index \nnames to clarify what you’re doing.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1186, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 977}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1187_6dd06791", "text": "But if \nyou have an array with two or more dimensions, you should use meaningful index \nnames to clarify what you’re doing. Meaningful array-index names clarify both the \npurpose of the loop and the part of the array you intend to access. Here’s code that doesn’t put this principle to work; it uses the meaningless names i, j, \nand k instead:\nJava Example of Bad Loop Variable Names\nfor ( int i = 0; i < numPayCodes; i++ ) {\n for ( int j = 0; j < 12; j++ ) {\n for ( int k = 0; k < numDivisions; k++ ) {\n sum = sum + transaction[ j ][ i ][ k ];\n }\n }\n}\nKEY POINT\nKEY POINT\nCODING \nHORROR\n16.2 Controlling the Loop 383\nWhat do you think the array indexes in transaction mean? Do i, j, and k tell you any-\nthing about the contents of transaction ? If you had the declaration of transaction , could \nyou easily determine whether the indexes were in the right order?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1187, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 862}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1188_26953b82", "text": "Do i, j, and k tell you any-\nthing about the contents of transaction ? If you had the declaration of transaction , could \nyou easily determine whether the indexes were in the right order? Here’s the same \nloop with more readable loop variable names:\nJava Example of Good Loop Variable Names\nfor ( int payCodeIdx = 0; payCodeIdx < numPayCodes; payCodeIdx++ ) {\n for (int month = 0; month < 12; month++ ) {\n for ( int divisionIdx = 0; divisionIdx < numDivisions; divisionIdx++ ) {\n sum = sum + transaction[ month ][ payCodeIdx ][ divisionIdx ];\n }\n }\n}\nWhat do you think the array indexes in transaction mean this time? In this case, the \nanswer is easier to come by because the variable names payCodeIdx , month , and divi-\nsionIdx tell you a lot more than i, j, and k did. The computer can read the two versions \nof the loop equally easily.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1188, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 840}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1189_f91fe9e0", "text": "The computer can read the two versions \nof the loop equally easily. People can read the second version more easily than the \nfirst, however, and the second version is better since your primary audience is made \nup of humans, not computers. Use meaningful names to avoid loop-index cross-talk Habitual use of i, j, and k can \ngive rise to index cross-talk—using the sa me index name for two different purposes. Take a look at this example:\nC+ + Example of Index Cross-Talk\ni is used first here... for ( i = 0; i < numPayCodes; i++ ) {\n // lots of code\n ... for ( j = 0; j < 12; j++ ) {\n // lots of code \n ... ...and again here. for ( i = 0; i < numDivisions; i++ ) {\n sum = sum + transaction[ j ][ i ][ k ];\n }\n }\n}\nThe use of i is so habitual that it’s used twice in the same nesting structure. The sec-\nond for loop controlled by i conflicts with the first, and that’s index cross-talk. Using \nmore meaningful names than i, j, and k would have prevented the problem.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1189, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1190_07ae1b27", "text": "The sec-\nond for loop controlled by i conflicts with the first, and that’s index cross-talk. Using \nmore meaningful names than i, j, and k would have prevented the problem. In general, \nif the body of a loop has more than a couple of lines, if it might grow, or if it’s in a \ngroup of nested loops, avoid i, j, and k. Limit the scope of loop-index variables to the loop itself Loop-index cross-talk and \nother uses of loop indexes outside their loops is such a significant problem that the \n384\nChapter 16: Controlling Loops\ndesigners of Ada decided to make for loop indexes invalid outside their loops; trying \nto use one outside its for loop generates an error at compile time. C++ and Java implement the same idea to so me extent—they allow loop indexes to be \ndeclared within a loop, but they don’t requ ire it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1190, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 815}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1191_13ae975e", "text": "C++ and Java implement the same idea to so me extent—they allow loop indexes to be \ndeclared within a loop, but they don’t requ ire it. In the example on page 378, the \nrecordCount variable could be declared inside the for statement, which would limit its \nscope to the for loop, like this:\nC+ + Example of Declaring a Loop-Index Variable Within a for loop\nfor ( int recordCount = 0; recordCount < MAX_RECORDS; recordCount++ ) {\n // looping code that uses recordCount\n}\nIn principle, this technique should al low creation of code that redeclares recordCount \nin multiple loops without any risk of misusing the two different recordCounts . That \nusage would give rise to code that looks like this:\nC+ + Example of Declaring Loop-Indexes Within for loops and Reusing Them Safely—\nMaybe!", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1191, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 784}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1192_04d998ba", "text": "That \nusage would give rise to code that looks like this:\nC+ + Example of Declaring Loop-Indexes Within for loops and Reusing Them Safely—\nMaybe! for ( int recordCount = 0; recordCount < MAX_RECORDS; recordCount++ ) {\n // looping code that uses recordCount\n}\n// intervening code\nfor ( int recordCount = 0; recordCount < MAX_RECORDS; recordCount++ ) {\n // additional looping code that uses a different recordCount\n}\nThis technique is helpful for documenting the purpose of the recordCount variable; \nhowever, don’t rely on your compiler to enforce recordCount ’s scope. Section 6.3.3.1 of \nThe C++ Programming Language (Stroustrup 1997) says that recordCount should have a \nscope limited to its loop. When I checked th is functionality with three different C++ \ncompilers, however, I got three different results:\n■\nThe first compiler flagged recordCount in the second for loop for multiple vari-\nable declarations and generated an error.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1192, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1193_9ce2a29e", "text": "■\nThe second compiler accepted recordCount in the second for loop but allowed it \nto be used outside the first for loop. ■\nThe third compiler allowed both usages of recordCount and did not allow either \none to be used outside the for loop in which it was declared. As is often the case with more esoteric language features, compiler implementations \ncan vary. 16.3 Creating Loops Easily—From the Inside Out 385\nHow Long Should a Loop Be? Loop length can be measured in lines of code or depth of nesting. Here are some \nguidelines:\nMake your loops short enough to view all at once If you usually look at loops on \nyour monitor and your monitor displays 50 lines, that puts a 50-line restriction on \nyou. Experts have suggested a loop-length limit of one page. When you begin to appre-\nciate the principle of writing simple code, however, you’ll rarely write loops longer \nthan 15 or 20 lines.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1193, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 891}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1194_7c19d030", "text": "Experts have suggested a loop-length limit of one page. When you begin to appre-\nciate the principle of writing simple code, however, you’ll rarely write loops longer \nthan 15 or 20 lines. Cross-Reference For details \non simplifying nesting, see \nSection 19.4, “Taming Dan-\ngerously Deep Nesting.”\nLimit nesting to three levels Studies have shown that the ability of programmers to \ncomprehend a loop deteriorates significantl y beyond three levels of nesting (Yourdon \n1986a). If you’re going beyond that number of levels, make the loop shorter (concep-\ntually) by breaking part of it into a routine or simplifying the control structure. Move loop innards of long loops into routines If the loop is well designed, the code \non the inside of a loop can often be moved into one or more routines that are called \nfrom within the loop. Make long loops especially clear Length adds complexity.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1194, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 889}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1195_bf3fea79", "text": "Make long loops especially clear Length adds complexity. If you write a short loop, \nyou can use riskier control structures such as break and continue , multiple exits, com-\nplicated termination conditions, and so on. If you write a longer loop and feel any con-\ncern for your reader, you’ll give the loop a single exit and make the exit condition \nunmistakably clear. 16.3 Creating Loops Easily—From the Inside Out\nIf you sometimes have trouble coding a complex loop—which most programmers do—\nyou can use a simple technique to get it righ t the first time. Here’s the general process. Start with one case. Code that case with lite rals. Then indent it, put a loop around it, \nand replace the literals with loop indexes or computed expressions. Put another loop \naround that, if necessary, and replace more literals. Continue the process as long as \nyou have to. When you finish, add all the n ecessary initializations.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1195, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 920}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1196_8a5c27ff", "text": "Put another loop \naround that, if necessary, and replace more literals. Continue the process as long as \nyou have to. When you finish, add all the n ecessary initializations. Since you start at \nthe simple case and work outward to generali ze it, you might think of this as coding \nfrom the inside out. Cross-Reference Coding a \nloop from the inside out is \nsimilar to the process \ndescribed in Chapter 9, “The \nPseudocode Programming \nProcess.”\nSuppose you’re writing a program for an insurance company. It has life-insurance \nrates that vary according to a person’s age and sex. Your job is to write a routine that \ncomputes the total life-insurance premium for a group. You need a loop that takes the \nrate for each person in a list and adds it to a total. Here’s how you’d do it. 386\nChapter 16: Controlling Loops\nFirst, in comments, write the steps the body of the loop needs to perform.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1196, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 892}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1197_5e54f3b3", "text": "Here’s how you’d do it. 386\nChapter 16: Controlling Loops\nFirst, in comments, write the steps the body of the loop needs to perform. It’s easier to \nwrite down what needs to be done when you’re not thinking about details of syntax, \nloop indexes, array indexes, and so on. Step 1: Creating a Loop from th e Inside Out (Pseudocode Example)\n-- get rate from table\n-- add rate to total\nSecond, convert the comments in the body of the loop to code, as much as you can \nwithout actually writing the whole loop. In this case, get the rate for one person and \nadd it to the overall total. Use concrete, specific data rather than abstractions. Step 2: Creating a Loop from th e Inside Out (Pseudocode Example)\ntable doesn’t have any \nindexes yet. rate = table[ ]\ntotalRate = totalRate + rate\nThe example assumes that table is an array that holds the rate data. You don’t have to \nworry about the array indexes at first. rate is the variable that holds the rate data selected \nfrom the rate table.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1197, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 988}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1198_506a5ef5", "text": "You don’t have to \nworry about the array indexes at first. rate is the variable that holds the rate data selected \nfrom the rate table. Likewise, totalRate is a variable that holds the total of the rates. Next, put in indexes for the table array:\nStep 3: Creating a Loop from th e Inside Out (Pseudocode Example)\nrate = table[ census.Age ][ census.Gender ]\ntotalRate = totalRate + rate\nThe array is accessed by age and sex, so census.Age and census.Gender are used to index \nthe array. The example assumes that census is a structure that holds information about \npeople in the group to be rated. The next step is to build a loop around th e existing statements. Since the loop is sup-\nposed to compute the rates for each person in a group, the loop should be indexed by \nperson.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1198, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 778}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1199_cd55892a", "text": "The next step is to build a loop around th e existing statements. Since the loop is sup-\nposed to compute the rates for each person in a group, the loop should be indexed by \nperson. Step 4: Creating a Loop from th e Inside Out (Pseudocode Example)\nFor person = firstPerson to lastPerson\n rate = table[ census.Age, census.Gender ]\n totalRate = totalRate + rate\nEnd For\nAll you have to do here is put the for loop around the existing code and then indent \nthe existing code and put it inside a begin-end pair. Finally, check to make sure that the \nvariables that depend on the person loop index have been generalized. In this case, the \ncensus variable varies with person , so it should be generalized appropriately.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1199, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 715}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1200_b1b9858d", "text": "In this case, the \ncensus variable varies with person , so it should be generalized appropriately. 16.4 Correspondence Be tween Loops and Arrays 387\nStep 5: Creating a Loop from th e Inside Out (Pseudocode Example)\nFor person = firstPerson to lastPerson\n rate = table[ census[ person ].Age, census[ person ].Gender ]\n totalRate = totalRate + rate\nEnd For\nFinally, write any initializations that are needed. In this case, the totalRate variable \nneeds to be initialized. Final Step: Creating a Loop from the Inside Out (Pseudocode Example)\ntotalRate = 0\nFor person = firstPerson to lastPerson\n rate = table[ census[ person ].Age, census[ person ].Gender ]\n totalRate = totalRate + rate\nEnd For\nIf you had to put another loop around the person loop, you would proceed in the same \nway. You don’t need to follow the steps rigidl y. The idea is to start with something con-\ncrete, worry about only one thing at a time, and build up the loop from simple com-\nponents.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1200, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1201_7bcbd744", "text": "You don’t need to follow the steps rigidl y. The idea is to start with something con-\ncrete, worry about only one thing at a time, and build up the loop from simple com-\nponents. Take small, understandable steps as you make the loop more general and \ncomplex. That way, you minimi ze the amount of code you have to concentrate on at \nany one time and therefore minimize the chance of error. 16.4 Correspondence Between Loops and Arrays\nCross-Reference For further \ndiscussion of the correspon-\ndence between loops and \narrays, see Section 10.7, \n“Relationship Between Data \nTypes and Control \nStructures.”\nLoops and arrays are often related. In many instances, a loop is created to perform an \narray manipulation, and loop counters corres pond one-to-one with array indexes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1201, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 774}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1202_3a04fc9b", "text": "In many instances, a loop is created to perform an \narray manipulation, and loop counters corres pond one-to-one with array indexes. For \nexample, these Java for loop indexes correspond to the array indexes:\nJava Example of an Array Multiplication\nfor ( int row = 0; row < maxRows; row++ ) {\n for ( int column = 0; column < maxCols; column++ ) {\n product[ row ][ column ] = a[ row ][ column ] * b[ row ][ column ];\n }\n}\nIn Java, a loop is necessary for this array op eration. But it’s worth noting that looping \nstructures and arrays aren’t inherently connected. Some languages, especially APL \nand Fortran 90 and later, provide powerful array operations that eliminate the need \nfor loops like the one just shown. Here’s an APL code fragment that performs the \nsame operation:\nAPL Example of an Array Multiplication\nproduct <- a x b\n388\nChapter 16: Controlling Loops\nThe APL is simpler and less error-prone. It uses only three operands, whereas the Java \nfragment uses 17.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1202, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1203_c8756264", "text": "It uses only three operands, whereas the Java \nfragment uses 17. It doesn’t have loop variables, array indexes, or control structures to \ncode incorrectly. One point of this example is that you do some programming to solve a problem and \nsome to solve it in a particular language. The language you use to solve a problem sub-\nstantially affects your solution. cc2e.com/1616\nCHECKLIST: Loops\nLoop Selection and Creation\n❑\nIs a while loop used instead of a for loop, if appropriate? ❑\nWas the loop created from the inside out? Entering the Loop\n❑\nIs the loop entered from the top? ❑\nIs initialization code directly before the loop? ❑\nIf the loop is an infinite loop or an event loop, is it constructed cleanly \nrather than using a kludge such as for i = 1 to 9999 ? ❑\nIf the loop is a C++, C, or Java for loop, is the loop header reserved for loop-\ncontrol code? Inside the Loop\n❑\nDoes the loop use { and } or their equivalent to enclose the loop body and \nprevent problems arising from improper modifications?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1203, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1008}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1204_dae4209a", "text": "Inside the Loop\n❑\nDoes the loop use { and } or their equivalent to enclose the loop body and \nprevent problems arising from improper modifications? ❑\nDoes the loop body have something in it? Is it nonempty? ❑\nAre housekeeping chores grouped, at either the beginning or the end of \nthe loop? ❑\nDoes the loop perform one and only one function, as a well-defined rou-\ntine does? ❑\nIs the loop short enough to view all at once? ❑\nIs the loop nested to three levels or less? ❑\nHave long loop contents been moved into their own routine? ❑\nIf the loop is long, is it especially clear? Key Points 389\nLoop Indexes\n❑\nIf the loop is a for loop, does the code inside it avoid monkeying with the \nloop index? ❑\nIs a variable used to save important loop-index values rather than using \nthe loop index outside the loop? ❑\nIs the loop index an ordinal type or an enumerated type—not floating-\npoint? ❑\nDoes the loop index have a meaningful name? ❑\nDoes the loop avoid index cross-talk?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1204, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1205_fd398e0e", "text": "❑\nIs the loop index an ordinal type or an enumerated type—not floating-\npoint? ❑\nDoes the loop index have a meaningful name? ❑\nDoes the loop avoid index cross-talk? Exiting the Loop\n❑\nDoes the loop end under all possible conditions? ❑\nDoes the loop use safety counters—if you’ve instituted a safety-counter \nstandard? ❑\nIs the loop’s termination condition obvious? ❑\nIf break or continue are used, are they correct? Key Points\n■\nLoops are complicated. Keeping them simple helps readers of your code. ■\nTechniques for keeping loops simple include avoiding exotic kinds of loops, \nminimizing nesting, making entries an d exits clear, and keeping housekeeping \ncode in one place. ■\nLoop indexes are subjected to a great deal of abuse. Name them clearly, and use \nthem for only one purpose. ■\nThink through the loop carefully to verify that it operates normally under each \ncase and terminates under all possible conditions.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1205, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 920}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1206_29a05802", "text": "Name them clearly, and use \nthem for only one purpose. ■\nThink through the loop carefully to verify that it operates normally under each \ncase and terminates under all possible conditions. 391\nChapter 17\nUnusual Control Structures\ncc2e.com/1778\nContents\n■\n17.1 Multiple Returns from a Routine: page 391\n■\n17.2 Recursion: page 393\n■\n17.3 goto: page 398\n■\n17.4 Perspective on Unusual Control Structures: page 408\nRelated Topics\n■\nGeneral control issues: Chapter 19\n■\nStraight-line code: Chapter 14\n■\nCode with conditionals: Chapter 15\n■\nCode with loops: Chapter 16\n■\nException handling: Section 8.4\nSeveral control constructs exist in a hazy twilight zone somewhere between being \nleading-edge and being discredited and disproved—often in both places at the same \ntime! These constructs aren’t available in all languages but can be useful when used \nwith care in those languages that do offer them.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1206, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 896}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1207_28815d6b", "text": "These constructs aren’t available in all languages but can be useful when used \nwith care in those languages that do offer them. 17.1 Multiple Returns from a Routine\nMost languages support some means of exiting from a routine partway through the \nroutine. The return and exit statements are control constructs that enable a program to \nexit from a routine at will. They cause the routine to terminate through the normal \nexit channel, returning control to the calling routine. The word return is used here as \na generic term for return in C++ and Java, Exit Sub and Exit Function in Microsoft Visual \nBasic, and similar constructs. Here are guidelines for using the return statement:\nUse a return when it enhances readability In certain routines, once you know the \nanswer, you want to return it to the calling routine immediately.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1207, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 831}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1208_f04d53a3", "text": "Here are guidelines for using the return statement:\nUse a return when it enhances readability In certain routines, once you know the \nanswer, you want to return it to the calling routine immediately. If the routine is \ndefined in such a way that it doesn’t require any further cleanup once it detects an \nerror, not returning immediately means that you have to write more code. KEY POINT\n392\nChapter 17: Unusual Control Structures\nThe following is a good example of a case in which returning from multiple places in \na routine makes sense:\nC+ + Example of a Good Multiple Return from a Routine\nThis routine returns a \nComparison enumerated \ntype. Comparison Compare( int value1, int value2 ) {\n if ( value1 < value2 ) {\n return Comparison_LessThan;\n }\n else if ( value1 > value2 ) {\n return Comparison_GreaterThan;\n }\n return Comparison_Equal;\n}\nOther examples are less clear-cut, as the next subsection illustrates.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1208, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 916}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1209_40282c39", "text": "Use guard clauses (early returns or exit s) to simplify complex error processing\nCode that has to check for numerous error conditions before performing its nominal \nactions can result in deeply indented code and can obscure the nominal case, as \nshown here:\nVisual Basic Code That Obscures the Nominal Case\nIf file.validName() Then\n If file.Open() Then\n If encryptionKey.valid() Then\n If file.Decrypt( encryptionKey ) Then\nThis is the code for the \nnominal case. ' lots of code\n ... End If\n End If\n End If\nEnd If\nIndenting the main body of the routine inside four if statements is aesthetically ugly, \nespecially if there’s much code inside the innermost if statement. In such cases, the \nflow of the code is sometimes clearer if th e erroneous cases are checked first, clearing \nthe way for the nominal path through the code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1209, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 826}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1210_d46e29ef", "text": "In such cases, the \nflow of the code is sometimes clearer if th e erroneous cases are checked first, clearing \nthe way for the nominal path through the code. Here’s how that might look:\nSimple Visual Basic Code That Uses Gu ard Clauses to Clarify the Nominal Case\n' set up, bailing out if errors are found\nIf Not file.validName() Then Exit Sub\nIf Not file.Open() Then Exit Sub\nIf Not encryptionKey.valid() Then Exit Sub\nIf Not file.Decrypt( encryptionKey ) Then Exit Sub\n' lots of code\n... 17.2 Recursion 393\nThis simple code makes this technique look like a tidy solution, but production code \noften requires more extensive housekeeping or cleanup when an error condition is \ndetected.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1210, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 686}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1211_d828446b", "text": "17.2 Recursion 393\nThis simple code makes this technique look like a tidy solution, but production code \noften requires more extensive housekeeping or cleanup when an error condition is \ndetected. Here is a more realistic example:\nMore Realistic Visual Basic Code That Uses Guard Clauses to Clarify the Nominal Case\n' set up, bailing out if errors are found\nIf Not file.validName() Then \n errorStatus = FileError_InvalidFileName\n Exit Sub\nEnd If \nIf Not file.Open() Then \n errorStatus = FileError_CantOpenFile\n Exit Sub\nEnd If \nIf Not encryptionKey.valid() Then \n errorStatus = FileError_InvalidEncryptionKey\n Exit Sub\nEnd If \nIf Not file.Decrypt( encryptionKey ) Then \n errorStatus = FileError_CantDecryptFile\n Exit Sub\nEnd If \nThis is the code for the \nnominal case. ' lots of code\n... With production-size code, the Exit Sub approach creates a noticeable amount of code \nbefore the nominal case is handled.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1211, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1212_eb02318f", "text": "' lots of code\n... With production-size code, the Exit Sub approach creates a noticeable amount of code \nbefore the nominal case is handled. The Exit Sub approach does avoid the deep nest-\ning of the first example, however, and, if the code in the first example were expanded \nto show setting an errorStatus variable, the Exit Sub approach would do a better job of \nkeeping related statements together. When all the dust settles, the Exit Sub approach \ndoes appear more readable and maintainable, just not by a very wide margin. Minimize the number of returns in each routine It’s harder to understand a routine \nwhen, reading it at the bottom, you’re unawar e of the possibility that it returned some-\nwhere above. For that reason, use returns judi ciously—only when they improve readability. 17.2 Recursion\nIn recursion, a routine solves a small part of a problem itself, divides the problem into \nsmaller pieces, and then calls itself to solv e each of the smaller pieces.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1212, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 975}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1213_7c06cbd4", "text": "17.2 Recursion\nIn recursion, a routine solves a small part of a problem itself, divides the problem into \nsmaller pieces, and then calls itself to solv e each of the smaller pieces. Recursion is \nusually called into play when a small part of the problem is easy to solve and a large \npart is easy to decompose into smaller pieces. Recursion isn’t useful often, but when used judiciously it produces elegant solutions, \nas in this example in which a sorting algorithm makes excellent use of recursion:\nKEY POINT\n394\nChapter 17: Unusual Control Structures\nJava Example of a Sorting Algorithm That Uses Recursion\nvoid QuickSort( int firstIndex, int lastIndex, String [] names ) {\n if ( lastIndex > firstIndex ) {\n int midPoint = Partition( firstIndex, lastIndex, names );\nHere are the recursive calls. QuickSort( firstIndex, midPoint-1, names );\n QuickSort( midPoint+1, lastIndex, names )\n }\n}\nIn this case, the sorting algorithm chops an array in two and then calls itself to sort \neach half of the array.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1213, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1214_4c77b38b", "text": "When it calls itself with a subarray that’s too small to sort—such \nas ( lastIndex <= firstIndex ) —it stops calling itself. For a small group of problems, recursion can produce simple, elegant solutions. For a \nslightly larger group of problems, it can produce simple, elegant, hard-to-understand \nsolutions. For most problems, it produces massively complicated solutions—in those \ncases, simple iteration is usually more understandable. Use recursion selectively. Example of Recursion\nSuppose you have a data type that represents a maze. A maze is basically a grid, and at \neach point on the grid you might be able to turn left, turn right, move up, or move \ndown. You’ll often be able to move in more than one direction. How do you write a program to find its way through the maze, as shown in Figure 17-\n1? If you use recursion, the answer is fairly straightforward. You start at the beginning \nand then try all possible paths until you find your way out of the maze.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1214, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1215_9d22b826", "text": "If you use recursion, the answer is fairly straightforward. You start at the beginning \nand then try all possible paths until you find your way out of the maze. The first time \nyou visit a point, you try to move left. If you can’t move left, you try to go up or down, \nand if you can’t go up or down, you try to go right. You don’t have to worry about get-\nting lost because you drop a few bread crumbs on each spot as you visit it, and you \ndon’t visit the same spot twice. Figure 17-1 Recursion can be a valuable tool in th e battle against co mplexity—when used \nto attack suitable problems. Left\nDownUp\nRight\nGo up because left\nis unavailable.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1215, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 647}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1216_9ebe7ab9", "text": "Figure 17-1 Recursion can be a valuable tool in th e battle against co mplexity—when used \nto attack suitable problems. Left\nDownUp\nRight\nGo up because left\nis unavailable. 17.2 Recursion 395\nThe recursive code looks like this:\nC+ + Example of Moving Through a Maze Recursively\nbool FindPathThroughMaze( Maze maze, Point position ) {\n // if the position has already been tried, don't try it again\n if ( AlreadyTried( maze, position ) ) {\n return false;\n }\n \n // if this position is the exit, declare success\n if ( ThisIsTheExit( maze, position ) ) {\n return true;\n }\n \n // remember that this position has been tried\n RememberPosition( maze, position );\n \n // check the paths to the left, up, down, and to the right; if\n // any path is successful, stop looking \n if ( MoveLeft( maze, position, &newPosition ) ) {\n if ( FindPathThroughMaze( maze, newPosition ) ) {\n return true;\n }\n }\n \n if ( MoveUp( maze, position, &newPosition ) ) {\n if ( FindPathThroughMaze( maze, newPosition ) ) {\n return true;\n }\n }\n \n if ( MoveDown( maze, position, &newPosition ) ) {\n if ( FindPathThroughMaze( maze, newPosition ) ) {\n return true;\n }\n }\n \n if ( MoveRight( maze, position, &newPosition ) ) {\n if ( FindPathThroughMaze( maze, newPosition ) ) {\n return true;\n }\n }\n return false;\n}\nThe first line of code checks to see whether the position has already been tried.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1216, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1352}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1217_6d6c813f", "text": "One \nkey aim in writing a recursive routine is the prevention of infinite recursion. In this \ncase, if you don’t check for having tried a po int, you might keep trying it infinitely. The second statement checks to see whether the position is the exit from the maze. If \nThisIsTheExit() returns true, the routine itself returns true. 396\nChapter 17: Unusual Control Structures\nThe third statement remembers that the position has been visited. This prevents the \ninfinite recursion that would result from a circular path. The remaining lines in the routine try to find a path to the left, up, down, and to the \nright. The code stops the recursion if the routine ever returns true—that is, when the \nroutine finds a path through the maze. The logic used in this routine is fairly st raightforward. Most people experience some \ninitial discomfort using recursion because it’s self-referential. In this case, however, an \nalternative solution would be much more complicated and recursion works well.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1217, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 994}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1218_57306d2c", "text": "Most people experience some \ninitial discomfort using recursion because it’s self-referential. In this case, however, an \nalternative solution would be much more complicated and recursion works well. Tips for Using Recursion\nKeep these tips in mind when using recursion:\nMake sure the recursion stops Check the routine to make sure that it includes a non-\nrecursive path. That usually means that the routine has a test that stops further recur-\nsion when it’s not needed. In the maze example, the tests for AlreadyTried() and \nThisIsTheExit() ensure that the recursion stops. Use safety counters to prevent infinite recursion If you’re using recursion in a situa-\ntion that doesn’t allow a simple test such as the one just described, use a safety \ncounter to prevent infinite recursion. The safe ty counter has to be a variable that’s not \nre-created each time you call the routine. Use a class member variable or pass the \nsafety counter as a parameter.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1218, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 954}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1219_02a4a196", "text": "The safe ty counter has to be a variable that’s not \nre-created each time you call the routine. Use a class member variable or pass the \nsafety counter as a parameter. Here’s an example:\nVisual Basic Example of Using a Safety Counter to Prevent Infinite Recursion\nThe recursive routine must \nbe able to change the value \nof safetyCounter , so in Visual \nBasic it’s a ByRef parameter. Public Sub RecursiveProc( ByRef safetyCounter As Integer )\n If ( safetyCounter > SAFETY_LIMIT ) Then\n Exit Sub\n End If\n safetyCounter = safetyCounter + 1\n ... RecursiveProc( safetyCounter )\nEnd Sub\nIn this case, if the routine exceeds the safety limit, it stops recursing. If you don’t want to pass the safety counter as an explicit parameter, you could use a \nmember variable in C++, Java, or Visual Ba sic, or the equivalent in other languages. Limit recursion to one routine Cyclic recursion (A calls B calls C calls A) is danger-\nous because it’s hard to detect.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1219, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 950}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1220_c3ef1195", "text": "Limit recursion to one routine Cyclic recursion (A calls B calls C calls A) is danger-\nous because it’s hard to detect. Mentally managing recursion in one routine is tough \nenough; understanding recursion that spans routines is too much. If you have cyclic \nrecursion, you can usually redesign the routines so that the recursion is restricted to a \n17.2 Recursion 397\nsingle routine. If you can’t and you still think that recursion is the best approach, use \nsafety counters as a recursive insurance policy. Keep an eye on the stack With recursion, you have no guarantees about how much \nstack space your program uses and it’s hard to predict in advance how the program \nwill behave at run time. You can take a coupl e of steps to control its run-time behavior, \nhowever. First, if you use a safety counter, one of th e considerations in setting a limit for it \nshould be how much stack you’re willing to allocate to the recursive routine. Set the \nsafety limit low enough to prevent a stack overflow.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1220, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1001}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1221_faec4839", "text": "Set the \nsafety limit low enough to prevent a stack overflow. Second, watch for allocation of local variab les in recursive functions, especially mem-\nory-intensive objects. In other words, use new to create objects on the heap rather \nthan letting the compiler create auto objects on the stack. Don’t use recursion for factorials or Fibonacci numbers One problem with com-\nputer-science textbooks is that they presen t silly examples of recursion. The typical \nexamples are computing a factorial or computing a Fibonacci sequence. Recursion is \na powerful tool, and it’s really dumb to use it in either of those cases. If a programmer \nwho worked for me used recursion to compute a factorial, I’d hire someone else.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1221, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 716}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1222_cd5b6b02", "text": "Recursion is \na powerful tool, and it’s really dumb to use it in either of those cases. If a programmer \nwho worked for me used recursion to compute a factorial, I’d hire someone else. Here’s the recursive version of the factorial routine:\nJava Example of an Inappropriate Solution: Using Recursion to Compute a Factorial\nint Factorial( int number ) {\n if ( number == 1 ) {\n return 1;\n }\n else {\n return number * Factorial( number - 1 );\n }\n}\nIn addition to being slow and making the use of run-time memory unpredictable, the \nrecursive version of this routine is harder to understand than the iterative version, \nwhich follows:\nJava Example of an Appropriate Solution: Using Iteration to Compute a Factorial\nint Factorial( int number ) {\n int intermediateResult = 1;\n for ( int factor = 2; factor <= number; factor++ ) {\n intermediateResult = intermediateResult * factor;\n }\n return intermediateResult;\n}\nCODING \nHORROR\n398\nChapter 17: Unusual Control Structures\nYou can draw three lessons from this exam ple.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1222, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1010}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1223_7491ad2f", "text": "First, computer-science textbooks \naren’t doing the world any favors with thei r examples of recursion. Second, and more \nimportant, recursion is a much more powerful tool than its confusing use in comput-\ning factorials or Fibonacci numbers would suggest. Third, and most important, you \nshould consider alternatives to recursion before using it. You can do anything with \nstacks and iteration that you can do with recursion. Sometimes one approach works \nbetter; sometimes the other does. Consider both before you choose either one. 17.3 goto\ncc2e.com/1785\nYou might think the debate related to gotos is extinct, but a quick trip through modern \nsource-code repositories like SourceForge.net shows that the goto is still alive and well \nand living deep in your company’s server. Moreover, modern equivalents of the goto \ndebate still crop up in various guises, in cluding debates about multiple returns, mul-\ntiple loop exits, named loop exits, er ror processing, and exception handling.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1223, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1224_6daf8af9", "text": "The Argument Against gotos\nThe general argument against gotos is that code without gotos is higher-quality code. The famous letter that sparked the original controversy was Edsger Dijkstra’s “Go To \nStatement Considered Harmful” in the March 1968 Communications of the ACM . Dijkstra observed that the qu ality of code was inversely proportional to the number of \ngotos the programmer used. In subsequent work, Dijkstra has argued that code that \ndoesn’t contain gotos can more easily be proven correct. Code containing gotos is hard to format. Indentation should be used to show logical \nstructure, and gotos have an effect on logical structure. Using indentation to show the \nlogical structure of a goto and its target, however, is difficult or impossible. Use of gotos defeats compiler optimizations. So me optimizations depend on a pro-\ngram’s flow of control residing within a few statements.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1224, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 897}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1225_b6862e48", "text": "Use of gotos defeats compiler optimizations. So me optimizations depend on a pro-\ngram’s flow of control residing within a few statements. An unconditional goto makes \nthe flow harder to analyze and reduces the ability of the compiler to optimize the \ncode. Thus, even if introducing a goto produces an efficiency at the source-language \nlevel, it may well reduce overall efficiency by thwarting compiler optimizations. Proponents of gotos sometimes argue that they make co de faster or smaller. But code \ncontaining gotos is rarely the fastest or smallest possible. Donald K nuth’s marvelous, \nclassic article “Structured Programming with go to Statements” gives several examples \nof cases in which using gotos makes for slower and larger code (Knuth 1974). In practice, the use of gotos leads to the violation of the principle that code should \nflow strictly from top to bottom.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1225, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 880}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1226_e2e08ca8", "text": "In practice, the use of gotos leads to the violation of the principle that code should \nflow strictly from top to bottom. Even if gotos aren’t confusing when used carefully, \nonce gotos are introduced, they spread through the code like termites through a rot-\nting house. If any gotos are allowed, the bad creep in with the good, so it’s better not \nto allow any of them. 17.3 goto 399\nOverall, experience in the two decades that followed the publication of Dijkstra’s letter \nshowed the folly of producing goto-laden code. In a survey of the literature, Ben Shneider-\nman concluded that the evidence supports Dijkstra’s view that we’re better off without \nthe goto (1980), and many modern languages, including Java, don’t even have gotos. The Argument for gotos\nThe argument for the goto is characterized by an advocacy of its careful use in specific \ncircumstances rather than its indiscri minate use. Most arguments against gotos speak \nagainst indiscriminate use.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1226, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1227_892f1212", "text": "Most arguments against gotos speak \nagainst indiscriminate use. The goto controversy erupted when Fortran was the most \npopular language. Fortran had no presentabl e loop structures, and in the absence of \ngood advice on programming loops with gotos, programmers wrote a lot of spaghetti \ncode. Such code was undoubtedly correlated with the production of low-quality pro-\ngrams, but it has little to do with the careful use of a goto to make up for a gap in a \nmodern language’s capabilities. A well-placed goto can eliminate the need for duplicate code. Duplicate code leads to \nproblems if the two sets of code are modified differently. Duplicate code increases the \nsize of source and executable files. The bad effects of the goto are outweighed in such \na case by the risks of duplicate code. Cross-Reference For details \non using gotos in code that \nallocates resources, see “Error \nProcessing and gotos” in this \nsection.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1227, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1228_b7eea0b7", "text": "Cross-Reference For details \non using gotos in code that \nallocates resources, see “Error \nProcessing and gotos” in this \nsection. See also the discus-\nsion of exception handling in \nSection 8.4, “Exceptions.”\nThe goto is useful in a routine that allocates resources, performs operations on those \nresources, and then deallocates the resources. With a goto, you can clean up in one \nsection of code. The goto reduces the likelihood of your forgetting to deallocate the \nresources in each place you detect an error. In some cases, the goto can result in faster and smaller code. Knuth’s 1974 article cited \na few cases in which the goto produced a legitimate gain. Good programming doesn’t mean eliminating gotos. Methodical decomposition, \nrefinement, and selection of control structures automatically lead to goto-free pro-\ngrams in most cases. Achieving goto-less code is not the aim but the outcome, and put-\nting the focus on avoiding gotos isn’t helpful.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1228, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1229_86aa202c", "text": "Achieving goto-less code is not the aim but the outcome, and put-\nting the focus on avoiding gotos isn’t helpful. The evidence suggests only \nthat deliberately chaotic \ncontrol structure degrades \n[programmer] performance. These experiments provide \nvirtually no evidence for the \nbeneficial effect of any spe-\ncific method of structuring \ncontrol flow. —B. A. Sheil\nDecades’ worth of research with gotos failed to demonstrate their harmfulness. In a \nsurvey of the literature, B. A. Sheil conclu ded that unrealistic test conditions, poor \ndata analysis, and inconclusive results failed to support the claim of Shneiderman and \nothers that the number of bugs in code was proportional to the number of gotos \n(1981). Sheil didn’t go so far as to conclude that using gotos is a good idea—rather, that \nexperimental evidence against them was not conclusive.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1229, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 855}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1230_df8ce13f", "text": "Sheil didn’t go so far as to conclude that using gotos is a good idea—rather, that \nexperimental evidence against them was not conclusive. Finally, the goto has been incorporated into many modern languages, including Visual \nBasic, C++, and the Ada language, the mo st carefully engineered programming lan-\nguage in history. Ada was developed long after the arguments on both sides of the goto \ndebate had been fully developed, and after considering all sides of the issue, Ada’s \nengineers decided to include the goto. 17.3 goto\n400\nChapter 17: Unusual Control Structures\nThe Phony goto Debate\nA primary feature of most goto discussions is a shallow approach to the question. The \narguer on the “ gotos are evil” side presents a trivial code fragment that uses gotos and \nthen shows how easy it is to rewrite the fragment without gotos. This proves mainly \nthat it’s easy to write trivial code without gotos.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1230, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 909}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1231_41d87286", "text": "This proves mainly \nthat it’s easy to write trivial code without gotos. The arguer on the “I can’t live without gotos” side usually presents a case in which \neliminating a goto results in an extra comparison or the duplication of a line of code. This proves mainly that there’s a case in which using a goto results in one less compar-\nison—not a significant gain on today’s computers. Most textbooks don’t help. They provide a trivial example of rewriting some code \nwithout a goto as if that covers the subject.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1231, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 512}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1232_d982ba8b", "text": "Most textbooks don’t help. They provide a trivial example of rewriting some code \nwithout a goto as if that covers the subject. Here’s a disguised example of a trivial piece \nof code from such a textbook:\nC+ + Example of Code That’s Supposed to Be Easy to Rewrite Without gotos\ndo {\n GetData( inputFile, data );\n if ( eof( inputFile ) ) {\n goto LOOP_EXIT;\n }\n DoSomething( data );\n} while ( data != -1 );\nLOOP_EXIT:\nThe book quickly replaces this code with goto-less code:\nC+ + Example of Supposedly Equivalent Code, Rewritten Without gotos\nGetData( inputFile, data );\nwhile ( ( !eof( inputFile ) ) && ( ( data != -1 ) ) ) {\n DoSomething( data );\n GetData( inputFile, data )\n}\nThis so-called “trivial” example contai ns an error. In the case in which data equals -1 \nentering the loop, the translated code detects the -1 and exits the loop before executing \nDoSomething() . The original code executes DoSomething() before the -1 is detected.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1232, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 941}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1233_da5889f8", "text": "The original code executes DoSomething() before the -1 is detected. The \nprogramming book trying to show how easy it is to code without gotos translated its own \nexample incorrectly. But the author of that book shouldn’t feel too bad; other books \nmake similar mistakes. Even the pros have difficulty translating code that uses gotos. Here’s a faithful translation of the code with no gotos:\n17.3 goto 401\n17.3 goto\nC+ + Example of Truly Equivalent Code, Rewritten Without gotos\ndo {\n GetData( inputFile, data );\n if ( !eof( inputFile )) {\n DoSomething( data );\n }\n} while ( ( data != -1 ) && ( !eof( inputFile ) ) );\nEven with a correct translation of the co de, the example is still phony because it \nshows a trivial use of the goto. Such cases are not the ones for which thoughtful pro-\ngrammers choose a goto as their preferred form of control. It would be hard at this late date to add anything worthwhile to the theoretical goto \ndebate.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1233, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 943}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1234_5df80554", "text": "It would be hard at this late date to add anything worthwhile to the theoretical goto \ndebate. What’s not usually addressed, however, is the situation in which a program-\nmer fully aware of the goto-less alternatives chooses to use a goto to enhance readabil-\nity and maintainability. The following sections present cases in which some experienced programmers have \nargued for using gotos. The discussions provide examples of code with gotos and code \nrewritten without gotos and evaluate the tradeoffs between the versions. Error Processing and gotos\nWriting highly interactive code calls for paying a lot of attention to error processing \nand cleaning up resources when errors o ccur. The following code example purges a \ngroup of files. The routine first gets a group of files to be purged, and then it finds each \nfile, opens it, overwrites it, and erases it. The routine checks for errors at each step.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1234, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1235_4e014034", "text": "The routine first gets a group of files to be purged, and then it finds each \nfile, opens it, overwrites it, and erases it. The routine checks for errors at each step. Visual Basic Code with gotos That Processes Errors an d Cleans Up Resources\n' This routine purges a group of files. Sub PurgeFiles( ByRef errorState As Error_Code )\n Dim fileIndex As Integer\n Dim fileToPurge As Data_File\n Dim fileList As File_List\n Dim numFilesToPurge As Integer\n MakePurgeFileList( fileList, numFilesToPurge )\n errorState = FileStatus_Success\n fileIndex = 0\n While ( fileIndex < numFilesToPurge ) \n fileIndex = fileIndex + 1\n If Not ( FindFile( fileList( fileIndex ), fileToPurge ) ) Then\n errorState = FileStatus_FileFindError\nHere’s a GoTo . GoTo END_PROC\n End If\n402\nChapter 17: Unusual Control Structures\n If Not OpenFile( fileToPurge ) Then\n errorState = FileStatus_FileOpenError\nHere’s a GoTo .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1235, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 886}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1236_85f3c3bd", "text": "GoTo END_PROC\n End If\n402\nChapter 17: Unusual Control Structures\n If Not OpenFile( fileToPurge ) Then\n errorState = FileStatus_FileOpenError\nHere’s a GoTo . GoTo END_PROC\n End If\n If Not OverwriteFile( fileToPurge ) Then\n errorState = FileStatus_FileOverwriteError\nHere’s a GoTo . GoTo END_PROC\n End If\n if Not Erase( fileToPurge ) Then\n errorState = FileStatus_FileEraseError\nHere’s a GoTo . GoTo END_PROC\n End If\n End While\nHere’s the GoTo label. END_PROC:\n DeletePurgeFileList( fileList, numFilesToPurge )\nEnd Sub\nThis routine is typical of circumstances in which experienced programmers decide to \nuse a goto. Similar cases come up when a routine needs to allocate and clean up \nresources like database connections, memory, or temporary files. The alternative to \ngotos in those cases is usually duplicating code to clean up the resources. In such \ncases, a programmer might balance the evil of the goto against the headache of dupli-\ncate-code maintenance and decide that the goto is the lesser evil.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1236, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1237_4640f92e", "text": "In such \ncases, a programmer might balance the evil of the goto against the headache of dupli-\ncate-code maintenance and decide that the goto is the lesser evil. You can rewrite the previous routine in a couple of ways to avoid gotos, and both ways \ninvolve tradeoffs. The possible rewrite strategies follow:\nRewrite with nested if statements To rewrite with nested if statements, nest the if \nstatements so that each is executed only if the previous test succeeds. This is the stan-\ndard, textbook programming approach to eliminating gotos. Here’s a rewrite of the \nroutine using the standard approach:\nCross-Reference This rou-\ntine could also be rewritten \nwith break and no gotos. For \ndetails on that approach, see \n“Exiting Loops Early” in Sec-\ntion 16.2. Visual Basic Code That Avoids gotos by Using Nested ifs\n' This routine purges a group of files.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1237, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 857}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1238_bcc5c8c5", "text": "For \ndetails on that approach, see \n“Exiting Loops Early” in Sec-\ntion 16.2. Visual Basic Code That Avoids gotos by Using Nested ifs\n' This routine purges a group of files. Sub PurgeFiles( ByRef errorState As Error_Code )\n Dim fileIndex As Integer\n Dim fileToPurge As Data_File\n Dim fileList As File_List\n Dim numFilesToPurge As Integer\n MakePurgeFileList( fileList, numFilesToPurge )\n errorState = FileStatus_Success\n fileIndex = 0\nThe While test has been \nchanged to add a test for \nerrorState .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1238, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 497}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1239_3c163fee", "text": "While ( fileIndex < numFilesToPurge And errorState = FileStatus_Success ) \n \n fileIndex = fileIndex + 1\nC17619670.fm Page 402 Tuesday, April 12, 2011 3:01 PM\n17.3 goto 403\n If FindFile( fileList( fileIndex ), fileToPurge ) Then\n If OpenFile( fileToPurge ) Then\n If OverwriteFile( fileToPurge ) Then\n If Not Erase( fileToPurge ) Then\n errorState = FileStatus_FileEraseError\n End If\n Else ' couldn't overwrite file\n errorState = FileStatus_FileOverwriteError\n End If\n Else ' couldn't open file\n errorState = FileStatus_FileOpenError\n End If\n Else ' couldn't find file \nThis line is 13 lines away \nfrom the If statement that \ninvokes it. errorState = FileStatus_FileFindError\n End If\n End While \n DeletePurgeFileList( fileList, numFilesToPurge )\nEnd Sub\nFor people used to programming without gotos, this code might be easier to read than \nthe goto version, and if you use it, you won’t have to face an inquisition from the goto \ngoon squad.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1239, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1240_a2e021a8", "text": "Cross-Reference For more \ndetails on indentation and \nother coding layout issues, \nsee Chapter 31, “Layout and \nStyle.” For details on nesting \nlevels, see Section 19.4, \n“Taming Dangerously Deep \nNesting.”\nThe main disadvantage of this nested- if approach is that the nesting level is deep, very \ndeep. To understand the code, you have to keep the whole set of nested ifs in your \nmind at once. Moreover, the distance between the error-processing code and the code \nthat invokes it is too great: the code that sets errorState to FileStatus_FileFindError , for \nexample, is 13 lines from the if statement that invokes it. With the goto version, no statement is more than four lines from the condition that \ninvokes it. And you don’t have to keep the whole structure in your mind at once. You \ncan essentially ignore any preceding conditions that were successful and focus on the \nnext operation. In this case, the goto version is more readable and more maintainable \nthan the nested- if version.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1240, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 995}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1241_25e2983f", "text": "In this case, the goto version is more readable and more maintainable \nthan the nested- if version. Rewrite with a status variable To rewrite with a status variable (also called a state \nvariable), create a variable that indicates whether the routine is in an error state. In \nthis case, the routine already uses the errorState status variable, so you can use that. Visual Basic Code That Avoids gotos by Using a Status Variable\n' This routine purges a group of files. Sub PurgeFiles( ByRef errorState As Error_Code )\n Dim fileIndex As Integer\n Dim fileToPurge As Data_File\n Dim fileList As File_List\n Dim numFilesToPurge As Integer\n MakePurgeFileList( fileList, numFilesToPurge )\n errorState = FileStatus_Success\n fileIndex = 0\n17.3 goto\nC17619670.fm Page 403 Tuesday, April 12, 2011 3:02 PM\n404\nChapter 17: Unusual Control Structures\nThe While test has been \nchanged to add a test for \nerrorState .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1241, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 900}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1242_00367324", "text": "While ( fileIndex < numFilesToPurge ) And ( errorState = FileStatus_Success ) \n \n fileIndex = fileIndex + 1\n If Not FindFile( fileList( fileIndex ), fileToPurge ) Then\n errorState = FileStatus_FileFindError\n End If \nThe status variable is tested. If ( errorState = FileStatus_Success ) Then\n If Not OpenFile( fileToPurge ) Then\n errorState = FileStatus_FileOpenError\n End If \n End If\nThe status variable is tested. If ( errorState = FileStatus_Success ) Then\n If Not OverwriteFile( fileToPurge ) Then\n errorState = FileStatus_FileOverwriteError\n End If\n End If\nThe status variable is tested. If ( errorState = FileStatus_Success ) Then\n If Not Erase( fileToPurge ) Then\n errorState = FileStatus_FileEraseError\n End If \n End If \n End While \n DeletePurgeFileList( fileList, numFilesToPurge )\nEnd Sub\nThe advantage of the status-variable approach is that it avoids the deeply nested if-\nthen-else structures of the first rewrite and is thus easier to understand.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1242, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1243_8a09fecd", "text": "It also places \nthe action following the if-then-else test closer to the test than the nested- if approach \ndid, and it completely avoids else clauses. Understanding the nested- if version requires some mental gymnastics. The status-\nvariable version is easier to understand because it closely models the way people \nthink about the problem. You find the file. If everything is OK, you open the file. If \neverything is still OK, you overwrite the file. If everything is still OK... The disadvantage of this approach is that using status variables isn’t as common a \npractice as it should be. Document their use fully, or some programmers might not \nunderstand what you’re up to. In this example, the use of well-named enumerated \ntypes helps significantly. Rewrite with try-finally Some languages, including Visual Basic and Java, provide a \ntry-finally statement that can be used to clean up resources under error conditions.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1243, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 926}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1244_55c98a6b", "text": "Rewrite with try-finally Some languages, including Visual Basic and Java, provide a \ntry-finally statement that can be used to clean up resources under error conditions. To rewrite using the try-finally approach, enclose the code that would otherwise need \nto check for errors inside a try block, and place the cleanup code inside a finally block. The try block specifies the scope of the exception handling, and the finally block per-\nforms any resource cleanup. The finally block will always be called regardless of \nwhether an exception is thrown and regardless of whether the PurgeFiles() routine \nCatches any exception that’s thrown. C17619670.fm Page 404 Tuesday, April 12, 2011 3:03 PM\n17.3 goto 405\nVisual Basic Code That Avoids gotos by Using try-finally\n' This routine purges a group of files. Exceptions are passed to the caller.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1244, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 840}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1245_50ddc230", "text": "C17619670.fm Page 404 Tuesday, April 12, 2011 3:03 PM\n17.3 goto 405\nVisual Basic Code That Avoids gotos by Using try-finally\n' This routine purges a group of files. Exceptions are passed to the caller. Sub PurgeFiles()\n Dim fileIndex As Integer\n Dim fileToPurge As Data_File\n Dim fileList As File_List\n Dim numFilesToPurge As Integer\n MakePurgeFileList( fileList, numFilesToPurge )\n Try\n fileIndex = 0\n While ( fileIndex < numFilesToPurge ) \n fileIndex = fileIndex + 1\n FindFile( fileList( fileIndex ), fileToPurge )\n OpenFile( fileToPurge )\n OverwriteFile( fileToPurge )\n Erase( fileToPurge )\n End While\n Finally\n DeletePurgeFileList( fileList, numFilesToPurge )\n End Try\nEnd Sub\nThis approach assumes that all function calls throw exceptions for failures rather than \nreturning error codes. The advantage of the try-finally approach is that it is simpler than the goto approach \nand doesn’t use gotos . It also avoids the deeply nested if-then-else structures.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1245, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1246_9ac448ef", "text": "The advantage of the try-finally approach is that it is simpler than the goto approach \nand doesn’t use gotos . It also avoids the deeply nested if-then-else structures. The limitation of the try-finally approach is that it must be implemented consistently \nthroughout a code base. If the previous code were part of a code base that used error \ncodes in addition to exceptions, the exception code would be required to set error \ncodes for each possible error, and that requirement would make the code about as \ncomplicated as the other approaches. Comparison of the Approaches\nCross-Reference For a com-\nplete list of techniques that \ncan be applied to situations \nlike this, see “Summary of \nTechniques for Reducing \nDeep Nesting” in Section \n19.4. Each of the four methods has something to be said for it. The goto approach avoids \ndeep nesting and unnecessary tests but of course has gotos.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1246, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 893}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1247_19ac522a", "text": "Each of the four methods has something to be said for it. The goto approach avoids \ndeep nesting and unnecessary tests but of course has gotos. The nested- if approach \navoids gotos but is deeply nested and gives an exaggerated picture of the logical com-\nplexity of the routine. The status-variable approach avoids gotos and deep nesting but \nintroduces extra tests. And the try-finally approach avoids both gotos and deep nesting \nbut isn’t available in all languages. The try-finally approach is the most straightforward in languages that provide try-\nfinally and in code bases that haven’t already standardized on another approach. If \ntry-finally isn’t an option, the status-variable approach is slightly preferable to the goto \nand nested- if approaches because it’s more readable and it models the problem better, \nbut that doesn’t make it the best approach in all circumstances. Any of these techniques works well when applied consistently to all the code in a proj-\nect.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1247, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1248_49f531f2", "text": "Any of these techniques works well when applied consistently to all the code in a proj-\nect. Consider all the tradeoffs, and then make a projectwide decision about which \nmethod to favor. 17.3 goto\nC17619670.fm Page 405 Tuesday, April 12, 2011 3:03 PM\nD\nownload from Wow! eBook <www.wowebook.com>\n406\nChapter 17: Unusual Control Structures\ngotos and Sharing Code in an else Clause\nOne challenging situation in which some programmers would use a goto is the case in \nwhich you have two conditional tests and an else clause and you want to execute code \nin one of the conditions and in the else clause. Here’s an example of a case that could \ndrive someone to goto:\nC+ + Example of Sharing Code in an else Clause with a goto\nif ( statusOk ) {\n if ( dataAvailable ) {\n importantVariable = x;\n goto MID_LOOP;\n }\n}\nelse {\n importantVariable = GetValue();\n MID_LOOP:\n // lots of code\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1248, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 882}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1249_e94365f3", "text": "}\nThis is a good example because it’s logically tortuous—it’s nearly impossible to read it \nas it stands, and it’s hard to rewrite it correctly without a goto. If you think you can eas-\nily rewrite it without gotos, ask someone to review your code! Several expert program-\nmers have rewritten it incorrectly. You can rewrite the code in several ways. You can duplicate code, put the common code \ninto a routine and call it from two places, or retest the conditions. In most languages, the \nrewrite will be a tiny bit larger and slower than the original, but it will be extremely close. Unless the code is in a really hot loop, rewrite it without thinking about efficiency. The best rewrite would be to put the // lots of code part into its own routine. Then you can \ncall the routine from the places you would othe rwise have used as or igins or destinations \nof gotos and preserve the original structure of the conditional.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1249, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1250_55b5cd5f", "text": "Then you can \ncall the routine from the places you would othe rwise have used as or igins or destinations \nof gotos and preserve the original structure of the conditional. Here’s how it looks:\nC+ + Example of Sharing Code in an else Clause by Putting Common Code \ninto a Routine\nif ( statusOk ) {\n if ( dataAvailable ) {\n importantVariable = x;\n DoLotsOfCode( importantVariable );\n }\n}\nelse {\n importantVariable = GetValue();\n DoLotsOfCode( importantVariable );\n}\nCODING \nHORROR\n17.3 goto 407\nNormally, writing a new routine is the best approach. Sometimes, however, it’s not \npractical to put duplicated code into its own routine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1250, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 631}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1251_b43f87a8", "text": "Sometimes, however, it’s not \npractical to put duplicated code into its own routine. In this case, you can work \naround the impractical solution by restruct uring the conditional so that you keep the \ncode in the same routine rather than putting it into a new routine:\nC+ + Example of Sharing Code in an else Clause Without a goto\nif ( ( statusOk && dataAvailable ) || !statusOk ) {\n if ( statusOk && dataAvailable ) {\n importantVariable = x;\n }\n else {\n importantVariable = GetValue();\n }\n // lots of code\n ... }\nCross-Reference Another \napproach to this problem is \nto use a decision table. For \ndetails, see Chapter 18, \n“Table-Driven Methods. ”\nThis is a faithful and mechanical translation of the logic in the goto version. It tests statu-\nsOK two extra times and dataAvailable once, but the code is equivalent. If retesting the \nconditionals bothers you, notice that the value of statusOK doesn’t need to be tested \ntwice in the first if test.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1251, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 949}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1252_2b0e2029", "text": "If retesting the \nconditionals bothers you, notice that the value of statusOK doesn’t need to be tested \ntwice in the first if test. You can also drop the test for dataAvailable in the second if test. Summary of Guidelines for Using gotos\nUse of gotos is a matter of religion. My dogma is that in modern languages, you can \neasily replace nine out of ten gotos with equivalent sequential constructs. In these sim-\nple cases, you should replace gotos out of habit. In the hard cases, you can still exorcise \nthe goto in nine out of ten cases: You can break the code into smaller routines, use try-\nfinally , use nested ifs, test and retest a status variab le, or restructure a conditional. Eliminating the goto is harder in these cases, but it’s good mental exercise and the \ntechniques discussed in this section give you the tools to do it. In the remaining one case out of 100 in which a goto is a legitimate solution to the prob-\nlem, document it clearly and use it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1252, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 968}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1253_dac13a02", "text": "In the remaining one case out of 100 in which a goto is a legitimate solution to the prob-\nlem, document it clearly and use it. If you have your rain boots on, it’s not worth walking \naround the block to avoid a mud puddle. But keep your mind open to goto-less \napproaches suggested by other programmers. They might see something you don’t. Here’s a summary of guidelines for using gotos:\n■\nUse gotos to emulate structured control cons tructs in languages that don’t sup-\nport them directly. When you do, emulat e them exactly. Don’t abuse the extra \nflexibility the goto gives you. ■\nDon’t use the goto when an equivalent built-in construct is available. Cross-Reference For details \non improving efficiency, see \nChapter 25, “Code-Tuning \nStrategies,” and Chapter 26, \n“Code-Tuning Techniques.”■\nMeasure the performance of any goto used to improve efficiency. In most cases, \nyou can recode without gotos for improved readability and no loss in efficiency.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1253, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 958}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1254_c35121f1", "text": "In most cases, \nyou can recode without gotos for improved readability and no loss in efficiency. If your case is the exception, document the efficiency improvement so that goto-\nless evangelists won’t remove the goto when they see it. KEY POINT\n17.3 goto\n408\nChapter 17: Unusual Control Structures\n■\nLimit yourself to one goto label per routine unless you’re emulating structured \nconstructs. ■\nLimit yourself to gotos that go forward, not backward, unless you’re emulating \nstructured constructs. ■\nMake sure all goto labels are used. Unused labels might be an indication of missing \ncode, namely the code that goes to the labe ls. If the labels aren’t used, delete them. ■\nMake sure a goto doesn’t create unreachable code. ■\nIf you’re a manager, adopt the perspective that a battle over a single goto isn’t \nworth the loss of the war. If the programmer is aware of the alternatives and is \nwilling to argue, the goto is probably OK.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1254, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 934}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1255_8687a32c", "text": "If the programmer is aware of the alternatives and is \nwilling to argue, the goto is probably OK. 17.4 Perspective on Unusual Control Structures\nAt one time or another, someone thought that each of the following control structures \nwas a good idea:\n■\nUnrestricted use of gotos\n■\nAbility to compute a goto target dynamically and jump to the computed location\n■\nAbility to use goto to jump from the middle of one routine into the middle of \nanother routine\n■\nAbility to call a routine with a line number or label that allowed execution to \nbegin somewhere in the middle of the routine\n■\nAbility to have the program generate code on the fly and then execute the code \nit just wrote \nAt one time, each of these ideas was regarded as acceptable or even desirable, even \nthough now they all look hopelessly quaint, outdated, or dangerous. The field of soft-\nware development has advanced largely through restricting what programmers can do \nwith their code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1255, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1256_13ed5a1c", "text": "The field of soft-\nware development has advanced largely through restricting what programmers can do \nwith their code. Consequently, I view uncon ventional control structures with strong \nskepticism. I suspect that the majority of cons tructs in this chapter will eventually find \ntheir way onto the programmer’s scrap heap along with computed goto labels, variable \nroutine entry points, self-modifying code, an d other structures that favored flexibility \nand convenience over structure and the ability to manage complexity. Additional Resources\ncc2e.com/1792\nThe following resources also addr ess unusual control structures:\nReturns\nFowler, Martin. Refactoring: Improving the Design of Existing Code . Reading, MA: \nAddison-Wesley, 1999. In th e description of the refactoring called “Replace Nested \nConditional with Guard Clauses,” Fowler suggests using multiple return statements \nAdditional Resources 409\nfrom a routine to reduce nesting in a set of if statements.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1256, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 971}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1257_2aee0877", "text": "Fowler ar gues that multiple \nreturn s are an appropriate means of achieving gr eater clarity, and that no harm arises \nfrom having multiple returns from a routine. gotos\nThese articles contain the whole goto debate. It erupts from time to time in most work-\nplaces, textbooks, and magazines, but you won’t hear anything that wasn’t fully \nexplored 20 years ago. cc2e.com/1799\nDijkstra, Edsger. “Go To Statement Considered Harmful.” Communications of the ACM \n11, no. 3 (March 1968): 147–48, also available from www.cs.utexas.edu/users/EWD/ . This is the famous letter in which Dijkstra put the match to the paper and ignited one \nof the longest-running controversies in software development. Wulf, W. A. “A Case Against the GOTO.” Proceedings of the 25th National ACM Confer-\nence, August 1972: 791–97. This paper was another argument against the indiscrimi-\nnate use of gotos. Wulf argued that if programming languages provided adequate control \nstructures, gotos would become largely unnecessary.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1257, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1258_67fb6820", "text": "This paper was another argument against the indiscrimi-\nnate use of gotos. Wulf argued that if programming languages provided adequate control \nstructures, gotos would become largely unnecessary. Since 1972, when the paper was \nwritten, languages such as C++, Java, an d Visual Basic have proven Wulf correct. Knuth, Donald. “Structured Programming with go to Statements,” 1974. In Classics in \nSoftware Engineering , edited by Edward Yourdon. Englewood Cliffs, NJ: Yourdon Press, \n1979. This long paper isn’t entirely about gotos, but it includes a horde of code exam-\nples that are made more efficient by eliminating gotos and another horde of code \nexamples that are made more efficient by adding gotos. Rubin, Frank. “‘GOTO Considered Harmful’ Considered Harmful.” Communications \nof the ACM 30, no. 3 (March 1987): 195–96.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1258, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 827}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1259_4b3979bd", "text": "Rubin, Frank. “‘GOTO Considered Harmful’ Considered Harmful.” Communications \nof the ACM 30, no. 3 (March 1987): 195–96. In th is rather hotheaded letter to the edi-\ntor, Rubin asserts that goto-less programming has cost businesses “hundreds of mil-\nlions of dollars.” He then offers a short code fragment that uses a goto and argues that \nit’s superior to goto-less alternatives. The response that Rubin’s letter generated wa s more interesting than the letter itself. For five months, Communications of the ACM (CACM) published letters that offered \ndifferent versions of Rubin’s original seve n-line program. The letters were evenly \ndivided between those defending gotos and those castigating them. Readers suggested \nroughly 17 different rewrites, and the rewritten code fully covered the spectrum of \napproaches to avoiding gotos. The editor of CACM noted that the letter had generated \nmore response by far than any other issue ever considered in the pages of CACM .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1259, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1260_8b1fc7c9", "text": "The editor of CACM noted that the letter had generated \nmore response by far than any other issue ever considered in the pages of CACM . For the follow-up letters, see\n■\nCommunications of the ACM 30, no. 5 (May 1987): 351–55. ■\nCommunications of the ACM 30, no. 6 (June 1987): 475–78. ■\nCommunications of the ACM 30, no. 7 (July 1987): 632–34. 410\nChapter 17: Unusual Control Structures\n■\nCommunications of the ACM 30, no. 8 (August 1987): 659–62. ■\nCommunications of the ACM 30, no. 12 (December 1987): 997, 1085. cc2e.com/1706\nClark, R. Lawrence, “A Linguistic Co ntribution of GOTO-less Programming,” Datama-\ntion, December 1973. This classic paper humorously argues for replacing the “go to” \nstatement with the “come from” statement. It was also reprinted in the April 1974 edi-\ntion of Communications of the ACM . cc2e.com/1713\nCHECKLIST: Unusual Control Structures\nreturn\n❑\nDoes each routine use return only when necessary? ❑\nDo return s enhance readability?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1260, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1261_bedec694", "text": "cc2e.com/1713\nCHECKLIST: Unusual Control Structures\nreturn\n❑\nDoes each routine use return only when necessary? ❑\nDo return s enhance readability? Recursion\n❑\nDoes the recursive routine include code to stop the recursion? ❑\nDoes the routine use a safety counter to guarantee that the routine stops? ❑\nIs recursion limited to one routine? ❑\nIs the routine’s depth of recursion within the limits imposed by the size of \nthe program’s stack? ❑\nIs recursion the best way to implement the routine? Is it better than simple \niteration? goto\n❑\nAre gotos used only as a last resort, and then only to make code more read-\nable and maintainable? ❑\nIf a goto is used for the sake of efficiency, has the gain in efficiency been \nmeasured and documented? ❑\nAre gotos limited to one label per routine? ❑\nDo all gotos go forward, not backward? ❑\nAre all goto labels used? Key Points\n■\nMultiple return s can enhance a routine’s readability and maintainability, and they \nhelp prevent deeply nested logic.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1261, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1262_62899bbd", "text": "❑\nDo all gotos go forward, not backward? ❑\nAre all goto labels used? Key Points\n■\nMultiple return s can enhance a routine’s readability and maintainability, and they \nhelp prevent deeply nested logic. They should, nevertheless, be used carefully. ■\nRecursion provides elegant solutions to a small set of problems. Use it carefully, too. ■\nIn a few cases, gotos are the best way to write code that’s readable and maintain-\nable. Such cases are rare. Use gotos only as a last resort.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1262, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 481}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1263_bbcdca5c", "text": "Use it carefully, too. ■\nIn a few cases, gotos are the best way to write code that’s readable and maintain-\nable. Such cases are rare. Use gotos only as a last resort. 411\nChapter 18\nTable-Driven Methods\ncc2e.com/1865\nContents\n■\n18.1 General Considerations in Using Table-Driven Methods: page 411\n■\n18.2 Direct Access Tables: page 413\n■\n18.3 Indexed Access Tables: page 425\n■\n18.4 Stair-Step Access Tables: page 426\n■\n18.5 Other Examples of Table Lookups: page 429\nRelated Topics\n■\nInformation hiding: “Hide Secrets (Inf ormation Hiding)” in Section 5.3\n■\nClass design: Chapter 6\n■\nUsing decision tables to replace complicated logic: in Section 19.1\n■\nSubstitute table lookups for compli cated expressions: in Section 26.1\nA table-driven method is a scheme that allows you to look up information in a table \nrather than using logic statements ( if and case) to figure it out. Virtually anything you \ncan select with logic statements, you can sel ect with tables instead.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1263, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1264_31472d15", "text": "Virtually anything you \ncan select with logic statements, you can sel ect with tables instead. In simple cases, \nlogic statements are easier and more direct . As the logic chain becomes more complex, \ntables become increasingly attractive. If you’re already familiar with table-driven methods, this chapter might be just a \nreview. In that case, you might examine “Flexible-Message-Format Example” in Sec-\ntion 18.2 for a good example of how an ob ject-oriented design is n’t necessarily better \nthan any other kind of design just because it’s object-oriented, and then you might \nmove on to the discussion of gene ral control issues in Chapter 19. 18.1 General Considerations in Using Table-Driven Methods\nUsed in appropriate circumstances, table-driven code is simpler than complicated \nlogic, easier to modify, and more efficient.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1264, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 833}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1265_592ca99c", "text": "18.1 General Considerations in Using Table-Driven Methods\nUsed in appropriate circumstances, table-driven code is simpler than complicated \nlogic, easier to modify, and more efficient. Suppose you wanted to classify characters \ninto letters, punctuation marks, and digits; you might use a compli cated chain of logic \nlike this one: \nKEY POINT\n412\nChapter 18: Table-Driven Methods\nJava Example of Using Complicated Logic to Classify a Character\nif ( ( ( 'a' <= inputChar ) && ( inputChar <= 'z' ) ) ||\n ( ( 'A' <= inputChar ) && ( inputChar <= 'Z' ) ) ) {\n charType = CharacterType.Letter;\n} \nelse if ( ( inputChar == ' ' ) || ( inputChar == ',' ) ||\n ( inputChar == '.' ) || ( inputChar == '!' ) || ( inputChar == '(' ) ||\n ( inputChar == ')' ) || ( inputChar == ':' ) || ( inputChar == ';' ) ||\n ( inputChar == '?' ) || ( inputChar == '-' ) ) {\n charType = CharacterType.Punctuation;\n}\nelse if ( ( '0' <= inputChar ) && ( inputChar <= '9' ) ) {\n charType = CharacterType.Digit;\n}\nIf you used a lookup table instead, you’d store the type of each character in an array \nthat’s accessed by character code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1265, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1104}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1266_bca748f0", "text": "The complicated code fragment just shown would \nbe replaced by this:\nJava Example of Using a Lookup Table to Classify a Character \ncharType = charTypeTable[ inputChar ];\nThis fragment assumes that the charTypeTable array has been set up earlier. You put \nyour program’s knowledge into its data rather than into its logic—in the table instead \nof in the if tests. Two Issues in Using Table-Driven Methods\nWhen you use table-driven methods, you have to address two issues. First you have to \naddress the question of how to look up entrie s in the table. You can use some data to \naccess a table directly. If you need to classify data by month, for example, keying into \na month table is straightforward. You can use an array with indexes 1 through 12. Other data is too awkward to be used to l ook up a table entry directly.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1266, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 822}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1267_2857b9e9", "text": "You can use an array with indexes 1 through 12. Other data is too awkward to be used to l ook up a table entry directly. If you need to \nclassify data by Social Secu rity Number, for example, you can’t use the Social Security \nNumber to key into the table directly unl ess you can afford to store 999-99-9999 \nentries in your table. You’re forced to use a more complicated approach. Here’s a list of \nways to look up an entry in a table:\n■\nDirect access\n■\nIndexed access \n■\nStair-step access \nEach of these kinds of accesses is described in more detail in subsections later in this \nchapter. KEY POINT\n18.2 Direct Access Tables 413\nThe second issue you have to address if yo u’re using a table-driven method is what \nyou should store in the table. In some cases, the result of a table lookup is data. If \nthat’s the case, you can store the data in the table. In other cases, the result of a table \nlookup is an action.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1267, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1268_8393cc48", "text": "In some cases, the result of a table lookup is data. If \nthat’s the case, you can store the data in the table. In other cases, the result of a table \nlookup is an action. In such a case, you can store a code that describes the action or, \nin some languages, you can store a reference to the routine that implements the action. In either of these cases, tables become more complicated. 18.2 Direct Access Tables\nLike all lookup tables, direct-access tables replace more complicated logical control \nstructures. They are “direct access” because you don’t have to jump through any com-\nplicated hoops to find the information you want in the table. As Figure 18-1 suggests, \nyou can pick out the entry you want directly. Figure 18-1 As the name suggests, a direct-access ta ble allows you to access the table ele-\nment you’re interested in directly. Days-in-Month Example\nSuppose you need to determine the number of days per month (forgetting about leap \nyear, for the sake of argument).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1268, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1269_ba9803e2", "text": "Days-in-Month Example\nSuppose you need to determine the number of days per month (forgetting about leap \nyear, for the sake of argument). A clumsy wa y to do it, of course, is to write a large if \nstatement:\nVisual Basic Example of a Clumsy Way to Determine the Number of Days in a Month\nIf ( month = 1 ) Then\n days = 31\nElseIf ( month = 2 ) Then\n days = 28\nElseIf ( month = 3 ) Then\n days = 31\nElseIf ( month = 4 ) Then\n days = 30\nElseIf ( month = 5 ) Then\n days = 31\nElseIf ( month = 6 ) Then\n days = 30\nElseIf ( month = 7 ) Then\n days = 31\nKEY POINT\n(age, year)\nLookup Table\n414\nChapter 18: Table-Driven Methods\nElseIf ( month = 8 ) Then\n days = 31\nElseIf ( month = 9 ) Then\n days = 30\nElseIf ( month = 10 ) Then\n days = 31\nElseIf ( month = 11 ) Then\n days = 30\nElseIf ( month = 12 ) Then\n days = 31\nEnd If \nAn easier and more modifiable way to perform the same function is to put the data in \na table.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1269, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 905}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1270_6a8dbf94", "text": "In Microsoft Visual Basic, you’d first set up the table:\nVisual Basic Example of an Elegant Way to Determine the Number of Days in a \nMonth\n' Initialize Table of \"Days Per Month\" Data\nDim daysPerMonth() As Integer = _\n { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }\nNow, instead of using the long if statement, you can just use a simple array access to \nfind out the number of days in a month:\nVisual Basic Example of an Elegant Way to Determine the Number of Days in a \nMonth (continued)\ndays = daysPerMonth( month-1 )\nIf you wanted to account for leap year in the table-lookup version, the code would still \nbe simple, assuming LeapYearIndex() has a value of either 0 or 1:\nVisual Basic Example of an Elegant Way to Determine the Number of Days in a \nMonth (continued)\ndays = daysPerMonth( month-1, LeapYearIndex() )\nIn the if-statement version, the long string of ifs would grow even more complicated if \nleap year were considered.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1270, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1271_a9d7c70a", "text": "Determining the number of days per month is a convenient example because you can \nuse the month variable to look up an entry in the table. You can often use the data that \nwould have controlled a lot of if statements to access a table directly. 18.2 Direct Access Tables 415\nInsurance Rates Example\nSuppose you’re writing a program to compute medical insurance rates and you have \nrates that vary by age, gender, marital stat us, and whether a person smokes. If you had \nto write a logical control structure for the rates, you’d get something like this:\nJava Example of a Clumsy Way to Determine an Insurance Rate\nif ( gender == Gender.Female ) {\n if ( maritalStatus == MaritalStatus.Single ) {\n if ( smokingStatus == SmokingStatus.NonSmoking ) {\n if ( age < 18 ) {\n rate = 200.00;\n }\n else if ( age == 18 ) {\n rate = 250.00;\n }\n else if ( age == 19 ) {\n rate = 300.00;\n }\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1271, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 877}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1272_0be5247c", "text": "else if ( 65 < age ) {\n rate = 450.00;\n }\n else { \n if ( age < 18 ) {\n rate = 250.00;\n }\n else if ( age == 18 ) {\n rate = 300.00;\n }\n else if ( age == 19 ) {\n rate = 350.00;\n }\n ... else if ( 65 < age ) {\n rate = 575.00;\n }\n }\n else if ( maritalStatus == MaritalStatus.Married )\n ... } \nThe abbreviated version of the logic structure should be enough to give you an idea of \nhow complicated this kind of thing can get. It doesn’t show married females, any \nmales, or most of the ages between 18 and 65. You can imagine how complicated it \nwould get when you programmed the whole rate table. You might say, “Yeah, but why did you do a test for each age? Why don’t you just put \nthe rates in arrays for each age?” That’s a good question, and one obvious improve-\nment would be to put the rates into separate arrays for each age. CODING \nHORROR\n416\nChapter 18: Table-Driven Methods\nA better solution, however, is to put the rates into arrays for all the factors, not just age.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1272, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 973}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1273_39c7a7a0", "text": "CODING \nHORROR\n416\nChapter 18: Table-Driven Methods\nA better solution, however, is to put the rates into arrays for all the factors, not just age. Here’s how you would declare the array in Visual Basic: \nVisual Basic Example of Declaring Data to Set Up an Insurance Rates Table\nPublic Enum SmokingStatus\n SmokingStatus_First = 0\n SmokingStatus_Smoking = 0\n SmokingStatus_NonSmoking = 1\n SmokingStatus_Last = 1\nEnd Enum\nPublic Enum Gender\n Gender_First = 0\n Gender_Male = 0\n Gender_Female = 1\n Gender_Last = 1\nEnd Enum\nPublic Enum MaritalStatus\n MaritalStatus_First = 0\n MaritalStatus_Single = 0\n MaritalStatus_Married = 1\n MaritalStatus_Last = 1\nEnd Enum\nConst MAX_AGE As Integer = 125\nDim rateTable ( SmokingStatus_Last, Gender_Last, MaritalStatus_Last, _\n MAX_AGE ) As Double\nCross-Reference One \nadvantage of a table-driven \napproach is that you can put \nthe table’s data in a file and \nread it at run time.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1273, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 910}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1274_5209b566", "text": "That \nallows you to change some-\nthing like an insurance rates \ntable without changing the \nprogram itself. For more on \nthe idea, see Section 10.6, \n“Binding Time.”\nOnce you declare the array, you have to figure out some way of putting data into it. You can use assignment statements, read the data from a disk file, compute the data, \nor do whatever is appropriate. After you’ve set up the data, you’ve got it made when \nyou need to calculate a rate. The complicate d logic shown earlier is replaced with a \nsimple statement like this one:\nVisual Basic Example of an Elegant Way to Determine an Insurance Rate \nrate = rateTable( smokingStatus, gender, maritalStatus, age )\nThis approach has the general advantages of replacing complicated logic with a table \nlookup. The table lookup is more readable and easier to change. Flexible-Message-Format Example\nYou can use a table to describe logic that’s too dynamic to represent in code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1274, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 935}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1275_f74d0b28", "text": "The table lookup is more readable and easier to change. Flexible-Message-Format Example\nYou can use a table to describe logic that’s too dynamic to represent in code. With the \ncharacter-classification example, the days -in-the-month example, and the insurance \nrates example, you at least knew that you could write a long string of if statements if \n18.2 Direct Access Tables 417\nyou needed to. In some cases, however, the data is too complicated to describe with \nhard-coded if statements. If you think you’ve got the idea of how direct-access tables work, you might want to \nskip the next example. It’s a little more complicated than the earlier examples, \nthough, and it further demonstrates the power of table-driven approaches. Suppose you’re writing a routine to print me ssages that are stored in a file. The file \nusually has about 500 messages, and each fi le has about 20 kinds of messages. The \nmessages originally come from a buoy and give water temperature, the buoy’s loca-\ntion, and so on.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1275, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1276_34d4ace7", "text": "The file \nusually has about 500 messages, and each fi le has about 20 kinds of messages. The \nmessages originally come from a buoy and give water temperature, the buoy’s loca-\ntion, and so on. Each of the messages has several fields, and ea ch message starts with a header that has \nan ID to let you know which of the 20 or so kinds of messages you’re dealing with. Fig-\nure 18-2 illustrates how the messages are stored. Figure 18-2 Messages are stored in no particular or der, and each one is identified with a \nmessage ID. The format of the messages is volatile, determined by your customer, and you don’t \nhave enough control over your customer to stabilize it. Figure 18-3 shows what a few \nof the messages look like in detail. ID for Buoy\nTemperature Message\nMessage Contents\nID for Buoy\nDrift Message\nMessage Contents\nID for Buoy\nLocation Message\nMessage Contents\n418\nChapter 18: Table-Driven Methods\nFigure 18-3 Aside from the Message ID, each ki nd of message has its own format.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1276, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1277_32404a5d", "text": "Logic-Based Approach\nIf you used a logic-based approach, you’d probably read each message, check the ID, \nand then call a routine that’s designed to read, interpret, and print each kind of mes-\nsage. If you had 20 kinds of messages, you’ d have 20 routines. You’d also have who-\nknows-how-many lower-level routines to support them—for example, you’d have a \nPrintBuoyTemperatureMessage() routine to print the buoy temperature message. An \nobject-oriented approach wouldn’t be much better: you’d typically use an abstract \nmessage object with a subclass for each message type. Each time the format of any message changed, you’d have to change the logic in the \nroutine or class responsible for that message . In the detailed message earlier, if the \naverage-temperature field changed from a floating point to something else, you’d have \nto change the logic of PrintBuoyTemperatureMessage() .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1277, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 890}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1278_6874b0dd", "text": "In the detailed message earlier, if the \naverage-temperature field changed from a floating point to something else, you’d have \nto change the logic of PrintBuoyTemperatureMessage() . (If the buoy itself changed from \na “floating point” to something else, you’d have to get a new buoy!)\nIn the logic-based approach, the message-reading routine consists of a loop to read \neach message, decode the ID, and then call one of 20 routines based on the message \nID. Here’s the pseudocode fo r the logic-based approach:\nCross-Reference This low-\nlevel pseudocode is used for \na different purpose than the \npseudocode you use for rou-\ntine design. For details on \ndesigning in pseudocode, \nsee Chapter 9, “The \nPseudocode Programming \nProcess.”\nWhile more messages to read\n Read a message header\n Decode the message ID from the message header\n If the message header is type 1 then\n Print a type 1 message\n Else if the message header is type 2 then\n Print a type 2 message\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1278, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 967}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1279_07f2e985", "text": "Else if the message header is type 19 then\n Print a type 19 message\n Else if the message header is type 20 then\n Print a type 20 message\nID for Buoy\nTemperature Message\nAverage Temperature\n(floating point)\nTemperature Range\n(floating point)\nNumber of Samples \n(integer)\nLocation \n(character string)\nTime of Measurement \n(time of day)\nID for Buoy\nDrift Message\nChange in Latitude \n(floating point)\nChange in Longitude\n(floating point)\nTime of Measurement \n(time of day)\nID for Buoy\nLocation Message\nLatitude\n(floating point)\nLongitude \n(floating point)\nDepth \n(integer)\nTime of Measurement \n(time of day)\n18.2 Direct Access Tables 419\nThe pseudocode is abbreviated because you ca n get the idea without seeing all 20 cases.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1279, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 722}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1280_79a3fd33", "text": "Object-Oriented Approach\nIf you were using a rote object-oriented a pproach, the logic would be hidden in the \nobject inheritance structure but the basic structure would be just as complicated: \nWhile more messages to read\n Read a message header\n Decode the message ID from the message header\n If the message header is type 1 then\n Instantiate a type 1 message object\n Else if the message header is type 2 then\n Instantiate a type 2 message object\n ... Else if the message header is type 19 then\n Instantiate a type 19 message object\n Else if the message header is type 20 then\n Instantiate a type 20 message object\n End if\nEnd While\nRegardless of whether the logic is written directly or contained within specialized \nclasses, each of the 20 kinds of messages will have its own routine for printing its mes-\nsage. Each routine could also be expressed in pseudocode.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1280, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 866}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1281_3bd5eb39", "text": "Each routine could also be expressed in pseudocode. This is the pseudocode for \nthe routine to read and print the buoy temperature message:\nPrint \"Buoy Temperature Message\"\nRead a floating-point value\nPrint \"Average Temperature\"\nPrint the floating-point value\nRead a floating-point value\nPrint \"Temperature Range\"\nPrint the floating-point value\nRead an integer value\nPrint \"Number of Samples\"\nPrint the integer value\nRead a character string\nPrint \"Location\"\nPrint the character string\nRead a time of day\nPrint \"Time of Measurement\"\nPrint the time of day\nThis is the code for just one kind of messa ge. Each of the other 19 kinds of messages \nwould require similar code. And if a 21st kind of message was added, either a 21st rou-\ntine or a 21st subclass would need to be added—either way a new message type would \nrequire the code to be changed. 420\nChapter 18: Table-Driven Methods\nTable-Driven Approach\nThe table-driven approach is more econom ical than the previous approach.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1281, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1282_84cbae72", "text": "420\nChapter 18: Table-Driven Methods\nTable-Driven Approach\nThe table-driven approach is more econom ical than the previous approach. The mes-\nsage-reading routine consists of a loop th at reads each message header, decodes the \nID, looks up the message description in the Message array, and then calls the same \nroutine every time to decode the message . With a table-driven approach, you can \ndescribe the format of each message in a table rather than hard-coding it in program \nlogic. This makes it easier to code origina lly, generates less code, and makes it easier to \nmaintain without changing code. To use this approach, you start by listing the kinds of messages and the types of fields.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1282, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 695}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1283_c2733ad0", "text": "To use this approach, you start by listing the kinds of messages and the types of fields. In C++, you could define the types of all the possible fields this way:\nC+ + Example of Defining Message Data Types \nenum FieldType { \n FieldType_FloatingPoint, \n FieldType_Integer,\n FieldType_String,\n FieldType_TimeOfDay, \n FieldType_Boolean, \n FieldType_BitField,\n FieldType_Last = FieldType_BitField\n};\nRather than hard-coding printing routines for each of the 20 kinds of messages, you \ncan create a handful of routines that prin t each of the primary data types—floating \npoint, integer, character string, and so on. You can describe the contents of each kind \nof message in a table (including the name of each field) and then decode each mes-\nsage based on the description in the table.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1283, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 782}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1284_3ff8a6f1", "text": "You can describe the contents of each kind \nof message in a table (including the name of each field) and then decode each mes-\nsage based on the description in the table. A table entry to describe one kind of mes-\nsage might look like this:\nExample of Defining a Message Table Entry\nMessage Begin\n NumFields 5\n MessageName \"Buoy Temperature Message\"\n Field 1, FloatingPoint, \"Average Temperature\"\n Field 2, FloatingPoint, \"Temperature Range\"\n Field 3, Integer, \"Number of Samples\"\n Field 4, String, \"Location\"\n Field 5, TimeOfDay, \"Time of Measurement\"\nMessage End\nThis table could be hard-coded in the prog ram (in which case, each of the elements \nshown would be assigned to variables), or it could be read from a file at program star-\ntup time or later. Once message definitions are read into the program, instead of having all the informa-\ntion embedded in a program’s logic, you have it embedded in data. Data tends to be \n18.2 Direct Access Tables 421\nmore flexible than logic.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1284, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 983}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1285_bb891010", "text": "Data tends to be \n18.2 Direct Access Tables 421\nmore flexible than logic. Data is easy to change when a message format changes. If you \nhave to add a new kind of message, you can just add another element to the data table. Here’s the pseudocode for the top-level loop in the table-driven approach:\nThe first three lines here \nare the same as in the \nlogic-based approach. While more messages to read\n Read a message header\n Decode the message ID from the message header\n Look up the message description in the message-description table\n Read the message fields and print them based on the message description\nEnd While\nUnlike the pseudocode for the logic-based a pproach, the pseudocode in this case isn’t \nabbreviated because the logic is so much less complicated. In the logic below this \nlevel, you’ll find one routine that’s capable of interpreting a message description from \nthe message description table, reading me ssage data, and printing a message.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1285, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 958}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1286_4baff8d7", "text": "In the logic below this \nlevel, you’ll find one routine that’s capable of interpreting a message description from \nthe message description table, reading me ssage data, and printing a message. That \nroutine is more general than any of the logic-based message-printing routines but not \nmuch more complicated, and it will be one routine instead of 20:\nWhile more fields to print\n Get the field type from the message description\n case ( field type )\n of ( floating point )\n read a floating-point value\n print the field label\n print the floating-point value\n of ( integer )\n read an integer value\n print the field label\n print the integer value\n of ( character string )\n read a character string\n print the field label\n print the character string\n of ( time of day )\n read a time of day\n print the field label\n print the time of day\n of ( boolean )\n read a single flag\n print the field label\n print the single flag\n of ( bit field )\n read a bit field\n print the field label\n print the bit field\n End Case\nEnd While\n422\nChapter 18: Table-Driven Methods\nAdmittedly, this routine with its six cases is longer than the single routine needed to \nprint the buoy temperature message.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1286, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1172}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1287_7462d721", "text": "But this is the only routine you need. You don’t \nneed 19 other routines for the 19 other kinds of messages. This routine handles the \nsix field types and takes care of all the kinds of messages. This routine also shows the most complicated way of implementing this kind of table \nlookup because it uses a case statement. Another approach would be to create an \nabstract class AbstractField and then create subclasses for each field type. You won’t need \na case statement; you can call the member routine of the appropriate type of object. Here’s how you would set up the object types in C++:\nC+ + Example of Setting Up Object Types\nclass AbstractField {\n public:\n virtual void ReadAndPrint( string, FileStatus & ) = 0;\n};\nclass FloatingPointField : public AbstractField {\n public:\n virtual void ReadAndPrint( string, FileStatus & ) {\n ... }\n};\nclass IntegerField ... class StringField ... ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1287, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 893}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1288_f93de1d3", "text": "}\n};\nclass IntegerField ... class StringField ... ... This code fragment declares a member routine for each class that has a string param-\neter and a FileStatus parameter. The next step is to declare an array to hold the set of objects.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1288, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 236}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1289_123d53aa", "text": "... This code fragment declares a member routine for each class that has a string param-\neter and a FileStatus parameter. The next step is to declare an array to hold the set of objects. The array is the lookup \ntable, and here’s how it looks:\nC+ + Example of Setting Up a T able to\n \nHold an Object of Each Type\nAbstractField* field[ Field_Last+1];\nThe final step required to set up the table of objects is to assign the names of specific \nobjects to the Field array:\nC+ + Example of Setting Up a List of Objects\nfield[ Field_FloatingPoint ] = new FloatingPointField();\nfield[ Field_Integer ] = new IntegerField();\nfield[ Field_String ] = new StringField();\nfield[ Field_TimeOfDay ] = new TimeOfDayField();\nfield[ Field_Boolean ] = new BooleanField();\nfield[ Field_BitField ] = new BitFieldField();\nC18619670.fm Page 422 Tuesday, April 12, 2011 5:37 PM\n18.2 Direct Access Tables 423\nThis code fragment assumes that FloatingPointField and the other identifiers on the \nright side of the assignment statements are names of objects of type AbstractField .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1289, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1053}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1290_884e7ea4", "text": "Assigning the objects to array elements in the array means that you can call the cor-\nrect ReadAndPrint() routine by referencing an array element instead of by using a spe-\ncific kind of object directly. Once the table of routines is set up, you can handle a field in the message simply by \naccessing the table of objects and calling one of the member routines in the table. The \ncode looks like this:\nC+ + Example of Looking Up Objects and Member Routines in a T able\nThis stuff is just house-\nkeeping for each field in \na message. fieldIdx = 1;\nwhile ( ( fieldIdx <= numFieldsInMessage ) && ( fileStatus == OK ) ) {\n fieldType = fieldDescription[ fieldIdx ].FieldType; \n fieldName = fieldDescription[ fieldIdx ].FieldName;\nThis is the table lookup that \ncalls a routine depending \non the type of the field—\njust by looking it up in a \ntable of objects.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1290, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 854}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1291_05a3bc78", "text": "field[ fieldType ].ReadAndPrint( fieldName, fileStatus );\n fieldIdx++;\n}\nRemember the original 34 lines of table-lookup pseudocode containing the case state-\nment? If you replace the case statement with a table of objects, this is all the code you’d \nneed to provide the same functionality. Incredibly, it’s also all the code needed to \nreplace all 20 of the individual routines in the logic-based approach. Moreover, if the \nmessage descriptions are read from a file, new message types won’t require code \nchanges unless there’s a new field type. You can use this approach in any object-oriented language. It’s less error-prone, more \nmaintainable, and more efficient than lengthy if statements, case statements, or copi-\nous subclasses. The fact that a design uses inheritance and polymorphism doesn’t make it a good \ndesign. The rote object-oriented design described earlier in the “Object-Oriented \nApproach” section would require as much code as a rote functional design—or more.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1291, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 984}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1292_d70651d0", "text": "The rote object-oriented design described earlier in the “Object-Oriented \nApproach” section would require as much code as a rote functional design—or more. That approach made the solution space more complicated, rather than less. The key \ndesign insight in this case is neither object orientation nor functional orientation—it’s \nthe use of a well thought out lookup table. Fudging Lookup Keys\nIn each of the three previous examples, you could use the data to key into the table \ndirectly. That is, you could use messageID as a key without alteration, as you could use \nmonth in the days-per-month example and gender , maritalStatus , and smokingStatus in \nthe insurance rates example. You’d always like to key into a table directly because it’s simple and fast. Sometimes, \nhowever, the data isn’t cooperative. In the insurance rates example, age wasn’t well \nbehaved.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1292, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 870}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1293_ebc33a21", "text": "You’d always like to key into a table directly because it’s simple and fast. Sometimes, \nhowever, the data isn’t cooperative. In the insurance rates example, age wasn’t well \nbehaved. The original logic had one rate for people under 18, individual rates for ages \nC18619670.fm Page 423 Tuesday, April 12, 2011 3:08 PM\n424\nChapter 18: Table-Driven Methods\n18 through 65, and one rate for people over 65. This meant that for ages 0 through 17 \nand 66 and over, you couldn’t use the age to key directly into a table that stored only \none set of rates for several ages. This leads to the topic of fudging table-lookup keys. You can fudge keys in several ways:\nDuplicate information to make the key work directly One straightforward way to \nmake age work as a key into the rates table is to duplicate the under-18 rates for each \nof the ages 0 through 17 and then use the age to key directly into the table. You can do \nthe same thing for ages 66 and over.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1293, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1294_e7f24d06", "text": "You can do \nthe same thing for ages 66 and over. The bene fits of this approach are that the table \nstructure itself is straightforward and the table accesses are also straightforward. If \nyou needed to add age-specific rates for ages 17 and below, you could just change the \ntable. The drawbacks are that the duplicat ion would waste space for redundant infor-\nmation and increase the possibi lity of errors in the tabl e—if only because the table \nwould contain redundant data. Transform the key to make it work directly A second way to make Age work as a \ndirect key is to apply a function to Age so that it works well. In this case, the function \nwould have to change all ages 0 through 17 to one key, say 17, and all ages above 66 to \nanother key, say 66. This particular range is well behaved enough that you could use \nmin() and max() functions to make the transformation. For example, you could use \nthe expression\nmax( min( 66, Age ), 17 )\nto create a table key that ranges from 17 to 66.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1294, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 997}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1295_273154db", "text": "For example, you could use \nthe expression\nmax( min( 66, Age ), 17 )\nto create a table key that ranges from 17 to 66. Creating the transformation function requ ires that you recognize a pattern in the \ndata you want to use as a key, and that ’s not always as simple as using the min() and \nmax() routines. Suppose that in this example the rates were for five-year age bands \ninstead of one-year bands. Unless you wanted to duplicate all your data five times, \nyou’d have to come up with a function that divided Age by 5 properly and used the \nmin() and max() routines. Isolate the key transformation in its own routine If you have to fudge data to make \nit work as a table key, put the operation that changes the data to a key into its own rou-\ntine. A routine eliminates the possibility of using different transformations in different \nplaces. It makes modifications easier when the transformation changes.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1295, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1296_c36f4edb", "text": "A routine eliminates the possibility of using different transformations in different \nplaces. It makes modifications easier when the transformation changes. A good name \nfor the routine, like KeyFromAge() , also clarifies and documents the purpose of the \nmathematical machinations. If your environment provides ready-made key transformations, use them. For exam-\nple, Java provides HashMap , which can be used to associate key/value pairs. 18.3 Indexed Access Tables 425\n18.3 Indexed Access Tables\nSometimes a simple mathematical transformation isn’t powerful enough to make the \njump from data like Age to a table key. Some such cases are suited to the use of an \nindexed access scheme. When you use indexes, you use the primary data to look up a key in an index table and \nthen you use the value from the index table to look up the main data you’re interested in. Suppose you run a warehouse and have an inventory of about 100 items.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1296, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1297_9ccdeebb", "text": "Suppose you run a warehouse and have an inventory of about 100 items. Suppose fur-\nther that each item has a four-digit part number that ranges from 0000 through 9999. In this case, if you want to use the part number to key directly into a table that \ndescribes some aspect of each item, you se t up an index array with 10,000 entries \n(from 0 through 9999). The array is empty except for the 100 entries that correspond \nto part numbers of the 100 items in your warehouse. As Figure 18-4 shows, those \nentries point to an item-description table that has far fewer than 10,000 entries. Figure 18-4 Rather than being accessed directly, an indexed access table is accessed via an \nintermediate index. Indexed access schemes offer two main advantag es. First, if each of the entries in the \nmain lookup table is large, it takes a lot less space to create an index array with a lot of \nwasted space than it does to create a main lookup table with a lot of wasted space.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1297, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1298_6ba189bd", "text": "For \nexample, suppose that the main table takes 100 bytes per entry and that the index \nA\nrray of Indexes into \nLookup Table \n(mostly empty)\nLookup Table \n(mostly full)\n426\nChapter 18: Table-Driven Methods\narray takes 2 bytes per entry. Suppose that the main table has 100 entries and that the \ndata used to access it has 10,000 possible va lues. In such a case, the choice is between \nhaving an index with 10,000 entries or a ma in data member with 10,000 entries. If \nyou use an index, your total memory use is 30,000 bytes. If you forgo the index struc-\nture and waste space in the main table, your total memory use is 1,000,000 bytes. The second advantage, even if you don’t save space by using an index, is that it’s some-\ntimes cheaper to manipulate entries in an index than entries in a main table.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1298, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 805}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1299_9bb00742", "text": "The second advantage, even if you don’t save space by using an index, is that it’s some-\ntimes cheaper to manipulate entries in an index than entries in a main table. For \nexample, if you have a table with employee names, hiring dates, and salaries, you can \ncreate one index that accesses the table by employee name, another that accesses the \ntable by hiring date, and a third that accesses the table by salary. A final advantage of an index-access scheme is the general table-lookup advantage of \nmaintainability. Data encoded in tables is easier to maintain than data embedded in \ncode. To maximize the flexibility, put the index-access code in its own routine and call \nthe routine when you need to get a table key from a part number. When it’s time to \nchange the table, you might decide to switch the index-accessing scheme or switch to \nanother table-lookup scheme altogether. The a ccess scheme will be easier to change if \nyou don’t spread index accesses throughout your program.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1299, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 989}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1300_2b5c1c3e", "text": "The a ccess scheme will be easier to change if \nyou don’t spread index accesses throughout your program. 18.4 Stair-Step Access Tables\nYet another kind of table access is the stai r-step method. This access method isn’t as \ndirect as an index structure, but it doesn’t waste as much data space. The general idea of stair-step structures, illu strated in Figure 18-5, is that entries in a \ntable are valid for ranges of data ra ther than for distinct data points. Figure 18-5 The stair-step approach categorizes ea ch entry by determining the level at \nwhich it hits a “staircase.” The “step” it hits determines its category. For example, if you’re writing a grading program, the “B” entry range might be from 75 \npercent to 90 percent.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1300, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 735}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1301_5dc431ae", "text": "For example, if you’re writing a grading program, the “B” entry range might be from 75 \npercent to 90 percent. Here’s a range of grades you might have to program someday:\n≥ 90.0% A\n< 90.0% B\n< 75.0% C\n< 65.0% D\n< 50.0% F\n18.4 Stair-Step Access Tables 427\nThis is an ugly range for a table lookup because you can’t use a simple data-transfor-\nmation function to key into the letters A through F. An index scheme would be awk-\nward because the numbers are floating po int. You might consider converting the \nfloating-point numbers to integers, and in this case that would be a valid design \noption, but for the sake of illustration, th is example will stick with floating point. To use the stair-step method, you put the upper end of each range into a table and \nthen write a loop to check a score against the upper end of each range. When you find \nthe point at which the score first exceeds the top of a range, you know what the grade \nis.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1301, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1302_9865d7f1", "text": "When you find \nthe point at which the score first exceeds the top of a range, you know what the grade \nis. With the stair-step technique, you have to be careful to handle the endpoints of the \nranges properly. Here’s the code in Visual Basic that assigns grades to a group of stu-\ndents based on this example:\nVisual Basic Example of a Stair-Step Table Lookup\n' set up data for grading table\nDim rangeLimit() As Double = { 50.0, 65.0, 75.0, 90.0, 100.0 }\nDim grade() As String = { \"F\", \"D\", \"C\", \"B\", \"A\" }\nmaxGradeLevel = grade.Length – 1\n...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1302, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 543}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1303_d19527e5", "text": "' assign a grade to a student based on the student's score\ngradeLevel = 0\nstudentGrade = \"A\"\nWhile ( ( studentGrade = \"A\" ) and ( gradeLevel < maxGradeLevel ) )\n If ( studentScore < rangeLimit( gradeLevel ) ) Then\n studentGrade = grade( gradeLevel )\n End If\n gradeLevel = gradeLevel + 1\nWend\nAlthough this is a simple example, you can easily generalize it to handle multiple stu-\ndents, multiple grading schemes (for example, different grades for different point lev-\nels on different assignments), an d changes in the grading scheme. The advantage of this approach over other ta ble-driven methods is that it works well \nwith irregular data. The grading example is simple in that, although grades are \nassigned at irregular intervals, the number s are “round,” ending with 5s and 0s. The \nstair-step approach is equally well suited to data that doesn’t end neatly with 5s and \n0s.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1303, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 881}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1304_d0c3238d", "text": "The \nstair-step approach is equally well suited to data that doesn’t end neatly with 5s and \n0s. You can use the stair-step approach in st atistics work for probability distributions \nwith numbers like this:\nProbability Insurance Claim Amount\n0.458747 $0.00\n0.547651 $254.32\n0.627764 $514.77\n0.776883 $747.82\n0.893211 $1,042.65\n428\nChapter 18: Table-Driven Methods\nUgly numbers like these defy any attempt to come up with a function to neatly trans-\nform them into table keys. The stair-step approach is the answer. This approach also enjoys the general advant ages of table-driven approaches: it’s flex-\nible and modifiable. If the grading ranges in the grading example were to change, the \nprogram could easily be adapted by modifying the entries in the RangeLimit array. You \ncould easily generalize the grade-assignment part of th e program so that it would \naccept a table of grades and corresponding cut-off scores.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1304, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1305_a324b35e", "text": "You \ncould easily generalize the grade-assignment part of th e program so that it would \naccept a table of grades and corresponding cut-off scores. The grade-assignment part \nof the program wouldn’t have to use scores expressed as percentages; it could use raw \npoints rather than percentages, and the program wouldn’t have to change much. Here are a few subtleties to consider as you use the stair-step technique: \nWatch the endpoints Make sure you’ve covered the case at the top end of each stair-\nstep range. Run the stair-step search so that it finds items that map to any range other \nthan the uppermost range, and then have the rest fall into the uppermost range. Sometimes this requires creating an artifici al value for the top of the uppermost range. Be careful about mistaking < for <=. Make su re that the loop terminates properly with \nvalues that fall into the top ranges and that the range boundaries are handled correctly.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1305, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 937}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1306_8e161045", "text": "Be careful about mistaking < for <=. Make su re that the loop terminates properly with \nvalues that fall into the top ranges and that the range boundaries are handled correctly. Consider using a binary search rather then a sequential search In the grading \nexample, the loop that assigns the grade se arches sequentially through the list of \ngrading limits. If you had a larger list, the cost of the sequential search might become \nprohibitive. If it does, you can replace it with a quasi-binary search. It’s a “quasi” \nbinary search because the point of most binary searches is to find a value. In this case, \nyou don’t expect to find the value; you expect to find the right category for the value. The binary-search algorithm must correctly determine where the value should go. Remember also to treat the endpoint as a special case.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1306, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 834}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1307_5b6919cb", "text": "The binary-search algorithm must correctly determine where the value should go. Remember also to treat the endpoint as a special case. Consider using indexed access inste ad of the stair-step technique An index-access \nscheme such as the ones described in Section 18.3 might be a good alternative to a stair-\nstep technique. The searching required in the stair-step method can add up, and if exe-\ncution speed is a concern, you might be willing to trade the space an extra index struc-\nture takes up for the time advantage you get with a more direct access method. Obviously, this alternative isn’t a good choi ce in all cases. In the grading example, you \ncould probably use it; if you had only 100 di screte percentage points, the memory cost \nof setting up an index array wouldn’t be pr ohibitive.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1307, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 800}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1308_755ee9f2", "text": "In the grading example, you \ncould probably use it; if you had only 100 di screte percentage points, the memory cost \nof setting up an index array wouldn’t be pr ohibitive. If, on the other hand, you had the \n0.957665 $5,887.55\n0.976544 $12,836.98\n0.987889 $27,234.12\n...Probability Insurance Claim Amount\n18.5 Other Examples of Table Lookups 429\nprobability data listed earlier, you couldn’t set up an indexing scheme because you \ncan’t key into entries with numbers like 0.458747 and 0.547651. Cross-Reference For more \non good approaches to \nchoosing design alternatives, \nsee Chapter 5, “Design in \nConstruction.”\nIn some cases, any of the several options mi ght work. The point of design is choosing \none of the several good options for your case. Don’t worry too much about choosing \nthe best one. As Butler Lampson, a distinguished engineer at Microsoft, says, it’s better \nto strive for a good solution and avoid disaster rather than trying to find the best solu-\ntion (Lampson 1984).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1308, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 992}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1309_4fd0cdbf", "text": "As Butler Lampson, a distinguished engineer at Microsoft, says, it’s better \nto strive for a good solution and avoid disaster rather than trying to find the best solu-\ntion (Lampson 1984). Put the stair-step table lookup into its own routine When you create a transforma-\ntion function that changes a value like StudentGrade into a table key, put it into its own \nroutine. 18.5 Other Examples of Table Lookups\nA few other examples of table lookups appear in other sections of the book. They’re \nused in the course of discussing other t echniques, and the contexts don’t emphasize \nthe table lookups per se. Here’s where you’ll find them:\n■\nLooking up rates in an insurance table: Section 16.3, “Creating Loops Easily—\nFrom the Inside Out”\n■\nUsing decision tables to replace compli cated logic: “Use decision tables to \nreplace complicated conditions” in Section 19.1.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1309, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 867}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1310_326c4e7a", "text": "■\nCost of memory paging during a table lookup: Section 25.3, “Kinds of Fat and \nMolasses”\n■\nCombinations of boolean values (A or B or C): “Substitute Table Lookups for \nComplicated Expressions” in Section 26.1\n■\nPrecomputing values in a loan repaymen t table: Section 26.4, “Expressions.”\ncc2e.com/1872\nCHECKLIST: Table-Driven Methods\n❑\nHave you considered table-driven methods as an alternative to compli-\ncated logic? ❑\nHave you considered table-driven methods as an alternative to compli-\ncated inheritance structures? ❑\nHave you considered storing the table’s data externally and reading it at \nrun time so that the data can be modified without changing code? ❑\nIf the table cannot be accessed directly via a straightforward array index \n(as in the age example), have you put the access-key calculation into a rou-\ntine rather than duplicating the index calculation in the code?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1310, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 882}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1311_19f7ff0d", "text": "430\nChapter 18: Table-Driven Methods\nKey Points\n■\nTables provide an alternative to complicated logic and inheritance structures. If \nyou find that you’re confused by a prog ram’s logic or inheritance tree, ask your-\nself whether you could simplify by using a lookup table. ■\nOne key consideration in using a table is deciding how to access the table. You \ncan access tables by using direct access, indexed access, or stair-step access. ■\nAnother key consideration in using a table is deciding what exactly to put into \nthe table.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1311, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 529}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1312_14f5ebc9", "text": "You \ncan access tables by using direct access, indexed access, or stair-step access. ■\nAnother key consideration in using a table is deciding what exactly to put into \nthe table. 431\nChapter 19\nGeneral Control Issues\ncc2e.com/1978\nContents\n■\n19.1 Boolean Expr essions: page 431\n■\n19.2 Compound Statements (Blocks): page 443\n■\n19.3 Null Statements: page 444\n■\n19.4 Taming Dangerously Deep Nesting: page 445\n■\n19.5 A Programming Foundation: Structured Programming: page 454\n■\n19.6 Control Structures and Complexity: page 456\nRelated Topics\n■\nStraight-line code: Chapter 14\n■\nCode with conditionals: Chapter 15\n■\nCode with loops: Chapter 16\n■\nUnusual control structures: Chapter 17\n■\nComplexity in software development: “Software’s Primary Technical Imperative: \nManaging Complexity” in Section 5.2\nNo discussion of control would be complete unless it went into several general issues \nthat crop up when you think about control constructs.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1312, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 936}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1313_3adc64fb", "text": "Most of the information in this \nchapter is detailed and pragmatic. If you’re reading for the theory of control structures \nrather than for the gritty details, concentrate on the historical perspective on struc-\ntured programming in Section 19.5 and on the relationships between control struc-\ntures in Section 19.6. 19.1 Boolean Expressions\nExcept for the simplest control structure, the one that calls for the execution of statements \nin sequence, all control structures depend on the evaluation of boolean expressions. Using true and false for Boolean Tests\nUse the identifiers true and false in boolean expressions rath er than using values like \n0 and 1. Most modern languages have a boolean data type and provide predefined \nidentifiers for true and false. They make it easy—they don’t even allow you to assign \n432\nChapter 19: General Control Issues\nvalues other than true or false to boolean variables.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1313, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 910}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1314_6948a16d", "text": "They make it easy—they don’t even allow you to assign \n432\nChapter 19: General Control Issues\nvalues other than true or false to boolean variables. Langua ges that don’t have a bool-\nean data type require you to have more di scipline to make boolean expressions read-\nable. Here’s an example of the problem:\nVisual Basic Examples of Using Am biguous Flags for Boolean Values\nDim printerError As Integer\nDim reportSelected As Integer\nDim summarySelected As Integer\n... If printerError = 0 Then InitializePrinter()\nIf printerError = 1 Then NotifyUserOfError()\nIf reportSelected = 1 Then PrintReport()\nIf summarySelected = 1 Then PrintSummary()\nIf printerError = 0 Then CleanupPrinter()\nIf using flags like 0 and 1 is common practice, what’s wrong with it? It’s not clear from \nreading the code whether the function calls are executed when the tests are true or \nwhen they’re false. Nothing in the code fragment itself tells you whether 1 represents \ntrue and 0 false or whether the opposite is true .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1314, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1315_dd5603ac", "text": "Nothing in the code fragment itself tells you whether 1 represents \ntrue and 0 false or whether the opposite is true . It’s not even clear that the values 1 and \n0 are being used to represent true and false. For example, in the If reportSelected = 1 line, \nthe 1 could easily represent the first report, a 2 the second, a 3 the third; nothing in the \ncode tells you that 1 represents either true or false. It’s also easy to write 0 when you \nmean 1 and vice versa. Use terms named true and false for tests with boolean expr essions. If your language \ndoesn’t support such terms directly, create them using preprocessor macros or global \nvariables. The previous code example is re written here using Microsoft Visual Basic’s \nbuilt-in True and False :\nGood, but Not Great Visual Basic Examples of Using True and False for Tests Instead \nof Numeric Values\nCross-Reference For an \neven better approach to \nmaking these same tests, \nsee the next code example.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1315, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 955}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1316_6b3b7927", "text": "Dim printerError As Boolean\nDim reportSelected As ReportType\nDim summarySelected As Boolean\n... If ( printerError = False ) Then InitializePrinter()\nIf ( printerError = True ) Then NotifyUserOfError()\nIf ( reportSelected = ReportType_First ) Then PrintReport()\nIf ( summarySelected = True ) Then PrintSummary()\nIf ( printerError = False ) Then CleanupPrinter()\nUse of the True and False constants makes the intent clearer. You don’t have to remem-\nber what 1 and 0 represent, and you won’t accidentally reverse them. Moreover, in the \nCODING \nHORROR\n19.1 Boolean Expressions 433\nrewritten code, it’s now clear that some of the 1s and 0s in the original Visual Basic \nexample weren’t being used as boolean flags. The If reportSelected = 1 line was not a \nboolean test at all; it tested whethe r the first report had been selected. This approach tells the reader that you’re making a boolean test.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1316, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 895}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1317_e92ae1ac", "text": "The If reportSelected = 1 line was not a \nboolean test at all; it tested whethe r the first report had been selected. This approach tells the reader that you’re making a boolean test. It’s also harder to \nwrite true when you mean false than it is to write 1 when you mean 0, and you avoid \nspreading the magic numbers 0 and 1 throughout your code. Here are some tips on \ndefining true and false in boolean tests:\nCompare boolean values to true and false implicitly You can write clearer tests by \ntreating the expressions as boolea n expressions. For example, write\nwhile ( not done ) ... while ( a > b ) ... rather than\nwhile ( done = false ) ... while ( (a > b) = true ) ... Using implicit comparisons reduces the numb er of terms that someone reading your \ncode has to keep in mind, and the resulting expressions read more like conversational \nEnglish.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1317, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 855}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1318_23f7e400", "text": "Using implicit comparisons reduces the numb er of terms that someone reading your \ncode has to keep in mind, and the resulting expressions read more like conversational \nEnglish. The previous exampl e could be rewritten with even better style like this:\nBetter Visual Basic Examples of Testing for True and False Implicitly\nDim printerError As Boolean\nDim reportSelected As ReportType\nDim summarySelected As Boolean\n... If ( Not printerError ) Then InitializePrinter()\nIf ( printerError ) Then NotifyUserOfError()\nIf ( reportSelected = ReportType_First ) Then PrintReport()\nIf ( summarySelected ) Then PrintSummary()\nIf ( Not printerError ) Then CleanupPrinter()\nCross-Reference For details, \nsee Section 12.5, “Boolean \nVariables.”\nIf your language doesn’t s upport boolean variables and you have to emulate them, you \nmight not be able to use this technique because emulations of true and false can’t \nalways be tested with statements like while ( not done ) .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1318, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 962}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1319_af524072", "text": "Making Complicated Expressions Simple\nYou can take several steps to si mplify complicated expressions:\nBreak complicated tests into partial tests with new boolean variables Rather than \ncreating a monstrous test with half a dozen terms, assign intermediate values to terms \nthat allow you to perform a simpler test. 434\nChapter 19: General Control Issues\nMove complicated expressi ons into boolean functions If a test is repeated often or \ndistracts from the main flow of the program, move the code for the test into a function \nand test the value of the function. For example, here’s a complicated test:\nVisual Basic Example of a Complicated Test\nIf ( ( document.AtEndOfStream ) And ( Not inputError ) ) And _\n ( ( MIN_LINES <= lineCount ) And ( lineCount <= MAX_LINES ) ) And _\n ( Not ErrorProcessing( ) ) Then\n ' do something or other\n ... End If\nThis is an ugly test to have to read through if you’re not interested in the test itself.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1319, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 939}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1320_727915c7", "text": "End If\nThis is an ugly test to have to read through if you’re not interested in the test itself. By \nputting it into a boolean function, you can isolate the test and allow the reader to for-\nget about it unless it’s important. Here’s how you could put the if test into a function:\nCross-Reference For details \non the technique of using \nintermediate variables to \nclarify a boolean test, see \n“Use boolean variables to \ndocument your program” in \nSection 12.5. Visual Basic Example of a Complicated T est Moved into a Boolean Function, with \nNew Intermediate Variables to Make the Test Clearer\nFunction DocumentIsValid( _\n ByRef documentToCheck As Document, _\n lineCount As Integer, _\n inputError As Boolean _\n ) As Boolean\n \n Dim allDataRead As Boolean\n Dim legalLineCount As Boolean\nIntermediate variables are \nintroduced here to clarify the \ntest on the final line, below.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1320, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 875}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1321_27fc116d", "text": "allDataRead = ( documentToCheck.AtEndOfStream ) And ( Not inputError )\n legalLineCount = ( MIN_LINES <= lineCount ) And ( lineCount <= MAX_LINES )\n DocumentIsValid = allDataRead And legalLineCount And ( Not ErrorProcessing() )\nEnd Function\nThis example assumes that ErrorProcessing() is a boolean function that indicates the \ncurrent processing status. Now, when you read through the main flow of the code, \nyou don’t have to read the complicated test:\nVisual Basic Example of the Main Flow of the Code Without the Complicated Test\nIf ( DocumentIsValid( document, lineCount, inputError ) ) Then\n ' do something or other\n ... End If \nIf you use the test only once, you might not think it’s worthwhile to put it into a rou-\ntine. But putting the test into a well-name d function improves readability and makes \nit easier for you to see what your code is doing, and that’s a sufficient reason to do it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1321, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 899}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1322_f0dd8beb", "text": "But putting the test into a well-name d function improves readability and makes \nit easier for you to see what your code is doing, and that’s a sufficient reason to do it. KEY POINT\n19.1 Boolean Expressions 435\nThe new function name introduces an abstraction into the program that documents \nthe purpose of the test in code . That’s even better than documenting the test with \ncomments because the code is more likely to be read than the comments and it’s \nmore likely to be kept up to date, too. Cross-Reference For details \non using tables as substi-\ntutes for complicated logic, \nsee Chapter 18, “Table-\nDriven Methods.”\nUse decision tables to replace complicated conditions Sometimes you have a compli-\ncated test involving several variables. It ca n be helpful to use a decision table to per-\nform the test rather than using ifs or cases. A decision-table lookup is easier to code \ninitially, having only a couple of lines of co de and no tricky control structures.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1322, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1323_219defa4", "text": "A decision-table lookup is easier to code \ninitially, having only a couple of lines of co de and no tricky control structures. This \nminimization of complexity minimizes the opportunity for mistakes. If your data \nchanges, you can change a decision table wi thout changing the code; you only need to \nupdate the contents of the data structure. Forming Boolean Expressions Positively\nI ain’t not no undummy. —Homer Simpson\nNot a few people don’t have not any trouble understanding a nonshort string of \nnonpositives—that is, most people have trouble understanding a lot of negatives. You can do several things to avoid complicated negative boolean expressions in \nyour programs:\nIn if statements, convert negatives to positives and flip-flop the code in the if and else \nclauses Here’s an example of a negatively expressed test:\nJava Example of a Confusing Negative Boolean Test\nHere’s the negative not. if ( !statusOK ) {\n // do something\n ... }\nelse {\n // do something else\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1323, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 979}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1324_79b16c18", "text": "if ( !statusOK ) {\n // do something\n ... }\nelse {\n // do something else\n ... }\nYou can change this to the foll owing positively expressed test:\nThe test in this line has \nbeen reversed. Java Example of a Clearer Positive Boolean Test\nif ( statusOK ) {\n // do something else\nThe code in this block has \nbeen switched... ... }\nelse {\n...with the code in this block. // do something\n ... }\n436\nChapter 19: General Control Issues\nCross-Reference The rec-\nommendation to frame \nboolean expressions posi-\ntively sometimes contradicts \nthe recommendation to \ncode the nominal case after \nthe if rather than the else. (See Section 15.1, “ if State-\nments.”) In such a case, you \nhave to think about the ben-\nefits of each approach and \ndecide which is better for \nyour situation. The second code fragment is logically the same as the first but is easier to read \nbecause the negative expression has been changed to a positive.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1324, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 918}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1325_6b50dacc", "text": "The second code fragment is logically the same as the first but is easier to read \nbecause the negative expression has been changed to a positive. Alternatively, you could choose a different variable name, one that would reverse the \ntruth value of the test. In th e example, you could replace statusOK with ErrorDetected , \nwhich would be true when statusOK was false. Apply DeMorgan’s Theorems to simplify boolean tests with negatives DeMorgan’s \nTheorems let you exploit the logical relationship between an expression and a version \nof the expression that means the same thing because it’s doubly negated. For exam-\nple, you might have a code fragment that contains the following test:\nJava Example of a Negative Test\nif ( !displayOK || !printerOK ) ... This is logically equivalent to the following:\nJava Example After Applying DeMorgan’s Theorems\nif ( !( displayOK && printerOK ) ) ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1325, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 890}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1326_523f5979", "text": "This is logically equivalent to the following:\nJava Example After Applying DeMorgan’s Theorems\nif ( !( displayOK && printerOK ) ) ... Here you don’t have to flip-flop if and else clauses; the expressions in the last two code \nfragments are logically equivalent. To apply DeMorgan’s Theorems to the logical oper-\nator and or the logical operator or and a pair of operands, you negate each of the oper-\nands, switch the ands and ors, and negate the entire expression. Table 19-1 \nsummarizes the possible transformations under DeMorgan’s Theorems. Table 19-1\nTransformations of Logical Expressions Under DeMorgan’s Theorems\nInitial Expression\nEquivalent Expression\nnot A and not B not ( A or B )\nnot A and B not ( A or not B )\nA and not B not ( not A or B )\nA and B not ( not A or not B )\nnot A or not B\n*\n* This is the expression used in the example.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1326, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 848}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1327_8ee2d120", "text": "not ( A and B )\nnot A or B not ( A and not B )\nA or not B not ( not A and B )\nA or B not ( not A and not B )\n19.1 Boolean Expressions 437\nUsing Parentheses to Clarify Boolean Expressions\nCross-Reference For an \nexample of using parenthe-\nses to clarify other kinds of \nexpressions, see “Parenthe-\nses” in Section 31.2. If you have a complicated bo olean expression, rather than relying on the language’s \nevaluation order, parenthesize to make yo ur meaning clear. Using parentheses makes \nless of a demand on your reader, who mi ght not understand the subtleties of how \nyour language evaluates boolean expressions. If you’re smart, you won’t depend on \nyour own or your reader’s in-depth memo rization of evaluation precedence—espe-\ncially when you have to switch among two or more languages. Using parentheses isn’t \nlike sending a telegram: you’re not charged for each character—the extra characters are \nfree.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1327, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 914}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1328_45db482a", "text": "Using parentheses isn’t \nlike sending a telegram: you’re not charged for each character—the extra characters are \nfree. Here’s an expression with too few parentheses:\nJava Example of an Expression Containing Too Few Parentheses\nif ( a < b == c == d ) ... This is a confusing expression to begin with , and it’s even more confusing because it’s \nnot clear whether the coder means to test ( a < b ) == ( c == d ) or ( ( a < b ) == c ) == d . The following version of the expression is still a little confusing, but the parentheses \nhelp:\nJava Example of an Expression Better Parenthesized\nif ( ( a < b ) == ( c == d ) ) ... In this case, the parentheses help readability and the program’s correctness—the com-\npiler wouldn’t have interpreted the first code fragment this way. When in doubt, \nparenthesize. Cross-Reference Many pro-\ngrammer-oriented text edi-\ntors have commands that \nmatch parentheses, brack-\nets, and braces. For details \non programming editors, see \n“Editing” in Section 30.2.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1328, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1329_7e8751c6", "text": "Cross-Reference Many pro-\ngrammer-oriented text edi-\ntors have commands that \nmatch parentheses, brack-\nets, and braces. For details \non programming editors, see \n“Editing” in Section 30.2. Use a simple counting technique to balance parentheses If you have trouble telling \nwhether parentheses balance, here’s a simple counting trick that helps. Start by saying \n“zero.” Move along the expression, left to right. When you encounter an opening \nparenthesis, say “one.” Each time you encounter another opening parenthesis, \nincrease the number you say. Each time you encounter a closing parenthesis, decrease \nthe number you say. If, at the end of the expression, you’re back to 0, your parentheses \nare balanced. Java Example of Balanced Parentheses\nRead this. if ( ( ( a < b ) == ( c == d ) ) && !done ) ... | | | | | | | |\nSay this. 0 1 2 3 2 3 2 1 0\n438\nChapter 19: General Control Issues\nIn this example, you ended with a 0, so the parentheses are balanced.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1329, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 960}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1330_534ce10e", "text": "if ( ( ( a < b ) == ( c == d ) ) && !done ) ... | | | | | | | |\nSay this. 0 1 2 3 2 3 2 1 0\n438\nChapter 19: General Control Issues\nIn this example, you ended with a 0, so the parentheses are balanced. In the next \nexample, the parentheses aren’t balanced:\nJava Example of Unbalanced Parentheses\nRead this. if ( ( a < b ) == ( c == d ) ) && !done ) ... | | | | | | |\nSay this. 0 1 2 1 2 1 0 -1\nThe 0 before you get to the last closing parenthesis is a tip-off that a parenthesis is \nmissing before that point. You shouldn’t get a 0 until the last parenthesis of the \nexpression. Fully parenthesize logical expressions Parentheses are cheap, and they aid readabil-\nity. Fully parenthesizing logical expression s as a matter of habit is good practice. Knowing How Boolean Expr essions Are Evaluated\nMany languages have an implied form of control that comes into play in the evalua-\ntion of boolean expressions.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1330, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 907}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1331_b6a190ad", "text": "Knowing How Boolean Expr essions Are Evaluated\nMany languages have an implied form of control that comes into play in the evalua-\ntion of boolean expressions. Compilers for some language s evaluate each term in a \nboolean expression before combining the te rms and evaluating the whole expression. Compilers for other languages have “short-c ircuit” or “lazy” ev aluation, evaluating \nonly the pieces necessary. This is particul arly significant when, depending on the \nresults of the first test, you might not want the second test to be executed. For exam-\nple, suppose you’re checking the elements of an array and you have the following test:\nPseudocode Example of an Erroneous Test\nwhile ( i < MAX_ELEMENTS and item[ i ] <> 0 ) ... If this whole expression is evaluated, you’ ll get an error on the last pass through the \nloop. The variable i equals maxElements , so the expression item[ i ] is equivalent to \nitem[ maxElements ] , which is an array-index error.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1331, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 965}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1332_ce09d057", "text": "The variable i equals maxElements , so the expression item[ i ] is equivalent to \nitem[ maxElements ] , which is an array-index error. You might argue that it doesn’t mat-\nter since you’re only looking at the value, not changing it. But it’s sloppy program-\nming practice and could confuse someone re ading the code. In many environments it \nwill also generate either a run-time error or a protection violation. In pseudocode, you could restructure the test so that the error doesn’t occur:\nPseudocode Example of a Correctly Restructured Test\nwhile ( i < MAX_ELEMENTS ) \n if ( item[ i ] <> 0 ) then\n ... This is correct because item[ i ] isn’t evaluated unless i is less than maxElements . 19.1 Boolean Expressions 439\nMany modern languages provide facilities that prevent this kind of error from hap-\npening in the first place. For example, C++ uses short-circuit evaluation: if the first \noperand of the and is false, the second isn’t evaluated because the whole expression \nwould be false anyway.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1332, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1333_30dc8826", "text": "For example, C++ uses short-circuit evaluation: if the first \noperand of the and is false, the second isn’t evaluated because the whole expression \nwould be false anyway. In other words, in C++ the only part of\nif ( SomethingFalse && SomeCondition ) ... that’s evaluated is SomethingFalse . Evaluation stops as soon as SomethingFalse is iden-\ntified as false. Evaluation is similarly short-circuited with the or operator. In C++ and Java, the only \npart of\nif ( somethingTrue || someCondition ) ... that is evaluated is somethingTrue . The evaluation stops as soon as somethingTrue is \nidentified as true because the expression is always true if any part of it is true. As a \nresult of this method of evaluation, the following statement is a fine, legal statement. Java Example of a Test That Works Because of Short-Circuit Evaluation\nif ( ( denominator != 0 ) && ( ( item / denominator ) > MIN_VALUE ) ) ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1333, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 908}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1334_76ce50b5", "text": "Java Example of a Test That Works Because of Short-Circuit Evaluation\nif ( ( denominator != 0 ) && ( ( item / denominator ) > MIN_VALUE ) ) ... If this full expression were evaluated when denominator equaled 0, the division in the \nsecond operand would produce a divide-by-zero error. But since the second part isn’t \nevaluated unless the first part is true, it is never evaluated when denominator equals 0, \nso no divide-by-zero error occurs. On the other hand, because the && (and) is evaluated left to right, the following log-\nically equivalent statement doesn’t work:\nJava Example of a Test That Shor t-Circuit Evaluation Doesn’t Rescue\nif ( ( ( item / denominator ) > MIN_VALUE ) && ( denominator != 0 ) ) ... In this case, item / denominator is evaluated before denominator != 0 . Consequently, \nthis code commits the divide-by-zero error. Java further complicates this picture by pr oviding “logical” operators.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1334, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 919}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1335_5f690b98", "text": "Consequently, \nthis code commits the divide-by-zero error. Java further complicates this picture by pr oviding “logical” operators. Java’s logical & \nand | operators guarantee that all terms will be fully evaluated regardless of whether \nthe truth or falsity of the expression could be determined without a full evaluation. In \nother words, in Java, this is safe:\nJava Example of a Test That Works Becau se of Short-Circuit (Conditional) Evaluation\nif ( ( denominator != 0 ) && ( ( item / denominator ) > MIN_VALUE ) ) ... 440\nChapter 19: General Control Issues\nBut this is not safe: \nJava Example of a Test That Doesn’t Work Because Short-Circuit Evaluation Isn’t \nGuaranteed\nif ( ( denominator != 0 ) & ( ( item / denominator ) > MIN_VALUE ) ) ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1335, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 749}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1336_bcff8c41", "text": "Different languages use different kinds of ev aluation, and language implementers tend \nto take liberties with expression evaluati on, so check the manual for the specific ver-\nsion of the language you’re using to find out what kind of eval uation your language \nuses. Better yet, since a reader of your co de might not be as sharp as you are, use \nnested tests to clarify your intentions in stead of depending on evaluation order and \nshort-circuit evaluation. Writing Numeric Expressions in Number-Line Order\nOrganize numeric tests so that they follow the points on a number line. In general, \nstructure your numeric tests so that you have comparisons like these:\nMIN_ELEMENTS <= i and i <= MAX_ELEMENTS\ni < MIN_ELEMENTS or MAX_ELEMENTS < i\nThe idea is to order the elements left to right, from smallest to largest. In the first line, \nMIN_ELEMENTS and MAX_ELEMENTS are the two endpoints, so they go at the ends. The variable i is supposed to be between them, so it goes in the middle.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1336, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 987}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1337_c38ce953", "text": "In the first line, \nMIN_ELEMENTS and MAX_ELEMENTS are the two endpoints, so they go at the ends. The variable i is supposed to be between them, so it goes in the middle. In the second \nexample, you’re testing whether i is outside the range, so i goes on the outside of the \ntest at either end and MIN_ELEMENTS and MAX_ELEMENTS go on the inside. This \napproach maps easily to a visual image of the comparison in Figure 19-1:\nFigure 19-1 Examples of using number-line ordering for boolean tests. If you’re testing i against MIN_ELEMENTS only, the position of i varies depending on \nwhere i is when the test is successful. If i is supposed to be smaller, you’ll have a test \nlike this:\nwhile ( i < MIN_ELEMENTS ) ... But if i is supposed to be larger, you’ll have a test like this:\nwhile ( MIN_ELEMENTS < i ) ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1337, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 809}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1338_8811aabf", "text": "If i is supposed to be smaller, you’ll have a test \nlike this:\nwhile ( i < MIN_ELEMENTS ) ... But if i is supposed to be larger, you’ll have a test like this:\nwhile ( MIN_ELEMENTS < i ) ... KEY POINT\nMIN_ELEMENTS <= i and i <= MAX_ELEMENTS\nMIN_ELEMENTS Valid values for i\nMAX_ELEMENTS\ni < MIN_ELEMENTS or MAX_ELEMENTS < i\nMIN_ELEMENTS\nValid values for i\nMAX_ELEMENTS\n19.1 Boolean Expressions 441\nThis approach is clearer than tests like\n( i > MIN_ELEMENTS ) and ( i < MAX_ELEMENTS )\nwhich give the reader no help in visualizing what is being tested. Guidelines for Comparisons to 0 \nProgramming languages use 0 for several purposes. It’s a numeric value. It’s a null ter-\nminator in a string. It’s the value of a null pointer. It’s the value of the first item in an \nenumeration. It’s false in logical expressions. Because it’s used for so many purposes, \nyou should write code that highlights the specific way 0 is used.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1338, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 921}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1339_91e6fc28", "text": "It’s the value of the first item in an \nenumeration. It’s false in logical expressions. Because it’s used for so many purposes, \nyou should write code that highlights the specific way 0 is used. Compare logical variables implicitly As mentioned earlier, it’s appropriate to write \nlogical expressions such as\nwhile ( !done ) ... This implicit comparison to 0 is appropriate because the comparison is in a logical \nexpression. Compare numbers to 0Although it’s appropriate to compare logical expressions \nimplicitly, you should compare numeric expressions explicitly. For numbers, write\nwhile ( balance != 0 ) ... rather than\nwhile ( balance ) ... Compare characters to the null terminator ( '\\0') explicitly in C Characters, like \nnumbers, aren’t logical expressi ons. Thus, for characters, write\nwhile ( *charPtr != '\\0' ) ... rather than\nwhile ( *charPtr ) ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1339, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 862}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1340_11476e39", "text": "Thus, for characters, write\nwhile ( *charPtr != '\\0' ) ... rather than\nwhile ( *charPtr ) ... This recommendation goes against the co mmon C convention for handling character \ndata (as in the second example here), but it reinforces the idea that the expression is \nworking with character data rather than logical data. Some C conventions aren’t \nbased on maximizing readability or maintainability, and this is an example of one. Fortunately, this whole issue is fading into the sunset as more code is written using \nC++ and STL strings. Compare pointers to NULL For pointers, write\nwhile ( bufferPtr != NULL ) ... 442\nChapter 19: General Control Issues\nrather than\nwhile ( bufferPtr ) ... Like the recommendation for characters, this one goes against the established C con-\nvention, but the gain in readability justifies it.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1340, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 824}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1341_099ab22d", "text": "Like the recommendation for characters, this one goes against the established C con-\nvention, but the gain in readability justifies it. Common Problems with Boolean Expressions\nBoolean expressions are subject to a few addi tional pitfalls that pertain to specific \nlanguages: \nIn C-derived languages, put constants on the left side of comparisons C-derived lan-\nguages pose some special problems with bo olean expressions. If you have problems \nmistyping = instead of ==, consider the programming conv ention of putting constants \nand literals on the left sides of expressions, like this:\nC+ + Example of Putting a Constant on the Left Side of an Expression—An Error the \nCompiler Will Catch\nif ( MIN_ELEMENTS = i ) ... In this expression, the compiler should flag the single = as an error since assigning any-\nthing to a constant is invalid.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1341, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 842}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1342_2b312821", "text": "In this expression, the compiler should flag the single = as an error since assigning any-\nthing to a constant is invalid. In contrast, in the following expression, the compiler will \nflag this only as a warning, and only if you have compiler warnings fully turned on:\nC+ + Example of Putting a Constant on the Right Side of an Expression—An Error the \nCompiler Might Not Catch\nif ( i = MIN_ELEMENTS ) ... This recommendation conflicts with the recommendation to use number-line order-\ning. My personal preference is to use number-line ordering and let the compiler warn \nme about unintended assignments. In C++, consider creating prep rocessor macro substitutions for &&, ||, and == (but \nonly as a last resort) If you have such a problem, it’s possible to create #define macros \nfor boolean and and or, and use AND and OR instead of && and ||. Similarly, using = \nwhen you mean == is an easy mistake to make.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1342, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 910}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1343_ea453c83", "text": "Similarly, using = \nwhen you mean == is an easy mistake to make. If you get stung often by this one, you \nmight create a macro like EQUALS for logical equals ( ==). Many experienced programmers view this approach as aiding readability for the pro-\ngrammer who can’t keep details of the prog ramming language straight but as degrad-\ning readability for the programmer who is mo re fluent in the language. In addition, \nmost compilers will provide error warnings for usages of assignment and bitwise \n19.2 Compound Statements (Blocks) 443\noperators that seem like errors. Turning on full compiler warnings is usually a better \noption than creating nonstandard macros. In Java, know the difference between a==b and a.equals(b) In Java, a==b tests for \nwhether a and b refer to the same object, whereas a.equals(b) tests for whether the \nobjects have the same logical value. In general, Java programs should use expressions \nlike a.equals(b) rather than a==b .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1343, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 956}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1344_df16d1d3", "text": "In general, Java programs should use expressions \nlike a.equals(b) rather than a==b . 19.2 Compound Statements (Blocks)\nA “compound statement” or “block” is a collection of statements that are treated as a \nsingle statement for purposes of controlling the flow of a program. Compound state-\nments are created by writing { and } around a group of statements in C++, C#, C, and \nJava. Sometimes they are implied by the keywords of a command, such as For and \nNext in Visual Basic. Guidelines for using compound statements effectively follow:\nCross-Reference Many pro-\ngrammer-oriented text edi-\ntors have commands that \nmatch braces, brackets, and \nparentheses. For details, see \n“Editing” in Section 30.2. Write pairs of braces together Fill in the middle after you write both the opening \nand closing parts of a block. People often co mplain about how hard it is to match pairs \nof braces or begin -and- end pairs, and that’s a completely unnecessary problem.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1344, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 959}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1345_5be5de5e", "text": "People often co mplain about how hard it is to match pairs \nof braces or begin -and- end pairs, and that’s a completely unnecessary problem. If you \nfollow this guideline, you will never ha ve trouble matching such pairs again. Write this first: \nfor ( i = 0; i < maxLines; i++ )\nWrite this next: \nfor ( i = 0; i < maxLines; i++ ) { }\nWrite this last: \nfor ( i = 0; i < maxLines; i++ ) {\n // whatever goes in here ... }\nThis applies to all blocking structures, including if, for, and while in C++ and Java and \nthe If-Then-Else , For-Next , and While-Wend combinations in Visual Basic. Use braces to clarify conditionals Conditionals are hard enough to read without \nhaving to determine which statements go with the if test. Putting a single statement \nafter an if test is sometimes appeal ing aesthetically, but under maintenance such state-\nments tend to become more complicated blocks, and single statements are error-\nprone when that happens.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1345, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1346_e584cd76", "text": "Use blocks to clarify your intentions regardless of whether the code inside the block is \n1 line or 20. 444\nChapter 19: General Control Issues\n19.3 Null Statements\nIn C++, it’s possible to have a null statement, a statement consisting entirely of a semi-\ncolon, as shown here:\nC+ + Example of a Traditional Null Statement\nwhile ( recordArray.Read( index++ ) != recordArray.EmptyRecord() )\n ;\nThe while in C++ requires that a statement follow , but it can be a null statement. The \nsemicolon on a line by itself is a null statement. Here are guidelines for handling null \nstatements in C++:\nCross-Reference The best \nway to handle null state-\nments is probably to avoid \nthem. For details, see “Avoid \nempty loops” in Section 16.2. Call attention to null statements Null statements are uncommon, so make them \nobvious. One way is to give the semicolon of a null statement a line of its own. Indent \nit, just as you would any other statement. This is the approach shown in the previous \nexample.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1346, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 993}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1347_657d72f2", "text": "One way is to give the semicolon of a null statement a line of its own. Indent \nit, just as you would any other statement. This is the approach shown in the previous \nexample. Alternatively, you can use a set of empty braces to emphasize the null state-\nment. Here are two examples:\nC+ + Examples of a Null Statement That’s Emphasized\nThis is one way to show the \nnull statement. This is another way to show \nit. while ( recordArray.Read( index++ ) ) != recordArray.EmptyRecord() ) {}\nwhile ( recordArray.Read( index++ ) != recordArray.EmptyRecord() ) {\n ;\n}\nCreate a preprocessor DoNothing() macro or inline function for null statements\nThe statement doesn’t do anything but make indisputably clear the fact that nothing \nis supposed to be done. This is similar to marking blank document pages with the \nstatement “This page intentionally left blank.” The page isn’t really blank, but you \nknow nothing else is supposed to be on it. Here’s how you can make your own null statement in C++ by using #define .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1347, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1007}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1348_814c9a8a", "text": "Here’s how you can make your own null statement in C++ by using #define . (You \ncould also create it as an inline function, which would have the same effect.)\nC+ + Example of a Null Statement That’s Emphasized with DoNothing() \n#define DoNothing()\n... while ( recordArray.Read( index++ ) != recordArray.EmptyRecord() ) {\n DoNothing();\n}\nIn addition to using DoNothing() in empty while and for loops, you can use it for unim-\nportant choices of a switch statement; including DoNothing() makes it clear that the \ncase was considered and nothing is supposed to be done. 19.4 Taming Dangerously Deep Nesting 445\nIf your language doesn’t support preprocesso r macros or inline functions, you could \ncreate a DoNothing() routine that simply immediately returns control back to the call-\ning routine. Consider whether the code would be clearer with a non-null loop body Most of the \ncode that results in loops with empty bodies relies on side effects in the loop-control \ncode.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1348, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 970}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1349_424fc186", "text": "Consider whether the code would be clearer with a non-null loop body Most of the \ncode that results in loops with empty bodies relies on side effects in the loop-control \ncode. In most cases, the code is more readable when the side effects are made explicit, \nas shown here:\nC+ + Examples of Rewriting Code More Clearly with a Non-Null Loop Body\nRecordType record = recordArray.Read( index );\nindex++;\nwhile ( record != recordArray.EmptyRecord() ) {\n record = recordArray.Read( index );\n index++;\n}\nThis approach introduces an additional loo p-control variable and requires more lines \nof code, but it emphasizes straightforward programming practice rather than clever \nuse of side effects. Such emphasis is preferable in production code. 19.4 Taming Dangerously Deep Nesting\nExcessive indentation, or “nesting,” has been pilloried in computing literature for 25 \nyears and is still one of the chief culprits in confusing code.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1349, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 927}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1350_09345450", "text": "19.4 Taming Dangerously Deep Nesting\nExcessive indentation, or “nesting,” has been pilloried in computing literature for 25 \nyears and is still one of the chief culprits in confusing code. Studies by Noam Chom-\nsky and Gerald Weinberg suggest that fe w people can understand more than three \nlevels of nested ifs (Yourdon 1986a), and many rese archers recommend avoiding nest-\ning to more than three or four levels (M yers 1976, Marca 1981, and Ledgard and Tauer \n1987a). Deep nesting works against what Chapter 5, “Design in Construction,” \ndescribes as Software’s Primary Technical Imperative: Managing Complexity. That is \nreason enough to avoid deep nesting. It’s not hard to avoid deep nesting. If you have deep nesting, you can redesign the tests \nperformed in the if and else clauses or you can refactor code into simpler routines.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1350, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 838}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1351_eea08495", "text": "It’s not hard to avoid deep nesting. If you have deep nesting, you can redesign the tests \nperformed in the if and else clauses or you can refactor code into simpler routines. The \nfollowing subsections present several ways to reduce the nesting depth:\nSimplify a nested if by retesting part of the condition If the nesting gets too deep, \nyou can decrease the number of nesting levels by retesting some of the conditions. This code example has nesting that’s deep enough to warrant restructuring:\nC+ + Example of Bad, Deeply Nested Code\nif ( inputStatus == InputStatus_Success ) {\n // lots of code\n ... if ( printerRoutine != NULL ) {\n1\n23\nHARD DATA\nKEY POINT\nCODING \nHORROR\n446\nChapter 19: General Control Issues\nCross-Reference Retesting \npart of the condition to \nreduce complexity is similar \nto retesting a status variable. That technique is demon-\nstrated in “Error Processing \nand gotos” in Section 17.3. // lots of code\n ... if ( SetupPage() ) {\n // lots of code\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1351, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1352_8a65000e", "text": "That technique is demon-\nstrated in “Error Processing \nand gotos” in Section 17.3. // lots of code\n ... if ( SetupPage() ) {\n // lots of code\n ... if ( AllocMem( &printData ) ) {\n // lots of code\n ... } \n } \n } \n} \nThis example is contrived to show nesting levels. The // lots of code parts are intended \nto suggest that the routine has enough code to stretch across several screens or across \nthe page boundary of a printed code listing. Here’s the code revised to use retesting \nrather than nesting:\nC+ + Example of Code Mercifully Unnested by Retesting\nif ( inputStatus == InputStatus_Success ) {\n // lots of code\n ... if ( printerRoutine != NULL ) {\n // lots of code\n ... }\n}\nif ( ( inputStatus == InputStatus_Success ) && \n ( printerRoutine != NULL ) && SetupPage() ) {\n // lots of code\n ... if ( AllocMem( &printData ) ) {\n // lots of code\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1352, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 850}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1353_e2b9c0ad", "text": "}\n}\nif ( ( inputStatus == InputStatus_Success ) && \n ( printerRoutine != NULL ) && SetupPage() ) {\n // lots of code\n ... if ( AllocMem( &printData ) ) {\n // lots of code\n ... }\n}\nThis is a particularly realistic example because it shows that you can’t reduce the nest-\ning level for free; you have to put up with a more complicated test in return for the \nreduced level of nesting. A reduction from four levels to two is a big improvement in \nreadability, however, and is worth considering. Simplify a nested if by using a break block An alternative to the approach just \ndescribed is to define a section of code that will be executed as a block. If some con-\ndition in the middle of the block fails, execution skips to the end of the block. C+ + Example of Using a break Block\ndo { \n // begin break block\n if ( inputStatus != InputStatus_Success ) {\n break; // break out of block\n }\n19.4 Taming Dangerously Deep Nesting 447\n // lots of code\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1353, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1354_7250d70b", "text": "if ( printerRoutine == NULL ) {\n break; // break out of block\n }\n // lots of code\n ... if ( !SetupPage() ) {\n break; // break out of block\n }\n // lots of code\n ... if ( !AllocMem( &printData ) ) {\n break; // break out of block\n }\n // lots of code\n ... } while (FALSE); // end break block\nThis technique is uncommon enough that it should be used only when your entire \nteam is familiar with it and when it has been adopted by the team as an accepted cod-\ning practice. Convert a nested if to a set of if-then-else sIf you think about a nested if test criti-\ncally, you might discover that you can reorganize it so that it uses if-then-else s rather \nthan nested ifs.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1354, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 665}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1355_0bf03906", "text": "Convert a nested if to a set of if-then-else sIf you think about a nested if test criti-\ncally, you might discover that you can reorganize it so that it uses if-then-else s rather \nthan nested ifs. Suppose you have a bushy decision tree like this:\nJava Example of an Overgrown Decision Tree\nif ( 10 < quantity ) {\n if ( 100 < quantity ) {\n if ( 1000 < quantity ) {\n discount = 0.10;\n }\n else {\n discount = 0.05;\n }\n }\n else {\n discount = 0.025;\n }\n}\nelse {\n discount = 0.0;\n}\nThis test is poorly organized in several ways, one of which is that the tests are redundant. When you test whether quantity is greater than 1000 , you don’t also need to test whether \nit’s greater than 100 and greater than 10.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1355, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 702}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1356_26088a68", "text": "When you test whether quantity is greater than 1000 , you don’t also need to test whether \nit’s greater than 100 and greater than 10. Consequently, you can reorganize the code:\n448\nChapter 19: General Control Issues\nJava Example of a Nested if Converted to a Set of if-then-else s\nif ( 1000 < quantity ) {\n discount = 0.10;\n}\nelse if ( 100 < quantity ) {\n discount = 0.05;\n}\nelse if ( 10 < quantity ) {\n discount = 0.025;\n}\nelse {\n discount = 0;\n}\nThis solution is easier than some because the numbers increase neatly.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1356, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 518}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1357_b7e4d5fe", "text": "Here’s how \nyou could rework the nested if if the numbers weren’t so tidy:\nJava Example of a Nested if Converted to a Set of if-then-else s When the \nNumbers Are “Messy”\nif ( 1000 < quantity ) {\n discount = 0.10;\n}\nelse if ( ( 100 < quantity ) && ( quantity <= 1000 ) ) {\n discount = 0.05;\n}\nelse if ( ( 10 < quantity ) && ( quantity <= 100 ) ) {\n discount = 0.025;\n}\nelse if ( quantity <= 10 ) {\n discount = 0;\n}\nThe main difference between this code and the previous code is that the expressions \nin the else-if clauses don’t rely on previous te sts. This code doesn’t need the else \nclauses to work, and the tests actually could be performed in any order. The code \ncould consist of four ifs and no elses. The only reason the else version is preferable is \nthat it avoids repeating tests unnecessarily. Convert a nested if to a case statement You can recode some kinds of tests, particu-\nlarly those with integers, to use a case statement rather than chains of ifs and elses.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1357, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 978}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1358_eb6d0c7e", "text": "Convert a nested if to a case statement You can recode some kinds of tests, particu-\nlarly those with integers, to use a case statement rather than chains of ifs and elses. You \ncan’t use this technique in some languages, but it’s a powerful technique for those in \nwhich you can. Here’s how to recode the example in Visual Basic:\nVisual Basic Example of Converting a Nested if to a case Statement\nSelect Case quantity\n Case 0 To 10\n discount = 0.0\n Case 11 To 100\n discount = 0.025\n19.4 Taming Dangerously Deep Nesting 449\n Case 101 To 1000\n discount = 0.05\n Case Else\n discount = 0.10\nEnd Select\nThis example reads like a book. When you compare it to the two examples of multiple \nindentations a few pages earlier, it se ems like a particularly clean solution. Factor deeply nested code into its own routine If deep nesting occurs inside a loop, \nyou can often improve the situation by putting the inside of the loop into its own rou-\ntine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1358, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 942}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1359_e5f7b01f", "text": "Factor deeply nested code into its own routine If deep nesting occurs inside a loop, \nyou can often improve the situation by putting the inside of the loop into its own rou-\ntine. This is especially effective if the nestin g is a result of both conditionals and itera-\ntions. Leave the if-then-else branches in the main loop to show the decision branching, \nand then move the statements within the branches to their own routines.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1359, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 429}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1360_b6ae1c64", "text": "Leave the if-then-else branches in the main loop to show the decision branching, \nand then move the statements within the branches to their own routines. This code \nneeds to be improved by such a modification:\nC+ + Example of Nested Code That Needs to Be Broken into Routines\nwhile ( !TransactionsComplete() ) {\n // read transaction record\n transaction = ReadTransaction();\n // process transaction depending on type of transaction\n if ( transaction.Type == TransactionType_Deposit ) {\n // process a deposit\n if ( transaction.AccountType == AccountType_Checking ) {\n if ( transaction.AccountSubType == AccountSubType_Business )\n MakeBusinessCheckDep( transaction.AccountNum, transaction.Amount );\n else if ( transaction.AccountSubType == AccountSubType_Personal )\n MakePersonalCheckDep( transaction.AccountNum, transaction.Amount );\n else if ( transaction.AccountSubType == AccountSubType_School )\n MakeSchoolCheckDep( transaction.AccountNum, transaction.Amount );\n }\n else if ( transaction.AccountType == AccountType_Savings )\n MakeSavingsDep( transaction.AccountNum, transaction.Amount );\n else if ( transaction.AccountType == AccountType_DebitCard )\n MakeDebitCardDep( transaction.AccountNum, transaction.Amount );\n else if ( transaction.AccountType == AccountType_MoneyMarket )\n MakeMoneyMarketDep( transaction.AccountNum, transaction.Amount );\n else if ( transaction.AccountType == AccountType_Cd )\n MakeCDDep( transaction.AccountNum, transaction.Amount );\n }\n else if ( transaction.Type == TransactionType_Withdrawal ) {\n // process a withdrawal\n if ( transaction.AccountType == AccountType_Checking )\n MakeCheckingWithdrawal( transaction.AccountNum, transaction.Amount );\n else if ( transaction.AccountType == AccountType_Savings )\n MakeSavingsWithdrawal( transaction.AccountNum, transaction.Amount );\n else if ( transaction.AccountType == AccountType_DebitCard )\n MakeDebitCardWithdrawal( transaction.AccountNum, transaction.Amount );\n }\n450\nChapter 19: General Control Issues\nHere’s the \nTransactionType_Transfer \ntransaction type.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1360, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 2039}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1361_1925af15", "text": "else if ( transaction.Type == TransactionType_Transfer ) {\n MakeFundsTransfer( \n transaction.SourceAccountType, \n transaction.TargetAccountType, \n transaction.AccountNum, \n transaction.Amount \n );\n }\n else {\n // process unknown kind of transaction\n LogTransactionError( \"Unknown Transaction Type\", transaction );\n }\n}\nAlthough it’s complicated, this isn’t the worst code you’ll ever see. It’s nested to only \nfour levels, it’s commented, it’s logically indented, and the functional decomposition \nis adequate, especially for the TransactionType_Transfer transaction type. In spite of its \nadequacy, however, you can improve it by breaking the contents of the inner if tests \ninto their own routines. Cross-Reference This kind of \nfunctional decomposition is \nespecially easy if you initially \nbuilt the routine using the \nsteps described in Chapter 9, \n“The Pseudocode Program-\nming Process.” Guidelines \nfor functional decomposition \nare given in “Divide and \nConquer” in Section 5.4.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1361, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 985}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1362_801a1cff", "text": "C+ + Example of Good, Nested Code After Decomposition into Routines\nwhile ( !TransactionsComplete() ) {\n // read transaction record\n transaction = ReadTransaction();\n // process transaction depending on type of transaction\n if ( transaction.Type == TransactionType_Deposit ) {\n ProcessDeposit( \n transaction.AccountType, \n transaction.AccountSubType,\n transaction.AccountNum, \n transaction.Amount \n );\n }\n else if ( transaction.Type == TransactionType_Withdrawal ) {\n ProcessWithdrawal( \n transaction.AccountType, \n transaction.AccountNum,\n transaction.Amount \n );\n }\n else if ( transaction.Type == TransactionType_Transfer ) {\n MakeFundsTransfer( \n transaction.SourceAccountType, \n transaction.TargetAccountType,\n transaction.AccountNum, \n transaction.Amount \n );\n }\n else {\n // process unknown transaction type\n LogTransactionError(\"Unknown Transaction Type\", transaction );\n }\n}\n19.4 Taming Dangerously Deep Nesting 451\nThe code in the new routines has simply b een lifted out of the original routine and \nformed into new routines.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1362, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1034}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1363_94d8ca76", "text": "(The new routines aren’t shown here.) The new code has \nseveral advantages. First, two-level nesting makes the structure simpler and easier to \nunderstand. Second, you can read, modify, and debug the shorter while loop on one \nscreen—it doesn’t need to be broken across screen or printed-page boundaries. Third, \nputting the functionality of ProcessDeposit() and ProcessWithdrawal() into routines \naccrues all the other general advantages of modularization.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1363, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 457}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1364_bde922dd", "text": "Third, \nputting the functionality of ProcessDeposit() and ProcessWithdrawal() into routines \naccrues all the other general advantages of modularization. Fourth, it’s now easy to \nsee that the code could be broken into a case statement, which would make it even eas-\nier to read, as shown below:\nC+ + Example of Good, Nested Code After Decomposition and Use of a \ncase Statement\nwhile ( !TransactionsComplete() ) {\n // read transaction record\n transaction = ReadTransaction();\n // process transaction depending on type of transaction\n switch ( transaction.Type ) {\n case ( TransactionType_Deposit ):\n ProcessDeposit( \n transaction.AccountType, \n transaction.AccountSubType,\n transaction.AccountNum, \n transaction.Amount \n );\n break;\n case ( TransactionType_Withdrawal ):\n ProcessWithdrawal( \n transaction.AccountType, \n transaction.AccountNum,\n transaction.Amount \n );\n break;\n case ( TransactionType_Transfer ):\n MakeFundsTransfer( \n transaction.SourceAccountType,\n transaction.TargetAccountType,\n transaction.AccountNum, \n transaction.Amount \n );\n break;\n default:\n // process unknown transaction type\n LogTransactionError(\"Unknown Transaction Type\", transaction );\n break;\n }\n}\n452\nChapter 19: General Control Issues\nUse a more object-oriented approach A straightforward way to simplify this particu-\nlar code in an object-oriented environment is to create an abstract Transaction base \nclass and subclasses for Deposit , Withdrawal , and Transfer .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1364, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1451}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1365_9a852584", "text": "C+ + Example of Good Code That Uses Polymorphism\nTransactionData transactionData;\nTransaction *transaction; \nwhile ( !TransactionsComplete() ) {\n // read transaction record\n transactionData = ReadTransaction();\n // create transaction object, depending on type of transaction\n switch ( transactionData.Type ) {\n case ( TransactionType_Deposit ):\n transaction = new Deposit( transactionData );\n break;\n case ( TransactionType_Withdrawal ):\n transaction = new Withdrawal( transactionData );\n break;\n case ( TransactionType_Transfer ):\n transaction = new Transfer( transactionData );\n break;\n default:\n // process unknown transaction type\n LogTransactionError(\"Unknown Transaction Type\", transactionData );\n return;\n }\n transaction->Complete(); \n delete transaction;\n}\nIn a system of any size, the switch statement would be converted to use a factory \nmethod that could be reused anywhere an object of Transaction type needed to be cre-\nated.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1365, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 938}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1366_a6a7a875", "text": "If this code were in such a system, this part of it would become even simpler:\nCross-Reference For more \nbeneficial code improve-\nments like this, see Chapter \n24, \"Refactoring.\"\nC+ + Example of Good Code That Uses Polymorphism and an Object Factory\nTransactionData transactionData;\nTransaction *transaction; \nwhile ( !TransactionsComplete() ) {\n // read transaction record and complete transaction\n transactionData = ReadTransaction();\n transaction = TransactionFactory.Create( transactionData );\n transaction->Complete(); \n delete transaction;\n}\nFor the record, the code in the TransactionFactory.Create() routine is a simple adapta-\ntion of the code from the prior example’s switch statement: \n19.4 Taming Dangerously Deep Nesting 453\nC+ + Example of Good Code for an Object Factory\nTransaction *TransactionFactory::Create( \n TransactionData transactionData \n ) {\n \n // create transaction object, depending on type of transaction\n switch ( transactionData.Type ) {\n case ( TransactionType_Deposit ):\n return new Deposit( transactionData );\n break;\n \n case ( TransactionType_Withdrawal ):\n return new Withdrawal( transactionData );\n break;\n \n case ( TransactionType_Transfer ):\n return new Transfer( transactionData );\n break;\n \n default:\n // process unknown transaction type\n LogTransactionError( \"Unknown Transaction Type\", transactionData );\n return NULL; \n }\n}\nRedesign deeply nested code Some experts argue that case statements virtually \nalways indicate poorly factored code in object-oriented programming and are rarely, if \never, needed (Meyer 1997).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1366, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1560}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1367_04b7657c", "text": "This transformation from case statements that invoke rou-\ntines to an object factory with polymo rphic method calls is one such example. More generally, complicated code is a sign that you don’t understand your program \nwell enough to make it simple. Deep nesting is a warning sign that indicates a need to \nbreak out a routine or redesign the part of the code that’s complicated. It doesn’t \nmean you have to modify the routine, but you should have a good reason for not \ndoing so if you don’t.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1367, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 495}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1368_b9df4791", "text": "It doesn’t \nmean you have to modify the routine, but you should have a good reason for not \ndoing so if you don’t. Summary of Techniques for Reducing Deep Nesting\nThe following is a list of the techniques you can use to reduce deep nesting, along with \nreferences to the sections in this book that discuss the techniques:\n■\nRetest part of the condition (this section)\n■\nConvert to if-then-else s (this section)\n■\nConvert to a case statement (this section)\n■\nFactor deeply nested code into its own routine (this section)\n■\nUse objects and polymorphic dispatch (this section) \n454\nChapter 19: General Control Issues\n■\nRewrite the code to use a status variable (in Section 17.3)\n■\nUse guard clauses to exit a routine and make the nominal path through the code \nclearer (in Section 17.1)\n■\nUse exceptions (Section 8.4)\n■\nRedesign deeply nested code entirely (this section)\n19.5 A Programming Foundati on: Structured Programming\nThe term “structured programming” originated in a landmark paper, “Structured Pro-\ngramming,” presented by Edsger Dijkstra at the 1969 NATO conference on software \nengineering (Dijkstra 1969).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1368, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1116}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1369_04fadcb6", "text": "By the time structured programming came and went, the \nterm “structured” had been applied to ever y software-development activity, including \nstructured analysis, structured design, and structured goofing off. The various struc-\ntured methodologies weren’t joined by any common thread except that they were all \ncreated at a time when the word “structured” gave them extra cachet. The core of structured programming is the simple idea that a program should use \nonly one-in, one-out control constructs (also called single-entry, single-exit control \nconstructs). A one-in, one-out control construct is a block of code that has only one \nplace it can start and only one place it can en d. It has no other entries or exits. Struc-\ntured programming isn’t the same as structured, top-down design. It applies only at \nthe detailed coding level. A structured program progresses in an orderl y, disciplined way, rather than jumping \naround unpredictably.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1369, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 948}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1370_d5ee4ed0", "text": "It applies only at \nthe detailed coding level. A structured program progresses in an orderl y, disciplined way, rather than jumping \naround unpredictably. You can read it from top to bottom, and it executes in much the \nsame way. Less disciplined approaches resu lt in source code that provides a less \nmeaningful, less readable picture of how a program executes in the machine. Less \nreadability means less understanding and, ultimately, lower program quality. The central concepts of structured programming are still useful today and apply to \nconsiderations in using break , continue , throw , catch , return , and other topics. The Three Components of Structured Programming\nThe next few sections describe the three constructs that constitute the core of struc-\ntured programming. Sequence\nCross-Reference For details \non using sequences, see \nChapter 14, “Organizing \nStraight-Line Code.”\nA sequence is a set of statements executed in order.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1370, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 946}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1371_ff4e99ea", "text": "Sequence\nCross-Reference For details \non using sequences, see \nChapter 14, “Organizing \nStraight-Line Code.”\nA sequence is a set of statements executed in order. Typical sequential statements \ninclude assignments and calls to routines. Here are two examples:\n19.5 A Programming Foundation: Structured Programming 455\nJava Examples of Sequential Code\n// a sequence of assignment statements\na = \"1\";\nb = \"2\";\nc = \"3\";\n// a sequence of calls to routines\nSystem.out.println( a );\nSystem.out.println( b );\nSystem.out.println( c );\nSelection\nCross-Reference For details \non using selections, see \nChapter 15, “Using Condi-\ntionals.”\nA selection is a control structure that causes statements to be executed selectively. The \nif-then-else statement is a common example. Either the if-then clause or the else clause \nis executed, but not both. One of the clauses is “selected” for execution. A case statement is another example of selection control.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1371, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1372_245861b2", "text": "Either the if-then clause or the else clause \nis executed, but not both. One of the clauses is “selected” for execution. A case statement is another example of selection control. The switch statement in C++ \nand Java and the select statement in Visual Ba sic are all examples of case. In each \ninstance, one of several cases is selected for execution. Conceptually, if statements and \ncase statements are similar. If your language doesn’t support case statements, you can \nemulate them with if statements. Here are two examples of selection:\nJava Examples of Selection\n// selection in an if statement\nif ( totalAmount > 0.0 ) {\n // do something\n ... }\nelse {\n // do something else\n ...", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1372, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 685}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1373_b2e2e254", "text": "Here are two examples of selection:\nJava Examples of Selection\n// selection in an if statement\nif ( totalAmount > 0.0 ) {\n // do something\n ... }\nelse {\n // do something else\n ... }\n// selection in a case statement\nswitch ( commandShortcutLetter ) {\n case 'a': \n PrintAnnualReport();\n break;\n case 'q': \n PrintQuarterlyReport();\n break;\n case 's': \n PrintSummaryReport();\n break;\n default: \n DisplayInternalError( \"Internal Error 905: Call customer support.\" );\n} \n456\nChapter 19: General Control Issues\nIteration\nCross-Reference For details \non using iterations, see \nChapter 16, “Controlling \nLoops.”\nAn iteration is a control structure that causes a group of statements to be executed \nmultiple times. An iteration is commonly refe rred to as a “loop.” Kinds of iterations \ninclude For-Next in Visual Basic and while and for in C++ and Java.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1373, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 844}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1374_31d12b63", "text": "An iteration is commonly refe rred to as a “loop.” Kinds of iterations \ninclude For-Next in Visual Basic and while and for in C++ and Java. This code fragment \nshows examples of iter ation in Visual Basic:\nVisual Basic Examples of Iteration\n' example of iteration using a For loop\nFor index = first To last \n DoSomething( index )\nNext\n' example of iteration using a while loop\nindex = first\nWhile ( index <= last ) \n DoSomething ( index )\n index = index + 1\nWend\n' example of iteration using a loop-with-exit loop\nindex = first\nDo \n If ( index > last ) Then Exit Do\n DoSomething ( index )\n index = index + 1\nLoop\nThe core thesis of structured programming is that any control flow whatsoever can be \ncreated from these three constructs of sequ ence, selection, and iteration (Böhm Jaco-\npini 1966). Programmers sometimes favor language structures that increase conve-\nnience, but programming seems to have advanced largely by restricting what we are \nallowed to do with our programming lang uages.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1374, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 996}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1375_61de1fef", "text": "Programmers sometimes favor language structures that increase conve-\nnience, but programming seems to have advanced largely by restricting what we are \nallowed to do with our programming lang uages. Prior to structured programming, \nuse of gotos provided the ultimate in control-flow convenience, but code written that \nway turned out to be incomprehensible and unmaintainable. My belief is that use of \nany control structure other than the three standard structured programming con-\nstructs—that is, the use of break , continue , return , throw-catch , and so on—should be \nviewed with a critical eye. 19.6 Control Structures and Complexity\nOne reason so much attention has been paid to control structures is that they are a big \ncontributor to overall program complexity. Poor use of control structures increases \ncomplexity; good use decreases it. 19.6 Control Structures and Complexity 457\nMake things as simple as \npossible—but no simpler.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1375, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 944}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1376_bf48458b", "text": "Poor use of control structures increases \ncomplexity; good use decreases it. 19.6 Control Structures and Complexity 457\nMake things as simple as \npossible—but no simpler. —Albert Einstein\nOne measure of “programming complexity” is the number of mental objects you have \nto keep in mind simultaneously in order to understand a program. This mental jug-\ngling act is one of the most difficult aspects of programming and is the reason pro-\ngramming requires more concentration than other activities. It’s the reason \nprogrammers get upset about “quick interruptions”—such interruptions are tanta-\nmount to asking a juggler to keep three balls in the air and hold your groceries at the \nsame time. Intuitively, the complexity of a program would seem to largely determine the amount \nof effort required to understand it. Tom McCabe published an influential paper argu-\ning that a program’s complexity is defined by its control flow (1976).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1376, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 934}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1377_f9d7c04d", "text": "Tom McCabe published an influential paper argu-\ning that a program’s complexity is defined by its control flow (1976). Other research-\ners have identified factors other than McCabe ’s cyclomatic complexity metric (such as \nthe number of variables used in a routine), but they agree that control flow is at least \none of the largest contributors to complexity, if not the largest. How Important Is Complexity? Cross-Reference For more \non complexity, see “Soft-\nware’s Primary Technical \nImperative: Managing Com-\nplexity” in Section 5.2. Computer-science researchers have been aware of the importance of complexity for at \nleast two decades. Many years ago, Edsger Dijkstra cautioned against the hazards of \ncomplexity: “The competent programmer is fully aware of the strictly limited size of \nhis own skull; therefore, he approaches the programming task in full humility” (Dijk-\nstra 1972). This does not imply that you shou ld increase the capacity of your skull to \ndeal with enormous complexity.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1377, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 999}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1378_bf7092d9", "text": "This does not imply that you shou ld increase the capacity of your skull to \ndeal with enormous complexity. It implies that you can never deal with enormous \ncomplexity and must take steps to reduce it wherever possible. Control-flow complexity is important because it has been correlated with low reliabil-\nity and frequent errors (McCabe 1976, Shen et al. 1985). William T. Ward reported a \nsignificant gain in software reliability re sulting from using McCabe’s complexity met-\nric at Hewlett-Packard (1989b). McCabe’s metric was used on one 77,000-line pro-\ngram to identify problem areas. The progra m had a post-release defect rate of 0.31 \ndefects per thousand lines of code. A 125,00 0-line program had a post-release defect \nrate of 0.02 defects per thousand lines of code. Ward reported that because of their \nlower complexity, both programs had substantially fewer defects than other programs \nat Hewlett-Packard.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1378, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 924}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1379_1bcf76d6", "text": "Ward reported that because of their \nlower complexity, both programs had substantially fewer defects than other programs \nat Hewlett-Packard. My own company, Co nstrux Software, has experienced similar \nresults using complexity measures to iden tify problematic routines in the 2000s. General Guidelines for Reducing Complexity\nYou can better deal with complexity in one of two ways. First, you can improve your \nown mental juggling abilities by doing mental exercises. But programming itself is \nusually enough exercise, and people seem to have trouble juggling more than about \nfive to nine mental entities (Miller 1956). The potential for improvement is small. Sec-\nond, you can decrease the complexity of your programs and the amount of concentra-\ntion required to understand them. KEY POINT\n1\n23\nHARD DATA\n458\nChapter 19: General Control Issues\nHow to Measure Complexity\nFurther Reading The \napproach described here is \nbased on Tom McCabe’s \ninfluential paper “A Com-\nplexity Measure” (1976).", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1379, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 998}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1380_271ed7e4", "text": "You probably have an intuitive feel for wh at makes a routine more or less complex. Researchers have tried to formalize their intu itive feelings and have come up with several \nways of measuring complexity. Perhaps the mo st influential of the numeric techniques is \nTom McCabe’s, in which complexity is meas ured by counting the number of “decision \npoints” in a routine. Table 19-2 describes a method for counting decision points. Here’s an example:\nif ( ( (status = Success) and done ) or\n ( not done and ( numLines >= maxLines ) ) ) then ... In this fragment, you count 1 to start, 2 for the if, 3 for the and, 4 for the or, and 5 for \nthe and. Thus, this fragment contains a total of five decision points. What to Do with Your Complexity Measurement\nAfter you have counted the decision points, you can use the number to analyze your \nroutine’s complexity:\nMoving part of a routine into another routine doesn’t reduce the overall complexity of \nthe program; it just moves the decision points around.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1380, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1003}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1381_0ff7e79c", "text": "But it reduces the amount of \ncomplexity you have to deal with at any on e time. Since the important goal is to min-\nimize the number of items you have to jugg le mentally, reducing the complexity of a \ngiven routine is worthwhile. The maximum of 10 decision points isn’t an absolute limit. Use the number of deci-\nsion points as a warning flag that indicates a routine might need to be redesigned. Don’t use it as an inflexible rule. A case statement with many cases could be more than \n10 elements long, and, depending on the purpose of the case statement, it might be \nfoolish to break it up. Table 19-2\nTechniques for Counting the Decision Points in a Routine\n1. Start with 1 for the straight path through the routine. 2. Add 1 for each of the following keywords, or their equivalents: if while repeat for \nand or\n3. Add 1 for each case in a case statement. 0–5 The routine is probably fine. 6–10 Start to think about ways to simplify the routine.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1381, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 951}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1382_9479f5aa", "text": "Add 1 for each case in a case statement. 0–5 The routine is probably fine. 6–10 Start to think about ways to simplify the routine. 10+ Break part of the routine into a second routine and call it from the first \nroutine. 19.6 Control Structures and Complexity 459\nOther Kinds of Complexity\nFurther Reading For an \nexcellent discussion of com-\nplexity metrics, see Software \nEngineering Metrics and \nModels (Conte, Dunsmore, \nand Shen 1986). The McCabe measure of complexity isn’t the only sound measure, but it’s the measure \nmost discussed in computing li terature and it’s especially helpful when you’re think-\ning about control flow. Other measures include the amount of data used, the number \nof nesting levels in control constructs, th e number of lines of code, the number of \nlines between successive references to vari ables (“span”), the number of lines that a \nvariable is in use (“live time”), and the am ount of input and output.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1382, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 940}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1383_20385ba1", "text": "Some researchers \nhave developed composite metrics based on combinations of these simpler ones. cc2e.com/1985\nCHECKLIST: Control-Structure Issues\n❑\nDo expressions use true and false rather than 1 and 0? ❑\nAre boolean values compared to true and false implicitly? ❑\nAre numeric values compared to their test values explicitly? ❑\nHave expressions been simplified by the addition of new boolean vari-\nables and the use of boolean f unctions and deci sion tables? ❑\nAre boolean expressions stated positively? ❑\nDo pairs of braces balance? ❑\nAre braces used everywhere they’re needed for clarity? ❑\nAre logical expressions fully parenthesized? ❑\nHave tests been written in number-line order? ❑\nDo Java tests uses a.equals(b) style instead of a == b when appropriate? ❑\nAre null statements obvious?", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1383, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 792}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1384_3d81526b", "text": "❑\nAre logical expressions fully parenthesized? ❑\nHave tests been written in number-line order? ❑\nDo Java tests uses a.equals(b) style instead of a == b when appropriate? ❑\nAre null statements obvious? ❑\nHave nested statements been simplified by retesting part of the condi-\ntional, converting to if-then-else or case statements, moving nested code \ninto its own routine, converting to a more object-oriented design, or have \nthey been improved in some other way? ❑\nIf a routine has a decision count of more than 10, is there a good reason for \nnot redesigning it? 460\nChapter 19: General Control Issues\nKey Points\n■\nMaking boolean expressions simple and readable contributes substantially to \nthe quality of your code. ■\nDeep nesting makes a routine hard to understand. Fortunately, you can avoid it \nrelatively easily. ■\nStructured programming is a simple idea that is still relevant: you can build any \nprogram out of a combination of se quences, selections, and iterations.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1384, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 976}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1385_9665458b", "text": "■\nStructured programming is a simple idea that is still relevant: you can build any \nprogram out of a combination of se quences, selections, and iterations. ■\nMinimizing complexity is a key to writing high-quality code. Part V\nCode Improvements\nIn this part:\nChapter 20: The Software-Quality Landscape . . . . . . . . . . . . . . . . . . . . . .463\nChapter 21: Collaborative Construction . . . . . . . . . . . . . . . . . . . . . . . . . . .479\nChapter 22: Developer Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .499\nChapter 23: Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .535\nChapter 24: Refactoring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .563\nChapter 25: Code-Tuning Strategies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .587\nChapter 26: Code-Tuning Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1385, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 952}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1386_03c8afe3", "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .563\nChapter 25: Code-Tuning Strategies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .587\nChapter 26: Code-Tuning Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . .609\n\n463\nChapter 20\nThe Software-Quality \nLandscape\ncc2e.com/2036\nContents\n■\n20.1 Characteristics of Software Quality: page 463\n■\n20.2 Techniques for Improving Software Quality: page 466\n■\n20.3 Relative Effectiveness of Quality Techniques: page 469\n■\n20.4 When to Do Quality Assurance: page 473\n■\n20.5 The General Principle of Software Quality: page 474\nRelated Topics\n■\nCollaborative construction: Chapter 21\n■\nDeveloper testing: Chapter 22\n■\nDebugging: Chapter 23\n■\nPrerequisites to construction: Chapters 3 and 4\n■\nDo prerequisites apply to modern software projects?: in Section 3.1\nThis chapter surveys software -quality techniques from a construction point of view. The entire book is about improving softwa re quality, of course, but this chapter \nfocuses on quality and quality assurance per se.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1386, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1075}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1387_6a31188e", "text": "The entire book is about improving softwa re quality, of course, but this chapter \nfocuses on quality and quality assurance per se. It focuses more on big-picture issues \nthan it does on hands-on techniques. If you’re looking for practical advice about col-\nlaborative development, testing, and debugging, move on to the next three chapters. 20.1 Characteristics of Software Quality\nSoftware has both external and internal quality characteristics. External characteristics \nare characteristics that a user of the software product is aware of, including the following:\n■\nCorrectness The degree to which a system is free from faults in its specifica-\ntion, design, and implementation. ■\nUsability The ease with which users can learn and use a system. 464\nChapter 20: The Softwa re-Quality Landscape\n■\nEfficiency Minimal use of system resources, including memory and execution \ntime.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1387, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 880}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1388_ed9a3538", "text": "■\nUsability The ease with which users can learn and use a system. 464\nChapter 20: The Softwa re-Quality Landscape\n■\nEfficiency Minimal use of system resources, including memory and execution \ntime. ■\nReliability The ability of a system to perf orm its required functions under \nstated conditions whenever required—having a long mean time between failures. ■\nIntegrity The degree to which a system prevents unauthorized or improper \naccess to its programs and its data. The idea of integrity includes restricting \nunauthorized user accesses as well as ensuring that data is accessed properly—\nthat is, that tables with parallel data are modified in parallel, that date fields con-\ntain only valid dates, and so on. ■\nAdaptability The extent to which a system ca n be used, without modification, \nin applications or environments other than those for which it was specifically \ndesigned. ■\nAccuracy The degree to which a system, as built, is free from error, especially \nwith respect to quantitative outputs.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1388, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 1005}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1389_708f1c8a", "text": "■\nAccuracy The degree to which a system, as built, is free from error, especially \nwith respect to quantitative outputs. Accuracy differs from correctness; it is a \ndetermination of how well a system does the job it’s built for rather than \nwhether it was built correctly. ■\nRobustness The degree to which a system continues to function in the pres-\nence of invalid inputs or stressf ul environmental conditions. Some of these characteristics overlap, but al l have different shades of meaning that are \napplicable more in some cases, less in others. External characteristics of quality are the on ly kind of software characteristics that \nusers care about. Users care about whether the software is easy to use, not about \nwhether it’s easy for you to modify. They care about whether the software works cor-\nrectly, not about whether the code is readable or well structured. Programmers care about the internal characte ristics of the software as well as the \nexternal ones.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1389, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 974}}
{"id": "computer_science_mcconnell_code_complete_2_chunk_1390_8f459b18", "text": "Programmers care about the internal characte ristics of the software as well as the \nexternal ones. This book is code-centered, so it focuses on the internal quality charac-\nteristics, including\n■\nMaintainability The ease with which you can mo dify a software system to \nchange or add capabili ties, improve performance, or correct defects. ■\nFlexibility The extent to which you can modify a system for uses or environ-\nments other than those for which it was specifically designed. ■\nPortability The ease with which you can modify a system to operate in an \nenvironment different from that for which it was specifically designed. ■\nReusability The extent to which and the ease with which you can use parts of \na system in other systems. ■\nReadability The ease with which you can read and understand the source \ncode of a system, especially at the detailed-statement level.", "metadata": {"book_id": "computer_science_mcconnell_code_complete_2", "book_title": "McConnell_Code_Complete_2", "category": "computer_science", "chunk_index": 1390, "total_chunks": 1391, "source_file": "McConnell_Code_Complete_2.pdf", "file_type": "pdf", "char_count": 873}}
