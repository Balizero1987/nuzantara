/* eslint-disable @typescript-eslint/no-explicit-any */
import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { chatAPI } from '../chat';
import { apiClient } from '../client';
import { fetchWithRetry } from '../fetch-utils';

// Mock fetchWithRetry
jest.mock('../fetch-utils', () => ({
  fetchWithRetry: jest.fn(),
}));

// Mock apiClient
jest.mock('../client', () => ({
  apiClient: {
    getToken: jest.fn(() => 'test-token'),
  },
}));

// Mock authAPI
jest.mock('../auth', () => ({
  authAPI: {
    getUser: jest.fn(() => ({ email: 'test@example.com' })),
  },
}));

describe.skip('chatAPI', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('streamChat', () => {
    it('should stream chat response successfully', async () => {
      const mockStream = new ReadableStream({
        start(controller) {
          const encoder = new TextEncoder();
          controller.enqueue(encoder.encode('data: {"type": "token", "data": "Hello"}\n\n'));
          controller.enqueue(encoder.encode('data: {"type": "token", "data": " World"}\n\n'));
          controller.close();
        },
      });

      (fetchWithRetry as any).mockResolvedValue({
        ok: true,
        body: mockStream,
      });

      const onChunk = jest.fn();
      const onMetadata = jest.fn();
      const onComplete = jest.fn();
      const onError = jest.fn();

      await chatAPI.streamChat('Hello', onChunk, onMetadata, onComplete, onError);

      expect(fetchWithRetry).toHaveBeenCalledWith(
        '/api/chat/stream',
        expect.objectContaining({
          method: 'POST',
          headers: expect.objectContaining({
            Authorization: 'Bearer test-token',
          }),
          body: expect.stringContaining('"message":"Hello"'),
        })
      );

      expect(onChunk).toHaveBeenCalledWith('Hello');
      expect(onChunk).toHaveBeenCalledWith(' World');
      expect(onComplete).toHaveBeenCalled();
    });

    it('should handle metadata events', async () => {
      const mockStream = new ReadableStream({
        start(controller) {
          const encoder = new TextEncoder();
          controller.enqueue(
            encoder.encode('data: {"type": "metadata", "data": {"intent": "greeting"}}\n\n')
          );
          controller.close();
        },
      });

      (fetchWithRetry as any).mockResolvedValue({
        ok: true,
        body: mockStream,
      });

      const onChunk = jest.fn();
      const onMetadata = jest.fn();
      const onComplete = jest.fn();
      const onError = jest.fn();

      await chatAPI.streamChat('Hello', onChunk, onMetadata, onComplete, onError);

      expect(onMetadata).toHaveBeenCalledWith({ intent: 'greeting' });
      expect(onComplete).toHaveBeenCalled();
    });

    it('should handle stream errors', async () => {
      const mockStream = new ReadableStream({
        start(controller) {
          const encoder = new TextEncoder();
          controller.enqueue(encoder.encode('data: {"type": "error", "data": "Stream error"}\n\n'));
          controller.close();
        },
      });

      (fetchWithRetry as any).mockResolvedValue({
        ok: true,
        body: mockStream,
      });

      const onChunk = jest.fn();
      const onMetadata = jest.fn();
      const onComplete = jest.fn();
      const onError = jest.fn();

      await chatAPI.streamChat('Hello', onChunk, onMetadata, onComplete, onError);

      expect(onError).toHaveBeenCalledWith(expect.any(Error));
    });

    it('should handle network errors', async () => {
      (fetchWithRetry as any).mockRejectedValue(new Error('Network error'));

      const onError = jest.fn();
      await chatAPI.streamChat('Hello', jest.fn(), jest.fn(), jest.fn(), onError);

      expect(onError).toHaveBeenCalledWith(expect.any(Error));
    });

    it('should handle authentication errors', async () => {
      (fetchWithRetry as any).mockResolvedValue({
        ok: false,
        status: 401,
      });

      const onError = jest.fn();
      await chatAPI.streamChat('Hello', jest.fn(), jest.fn(), jest.fn(), onError);

      expect(onError).toHaveBeenCalledWith(expect.any(Error));
    });

    it('should handle missing token', async () => {
      (apiClient.getToken as any).mockReturnValue(null);

      const onError = jest.fn();
      await chatAPI.streamChat('Hello', jest.fn(), jest.fn(), jest.fn(), onError);

      expect(onError).toHaveBeenCalledWith(expect.any(Error));
    });
  });
});
