"""
THE SCRIBE FRONTEND: Automated Documentation Generator
Scans Frontend codebase (Next.js/TypeScript), extracts Components, Pages, and API calls.
Generates FRONTEND_ARCHITECTURE.md
"""

import re
from pathlib import Path
from typing import Dict, List, Tuple
from datetime import datetime


class Colors:
    """Terminal colors"""

    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"


class FrontendScribe:
    def __init__(self, frontend_dir: Path, docs_dir: Path):
        self.frontend_dir = frontend_dir
        self.docs_dir = docs_dir
        self.output_file = docs_dir / "FRONTEND_ARCHITECTURE.md"

    def scan_codebase(self) -> Tuple[List[Dict], List[Dict], List[Dict]]:
        """Scan TypeScript files"""
        pages = []
        components = []
        api_calls = []

        print(f"{Colors.OKCYAN}ğŸ“š Scanning Frontend Codebase...{Colors.ENDC}")

        # 1. Scan Pages (app directory)
        app_dir = self.frontend_dir / "app"
        if app_dir.exists():
            for file_path in app_dir.rglob("page.tsx"):
                rel_path = file_path.relative_to(app_dir).parent
                route = f"/{rel_path}" if str(rel_path) != "." else "/"
                pages.append(
                    {
                        "route": route,
                        "file": str(file_path.relative_to(self.frontend_dir)),
                        "description": self._extract_description(file_path),
                    }
                )

        # 2. Scan Components
        components_dir = self.frontend_dir / "components"
        if components_dir.exists():
            for file_path in components_dir.rglob("*.tsx"):
                components.append(
                    {
                        "name": file_path.stem,
                        "file": str(file_path.relative_to(self.frontend_dir)),
                        "description": self._extract_description(file_path),
                    }
                )

        # 3. Scan API Calls (lib/api)
        api_dir = self.frontend_dir / "lib" / "api"
        if api_dir.exists():
            for file_path in api_dir.rglob("*.ts"):
                api_calls.extend(self._extract_api_functions(file_path))

        return pages, components, api_calls

    def _extract_description(self, file_path: Path) -> str:
        """Extract comment at top of file"""
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read(500)  # Read first 500 chars
                match = re.search(r"/\*\*(.*?)\*/", content, re.DOTALL)
                if match:
                    return match.group(1).strip().replace("*", "").strip()
                return "No description available."
        except Exception:
            return "Error reading file."

    def _extract_api_functions(self, file_path: Path) -> List[Dict]:
        """Extract exported functions from API files"""
        functions = []
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read()
                # Match export const func = ... or export function func(...)
                matches = re.finditer(r"export\s+(?:const|function)\s+(\w+)", content)
                for match in matches:
                    functions.append(
                        {
                            "name": match.group(1),
                            "file": str(file_path.relative_to(self.frontend_dir)),
                        }
                    )
        except Exception:
            pass
        return functions

    def generate_markdown(self, pages, components, api_calls) -> str:
        lines = []
        lines.append("# FRONTEND ARCHITECTURE")
        lines.append(
            f"*Auto-generated by The Scribe Frontend on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*"
        )
        lines.append("")
        lines.append("## Pages (Routes)")
        for page in sorted(pages, key=lambda x: x["route"]):
            lines.append(f"### `{page['route']}`")
            lines.append(f"- **File:** `{page['file']}`")
            lines.append(f"- **Description:** {page['description']}")
            lines.append("")

        lines.append("## Components")
        for comp in sorted(components, key=lambda x: x["name"]):
            lines.append(f"### `{comp['name']}`")
            lines.append(f"- **File:** `{comp['file']}`")
            lines.append(f"- **Description:** {comp['description']}")
            lines.append("")

        lines.append("## API Client Functions")
        for api in sorted(api_calls, key=lambda x: x["name"]):
            lines.append(f"- `{api['name']}` ({api['file']})")

        return "\n".join(lines)

    def run(self):
        print(f"{Colors.HEADER}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
        print("â•‘   THE SCRIBE FRONTEND: DOCUMENTATION   â•‘")
        print(f"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Colors.ENDC}")

        pages, components, api_calls = self.scan_codebase()

        print(f"{Colors.OKGREEN}âœ” Found {len(pages)} Pages{Colors.ENDC}")
        print(f"{Colors.OKGREEN}âœ” Found {len(components)} Components{Colors.ENDC}")
        print(f"{Colors.OKGREEN}âœ” Found {len(api_calls)} API Functions{Colors.ENDC}")

        content = self.generate_markdown(pages, components, api_calls)
        self.output_file.write_text(content, encoding="utf-8")
        print(
            f"{Colors.OKGREEN}âœ” Documentation written to {self.output_file}{Colors.ENDC}"
        )
        return True


def main():
    import sys

    script_dir = Path(__file__).parent
    root_dir = script_dir.parent.parent
    frontend_dir = root_dir / "apps" / "webapp-next"
    docs_dir = root_dir / "docs"

    scribe = FrontendScribe(frontend_dir, docs_dir)
    success = scribe.run()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
