"""
FLAN-T5 Router-Only Implementation
IMPORTANT: This router ONLY selects tools, NEVER generates responses
All responses are generated by Haiku 4.5
"""

import torch
from transformers import T5ForConditionalGeneration, T5Tokenizer
import json
import time
from typing import Dict, List, Optional, Tuple
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import logging

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class QueryRequest(BaseModel):
    query: str
    user_id: Optional[str] = None
    session_id: Optional[str] = None
    context: Optional[Dict] = None

class RouterResponse(BaseModel):
    tools: List[str]
    confidence: float
    intent: str
    latency_ms: int
    reasoning: str

class FlanRouterOnly:
    """
    Router that ONLY selects tools, never generates responses
    """

    def __init__(self):
        logger.info("ðŸš€ Initializing FLAN-T5 Router-Only...")

        # Detect device - Force CPU for stability (MPS can be slow on first load)
        # if torch.cuda.is_available():
        #     self.device = torch.device("cuda")
        # elif torch.backends.mps.is_available():
        #     self.device = torch.device("mps")  # Apple Silicon
        # else:
        self.device = torch.device("cpu")
        logger.info("Using CPU for model inference (for stability)")

        logger.info(f"Using device: {self.device}")

        # Load model - using small version for faster startup
        self.model_name = 'google/flan-t5-small'  # ~300MB instead of ~900MB
        logger.info(f"Loading {self.model_name}...")

        self.tokenizer = T5Tokenizer.from_pretrained(self.model_name)
        self.model = T5ForConditionalGeneration.from_pretrained(self.model_name)
        self.model.to(self.device)
        self.model.eval()

        logger.info("âœ… Model loaded successfully")

        # Define 5 super-tools (consolidated from 143)
        self.super_tools = {
            'universal.query': {
                'description': 'Query any data (knowledge, memory, pricing, team)',
                'handles': ['search', 'lookup', 'find', 'get', 'retrieve', 'show'],
                'examples': ['price', 'cost', 'requirements', 'documents', 'info']
            },
            'universal.action': {
                'description': 'Perform actions (save, update, delete, notify)',
                'handles': ['save', 'update', 'delete', 'create', 'modify', 'remove'],
                'examples': ['remember', 'store', 'change', 'edit']
            },
            'universal.generate': {
                'description': 'Generate content (documents, quotes, reports)',
                'handles': ['generate', 'create', 'produce', 'make', 'build'],
                'examples': ['quote', 'report', 'document', 'invoice', 'proposal']
            },
            'universal.analyze': {
                'description': 'Analyze data (predict, classify, insights)',
                'handles': ['analyze', 'predict', 'forecast', 'evaluate', 'assess'],
                'examples': ['statistics', 'trends', 'performance', 'analytics']
            },
            'universal.admin': {
                'description': 'System operations (auth, config, monitoring)',
                'handles': ['login', 'logout', 'configure', 'admin', 'system'],
                'examples': ['authenticate', 'settings', 'permissions', 'access']
            }
        }

    def classify_intent(self, query: str) -> Tuple[str, List[str]]:
        """
        Classify query intent and select appropriate tools
        """
        query_lower = query.lower()
        selected_tools = []
        intent = "general"

        # Check each super-tool's keywords
        tool_scores = {}

        for tool_name, tool_info in self.super_tools.items():
            score = 0

            # Check handles
            for handle in tool_info['handles']:
                if handle in query_lower:
                    score += 10

            # Check examples
            for example in tool_info['examples']:
                if example in query_lower:
                    score += 5

            if score > 0:
                tool_scores[tool_name] = score

        # Select top 2-3 tools
        if tool_scores:
            sorted_tools = sorted(tool_scores.items(), key=lambda x: x[1], reverse=True)
            selected_tools = [tool for tool, _ in sorted_tools[:3]]

            # Determine intent based on top tool
            if sorted_tools[0][0] == 'universal.query':
                intent = "information_seeking"
            elif sorted_tools[0][0] == 'universal.action':
                intent = "action_request"
            elif sorted_tools[0][0] == 'universal.generate':
                intent = "content_generation"
            elif sorted_tools[0][0] == 'universal.analyze':
                intent = "analysis_request"
            elif sorted_tools[0][0] == 'universal.admin':
                intent = "system_operation"

        # Default to universal.query if no tools selected
        if not selected_tools:
            selected_tools = ['universal.query']
            intent = "unclear"

        return intent, selected_tools

    def create_routing_prompt(self, query: str) -> str:
        """
        Create prompt for FLAN-T5 to improve tool selection
        """
        prompt = f"""You are a tool selection system. Select 1-3 tools for this query.

Available tools:
1. universal.query - Get information, search, lookup data
2. universal.action - Save, update, delete, modify data
3. universal.generate - Create documents, quotes, reports
4. universal.analyze - Analytics, predictions, insights
5. universal.admin - Login, settings, system operations

Query: "{query}"

Which tools are needed? List tool names separated by commas.
Answer:"""

        return prompt

    def route(self, query: str) -> RouterResponse:
        """
        Main routing function - ONLY selects tools, no response generation
        """
        start_time = time.time()

        # Step 1: Quick keyword-based classification
        intent, keyword_tools = self.classify_intent(query)

        # Step 2: Use FLAN-T5 for confirmation/refinement
        prompt = self.create_routing_prompt(query)

        inputs = self.tokenizer(
            prompt,
            return_tensors="pt",
            max_length=512,
            truncation=True
        ).to(self.device)

        with torch.no_grad():
            outputs = self.model.generate(
                **inputs,
                max_length=50,
                temperature=0.3,
                do_sample=True,
                num_beams=2
            )

        flan_output = self.tokenizer.decode(outputs[0], skip_special_tokens=True)

        # Step 3: Parse and merge results
        flan_tools = self.parse_flan_tools(flan_output)

        # Merge keyword and FLAN suggestions
        final_tools = self.merge_tool_selections(keyword_tools, flan_tools)

        # Calculate confidence
        confidence = self.calculate_confidence(keyword_tools, flan_tools)

        # Calculate latency
        latency_ms = int((time.time() - start_time) * 1000)

        return RouterResponse(
            tools=final_tools[:3],  # Max 3 tools
            confidence=confidence,
            intent=intent,
            latency_ms=latency_ms,
            reasoning=f"Keywords suggested: {keyword_tools}, FLAN suggested: {flan_tools}"
        )

    def parse_flan_tools(self, output: str) -> List[str]:
        """
        Parse FLAN output to extract tool names
        """
        tools = []
        output_lower = output.lower()

        for tool_name in self.super_tools.keys():
            if tool_name in output_lower or tool_name.split('.')[1] in output_lower:
                tools.append(tool_name)

        return tools

    def merge_tool_selections(self, keyword_tools: List[str], flan_tools: List[str]) -> List[str]:
        """
        Intelligently merge keyword and FLAN tool selections
        """
        # If both agree, high confidence
        common = set(keyword_tools) & set(flan_tools)
        if common:
            return list(common) + [t for t in keyword_tools if t not in common][:2]

        # If no agreement, prefer keyword-based (more deterministic)
        if keyword_tools:
            return keyword_tools

        # Fallback to FLAN
        if flan_tools:
            return flan_tools

        # Ultimate fallback
        return ['universal.query']

    def calculate_confidence(self, keyword_tools: List[str], flan_tools: List[str]) -> float:
        """
        Calculate routing confidence
        """
        if not keyword_tools and not flan_tools:
            return 0.3

        # High confidence if both agree
        if set(keyword_tools) == set(flan_tools):
            return 0.95

        # Medium-high if overlap
        if set(keyword_tools) & set(flan_tools):
            return 0.85

        # Medium if only one source
        if keyword_tools and not flan_tools:
            return 0.7

        if flan_tools and not keyword_tools:
            return 0.6

        # Low confidence for mismatch
        return 0.5

# FastAPI Application
app = FastAPI(
    title="FLAN-T5 Router-Only",
    description="Tool selection router for ZANTARA - does NOT generate responses",
    version="1.0.0"
)

# Global router instance
router: Optional[FlanRouterOnly] = None

@app.on_event("startup")
async def startup_event():
    """Initialize router on startup"""
    global router
    router = FlanRouterOnly()
    logger.info("âœ… Router initialized and ready")

@app.post("/route", response_model=RouterResponse)
async def route_query(request: QueryRequest):
    """
    Route a query - returns tool selection only, no response generation
    """
    if not router:
        raise HTTPException(status_code=503, detail="Router not initialized")

    try:
        return router.route(request.query)
    except Exception as e:
        logger.error(f"Routing error: {e}")
        # Fallback response
        return RouterResponse(
            tools=['universal.query'],
            confidence=0.1,
            intent='error',
            latency_ms=0,
            reasoning=f"Error: {str(e)}"
        )

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy" if router else "initializing",
        "model": router.model_name if router else "unknown",
        "mode": "router-only",
        "total_tools": 5,
        "device": str(router.device) if router else "unknown"
    }

@app.get("/tools")
async def list_tools():
    """List available super-tools"""
    if not router:
        raise HTTPException(status_code=503, detail="Router not initialized")

    return {
        "tools": router.super_tools,
        "total": len(router.super_tools),
        "note": "These 5 super-tools replace the original 143 tools"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000, log_level="info")
